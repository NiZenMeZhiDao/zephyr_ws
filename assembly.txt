
build/zephyr/zephyr.elf:	file format elf32-littlearm

Disassembly of section rom_start:

08000000 <_vector_start>:
 8000000: 90 36 00 20  	.word	0x20003690
 8000004: 75 5c 00 08  	.word	0x08005c75
 8000008: fd 4e 00 08  	.word	0x08004efd
 800000c: 61 5c 00 08  	.word	0x08005c61
 8000010: 61 5c 00 08  	.word	0x08005c61
 8000014: 61 5c 00 08  	.word	0x08005c61
 8000018: 61 5c 00 08  	.word	0x08005c61
 800001c: 00 00 00 00  	.word	0x00000000
 8000020: 00 00 00 00  	.word	0x00000000
 8000024: 00 00 00 00  	.word	0x00000000
 8000028: 00 00 00 00  	.word	0x00000000
 800002c: e1 5d 00 08  	.word	0x08005de1
 8000030: 61 5c 00 08  	.word	0x08005c61
 8000034: 00 00 00 00  	.word	0x00000000
 8000038: 71 5d 00 08  	.word	0x08005d71
 800003c: e1 c6 00 08  	.word	0x0800c6e1

08000040 <$d>:
 8000040: 35 60 00 08  	.word	0x08006035
 8000044: 35 60 00 08  	.word	0x08006035
 8000048: 35 60 00 08  	.word	0x08006035
 800004c: 35 60 00 08  	.word	0x08006035
 8000050: 35 60 00 08  	.word	0x08006035
 8000054: 35 60 00 08  	.word	0x08006035
 8000058: 35 60 00 08  	.word	0x08006035
 800005c: 35 60 00 08  	.word	0x08006035
 8000060: 35 60 00 08  	.word	0x08006035
 8000064: 35 60 00 08  	.word	0x08006035
 8000068: 35 60 00 08  	.word	0x08006035
 800006c: 35 60 00 08  	.word	0x08006035
 8000070: 35 60 00 08  	.word	0x08006035
 8000074: 35 60 00 08  	.word	0x08006035
 8000078: 35 60 00 08  	.word	0x08006035
 800007c: 35 60 00 08  	.word	0x08006035
 8000080: 35 60 00 08  	.word	0x08006035
 8000084: 35 60 00 08  	.word	0x08006035
 8000088: 35 60 00 08  	.word	0x08006035
 800008c: 35 60 00 08  	.word	0x08006035
 8000090: 35 60 00 08  	.word	0x08006035
 8000094: 35 60 00 08  	.word	0x08006035
 8000098: 35 60 00 08  	.word	0x08006035
 800009c: 35 60 00 08  	.word	0x08006035
 80000a0: 35 60 00 08  	.word	0x08006035
 80000a4: 35 60 00 08  	.word	0x08006035
 80000a8: 35 60 00 08  	.word	0x08006035
 80000ac: 35 60 00 08  	.word	0x08006035
 80000b0: 35 60 00 08  	.word	0x08006035
 80000b4: 35 60 00 08  	.word	0x08006035
 80000b8: 35 60 00 08  	.word	0x08006035
 80000bc: 35 60 00 08  	.word	0x08006035
 80000c0: 35 60 00 08  	.word	0x08006035
 80000c4: 35 60 00 08  	.word	0x08006035
 80000c8: 35 60 00 08  	.word	0x08006035
 80000cc: 35 60 00 08  	.word	0x08006035
 80000d0: 35 60 00 08  	.word	0x08006035
 80000d4: 35 60 00 08  	.word	0x08006035
 80000d8: 35 60 00 08  	.word	0x08006035
 80000dc: 35 60 00 08  	.word	0x08006035
 80000e0: 35 60 00 08  	.word	0x08006035
 80000e4: 35 60 00 08  	.word	0x08006035
 80000e8: 35 60 00 08  	.word	0x08006035
 80000ec: 35 60 00 08  	.word	0x08006035
 80000f0: 35 60 00 08  	.word	0x08006035
 80000f4: 35 60 00 08  	.word	0x08006035
 80000f8: 35 60 00 08  	.word	0x08006035
 80000fc: 35 60 00 08  	.word	0x08006035
 8000100: 35 60 00 08  	.word	0x08006035
 8000104: 35 60 00 08  	.word	0x08006035
 8000108: 35 60 00 08  	.word	0x08006035
 800010c: 35 60 00 08  	.word	0x08006035
 8000110: 35 60 00 08  	.word	0x08006035
 8000114: 35 60 00 08  	.word	0x08006035
 8000118: 35 60 00 08  	.word	0x08006035
 800011c: 35 60 00 08  	.word	0x08006035
 8000120: 35 60 00 08  	.word	0x08006035
 8000124: 35 60 00 08  	.word	0x08006035
 8000128: 35 60 00 08  	.word	0x08006035
 800012c: 35 60 00 08  	.word	0x08006035
 8000130: 35 60 00 08  	.word	0x08006035
 8000134: 35 60 00 08  	.word	0x08006035
 8000138: 35 60 00 08  	.word	0x08006035
 800013c: 35 60 00 08  	.word	0x08006035
 8000140: 35 60 00 08  	.word	0x08006035
 8000144: 35 60 00 08  	.word	0x08006035
 8000148: 35 60 00 08  	.word	0x08006035
 800014c: 35 60 00 08  	.word	0x08006035
 8000150: 35 60 00 08  	.word	0x08006035
 8000154: 35 60 00 08  	.word	0x08006035
 8000158: 35 60 00 08  	.word	0x08006035
 800015c: 35 60 00 08  	.word	0x08006035
 8000160: 35 60 00 08  	.word	0x08006035
 8000164: 35 60 00 08  	.word	0x08006035
 8000168: 35 60 00 08  	.word	0x08006035
 800016c: 35 60 00 08  	.word	0x08006035
 8000170: 35 60 00 08  	.word	0x08006035
 8000174: 35 60 00 08  	.word	0x08006035
 8000178: 35 60 00 08  	.word	0x08006035
 800017c: 35 60 00 08  	.word	0x08006035
 8000180: 35 60 00 08  	.word	0x08006035
 8000184: 35 60 00 08  	.word	0x08006035

Disassembly of section text:

08000188 <__text_region_start>:
 8000188: f080 4000    	eor	r0, r0, #0x80000000
 800018c: e002         	b	0x8000194 <__aeabi_fadd> @ imm = #0x4
 800018e: bf00         	nop

08000190 <__subsf3>:
 8000190: f081 4100    	eor	r1, r1, #0x80000000

08000194 <__aeabi_fadd>:
 8000194: 0042         	lsls	r2, r0, #0x1
 8000196: bf1f         	itttt	ne
 8000198: ea5f 0341    	lslsne.w	r3, r1, #0x1
 800019c: ea92 0f03    	teqne.w	r2, r3
 80001a0: ea7f 6c22    	mvnsne.w	r12, r2, asr #24
 80001a4: ea7f 6c23    	mvnsne.w	r12, r3, asr #24
 80001a8: d06a         	beq	0x8000280 <__aeabi_fadd+0xec> @ imm = #0xd4
 80001aa: ea4f 6212    	lsr.w	r2, r2, #0x18
 80001ae: ebd2 6313    	rsbs	r3, r2, r3, lsr #24
 80001b2: bfc1         	itttt	gt
 80001b4: 18d2         	addgt	r2, r2, r3
 80001b6: 4041         	eorgt	r1, r0
 80001b8: 4048         	eorgt	r0, r1
 80001ba: 4041         	eorgt	r1, r0
 80001bc: bfb8         	it	lt
 80001be: 425b         	rsblt	r3, r3, #0
 80001c0: 2b19         	cmp	r3, #0x19
 80001c2: bf88         	it	hi
 80001c4: 4770         	bxhi	lr
 80001c6: f010 4f00    	tst.w	r0, #0x80000000
 80001ca: f440 0000    	orr	r0, r0, #0x800000
 80001ce: f020 407f    	bic	r0, r0, #0xff000000
 80001d2: bf18         	it	ne
 80001d4: 4240         	rsbne	r0, r0, #0
 80001d6: f011 4f00    	tst.w	r1, #0x80000000
 80001da: f441 0100    	orr	r1, r1, #0x800000
 80001de: f021 417f    	bic	r1, r1, #0xff000000
 80001e2: bf18         	it	ne
 80001e4: 4249         	rsbne	r1, r1, #0
 80001e6: ea92 0f03    	teq.w	r2, r3
 80001ea: d03f         	beq	0x800026c <__aeabi_fadd+0xd8> @ imm = #0x7e
 80001ec: f1a2 0201    	sub.w	r2, r2, #0x1
 80001f0: fa41 fc03    	asr.w	r12, r1, r3
 80001f4: eb10 000c    	adds.w	r0, r0, r12
 80001f8: f1c3 0320    	rsb.w	r3, r3, #0x20
 80001fc: fa01 f103    	lsl.w	r1, r1, r3
 8000200: f000 4300    	and	r3, r0, #0x80000000
 8000204: d502         	bpl	0x800020c <__aeabi_fadd+0x78> @ imm = #0x4
 8000206: 4249         	rsbs	r1, r1, #0
 8000208: eb60 0040    	sbc.w	r0, r0, r0, lsl #1
 800020c: f5b0 0f00    	cmp.w	r0, #0x800000
 8000210: d313         	blo	0x800023a <__aeabi_fadd+0xa6> @ imm = #0x26
 8000212: f1b0 7f80    	cmp.w	r0, #0x1000000
 8000216: d306         	blo	0x8000226 <__aeabi_fadd+0x92> @ imm = #0xc
 8000218: 0840         	lsrs	r0, r0, #0x1
 800021a: ea4f 0131    	rrx	r1, r1
 800021e: f102 0201    	add.w	r2, r2, #0x1
 8000222: 2afe         	cmp	r2, #0xfe
 8000224: d251         	bhs	0x80002ca <__aeabi_fadd+0x136> @ imm = #0xa2
 8000226: f1b1 4f00    	cmp.w	r1, #0x80000000
 800022a: eb40 50c2    	adc.w	r0, r0, r2, lsl #23
 800022e: bf08         	it	eq
 8000230: f020 0001    	biceq	r0, r0, #0x1
 8000234: ea40 0003    	orr.w	r0, r0, r3
 8000238: 4770         	bx	lr
 800023a: 0049         	lsls	r1, r1, #0x1
 800023c: eb40 0000    	adc.w	r0, r0, r0
 8000240: 3a01         	subs	r2, #0x1
 8000242: bf28         	it	hs
 8000244: f5b0 0f00    	cmphs.w	r0, #0x800000
 8000248: d2ed         	bhs	0x8000226 <__aeabi_fadd+0x92> @ imm = #-0x26
 800024a: fab0 fc80    	clz	r12, r0
 800024e: f1ac 0c08    	sub.w	r12, r12, #0x8
 8000252: ebb2 020c    	subs.w	r2, r2, r12
 8000256: fa00 f00c    	lsl.w	r0, r0, r12
 800025a: bfaa         	itet	ge
 800025c: eb00 50c2    	addge.w	r0, r0, r2, lsl #23
 8000260: 4252         	rsblt	r2, r2, #0
 8000262: 4318         	orrge	r0, r3
 8000264: bfbc         	itt	lt
 8000266: 40d0         	lsrlt	r0, r2
 8000268: 4318         	orrlt	r0, r3
 800026a: 4770         	bx	lr
 800026c: f092 0f00    	teq.w	r2, #0x0
 8000270: f481 0100    	eor	r1, r1, #0x800000
 8000274: bf06         	itte	eq
 8000276: f480 0000    	eoreq	r0, r0, #0x800000
 800027a: 3201         	addeq	r2, #0x1
 800027c: 3b01         	subne	r3, #0x1
 800027e: e7b5         	b	0x80001ec <__aeabi_fadd+0x58> @ imm = #-0x96
 8000280: ea4f 0341    	lsl.w	r3, r1, #0x1
 8000284: ea7f 6c22    	mvns.w	r12, r2, asr #24
 8000288: bf18         	it	ne
 800028a: ea7f 6c23    	mvnsne.w	r12, r3, asr #24
 800028e: d021         	beq	0x80002d4 <__aeabi_fadd+0x140> @ imm = #0x42
 8000290: ea92 0f03    	teq.w	r2, r3
 8000294: d004         	beq	0x80002a0 <__aeabi_fadd+0x10c> @ imm = #0x8
 8000296: f092 0f00    	teq.w	r2, #0x0
 800029a: bf08         	it	eq
 800029c: 4608         	moveq	r0, r1
 800029e: 4770         	bx	lr
 80002a0: ea90 0f01    	teq.w	r0, r1
 80002a4: bf1c         	itt	ne
 80002a6: 2000         	movne	r0, #0x0
 80002a8: 4770         	bxne	lr
 80002aa: f012 4f7f    	tst.w	r2, #0xff000000
 80002ae: d104         	bne	0x80002ba <__aeabi_fadd+0x126> @ imm = #0x8
 80002b0: 0040         	lsls	r0, r0, #0x1
 80002b2: bf28         	it	hs
 80002b4: f040 4000    	orrhs	r0, r0, #0x80000000
 80002b8: 4770         	bx	lr
 80002ba: f112 7200    	adds.w	r2, r2, #0x2000000
 80002be: bf3c         	itt	lo
 80002c0: f500 0000    	addlo.w	r0, r0, #0x800000
 80002c4: 4770         	bxlo	lr
 80002c6: f000 4300    	and	r3, r0, #0x80000000
 80002ca: f043 40fe    	orr	r0, r3, #0x7f000000
 80002ce: f440 0000    	orr	r0, r0, #0x800000
 80002d2: 4770         	bx	lr
 80002d4: ea7f 6222    	mvns.w	r2, r2, asr #24
 80002d8: bf16         	itet	ne
 80002da: 4608         	movne	r0, r1
 80002dc: ea7f 6323    	mvnseq.w	r3, r3, asr #24
 80002e0: 4601         	movne	r1, r0
 80002e2: 0242         	lsls	r2, r0, #0x9
 80002e4: bf06         	itte	eq
 80002e6: ea5f 2341    	lslseq.w	r3, r1, #0x9
 80002ea: ea90 0f01    	teqeq.w	r0, r1
 80002ee: f440 0080    	orrne	r0, r0, #0x400000
 80002f2: 4770         	bx	lr

080002f4 <__floatunsisf>:
 80002f4: f04f 0300    	mov.w	r3, #0x0
 80002f8: e004         	b	0x8000304 <__floatsisf+0x8> @ imm = #0x8
 80002fa: bf00         	nop

080002fc <__floatsisf>:
 80002fc: f010 4300    	ands	r3, r0, #0x80000000
 8000300: bf48         	it	mi
 8000302: 4240         	rsbmi	r0, r0, #0
 8000304: ea5f 0c00    	movs.w	r12, r0
 8000308: bf08         	it	eq
 800030a: 4770         	bxeq	lr
 800030c: f043 4396    	orr	r3, r3, #0x4b000000
 8000310: 4601         	mov	r1, r0
 8000312: f04f 0000    	mov.w	r0, #0x0
 8000316: e01c         	b	0x8000352 <__floatdisf+0x2a> @ imm = #0x38

08000318 <__floatundisf>:
 8000318: ea50 0201    	orrs.w	r2, r0, r1
 800031c: bf08         	it	eq
 800031e: 4770         	bxeq	lr
 8000320: f04f 0300    	mov.w	r3, #0x0
 8000324: e00a         	b	0x800033c <__floatdisf+0x14> @ imm = #0x14
 8000326: bf00         	nop

08000328 <__floatdisf>:
 8000328: ea50 0201    	orrs.w	r2, r0, r1
 800032c: bf08         	it	eq
 800032e: 4770         	bxeq	lr
 8000330: f011 4300    	ands	r3, r1, #0x80000000
 8000334: d502         	bpl	0x800033c <__floatdisf+0x14> @ imm = #0x4
 8000336: 4240         	rsbs	r0, r0, #0
 8000338: eb61 0141    	sbc.w	r1, r1, r1, lsl #1
 800033c: ea5f 0c01    	movs.w	r12, r1
 8000340: bf02         	ittt	eq
 8000342: 4684         	moveq	r12, r0
 8000344: 4601         	moveq	r1, r0
 8000346: 2000         	moveq	r0, #0x0
 8000348: f043 43b6    	orr	r3, r3, #0x5b000000
 800034c: bf08         	it	eq
 800034e: f1a3 5380    	subeq.w	r3, r3, #0x10000000
 8000352: f5a3 0300    	sub.w	r3, r3, #0x800000
 8000356: fabc f28c    	clz	r2, r12
 800035a: 3a08         	subs	r2, #0x8
 800035c: eba3 53c2    	sub.w	r3, r3, r2, lsl #23
 8000360: db10         	blt	0x8000384 <__floatdisf+0x5c> @ imm = #0x20
 8000362: fa01 fc02    	lsl.w	r12, r1, r2
 8000366: 4463         	add	r3, r12
 8000368: fa00 fc02    	lsl.w	r12, r0, r2
 800036c: f1c2 0220    	rsb.w	r2, r2, #0x20
 8000370: f1bc 4f00    	cmp.w	r12, #0x80000000
 8000374: fa20 f202    	lsr.w	r2, r0, r2
 8000378: eb43 0002    	adc.w	r0, r3, r2
 800037c: bf08         	it	eq
 800037e: f020 0001    	biceq	r0, r0, #0x1
 8000382: 4770         	bx	lr
 8000384: f102 0220    	add.w	r2, r2, #0x20
 8000388: fa01 fc02    	lsl.w	r12, r1, r2
 800038c: f1c2 0220    	rsb.w	r2, r2, #0x20
 8000390: ea50 004c    	orrs.w	r0, r0, r12, lsl #1
 8000394: fa21 f202    	lsr.w	r2, r1, r2
 8000398: eb43 0002    	adc.w	r0, r3, r2
 800039c: bf08         	it	eq
 800039e: ea20 70dc    	biceq.w	r0, r0, r12, lsr #31
 80003a2: 4770         	bx	lr

080003a4 <__mulsf3>:
 80003a4: f04f 0cff    	mov.w	r12, #0xff
 80003a8: ea1c 52d0    	ands.w	r2, r12, r0, lsr #23
 80003ac: bf1e         	ittt	ne
 80003ae: ea1c 53d1    	andsne.w	r3, r12, r1, lsr #23
 80003b2: ea92 0f0c    	teqne.w	r2, r12
 80003b6: ea93 0f0c    	teqne.w	r3, r12
 80003ba: d06f         	beq	0x800049c <__mulsf3+0xf8> @ imm = #0xde
 80003bc: 441a         	add	r2, r3
 80003be: ea80 0c01    	eor.w	r12, r0, r1
 80003c2: 0240         	lsls	r0, r0, #0x9
 80003c4: bf18         	it	ne
 80003c6: ea5f 2141    	lslsne.w	r1, r1, #0x9
 80003ca: d01e         	beq	0x800040a <__mulsf3+0x66> @ imm = #0x3c
 80003cc: f04f 6300    	mov.w	r3, #0x8000000
 80003d0: ea43 1050    	orr.w	r0, r3, r0, lsr #5
 80003d4: ea43 1151    	orr.w	r1, r3, r1, lsr #5
 80003d8: fba0 3101    	umull	r3, r1, r0, r1
 80003dc: f00c 4000    	and	r0, r12, #0x80000000
 80003e0: f5b1 0f00    	cmp.w	r1, #0x800000
 80003e4: bf3e         	ittt	lo
 80003e6: 0049         	lsllo	r1, r1, #0x1
 80003e8: ea41 71d3    	orrlo.w	r1, r1, r3, lsr #31
 80003ec: 005b         	lsllo	r3, r3, #0x1
 80003ee: ea40 0001    	orr.w	r0, r0, r1
 80003f2: f162 027f    	sbc	r2, r2, #0x7f
 80003f6: 2afd         	cmp	r2, #0xfd
 80003f8: d81d         	bhi	0x8000436 <__mulsf3+0x92> @ imm = #0x3a
 80003fa: f1b3 4f00    	cmp.w	r3, #0x80000000
 80003fe: eb40 50c2    	adc.w	r0, r0, r2, lsl #23
 8000402: bf08         	it	eq
 8000404: f020 0001    	biceq	r0, r0, #0x1
 8000408: 4770         	bx	lr
 800040a: f090 0f00    	teq.w	r0, #0x0
 800040e: f00c 4c00    	and	r12, r12, #0x80000000
 8000412: bf08         	it	eq
 8000414: 0249         	lsleq	r1, r1, #0x9
 8000416: ea4c 2050    	orr.w	r0, r12, r0, lsr #9
 800041a: ea40 2051    	orr.w	r0, r0, r1, lsr #9
 800041e: 3a7f         	subs	r2, #0x7f
 8000420: bfc2         	ittt	gt
 8000422: f1d2 03ff    	rsbsgt.w	r3, r2, #0xff
 8000426: ea40 50c2    	orrgt.w	r0, r0, r2, lsl #23
 800042a: 4770         	bxgt	lr
 800042c: f440 0000    	orr	r0, r0, #0x800000
 8000430: f04f 0300    	mov.w	r3, #0x0
 8000434: 3a01         	subs	r2, #0x1
 8000436: dc5d         	bgt	0x80004f4 <__mulsf3+0x150> @ imm = #0xba
 8000438: f112 0f19    	cmn.w	r2, #0x19
 800043c: bfdc         	itt	le
 800043e: f000 4000    	andle	r0, r0, #0x80000000
 8000442: 4770         	bxle	lr
 8000444: f1c2 0200    	rsb.w	r2, r2, #0x0
 8000448: 0041         	lsls	r1, r0, #0x1
 800044a: fa21 f102    	lsr.w	r1, r1, r2
 800044e: f1c2 0220    	rsb.w	r2, r2, #0x20
 8000452: fa00 fc02    	lsl.w	r12, r0, r2
 8000456: ea5f 0031    	rrxs	r0, r1
 800045a: f140 0000    	adc	r0, r0, #0x0
 800045e: ea53 034c    	orrs.w	r3, r3, r12, lsl #1
 8000462: bf08         	it	eq
 8000464: ea20 70dc    	biceq.w	r0, r0, r12, lsr #31
 8000468: 4770         	bx	lr
 800046a: f092 0f00    	teq.w	r2, #0x0
 800046e: f000 4c00    	and	r12, r0, #0x80000000
 8000472: bf02         	ittt	eq
 8000474: 0040         	lsleq	r0, r0, #0x1
 8000476: f410 0f00    	tsteq.w	r0, #0x800000
 800047a: 3a01         	subeq	r2, #0x1
 800047c: d0f9         	beq	0x8000472 <__mulsf3+0xce> @ imm = #-0xe
 800047e: ea40 000c    	orr.w	r0, r0, r12
 8000482: f093 0f00    	teq.w	r3, #0x0
 8000486: f001 4c00    	and	r12, r1, #0x80000000
 800048a: bf02         	ittt	eq
 800048c: 0049         	lsleq	r1, r1, #0x1
 800048e: f411 0f00    	tsteq.w	r1, #0x800000
 8000492: 3b01         	subeq	r3, #0x1
 8000494: d0f9         	beq	0x800048a <__mulsf3+0xe6> @ imm = #-0xe
 8000496: ea41 010c    	orr.w	r1, r1, r12
 800049a: e78f         	b	0x80003bc <__mulsf3+0x18> @ imm = #-0xe2
 800049c: ea0c 53d1    	and.w	r3, r12, r1, lsr #23
 80004a0: ea92 0f0c    	teq.w	r2, r12
 80004a4: bf18         	it	ne
 80004a6: ea93 0f0c    	teqne.w	r3, r12
 80004aa: d00a         	beq	0x80004c2 <__mulsf3+0x11e> @ imm = #0x14
 80004ac: f030 4c00    	bics	r12, r0, #0x80000000
 80004b0: bf18         	it	ne
 80004b2: f031 4c00    	bicsne	r12, r1, #0x80000000
 80004b6: d1d8         	bne	0x800046a <__mulsf3+0xc6> @ imm = #-0x50
 80004b8: ea80 0001    	eor.w	r0, r0, r1
 80004bc: f000 4000    	and	r0, r0, #0x80000000
 80004c0: 4770         	bx	lr
 80004c2: f090 0f00    	teq.w	r0, #0x0
 80004c6: bf17         	itett	ne
 80004c8: f090 4f00    	teqne.w	r0, #0x80000000
 80004cc: 4608         	moveq	r0, r1
 80004ce: f091 0f00    	teqne.w	r1, #0x0
 80004d2: f091 4f00    	teqne.w	r1, #0x80000000
 80004d6: d014         	beq	0x8000502 <__mulsf3+0x15e> @ imm = #0x28
 80004d8: ea92 0f0c    	teq.w	r2, r12
 80004dc: d101         	bne	0x80004e2 <__mulsf3+0x13e> @ imm = #0x2
 80004de: 0242         	lsls	r2, r0, #0x9
 80004e0: d10f         	bne	0x8000502 <__mulsf3+0x15e> @ imm = #0x1e
 80004e2: ea93 0f0c    	teq.w	r3, r12
 80004e6: d103         	bne	0x80004f0 <__mulsf3+0x14c> @ imm = #0x6
 80004e8: 024b         	lsls	r3, r1, #0x9
 80004ea: bf18         	it	ne
 80004ec: 4608         	movne	r0, r1
 80004ee: d108         	bne	0x8000502 <__mulsf3+0x15e> @ imm = #0x10
 80004f0: ea80 0001    	eor.w	r0, r0, r1
 80004f4: f000 4000    	and	r0, r0, #0x80000000
 80004f8: f040 40fe    	orr	r0, r0, #0x7f000000
 80004fc: f440 0000    	orr	r0, r0, #0x800000
 8000500: 4770         	bx	lr
 8000502: f040 40fe    	orr	r0, r0, #0x7f000000
 8000506: f440 0040    	orr	r0, r0, #0xc00000
 800050a: 4770         	bx	lr

0800050c <__divsf3>:
 800050c: f04f 0cff    	mov.w	r12, #0xff
 8000510: ea1c 52d0    	ands.w	r2, r12, r0, lsr #23
 8000514: bf1e         	ittt	ne
 8000516: ea1c 53d1    	andsne.w	r3, r12, r1, lsr #23
 800051a: ea92 0f0c    	teqne.w	r2, r12
 800051e: ea93 0f0c    	teqne.w	r3, r12
 8000522: d069         	beq	0x80005f8 <__divsf3+0xec> @ imm = #0xd2
 8000524: eba2 0203    	sub.w	r2, r2, r3
 8000528: ea80 0c01    	eor.w	r12, r0, r1
 800052c: 0249         	lsls	r1, r1, #0x9
 800052e: ea4f 2040    	lsl.w	r0, r0, #0x9
 8000532: d037         	beq	0x80005a4 <__divsf3+0x98> @ imm = #0x6e
 8000534: f04f 5380    	mov.w	r3, #0x10000000
 8000538: ea43 1111    	orr.w	r1, r3, r1, lsr #4
 800053c: ea43 1310    	orr.w	r3, r3, r0, lsr #4
 8000540: f00c 4000    	and	r0, r12, #0x80000000
 8000544: 428b         	cmp	r3, r1
 8000546: bf38         	it	lo
 8000548: 005b         	lsllo	r3, r3, #0x1
 800054a: f142 027d    	adc	r2, r2, #0x7d
 800054e: f44f 0c00    	mov.w	r12, #0x800000
 8000552: 428b         	cmp	r3, r1
 8000554: bf24         	itt	hs
 8000556: 1a5b         	subhs	r3, r3, r1
 8000558: ea40 000c    	orrhs.w	r0, r0, r12
 800055c: ebb3 0f51    	cmp.w	r3, r1, lsr #1
 8000560: bf24         	itt	hs
 8000562: eba3 0351    	subhs.w	r3, r3, r1, lsr #1
 8000566: ea40 005c    	orrhs.w	r0, r0, r12, lsr #1
 800056a: ebb3 0f91    	cmp.w	r3, r1, lsr #2
 800056e: bf24         	itt	hs
 8000570: eba3 0391    	subhs.w	r3, r3, r1, lsr #2
 8000574: ea40 009c    	orrhs.w	r0, r0, r12, lsr #2
 8000578: ebb3 0fd1    	cmp.w	r3, r1, lsr #3
 800057c: bf24         	itt	hs
 800057e: eba3 03d1    	subhs.w	r3, r3, r1, lsr #3
 8000582: ea40 00dc    	orrhs.w	r0, r0, r12, lsr #3
 8000586: 011b         	lsls	r3, r3, #0x4
 8000588: bf18         	it	ne
 800058a: ea5f 1c1c    	lsrsne.w	r12, r12, #0x4
 800058e: d1e0         	bne	0x8000552 <__divsf3+0x46> @ imm = #-0x40
 8000590: 2afd         	cmp	r2, #0xfd
 8000592: f63f af50    	bhi.w	0x8000436 <__mulsf3+0x92> @ imm = #-0x160
 8000596: 428b         	cmp	r3, r1
 8000598: eb40 50c2    	adc.w	r0, r0, r2, lsl #23
 800059c: bf08         	it	eq
 800059e: f020 0001    	biceq	r0, r0, #0x1
 80005a2: 4770         	bx	lr
 80005a4: f00c 4c00    	and	r12, r12, #0x80000000
 80005a8: ea4c 2050    	orr.w	r0, r12, r0, lsr #9
 80005ac: 327f         	adds	r2, #0x7f
 80005ae: bfc2         	ittt	gt
 80005b0: f1d2 03ff    	rsbsgt.w	r3, r2, #0xff
 80005b4: ea40 50c2    	orrgt.w	r0, r0, r2, lsl #23
 80005b8: 4770         	bxgt	lr
 80005ba: f440 0000    	orr	r0, r0, #0x800000
 80005be: f04f 0300    	mov.w	r3, #0x0
 80005c2: 3a01         	subs	r2, #0x1
 80005c4: e737         	b	0x8000436 <__mulsf3+0x92> @ imm = #-0x192
 80005c6: f092 0f00    	teq.w	r2, #0x0
 80005ca: f000 4c00    	and	r12, r0, #0x80000000
 80005ce: bf02         	ittt	eq
 80005d0: 0040         	lsleq	r0, r0, #0x1
 80005d2: f410 0f00    	tsteq.w	r0, #0x800000
 80005d6: 3a01         	subeq	r2, #0x1
 80005d8: d0f9         	beq	0x80005ce <__divsf3+0xc2> @ imm = #-0xe
 80005da: ea40 000c    	orr.w	r0, r0, r12
 80005de: f093 0f00    	teq.w	r3, #0x0
 80005e2: f001 4c00    	and	r12, r1, #0x80000000
 80005e6: bf02         	ittt	eq
 80005e8: 0049         	lsleq	r1, r1, #0x1
 80005ea: f411 0f00    	tsteq.w	r1, #0x800000
 80005ee: 3b01         	subeq	r3, #0x1
 80005f0: d0f9         	beq	0x80005e6 <__divsf3+0xda> @ imm = #-0xe
 80005f2: ea41 010c    	orr.w	r1, r1, r12
 80005f6: e795         	b	0x8000524 <__divsf3+0x18> @ imm = #-0xd6
 80005f8: ea0c 53d1    	and.w	r3, r12, r1, lsr #23
 80005fc: ea92 0f0c    	teq.w	r2, r12
 8000600: d108         	bne	0x8000614 <__divsf3+0x108> @ imm = #0x10
 8000602: 0242         	lsls	r2, r0, #0x9
 8000604: f47f af7d    	bne.w	0x8000502 <__mulsf3+0x15e> @ imm = #-0x106
 8000608: ea93 0f0c    	teq.w	r3, r12
 800060c: f47f af70    	bne.w	0x80004f0 <__mulsf3+0x14c> @ imm = #-0x120
 8000610: 4608         	mov	r0, r1
 8000612: e776         	b	0x8000502 <__mulsf3+0x15e> @ imm = #-0x114
 8000614: ea93 0f0c    	teq.w	r3, r12
 8000618: d104         	bne	0x8000624 <__divsf3+0x118> @ imm = #0x8
 800061a: 024b         	lsls	r3, r1, #0x9
 800061c: f43f af4c    	beq.w	0x80004b8 <__mulsf3+0x114> @ imm = #-0x168
 8000620: 4608         	mov	r0, r1
 8000622: e76e         	b	0x8000502 <__mulsf3+0x15e> @ imm = #-0x124
 8000624: f030 4c00    	bics	r12, r0, #0x80000000
 8000628: bf18         	it	ne
 800062a: f031 4c00    	bicsne	r12, r1, #0x80000000
 800062e: d1ca         	bne	0x80005c6 <__divsf3+0xba> @ imm = #-0x6c
 8000630: f030 4200    	bics	r2, r0, #0x80000000
 8000634: f47f af5c    	bne.w	0x80004f0 <__mulsf3+0x14c> @ imm = #-0x148
 8000638: f031 4300    	bics	r3, r1, #0x80000000
 800063c: f47f af3c    	bne.w	0x80004b8 <__mulsf3+0x114> @ imm = #-0x188
 8000640: e75f         	b	0x8000502 <__mulsf3+0x15e> @ imm = #-0x142
 8000642: bf00         	nop

08000644 <__gtsf2>:
 8000644: f04f 3cff    	mov.w	r12, #0xffffffff
 8000648: e006         	b	0x8000658 <__nesf2+0x4> @ imm = #0xc
 800064a: bf00         	nop

0800064c <__ltsf2>:
 800064c: f04f 0c01    	mov.w	r12, #0x1
 8000650: e002         	b	0x8000658 <__nesf2+0x4> @ imm = #0x4
 8000652: bf00         	nop

08000654 <__nesf2>:
 8000654: f04f 0c01    	mov.w	r12, #0x1
 8000658: f84d cd04    	str	r12, [sp, #-4]!
 800065c: ea4f 0240    	lsl.w	r2, r0, #0x1
 8000660: ea4f 0341    	lsl.w	r3, r1, #0x1
 8000664: ea7f 6c22    	mvns.w	r12, r2, asr #24
 8000668: bf18         	it	ne
 800066a: ea7f 6c23    	mvnsne.w	r12, r3, asr #24
 800066e: d011         	beq	0x8000694 <__nesf2+0x40> @ imm = #0x22
 8000670: b001         	add	sp, #0x4
 8000672: ea52 0c53    	orrs.w	r12, r2, r3, lsr #1
 8000676: bf18         	it	ne
 8000678: ea90 0f01    	teqne.w	r0, r1
 800067c: bf58         	it	pl
 800067e: ebb2 0003    	subspl.w	r0, r2, r3
 8000682: bf88         	it	hi
 8000684: 17c8         	asrhi	r0, r1, #0x1f
 8000686: bf38         	it	lo
 8000688: ea6f 70e1    	mvnlo.w	r0, r1, asr #31
 800068c: bf18         	it	ne
 800068e: f040 0001    	orrne	r0, r0, #0x1
 8000692: 4770         	bx	lr
 8000694: ea7f 6c22    	mvns.w	r12, r2, asr #24
 8000698: d102         	bne	0x80006a0 <__nesf2+0x4c> @ imm = #0x4
 800069a: ea5f 2c40    	lsls.w	r12, r0, #0x9
 800069e: d105         	bne	0x80006ac <__nesf2+0x58> @ imm = #0xa
 80006a0: ea7f 6c23    	mvns.w	r12, r3, asr #24
 80006a4: d1e4         	bne	0x8000670 <__nesf2+0x1c> @ imm = #-0x38
 80006a6: ea5f 2c41    	lsls.w	r12, r1, #0x9
 80006aa: d0e1         	beq	0x8000670 <__nesf2+0x1c> @ imm = #-0x3e
 80006ac: f85d 0b04    	ldr	r0, [sp], #4
 80006b0: 4770         	bx	lr
 80006b2: bf00         	nop

080006b4 <__aeabi_cfrcmple>:
 80006b4: 4684         	mov	r12, r0
 80006b6: 4608         	mov	r0, r1
 80006b8: 4661         	mov	r1, r12
 80006ba: e7ff         	b	0x80006bc <__aeabi_cfcmple> @ imm = #-0x2

080006bc <__aeabi_cfcmple>:
 80006bc: b50f         	push	{r0, r1, r2, r3, lr}
 80006be: f7ff ffc9    	bl	0x8000654 <__nesf2>     @ imm = #-0x6e
 80006c2: 2800         	cmp	r0, #0x0
 80006c4: bf48         	it	mi
 80006c6: f110 0f00    	cmnmi.w	r0, #0x0
 80006ca: bd0f         	pop	{r0, r1, r2, r3, pc}

080006cc <__aeabi_fcmpeq>:
 80006cc: f84d ed08    	str	lr, [sp, #-8]!
 80006d0: f7ff fff4    	bl	0x80006bc <__aeabi_cfcmple> @ imm = #-0x18
 80006d4: bf0c         	ite	eq
 80006d6: 2001         	moveq	r0, #0x1
 80006d8: 2000         	movne	r0, #0x0
 80006da: f85d fb08    	ldr	pc, [sp], #8
 80006de: bf00         	nop

080006e0 <__aeabi_fcmplt>:
 80006e0: f84d ed08    	str	lr, [sp, #-8]!
 80006e4: f7ff ffea    	bl	0x80006bc <__aeabi_cfcmple> @ imm = #-0x2c
 80006e8: bf34         	ite	lo
 80006ea: 2001         	movlo	r0, #0x1
 80006ec: 2000         	movhs	r0, #0x0
 80006ee: f85d fb08    	ldr	pc, [sp], #8
 80006f2: bf00         	nop

080006f4 <__aeabi_fcmple>:
 80006f4: f84d ed08    	str	lr, [sp, #-8]!
 80006f8: f7ff ffe0    	bl	0x80006bc <__aeabi_cfcmple> @ imm = #-0x40
 80006fc: bf94         	ite	ls
 80006fe: 2001         	movls	r0, #0x1
 8000700: 2000         	movhi	r0, #0x0
 8000702: f85d fb08    	ldr	pc, [sp], #8
 8000706: bf00         	nop

08000708 <__aeabi_fcmpge>:
 8000708: f84d ed08    	str	lr, [sp, #-8]!
 800070c: f7ff ffd2    	bl	0x80006b4 <__aeabi_cfrcmple> @ imm = #-0x5c
 8000710: bf94         	ite	ls
 8000712: 2001         	movls	r0, #0x1
 8000714: 2000         	movhi	r0, #0x0
 8000716: f85d fb08    	ldr	pc, [sp], #8
 800071a: bf00         	nop

0800071c <__aeabi_fcmpgt>:
 800071c: f84d ed08    	str	lr, [sp, #-8]!
 8000720: f7ff ffc8    	bl	0x80006b4 <__aeabi_cfrcmple> @ imm = #-0x70
 8000724: bf34         	ite	lo
 8000726: 2001         	movlo	r0, #0x1
 8000728: 2000         	movhs	r0, #0x0
 800072a: f85d fb08    	ldr	pc, [sp], #8
 800072e: bf00         	nop

08000730 <__fixsfsi>:
 8000730: ea4f 0240    	lsl.w	r2, r0, #0x1
 8000734: f1b2 4ffe    	cmp.w	r2, #0x7f000000
 8000738: d30f         	blo	0x800075a <__fixsfsi+0x2a> @ imm = #0x1e
 800073a: f04f 039e    	mov.w	r3, #0x9e
 800073e: ebb3 6212    	subs.w	r2, r3, r2, lsr #24
 8000742: d90d         	bls	0x8000760 <__fixsfsi+0x30> @ imm = #0x1a
 8000744: ea4f 2300    	lsl.w	r3, r0, #0x8
 8000748: f043 4300    	orr	r3, r3, #0x80000000
 800074c: f010 4f00    	tst.w	r0, #0x80000000
 8000750: fa23 f002    	lsr.w	r0, r3, r2
 8000754: bf18         	it	ne
 8000756: 4240         	rsbne	r0, r0, #0
 8000758: 4770         	bx	lr
 800075a: f04f 0000    	mov.w	r0, #0x0
 800075e: 4770         	bx	lr
 8000760: f112 0f61    	cmn.w	r2, #0x61
 8000764: d101         	bne	0x800076a <__fixsfsi+0x3a> @ imm = #0x2
 8000766: 0242         	lsls	r2, r0, #0x9
 8000768: d105         	bne	0x8000776 <__fixsfsi+0x46> @ imm = #0xa
 800076a: f010 4000    	ands	r0, r0, #0x80000000
 800076e: bf08         	it	eq
 8000770: f06f 4000    	mvneq	r0, #0x80000000
 8000774: 4770         	bx	lr
 8000776: f04f 0000    	mov.w	r0, #0x0
 800077a: 4770         	bx	lr

0800077c <__aeabi_ldivmod>:
 800077c: b97b         	cbnz	r3, 0x800079e <__aeabi_ldivmod+0x22> @ imm = #0x1e
 800077e: b972         	cbnz	r2, 0x800079e <__aeabi_ldivmod+0x22> @ imm = #0x1c
 8000780: 2900         	cmp	r1, #0x0
 8000782: bfbe         	ittt	lt
 8000784: 2000         	movlt	r0, #0x0
 8000786: f04f 4100    	movlt.w	r1, #0x80000000
 800078a: e006         	blt	0x800079a <__aeabi_ldivmod+0x1e> @ imm = #0xc
 800078c: bf08         	it	eq
 800078e: 2800         	cmpeq	r0, #0x0
 8000790: bf1c         	itt	ne
 8000792: f06f 4100    	mvnne	r1, #0x80000000
 8000796: f04f 30ff    	movne.w	r0, #0xffffffff
 800079a: f000 b857    	b.w	0x800084c <__aeabi_ldiv0> @ imm = #0xae
 800079e: f1ad 0c08    	sub.w	r12, sp, #0x8
 80007a2: e96d ce04    	strd	r12, lr, [sp, #-16]!
 80007a6: 2900         	cmp	r1, #0x0
 80007a8: db09         	blt	0x80007be <__aeabi_ldivmod+0x42> @ imm = #0x12
 80007aa: 2b00         	cmp	r3, #0x0
 80007ac: db1a         	blt	0x80007e4 <__aeabi_ldivmod+0x68> @ imm = #0x34
 80007ae: f000 f857    	bl	0x8000860 <__udivmoddi4> @ imm = #0xae
 80007b2: f8dd e004    	ldr.w	lr, [sp, #0x4]
 80007b6: e9dd 2302    	ldrd	r2, r3, [sp, #8]
 80007ba: b004         	add	sp, #0x10
 80007bc: 4770         	bx	lr
 80007be: 4240         	rsbs	r0, r0, #0
 80007c0: eb61 0141    	sbc.w	r1, r1, r1, lsl #1
 80007c4: 2b00         	cmp	r3, #0x0
 80007c6: db1b         	blt	0x8000800 <__aeabi_ldivmod+0x84> @ imm = #0x36
 80007c8: f000 f84a    	bl	0x8000860 <__udivmoddi4> @ imm = #0x94
 80007cc: f8dd e004    	ldr.w	lr, [sp, #0x4]
 80007d0: e9dd 2302    	ldrd	r2, r3, [sp, #8]
 80007d4: b004         	add	sp, #0x10
 80007d6: 4240         	rsbs	r0, r0, #0
 80007d8: eb61 0141    	sbc.w	r1, r1, r1, lsl #1
 80007dc: 4252         	rsbs	r2, r2, #0
 80007de: eb63 0343    	sbc.w	r3, r3, r3, lsl #1
 80007e2: 4770         	bx	lr
 80007e4: 4252         	rsbs	r2, r2, #0
 80007e6: eb63 0343    	sbc.w	r3, r3, r3, lsl #1
 80007ea: f000 f839    	bl	0x8000860 <__udivmoddi4> @ imm = #0x72
 80007ee: f8dd e004    	ldr.w	lr, [sp, #0x4]
 80007f2: e9dd 2302    	ldrd	r2, r3, [sp, #8]
 80007f6: b004         	add	sp, #0x10
 80007f8: 4240         	rsbs	r0, r0, #0
 80007fa: eb61 0141    	sbc.w	r1, r1, r1, lsl #1
 80007fe: 4770         	bx	lr
 8000800: 4252         	rsbs	r2, r2, #0
 8000802: eb63 0343    	sbc.w	r3, r3, r3, lsl #1
 8000806: f000 f82b    	bl	0x8000860 <__udivmoddi4> @ imm = #0x56
 800080a: f8dd e004    	ldr.w	lr, [sp, #0x4]
 800080e: e9dd 2302    	ldrd	r2, r3, [sp, #8]
 8000812: b004         	add	sp, #0x10
 8000814: 4252         	rsbs	r2, r2, #0
 8000816: eb63 0343    	sbc.w	r3, r3, r3, lsl #1
 800081a: 4770         	bx	lr

0800081c <__aeabi_uldivmod>:
 800081c: b953         	cbnz	r3, 0x8000834 <__aeabi_uldivmod+0x18> @ imm = #0x14
 800081e: b94a         	cbnz	r2, 0x8000834 <__aeabi_uldivmod+0x18> @ imm = #0x12
 8000820: 2900         	cmp	r1, #0x0
 8000822: bf08         	it	eq
 8000824: 2800         	cmpeq	r0, #0x0
 8000826: bf1c         	itt	ne
 8000828: f04f 31ff    	movne.w	r1, #0xffffffff
 800082c: f04f 30ff    	movne.w	r0, #0xffffffff
 8000830: f000 b80c    	b.w	0x800084c <__aeabi_ldiv0> @ imm = #0x18
 8000834: f1ad 0c08    	sub.w	r12, sp, #0x8
 8000838: e96d ce04    	strd	r12, lr, [sp, #-16]!
 800083c: f000 f810    	bl	0x8000860 <__udivmoddi4> @ imm = #0x20
 8000840: f8dd e004    	ldr.w	lr, [sp, #0x4]
 8000844: e9dd 2302    	ldrd	r2, r3, [sp, #8]
 8000848: b004         	add	sp, #0x10
 800084a: 4770         	bx	lr

0800084c <__aeabi_ldiv0>:
 800084c: 4770         	bx	lr
 800084e: bf00         	nop

08000850 <strlen>:
 8000850: 4603         	mov	r3, r0
 8000852: f813 2b01    	ldrb	r2, [r3], #1
 8000856: 2a00         	cmp	r2, #0x0
 8000858: d1fb         	bne	0x8000852 <strlen+0x2>  @ imm = #-0xa
 800085a: 1a18         	subs	r0, r3, r0
 800085c: 3801         	subs	r0, #0x1
 800085e: 4770         	bx	lr

08000860 <__udivmoddi4>:
 8000860: e92d 47f0    	push.w	{r4, r5, r6, r7, r8, r9, r10, lr}
 8000864: 4686         	mov	lr, r0
 8000866: 468c         	mov	r12, r1
 8000868: 4608         	mov	r0, r1
 800086a: 9e08         	ldr	r6, [sp, #0x20]
 800086c: 4615         	mov	r5, r2
 800086e: 4674         	mov	r4, lr
 8000870: 4619         	mov	r1, r3
 8000872: 2b00         	cmp	r3, #0x0
 8000874: f040 80c2    	bne.w	0x80009fc <__udivmoddi4+0x19c> @ imm = #0x184
 8000878: 4285         	cmp	r5, r0
 800087a: fab2 f282    	clz	r2, r2
 800087e: d945         	bls	0x800090c <__udivmoddi4+0xac> @ imm = #0x8a
 8000880: b14a         	cbz	r2, 0x8000896 <__udivmoddi4+0x36> @ imm = #0x12
 8000882: f1c2 0320    	rsb.w	r3, r2, #0x20
 8000886: fa00 fc02    	lsl.w	r12, r0, r2
 800088a: fa2e f303    	lsr.w	r3, lr, r3
 800088e: 4095         	lsls	r5, r2
 8000890: ea43 0c0c    	orr.w	r12, r3, r12
 8000894: 4094         	lsls	r4, r2
 8000896: ea4f 4e15    	lsr.w	lr, r5, #0x10
 800089a: b2a8         	uxth	r0, r5
 800089c: fbbc f8fe    	udiv	r8, r12, lr
 80008a0: 0c23         	lsrs	r3, r4, #0x10
 80008a2: fb0e cc18    	mls	r12, lr, r8, r12
 80008a6: fb08 f900    	mul	r9, r8, r0
 80008aa: ea43 430c    	orr.w	r3, r3, r12, lsl #16
 80008ae: 4599         	cmp	r9, r3
 80008b0: d928         	bls	0x8000904 <__udivmoddi4+0xa4> @ imm = #0x50
 80008b2: 18eb         	adds	r3, r5, r3
 80008b4: f108 37ff    	add.w	r7, r8, #0xffffffff
 80008b8: d204         	bhs	0x80008c4 <__udivmoddi4+0x64> @ imm = #0x8
 80008ba: 4599         	cmp	r9, r3
 80008bc: d902         	bls	0x80008c4 <__udivmoddi4+0x64> @ imm = #0x4
 80008be: f1a8 0702    	sub.w	r7, r8, #0x2
 80008c2: 442b         	add	r3, r5
 80008c4: eba3 0309    	sub.w	r3, r3, r9
 80008c8: b2a4         	uxth	r4, r4
 80008ca: fbb3 fcfe    	udiv	r12, r3, lr
 80008ce: fb0e 331c    	mls	r3, lr, r12, r3
 80008d2: fb0c f000    	mul	r0, r12, r0
 80008d6: ea44 4403    	orr.w	r4, r4, r3, lsl #16
 80008da: 42a0         	cmp	r0, r4
 80008dc: d914         	bls	0x8000908 <__udivmoddi4+0xa8> @ imm = #0x28
 80008de: 192c         	adds	r4, r5, r4
 80008e0: f10c 33ff    	add.w	r3, r12, #0xffffffff
 80008e4: d204         	bhs	0x80008f0 <__udivmoddi4+0x90> @ imm = #0x8
 80008e6: 42a0         	cmp	r0, r4
 80008e8: d902         	bls	0x80008f0 <__udivmoddi4+0x90> @ imm = #0x4
 80008ea: f1ac 0302    	sub.w	r3, r12, #0x2
 80008ee: 442c         	add	r4, r5
 80008f0: 1a24         	subs	r4, r4, r0
 80008f2: ea43 4007    	orr.w	r0, r3, r7, lsl #16
 80008f6: b11e         	cbz	r6, 0x8000900 <__udivmoddi4+0xa0> @ imm = #0x6
 80008f8: 40d4         	lsrs	r4, r2
 80008fa: 2300         	movs	r3, #0x0
 80008fc: 6034         	str	r4, [r6]
 80008fe: 6073         	str	r3, [r6, #0x4]
 8000900: e8bd 87f0    	pop.w	{r4, r5, r6, r7, r8, r9, r10, pc}
 8000904: 4647         	mov	r7, r8
 8000906: e7dd         	b	0x80008c4 <__udivmoddi4+0x64> @ imm = #-0x46
 8000908: 4663         	mov	r3, r12
 800090a: e7f1         	b	0x80008f0 <__udivmoddi4+0x90> @ imm = #-0x1e
 800090c: bb92         	cbnz	r2, 0x8000974 <__udivmoddi4+0x114> @ imm = #0x64
 800090e: 1b43         	subs	r3, r0, r5
 8000910: 2101         	movs	r1, #0x1
 8000912: ea4f 4e15    	lsr.w	lr, r5, #0x10
 8000916: b2af         	uxth	r7, r5
 8000918: fbb3 fcfe    	udiv	r12, r3, lr
 800091c: 0c20         	lsrs	r0, r4, #0x10
 800091e: fb0e 331c    	mls	r3, lr, r12, r3
 8000922: fb0c f807    	mul	r8, r12, r7
 8000926: ea40 4303    	orr.w	r3, r0, r3, lsl #16
 800092a: 4598         	cmp	r8, r3
 800092c: d962         	bls	0x80009f4 <__udivmoddi4+0x194> @ imm = #0xc4
 800092e: 18eb         	adds	r3, r5, r3
 8000930: f10c 30ff    	add.w	r0, r12, #0xffffffff
 8000934: d204         	bhs	0x8000940 <__udivmoddi4+0xe0> @ imm = #0x8
 8000936: 4598         	cmp	r8, r3
 8000938: d902         	bls	0x8000940 <__udivmoddi4+0xe0> @ imm = #0x4
 800093a: f1ac 0002    	sub.w	r0, r12, #0x2
 800093e: 442b         	add	r3, r5
 8000940: eba3 0308    	sub.w	r3, r3, r8
 8000944: b2a4         	uxth	r4, r4
 8000946: fbb3 fcfe    	udiv	r12, r3, lr
 800094a: fb0e 331c    	mls	r3, lr, r12, r3
 800094e: fb0c f707    	mul	r7, r12, r7
 8000952: ea44 4403    	orr.w	r4, r4, r3, lsl #16
 8000956: 42a7         	cmp	r7, r4
 8000958: d94e         	bls	0x80009f8 <__udivmoddi4+0x198> @ imm = #0x9c
 800095a: 192c         	adds	r4, r5, r4
 800095c: f10c 33ff    	add.w	r3, r12, #0xffffffff
 8000960: d204         	bhs	0x800096c <__udivmoddi4+0x10c> @ imm = #0x8
 8000962: 42a7         	cmp	r7, r4
 8000964: d902         	bls	0x800096c <__udivmoddi4+0x10c> @ imm = #0x4
 8000966: f1ac 0302    	sub.w	r3, r12, #0x2
 800096a: 442c         	add	r4, r5
 800096c: 1be4         	subs	r4, r4, r7
 800096e: ea43 4000    	orr.w	r0, r3, r0, lsl #16
 8000972: e7c0         	b	0x80008f6 <__udivmoddi4+0x96> @ imm = #-0x80
 8000974: f1c2 0320    	rsb.w	r3, r2, #0x20
 8000978: fa20 f103    	lsr.w	r1, r0, r3
 800097c: 4095         	lsls	r5, r2
 800097e: 4090         	lsls	r0, r2
 8000980: fa2e f303    	lsr.w	r3, lr, r3
 8000984: 4303         	orrs	r3, r0
 8000986: ea4f 4e15    	lsr.w	lr, r5, #0x10
 800098a: b2af         	uxth	r7, r5
 800098c: fbb1 fcfe    	udiv	r12, r1, lr
 8000990: fb0e 101c    	mls	r0, lr, r12, r1
 8000994: 0c19         	lsrs	r1, r3, #0x10
 8000996: fb0c f807    	mul	r8, r12, r7
 800099a: ea41 4100    	orr.w	r1, r1, r0, lsl #16
 800099e: 4588         	cmp	r8, r1
 80009a0: fa04 f402    	lsl.w	r4, r4, r2
 80009a4: d922         	bls	0x80009ec <__udivmoddi4+0x18c> @ imm = #0x44
 80009a6: 1869         	adds	r1, r5, r1
 80009a8: f10c 30ff    	add.w	r0, r12, #0xffffffff
 80009ac: d204         	bhs	0x80009b8 <__udivmoddi4+0x158> @ imm = #0x8
 80009ae: 4588         	cmp	r8, r1
 80009b0: d902         	bls	0x80009b8 <__udivmoddi4+0x158> @ imm = #0x4
 80009b2: f1ac 0002    	sub.w	r0, r12, #0x2
 80009b6: 4429         	add	r1, r5
 80009b8: eba1 0108    	sub.w	r1, r1, r8
 80009bc: b29b         	uxth	r3, r3
 80009be: fbb1 fcfe    	udiv	r12, r1, lr
 80009c2: fb0e 111c    	mls	r1, lr, r12, r1
 80009c6: fb0c f707    	mul	r7, r12, r7
 80009ca: ea43 4301    	orr.w	r3, r3, r1, lsl #16
 80009ce: 429f         	cmp	r7, r3
 80009d0: d90e         	bls	0x80009f0 <__udivmoddi4+0x190> @ imm = #0x1c
 80009d2: 18eb         	adds	r3, r5, r3
 80009d4: f10c 31ff    	add.w	r1, r12, #0xffffffff
 80009d8: d204         	bhs	0x80009e4 <__udivmoddi4+0x184> @ imm = #0x8
 80009da: 429f         	cmp	r7, r3
 80009dc: d902         	bls	0x80009e4 <__udivmoddi4+0x184> @ imm = #0x4
 80009de: f1ac 0102    	sub.w	r1, r12, #0x2
 80009e2: 442b         	add	r3, r5
 80009e4: 1bdb         	subs	r3, r3, r7
 80009e6: ea41 4100    	orr.w	r1, r1, r0, lsl #16
 80009ea: e792         	b	0x8000912 <__udivmoddi4+0xb2> @ imm = #-0xdc
 80009ec: 4660         	mov	r0, r12
 80009ee: e7e3         	b	0x80009b8 <__udivmoddi4+0x158> @ imm = #-0x3a
 80009f0: 4661         	mov	r1, r12
 80009f2: e7f7         	b	0x80009e4 <__udivmoddi4+0x184> @ imm = #-0x12
 80009f4: 4660         	mov	r0, r12
 80009f6: e7a3         	b	0x8000940 <__udivmoddi4+0xe0> @ imm = #-0xba
 80009f8: 4663         	mov	r3, r12
 80009fa: e7b7         	b	0x800096c <__udivmoddi4+0x10c> @ imm = #-0x92
 80009fc: 4283         	cmp	r3, r0
 80009fe: d906         	bls	0x8000a0e <__udivmoddi4+0x1ae> @ imm = #0xc
 8000a00: b916         	cbnz	r6, 0x8000a08 <__udivmoddi4+0x1a8> @ imm = #0x4
 8000a02: 2100         	movs	r1, #0x0
 8000a04: 4608         	mov	r0, r1
 8000a06: e77b         	b	0x8000900 <__udivmoddi4+0xa0> @ imm = #-0x10a
 8000a08: e9c6 e000    	strd	lr, r0, [r6]
 8000a0c: e7f9         	b	0x8000a02 <__udivmoddi4+0x1a2> @ imm = #-0xe
 8000a0e: fab3 f783    	clz	r7, r3
 8000a12: b98f         	cbnz	r7, 0x8000a38 <__udivmoddi4+0x1d8> @ imm = #0x22
 8000a14: 4283         	cmp	r3, r0
 8000a16: d301         	blo	0x8000a1c <__udivmoddi4+0x1bc> @ imm = #0x2
 8000a18: 4572         	cmp	r2, lr
 8000a1a: d808         	bhi	0x8000a2e <__udivmoddi4+0x1ce> @ imm = #0x10
 8000a1c: ebbe 0402    	subs.w	r4, lr, r2
 8000a20: eb60 0303    	sbc.w	r3, r0, r3
 8000a24: 2001         	movs	r0, #0x1
 8000a26: 469c         	mov	r12, r3
 8000a28: b91e         	cbnz	r6, 0x8000a32 <__udivmoddi4+0x1d2> @ imm = #0x6
 8000a2a: 2100         	movs	r1, #0x0
 8000a2c: e768         	b	0x8000900 <__udivmoddi4+0xa0> @ imm = #-0x130
 8000a2e: 4638         	mov	r0, r7
 8000a30: e7fa         	b	0x8000a28 <__udivmoddi4+0x1c8> @ imm = #-0xc
 8000a32: e9c6 4c00    	strd	r4, r12, [r6]
 8000a36: e7f8         	b	0x8000a2a <__udivmoddi4+0x1ca> @ imm = #-0x10
 8000a38: f1c7 0c20    	rsb.w	r12, r7, #0x20
 8000a3c: 40bb         	lsls	r3, r7
 8000a3e: fa22 f40c    	lsr.w	r4, r2, r12
 8000a42: 431c         	orrs	r4, r3
 8000a44: fa2e f10c    	lsr.w	r1, lr, r12
 8000a48: fa20 f30c    	lsr.w	r3, r0, r12
 8000a4c: 40b8         	lsls	r0, r7
 8000a4e: 4301         	orrs	r1, r0
 8000a50: ea4f 4914    	lsr.w	r9, r4, #0x10
 8000a54: fa0e f507    	lsl.w	r5, lr, r7
 8000a58: fbb3 f8f9    	udiv	r8, r3, r9
 8000a5c: fa1f fe84    	uxth.w	lr, r4
 8000a60: fb09 3018    	mls	r0, r9, r8, r3
 8000a64: 0c0b         	lsrs	r3, r1, #0x10
 8000a66: fb08 fa0e    	mul	r10, r8, lr
 8000a6a: ea43 4300    	orr.w	r3, r3, r0, lsl #16
 8000a6e: 459a         	cmp	r10, r3
 8000a70: fa02 f207    	lsl.w	r2, r2, r7
 8000a74: d940         	bls	0x8000af8 <__udivmoddi4+0x298> @ imm = #0x80
 8000a76: 18e3         	adds	r3, r4, r3
 8000a78: f108 30ff    	add.w	r0, r8, #0xffffffff
 8000a7c: d204         	bhs	0x8000a88 <__udivmoddi4+0x228> @ imm = #0x8
 8000a7e: 459a         	cmp	r10, r3
 8000a80: d902         	bls	0x8000a88 <__udivmoddi4+0x228> @ imm = #0x4
 8000a82: f1a8 0002    	sub.w	r0, r8, #0x2
 8000a86: 4423         	add	r3, r4
 8000a88: eba3 030a    	sub.w	r3, r3, r10
 8000a8c: b289         	uxth	r1, r1
 8000a8e: fbb3 f8f9    	udiv	r8, r3, r9
 8000a92: fb09 3318    	mls	r3, r9, r8, r3
 8000a96: fb08 fe0e    	mul	lr, r8, lr
 8000a9a: ea41 4103    	orr.w	r1, r1, r3, lsl #16
 8000a9e: 458e         	cmp	lr, r1
 8000aa0: d92c         	bls	0x8000afc <__udivmoddi4+0x29c> @ imm = #0x58
 8000aa2: 1861         	adds	r1, r4, r1
 8000aa4: f108 33ff    	add.w	r3, r8, #0xffffffff
 8000aa8: d204         	bhs	0x8000ab4 <__udivmoddi4+0x254> @ imm = #0x8
 8000aaa: 458e         	cmp	lr, r1
 8000aac: d902         	bls	0x8000ab4 <__udivmoddi4+0x254> @ imm = #0x4
 8000aae: f1a8 0302    	sub.w	r3, r8, #0x2
 8000ab2: 4421         	add	r1, r4
 8000ab4: ea43 4000    	orr.w	r0, r3, r0, lsl #16
 8000ab8: fba0 9802    	umull	r9, r8, r0, r2
 8000abc: eba1 010e    	sub.w	r1, r1, lr
 8000ac0: 4541         	cmp	r1, r8
 8000ac2: 46ce         	mov	lr, r9
 8000ac4: 4643         	mov	r3, r8
 8000ac6: d302         	blo	0x8000ace <__udivmoddi4+0x26e> @ imm = #0x4
 8000ac8: d106         	bne	0x8000ad8 <__udivmoddi4+0x278> @ imm = #0xc
 8000aca: 454d         	cmp	r5, r9
 8000acc: d204         	bhs	0x8000ad8 <__udivmoddi4+0x278> @ imm = #0x8
 8000ace: ebb9 0e02    	subs.w	lr, r9, r2
 8000ad2: eb68 0304    	sbc.w	r3, r8, r4
 8000ad6: 3801         	subs	r0, #0x1
 8000ad8: 2e00         	cmp	r6, #0x0
 8000ada: d0a6         	beq	0x8000a2a <__udivmoddi4+0x1ca> @ imm = #-0xb4
 8000adc: ebb5 020e    	subs.w	r2, r5, lr
 8000ae0: eb61 0103    	sbc.w	r1, r1, r3
 8000ae4: fa01 fc0c    	lsl.w	r12, r1, r12
 8000ae8: fa22 f307    	lsr.w	r3, r2, r7
 8000aec: ea4c 0303    	orr.w	r3, r12, r3
 8000af0: 40f9         	lsrs	r1, r7
 8000af2: e9c6 3100    	strd	r3, r1, [r6]
 8000af6: e798         	b	0x8000a2a <__udivmoddi4+0x1ca> @ imm = #-0xd0
 8000af8: 4640         	mov	r0, r8
 8000afa: e7c5         	b	0x8000a88 <__udivmoddi4+0x228> @ imm = #-0x76
 8000afc: 4643         	mov	r3, r8
 8000afe: e7d9         	b	0x8000ab4 <__udivmoddi4+0x254> @ imm = #-0x4e

08000b00 <sensor_ms2_to_g>:
; {
 8000b00: e92d 4fb0    	push.w	{r4, r5, r7, r8, r9, r10, r11, lr}
 8000b04: b090         	sub	sp, #0x40
 8000b06: af00         	add	r7, sp, #0x0
 8000b08: 6378         	str	r0, [r7, #0x34]
; 	int64_t micro_ms2 = ms2->val1 * 1000000LL + ms2->val2;
 8000b0a: 6b7b         	ldr	r3, [r7, #0x34]
 8000b0c: 681b         	ldr	r3, [r3]
 8000b0e: 17da         	asrs	r2, r3, #0x1f
 8000b10: 469a         	mov	r10, r3
 8000b12: 4693         	mov	r11, r2
 8000b14: 4652         	mov	r2, r10
 8000b16: 465b         	mov	r3, r11
 8000b18: f04f 0000    	mov.w	r0, #0x0
 8000b1c: f04f 0100    	mov.w	r1, #0x0
 8000b20: 0159         	lsls	r1, r3, #0x5
 8000b22: ea41 61d2    	orr.w	r1, r1, r2, lsr #27
 8000b26: 0150         	lsls	r0, r2, #0x5
 8000b28: 4602         	mov	r2, r0
 8000b2a: 460b         	mov	r3, r1
 8000b2c: ebb2 040a    	subs.w	r4, r2, r10
 8000b30: eb63 050b    	sbc.w	r5, r3, r11
 8000b34: f04f 0200    	mov.w	r2, #0x0
 8000b38: f04f 0300    	mov.w	r3, #0x0
 8000b3c: 026b         	lsls	r3, r5, #0x9
 8000b3e: ea43 53d4    	orr.w	r3, r3, r4, lsr #23
 8000b42: 0262         	lsls	r2, r4, #0x9
 8000b44: 4614         	mov	r4, r2
 8000b46: 461d         	mov	r5, r3
 8000b48: eb14 080a    	adds.w	r8, r4, r10
 8000b4c: eb45 090b    	adc.w	r9, r5, r11
 8000b50: f04f 0200    	mov.w	r2, #0x0
 8000b54: f04f 0300    	mov.w	r3, #0x0
 8000b58: ea4f 1389    	lsl.w	r3, r9, #0x6
 8000b5c: ea43 6398    	orr.w	r3, r3, r8, lsr #26
 8000b60: ea4f 1288    	lsl.w	r2, r8, #0x6
 8000b64: ebb2 0108    	subs.w	r1, r2, r8
 8000b68: 60b9         	str	r1, [r7, #0x8]
 8000b6a: eb63 0309    	sbc.w	r3, r3, r9
 8000b6e: 60fb         	str	r3, [r7, #0xc]
 8000b70: e9d7 3402    	ldrd	r3, r4, [r7, #8]
 8000b74: 461a         	mov	r2, r3
 8000b76: eb12 020a    	adds.w	r2, r2, r10
 8000b7a: 62ba         	str	r2, [r7, #0x28]
 8000b7c: 4623         	mov	r3, r4
 8000b7e: eb43 030b    	adc.w	r3, r3, r11
 8000b82: 62fb         	str	r3, [r7, #0x2c]
 8000b84: 6b7b         	ldr	r3, [r7, #0x34]
 8000b86: 685b         	ldr	r3, [r3, #0x4]
 8000b88: 17da         	asrs	r2, r3, #0x1f
 8000b8a: 623b         	str	r3, [r7, #0x20]
 8000b8c: 627a         	str	r2, [r7, #0x24]
 8000b8e: e9d7 450a    	ldrd	r4, r5, [r7, #40]
 8000b92: 4623         	mov	r3, r4
 8000b94: e9d7 0108    	ldrd	r0, r1, [r7, #32]
 8000b98: 4602         	mov	r2, r0
 8000b9a: 189b         	adds	r3, r3, r2
 8000b9c: 603b         	str	r3, [r7]
 8000b9e: 460b         	mov	r3, r1
 8000ba0: 462a         	mov	r2, r5
 8000ba2: eb42 0303    	adc.w	r3, r2, r3
 8000ba6: 607b         	str	r3, [r7, #0x4]
 8000ba8: e9d7 3400    	ldrd	r3, r4, [r7]
 8000bac: e9c7 340e    	strd	r3, r4, [r7, #56]
; 	if (micro_ms2 > 0) {
 8000bb0: e9d7 230e    	ldrd	r2, r3, [r7, #56]
 8000bb4: 2a01         	cmp	r2, #0x1
 8000bb6: f173 0300    	sbcs	r3, r3, #0x0
 8000bba: db12         	blt	0x8000be2 <sensor_ms2_to_g+0xe2> @ imm = #0x24
; 		return (micro_ms2 + SENSOR_G / 2) / SENSOR_G;
 8000bbc: e9d7 230e    	ldrd	r2, r3, [r7, #56]
 8000bc0: 4915         	ldr	r1, [pc, #0x54]         @ 0x8000c18 <sensor_ms2_to_g+0x118>
 8000bc2: 1851         	adds	r1, r2, r1
 8000bc4: 61b9         	str	r1, [r7, #0x18]
 8000bc6: f143 0300    	adc	r3, r3, #0x0
 8000bca: 61fb         	str	r3, [r7, #0x1c]
 8000bcc: a310         	adr	r3, #64 <sensor_ms2_to_g+0xe0>
 8000bce: e9d3 2300    	ldrd	r2, r3, [r3]
 8000bd2: e9d7 0106    	ldrd	r0, r1, [r7, #24]
 8000bd6: f7ff fdd1    	bl	0x800077c <__aeabi_ldivmod> @ imm = #-0x45e
 8000bda: 4602         	mov	r2, r0
 8000bdc: 460b         	mov	r3, r1
 8000bde: 4613         	mov	r3, r2
 8000be0: e011         	b	0x8000c06 <sensor_ms2_to_g+0x106> @ imm = #0x22
; 		return (micro_ms2 - SENSOR_G / 2) / SENSOR_G;
 8000be2: e9d7 230e    	ldrd	r2, r3, [r7, #56]
 8000be6: 490d         	ldr	r1, [pc, #0x34]         @ 0x8000c1c <sensor_ms2_to_g+0x11c>
 8000be8: 1851         	adds	r1, r2, r1
 8000bea: 6139         	str	r1, [r7, #0x10]
 8000bec: f143 33ff    	adc	r3, r3, #0xffffffff
 8000bf0: 617b         	str	r3, [r7, #0x14]
 8000bf2: a307         	adr	r3, #28 <sensor_ms2_to_g+0xfd>
 8000bf4: e9d3 2300    	ldrd	r2, r3, [r3]
 8000bf8: e9d7 0104    	ldrd	r0, r1, [r7, #16]
 8000bfc: f7ff fdbe    	bl	0x800077c <__aeabi_ldivmod> @ imm = #-0x484
 8000c00: 4602         	mov	r2, r0
 8000c02: 460b         	mov	r3, r1
 8000c04: 4613         	mov	r3, r2
; }
 8000c06: 4618         	mov	r0, r3
 8000c08: 3740         	adds	r7, #0x40
 8000c0a: 46bd         	mov	sp, r7
 8000c0c: e8bd 8fb0    	pop.w	{r4, r5, r7, r8, r9, r10, r11, pc}

08000c10 <$d>:
 8000c10: 3a a3 95 00  	.word	0x0095a33a
 8000c14: 00 00 00 00  	.word	0x00000000
 8000c18: 9d d1 4a 00  	.word	0x004ad19d
 8000c1c: 63 2e b5 ff  	.word	0xffb52e63

08000c20 <sensor_rad_to_degrees>:
; {
 8000c20: e92d 4fb0    	push.w	{r4, r5, r7, r8, r9, r10, r11, lr}
 8000c24: b09c         	sub	sp, #0x70
 8000c26: af00         	add	r7, sp, #0x0
 8000c28: 6678         	str	r0, [r7, #0x64]
; 	int64_t micro_rad_s = rad->val1 * 1000000LL + rad->val2;
 8000c2a: 6e7b         	ldr	r3, [r7, #0x64]
 8000c2c: 681b         	ldr	r3, [r3]
 8000c2e: 17da         	asrs	r2, r3, #0x1f
 8000c30: 65bb         	str	r3, [r7, #0x58]
 8000c32: 65fa         	str	r2, [r7, #0x5c]
 8000c34: e9d7 2316    	ldrd	r2, r3, [r7, #88]
 8000c38: f04f 0000    	mov.w	r0, #0x0
 8000c3c: f04f 0100    	mov.w	r1, #0x0
 8000c40: 0159         	lsls	r1, r3, #0x5
 8000c42: ea41 61d2    	orr.w	r1, r1, r2, lsr #27
 8000c46: 0150         	lsls	r0, r2, #0x5
 8000c48: 4602         	mov	r2, r0
 8000c4a: 460b         	mov	r3, r1
 8000c4c: e9d7 0116    	ldrd	r0, r1, [r7, #88]
 8000c50: 4684         	mov	r12, r0
 8000c52: ebb2 040c    	subs.w	r4, r2, r12
 8000c56: 468c         	mov	r12, r1
 8000c58: eb63 050c    	sbc.w	r5, r3, r12
 8000c5c: f04f 0200    	mov.w	r2, #0x0
 8000c60: f04f 0300    	mov.w	r3, #0x0
 8000c64: 026b         	lsls	r3, r5, #0x9
 8000c66: ea43 53d4    	orr.w	r3, r3, r4, lsr #23
 8000c6a: 0262         	lsls	r2, r4, #0x9
 8000c6c: 4614         	mov	r4, r2
 8000c6e: 461d         	mov	r5, r3
 8000c70: 4603         	mov	r3, r0
 8000c72: eb14 0803    	adds.w	r8, r4, r3
 8000c76: 460b         	mov	r3, r1
 8000c78: eb45 0903    	adc.w	r9, r5, r3
 8000c7c: f04f 0200    	mov.w	r2, #0x0
 8000c80: f04f 0300    	mov.w	r3, #0x0
 8000c84: ea4f 1389    	lsl.w	r3, r9, #0x6
 8000c88: ea43 6398    	orr.w	r3, r3, r8, lsr #26
 8000c8c: ea4f 1288    	lsl.w	r2, r8, #0x6
 8000c90: ebb2 0408    	subs.w	r4, r2, r8
 8000c94: 633c         	str	r4, [r7, #0x30]
 8000c96: eb63 0309    	sbc.w	r3, r3, r9
 8000c9a: 637b         	str	r3, [r7, #0x34]
 8000c9c: e9d7 450c    	ldrd	r4, r5, [r7, #48]
 8000ca0: 4623         	mov	r3, r4
 8000ca2: 4602         	mov	r2, r0
 8000ca4: 189b         	adds	r3, r3, r2
 8000ca6: 653b         	str	r3, [r7, #0x50]
 8000ca8: 460b         	mov	r3, r1
 8000caa: 462a         	mov	r2, r5
 8000cac: eb42 0303    	adc.w	r3, r2, r3
 8000cb0: 657b         	str	r3, [r7, #0x54]
 8000cb2: 6e7b         	ldr	r3, [r7, #0x64]
 8000cb4: 685b         	ldr	r3, [r3, #0x4]
 8000cb6: 17da         	asrs	r2, r3, #0x1f
 8000cb8: 64bb         	str	r3, [r7, #0x48]
 8000cba: 64fa         	str	r2, [r7, #0x4c]
 8000cbc: e9d7 4514    	ldrd	r4, r5, [r7, #80]
 8000cc0: 4623         	mov	r3, r4
 8000cc2: e9d7 0112    	ldrd	r0, r1, [r7, #72]
 8000cc6: 4602         	mov	r2, r0
 8000cc8: 189b         	adds	r3, r3, r2
 8000cca: 62bb         	str	r3, [r7, #0x28]
 8000ccc: 460b         	mov	r3, r1
 8000cce: 462a         	mov	r2, r5
 8000cd0: eb42 0303    	adc.w	r3, r2, r3
 8000cd4: 62fb         	str	r3, [r7, #0x2c]
 8000cd6: e9d7 340a    	ldrd	r3, r4, [r7, #40]
 8000cda: e9c7 341a    	strd	r3, r4, [r7, #104]
; 	if (micro_rad_s > 0) {
 8000cde: e9d7 231a    	ldrd	r2, r3, [r7, #104]
 8000ce2: 2a01         	cmp	r2, #0x1
 8000ce4: f173 0300    	sbcs	r3, r3, #0x0
 8000ce8: db42         	blt	0x8000d70 <sensor_rad_to_degrees+0x150> @ imm = #0x84
; 		return (micro_rad_s * 180LL + SENSOR_PI / 2) / SENSOR_PI;
 8000cea: e9d7 011a    	ldrd	r0, r1, [r7, #104]
 8000cee: 4602         	mov	r2, r0
 8000cf0: 460b         	mov	r3, r1
 8000cf2: 1894         	adds	r4, r2, r2
 8000cf4: 623c         	str	r4, [r7, #0x20]
 8000cf6: 415b         	adcs	r3, r3
 8000cf8: 627b         	str	r3, [r7, #0x24]
 8000cfa: e9d7 2308    	ldrd	r2, r3, [r7, #32]
 8000cfe: 1814         	adds	r4, r2, r0
 8000d00: 61bc         	str	r4, [r7, #0x18]
 8000d02: 414b         	adcs	r3, r1
 8000d04: 61fb         	str	r3, [r7, #0x1c]
 8000d06: f04f 0200    	mov.w	r2, #0x0
 8000d0a: f04f 0300    	mov.w	r3, #0x0
 8000d0e: e9d7 4506    	ldrd	r4, r5, [r7, #24]
 8000d12: 4629         	mov	r1, r5
 8000d14: 010b         	lsls	r3, r1, #0x4
 8000d16: 4621         	mov	r1, r4
 8000d18: ea43 7311    	orr.w	r3, r3, r1, lsr #28
 8000d1c: 4621         	mov	r1, r4
 8000d1e: 010a         	lsls	r2, r1, #0x4
 8000d20: 4620         	mov	r0, r4
 8000d22: 4629         	mov	r1, r5
 8000d24: 4604         	mov	r4, r0
 8000d26: 1b14         	subs	r4, r2, r4
 8000d28: 613c         	str	r4, [r7, #0x10]
 8000d2a: eb63 0301    	sbc.w	r3, r3, r1
 8000d2e: 617b         	str	r3, [r7, #0x14]
 8000d30: f04f 0200    	mov.w	r2, #0x0
 8000d34: f04f 0300    	mov.w	r3, #0x0
 8000d38: e9d7 4504    	ldrd	r4, r5, [r7, #16]
 8000d3c: 4629         	mov	r1, r5
 8000d3e: 008b         	lsls	r3, r1, #0x2
 8000d40: 4620         	mov	r0, r4
 8000d42: 4629         	mov	r1, r5
 8000d44: 4604         	mov	r4, r0
 8000d46: ea43 7394    	orr.w	r3, r3, r4, lsr #30
 8000d4a: 4601         	mov	r1, r0
 8000d4c: 008a         	lsls	r2, r1, #0x2
 8000d4e: 492c         	ldr	r1, [pc, #0xb0]         @ 0x8000e00 <sensor_rad_to_degrees+0x1e0>
 8000d50: 1851         	adds	r1, r2, r1
 8000d52: 6439         	str	r1, [r7, #0x40]
 8000d54: f143 0300    	adc	r3, r3, #0x0
 8000d58: 647b         	str	r3, [r7, #0x44]
 8000d5a: a327         	adr	r3, #156 <sensor_rad_to_degrees+0x165>
 8000d5c: e9d3 2300    	ldrd	r2, r3, [r3]
 8000d60: e9d7 0110    	ldrd	r0, r1, [r7, #64]
 8000d64: f7ff fd0a    	bl	0x800077c <__aeabi_ldivmod> @ imm = #-0x5ec
 8000d68: 4602         	mov	r2, r0
 8000d6a: 460b         	mov	r3, r1
 8000d6c: 4613         	mov	r3, r2
 8000d6e: e03c         	b	0x8000dea <sensor_rad_to_degrees+0x1ca> @ imm = #0x78
; 		return (micro_rad_s * 180LL - SENSOR_PI / 2) / SENSOR_PI;
 8000d70: e9d7 011a    	ldrd	r0, r1, [r7, #104]
 8000d74: 4602         	mov	r2, r0
 8000d76: 460b         	mov	r3, r1
 8000d78: 1894         	adds	r4, r2, r2
 8000d7a: 60bc         	str	r4, [r7, #0x8]
 8000d7c: 415b         	adcs	r3, r3
 8000d7e: 60fb         	str	r3, [r7, #0xc]
 8000d80: e9d7 2302    	ldrd	r2, r3, [r7, #8]
 8000d84: eb12 0a00    	adds.w	r10, r2, r0
 8000d88: eb43 0b01    	adc.w	r11, r3, r1
 8000d8c: f04f 0200    	mov.w	r2, #0x0
 8000d90: f04f 0300    	mov.w	r3, #0x0
 8000d94: ea4f 130b    	lsl.w	r3, r11, #0x4
 8000d98: ea43 731a    	orr.w	r3, r3, r10, lsr #28
 8000d9c: ea4f 120a    	lsl.w	r2, r10, #0x4
 8000da0: ebb2 010a    	subs.w	r1, r2, r10
 8000da4: 6039         	str	r1, [r7]
 8000da6: eb63 030b    	sbc.w	r3, r3, r11
 8000daa: 607b         	str	r3, [r7, #0x4]
 8000dac: f04f 0200    	mov.w	r2, #0x0
 8000db0: f04f 0300    	mov.w	r3, #0x0
 8000db4: e9d7 4500    	ldrd	r4, r5, [r7]
 8000db8: 4629         	mov	r1, r5
 8000dba: 008b         	lsls	r3, r1, #0x2
 8000dbc: 4620         	mov	r0, r4
 8000dbe: 4629         	mov	r1, r5
 8000dc0: 4604         	mov	r4, r0
 8000dc2: ea43 7394    	orr.w	r3, r3, r4, lsr #30
 8000dc6: 4601         	mov	r1, r0
 8000dc8: 008a         	lsls	r2, r1, #0x2
 8000dca: 490e         	ldr	r1, [pc, #0x38]         @ 0x8000e04 <sensor_rad_to_degrees+0x1e4>
 8000dcc: 1851         	adds	r1, r2, r1
 8000dce: 63b9         	str	r1, [r7, #0x38]
 8000dd0: f143 33ff    	adc	r3, r3, #0xffffffff
 8000dd4: 63fb         	str	r3, [r7, #0x3c]
 8000dd6: a308         	adr	r3, #32 <sensor_rad_to_degrees+0x1c2>
 8000dd8: e9d3 2300    	ldrd	r2, r3, [r3]
 8000ddc: e9d7 010e    	ldrd	r0, r1, [r7, #56]
 8000de0: f7ff fccc    	bl	0x800077c <__aeabi_ldivmod> @ imm = #-0x668
 8000de4: 4602         	mov	r2, r0
 8000de6: 460b         	mov	r3, r1
 8000de8: 4613         	mov	r3, r2
; }
 8000dea: 4618         	mov	r0, r3
 8000dec: 3770         	adds	r7, #0x70
 8000dee: 46bd         	mov	sp, r7
 8000df0: e8bd 8fb0    	pop.w	{r4, r5, r7, r8, r9, r10, r11, pc}
 8000df4: f3af 8000    	nop.w

08000df8 <$d>:
 8000df8: d8 ef 2f 00  	.word	0x002fefd8
 8000dfc: 00 00 00 00  	.word	0x00000000
 8000e00: ec f7 17 00  	.word	0x0017f7ec
 8000e04: 14 08 e8 ff  	.word	0xffe80814

08000e08 <sensor_value_to_float>:
; {
 8000e08: b590         	push	{r4, r7, lr}
 8000e0a: b083         	sub	sp, #0xc
 8000e0c: af00         	add	r7, sp, #0x0
 8000e0e: 6078         	str	r0, [r7, #0x4]
; 	return (float)val->val1 + (float)val->val2 / 1000000;
 8000e10: 687b         	ldr	r3, [r7, #0x4]
 8000e12: 681b         	ldr	r3, [r3]
 8000e14: 4618         	mov	r0, r3
 8000e16: f7ff fa71    	bl	0x80002fc <__floatsisf> @ imm = #-0xb1e
 8000e1a: 4604         	mov	r4, r0
 8000e1c: 687b         	ldr	r3, [r7, #0x4]
 8000e1e: 685b         	ldr	r3, [r3, #0x4]
 8000e20: 4618         	mov	r0, r3
 8000e22: f7ff fa6b    	bl	0x80002fc <__floatsisf> @ imm = #-0xb2a
 8000e26: 4603         	mov	r3, r0
 8000e28: 4906         	ldr	r1, [pc, #0x18]         @ 0x8000e44 <sensor_value_to_float+0x3c>
 8000e2a: 4618         	mov	r0, r3
 8000e2c: f7ff fb6e    	bl	0x800050c <__divsf3>    @ imm = #-0x924
 8000e30: 4603         	mov	r3, r0
 8000e32: 4619         	mov	r1, r3
 8000e34: 4620         	mov	r0, r4
 8000e36: f7ff f9ad    	bl	0x8000194 <__aeabi_fadd> @ imm = #-0xca6
 8000e3a: 4603         	mov	r3, r0
; }
 8000e3c: 4618         	mov	r0, r3
 8000e3e: 370c         	adds	r7, #0xc
 8000e40: 46bd         	mov	sp, r7
 8000e42: bd90         	pop	{r4, r7, pc}

08000e44 <$d>:
 8000e44: 00 24 74 49  	.word	0x49742400

08000e48 <jf_send_float>:
; {
 8000e48: b580         	push	{r7, lr}
 8000e4a: b084         	sub	sp, #0x10
 8000e4c: af00         	add	r7, sp, #0x0
 8000e4e: 6078         	str	r0, [r7, #0x4]
; 	const struct device *uart_dev = data->uart_dev;
 8000e50: 687b         	ldr	r3, [r7, #0x4]
 8000e52: 681b         	ldr	r3, [r3]
 8000e54: 60bb         	str	r3, [r7, #0x8]
; 	for (int i = 0; i < data->channel; i++) {
 8000e56: 2300         	movs	r3, #0x0
 8000e58: 60fb         	str	r3, [r7, #0xc]
 8000e5a: e01c         	b	0x8000e96 <jf_send_float+0x4e> @ imm = #0x38
; 		if (data->fdata[i] == data->fdata[data->channel]) {
 8000e5c: 687b         	ldr	r3, [r7, #0x4]
 8000e5e: 685a         	ldr	r2, [r3, #0x4]
 8000e60: 68fb         	ldr	r3, [r7, #0xc]
 8000e62: 009b         	lsls	r3, r3, #0x2
 8000e64: 4413         	add	r3, r2
 8000e66: 6818         	ldr	r0, [r3]
 8000e68: 687b         	ldr	r3, [r7, #0x4]
 8000e6a: 685a         	ldr	r2, [r3, #0x4]
 8000e6c: 687b         	ldr	r3, [r7, #0x4]
 8000e6e: 689b         	ldr	r3, [r3, #0x8]
 8000e70: 009b         	lsls	r3, r3, #0x2
 8000e72: 4413         	add	r3, r2
 8000e74: 681b         	ldr	r3, [r3]
 8000e76: 4619         	mov	r1, r3
 8000e78: f7ff fc28    	bl	0x80006cc <__aeabi_fcmpeq> @ imm = #-0x7b0
 8000e7c: 4603         	mov	r3, r0
 8000e7e: 2b00         	cmp	r3, #0x0
 8000e80: d006         	beq	0x8000e90 <jf_send_float+0x48> @ imm = #0xc
; 			data->fdata[i] = 1e+6;
 8000e82: 687b         	ldr	r3, [r7, #0x4]
 8000e84: 685a         	ldr	r2, [r3, #0x4]
 8000e86: 68fb         	ldr	r3, [r7, #0xc]
 8000e88: 009b         	lsls	r3, r3, #0x2
 8000e8a: 4413         	add	r3, r2
 8000e8c: 4a0c         	ldr	r2, [pc, #0x30]         @ 0x8000ec0 <jf_send_float+0x78>
 8000e8e: 601a         	str	r2, [r3]
; 	for (int i = 0; i < data->channel; i++) {
 8000e90: 68fb         	ldr	r3, [r7, #0xc]
 8000e92: 3301         	adds	r3, #0x1
 8000e94: 60fb         	str	r3, [r7, #0xc]
 8000e96: 687b         	ldr	r3, [r7, #0x4]
 8000e98: 689b         	ldr	r3, [r3, #0x8]
 8000e9a: 68fa         	ldr	r2, [r7, #0xc]
 8000e9c: 429a         	cmp	r2, r3
 8000e9e: dbdd         	blt	0x8000e5c <jf_send_float+0x14> @ imm = #-0x46
; 	uart_tx(uart_dev, (const uint8_t *)data->fdata, data->channel * 4 + 4, SYS_FOREVER_US);
 8000ea0: 687b         	ldr	r3, [r7, #0x4]
 8000ea2: 6859         	ldr	r1, [r3, #0x4]
 8000ea4: 687b         	ldr	r3, [r7, #0x4]
 8000ea6: 689b         	ldr	r3, [r3, #0x8]
 8000ea8: 3301         	adds	r3, #0x1
 8000eaa: 009b         	lsls	r3, r3, #0x2
 8000eac: 461a         	mov	r2, r3
 8000eae: f04f 33ff    	mov.w	r3, #0xffffffff
 8000eb2: 68b8         	ldr	r0, [r7, #0x8]
 8000eb4: f012 fe2d    	bl	0x8013b12 <uart_tx>     @ imm = #0x12c5a
; }
 8000eb8: bf00         	nop
 8000eba: 3710         	adds	r7, #0x10
 8000ebc: 46bd         	mov	sp, r7
 8000ebe: bd80         	pop	{r7, pc}

08000ec0 <$d>:
 8000ec0: 00 24 74 49  	.word	0x49742400

08000ec4 <jf_send_init>:
; {
 8000ec4: b580         	push	{r7, lr}
 8000ec6: b08e         	sub	sp, #0x38
 8000ec8: af08         	add	r7, sp, #0x20
 8000eca: 60f8         	str	r0, [r7, #0xc]
 8000ecc: 60b9         	str	r1, [r7, #0x8]
 8000ece: 607a         	str	r2, [r7, #0x4]
; 	struct JFData *data = (struct JFData *)malloc(sizeof(struct JFData));
 8000ed0: 200c         	movs	r0, #0xc
 8000ed2: f005 f937    	bl	0x8006144 <malloc>      @ imm = #0x526e
 8000ed6: 4603         	mov	r3, r0
 8000ed8: 617b         	str	r3, [r7, #0x14]
; 	data->fdata = (float *)malloc(sizeof(float) * (channel + 1));
 8000eda: 687b         	ldr	r3, [r7, #0x4]
 8000edc: 3301         	adds	r3, #0x1
 8000ede: 009b         	lsls	r3, r3, #0x2
 8000ee0: 4618         	mov	r0, r3
 8000ee2: f005 f92f    	bl	0x8006144 <malloc>      @ imm = #0x525e
 8000ee6: 4603         	mov	r3, r0
 8000ee8: 461a         	mov	r2, r3
 8000eea: 697b         	ldr	r3, [r7, #0x14]
 8000eec: 605a         	str	r2, [r3, #0x4]
; 	data->channel = channel;
 8000eee: 697b         	ldr	r3, [r7, #0x14]
 8000ef0: 687a         	ldr	r2, [r7, #0x4]
 8000ef2: 609a         	str	r2, [r3, #0x8]
; 	if (!device_is_ready(uart_dev)) {
 8000ef4: 68f8         	ldr	r0, [r7, #0xc]
 8000ef6: f012 fd23    	bl	0x8013940 <device_is_ready> @ imm = #0x12a46
 8000efa: 4603         	mov	r3, r0
 8000efc: f083 0301    	eor	r3, r3, #0x1
 8000f00: b2db         	uxtb	r3, r3
 8000f02: 2b00         	cmp	r3, #0x0
 8000f04: d001         	beq	0x8000f0a <jf_send_init+0x46> @ imm = #0x2
; 		return NULL;
 8000f06: 2100         	movs	r1, #0x0
 8000f08: e022         	b	0x8000f50 <jf_send_init+0x8c> @ imm = #0x44
; 	data->uart_dev = (struct device *)uart_dev;
 8000f0a: 697b         	ldr	r3, [r7, #0x14]
 8000f0c: 68fa         	ldr	r2, [r7, #0xc]
 8000f0e: 601a         	str	r2, [r3]
; 	memcpy(&(data->fdata[channel]), tail, 4 * sizeof(uint8_t));
 8000f10: 697b         	ldr	r3, [r7, #0x14]
 8000f12: 685a         	ldr	r2, [r3, #0x4]
 8000f14: 687b         	ldr	r3, [r7, #0x4]
 8000f16: 009b         	lsls	r3, r3, #0x2
 8000f18: 4413         	add	r3, r2
 8000f1a: 4a10         	ldr	r2, [pc, #0x40]         @ 0x8000f5c <jf_send_init+0x98>
 8000f1c: 6810         	ldr	r0, [r2]
 8000f1e: 6018         	str	r0, [r3]
; 	k_thread_create(&jf_thread_data, jf_stack_area, K_THREAD_STACK_SIZEOF(jf_stack_area),
 8000f20: 68b9         	ldr	r1, [r7, #0x8]
; 			jf_feedback, (void *)delay, data, NULL, 1, 0, K_NO_WAIT);
 8000f22: f04f 0200    	mov.w	r2, #0x0
 8000f26: f04f 0300    	mov.w	r3, #0x0
; 	k_thread_create(&jf_thread_data, jf_stack_area, K_THREAD_STACK_SIZEOF(jf_stack_area),
 8000f2a: e9cd 2306    	strd	r2, r3, [sp, #24]
 8000f2e: 2300         	movs	r3, #0x0
 8000f30: 9304         	str	r3, [sp, #0x10]
 8000f32: 2301         	movs	r3, #0x1
 8000f34: 9303         	str	r3, [sp, #0xc]
 8000f36: 2300         	movs	r3, #0x0
 8000f38: 9302         	str	r3, [sp, #0x8]
 8000f3a: 697b         	ldr	r3, [r7, #0x14]
 8000f3c: 9301         	str	r3, [sp, #0x4]
 8000f3e: 9100         	str	r1, [sp]
 8000f40: 4b07         	ldr	r3, [pc, #0x1c]         @ 0x8000f60 <jf_send_init+0x9c>
 8000f42: f44f 7240    	mov.w	r2, #0x300
 8000f46: 4907         	ldr	r1, [pc, #0x1c]         @ 0x8000f64 <jf_send_init+0xa0>
 8000f48: 4807         	ldr	r0, [pc, #0x1c]         @ 0x8000f68 <jf_send_init+0xa4>
 8000f4a: f012 fd3f    	bl	0x80139cc <k_thread_create> @ imm = #0x12a7e
; 	return data;
 8000f4e: 6979         	ldr	r1, [r7, #0x14]
; }
 8000f50: 460b         	mov	r3, r1
 8000f52: 4618         	mov	r0, r3
 8000f54: 3718         	adds	r7, #0x18
 8000f56: 46bd         	mov	sp, r7
 8000f58: bd80         	pop	{r7, pc}
 8000f5a: bf00         	nop

08000f5c <$d>:
 8000f5c: 50 fe 01 08  	.word	0x0801fe50
 8000f60: 37 3b 01 08  	.word	0x08013b37
 8000f64: 90 1f 00 20  	.word	0x20001f90
 8000f68: 28 06 00 20  	.word	0x20000628

08000f6c <Kalman_Filter_Init>:
; {
 8000f6c: b580         	push	{r7, lr}
 8000f6e: b082         	sub	sp, #0x8
 8000f70: af00         	add	r7, sp, #0x0
 8000f72: 6078         	str	r0, [r7, #0x4]
 8000f74: 4608         	mov	r0, r1
 8000f76: 4611         	mov	r1, r2
 8000f78: 461a         	mov	r2, r3
 8000f7a: 4603         	mov	r3, r0
 8000f7c: 70fb         	strb	r3, [r7, #0x3]
 8000f7e: 460b         	mov	r3, r1
 8000f80: 70bb         	strb	r3, [r7, #0x2]
 8000f82: 4613         	mov	r3, r2
 8000f84: 707b         	strb	r3, [r7, #0x1]
; 	sizeof_float = sizeof(float);
 8000f86: 4bba         	ldr	r3, [pc, #0x2e8]        @ 0x8001270 <Kalman_Filter_Init+0x304>
 8000f88: 2204         	movs	r2, #0x4
 8000f8a: 801a         	strh	r2, [r3]
; 	sizeof_double = sizeof(double);
 8000f8c: 4bb9         	ldr	r3, [pc, #0x2e4]        @ 0x8001274 <Kalman_Filter_Init+0x308>
 8000f8e: 2208         	movs	r2, #0x8
 8000f90: 801a         	strh	r2, [r3]
; 	kf->xhatSize = xhatSize;
 8000f92: 687b         	ldr	r3, [r7, #0x4]
 8000f94: 78fa         	ldrb	r2, [r7, #0x3]
 8000f96: 731a         	strb	r2, [r3, #0xc]
; 	kf->uSize = uSize;
 8000f98: 687b         	ldr	r3, [r7, #0x4]
 8000f9a: 78ba         	ldrb	r2, [r7, #0x2]
 8000f9c: 735a         	strb	r2, [r3, #0xd]
; 	kf->zSize = zSize;
 8000f9e: 687b         	ldr	r3, [r7, #0x4]
 8000fa0: 787a         	ldrb	r2, [r7, #0x1]
 8000fa2: 739a         	strb	r2, [r3, #0xe]
; 	kf->MeasurementValidNum = 0;
 8000fa4: 687b         	ldr	r3, [r7, #0x4]
 8000fa6: 2200         	movs	r2, #0x0
 8000fa8: 741a         	strb	r2, [r3, #0x10]
; 	kf->MeasurementMap = (uint8_t *)user_malloc(sizeof(uint8_t) * zSize);
 8000faa: 787b         	ldrb	r3, [r7, #0x1]
 8000fac: 4618         	mov	r0, r3
 8000fae: f005 f8c9    	bl	0x8006144 <malloc>      @ imm = #0x5192
 8000fb2: 4603         	mov	r3, r0
 8000fb4: 461a         	mov	r2, r3
 8000fb6: 687b         	ldr	r3, [r7, #0x4]
 8000fb8: 615a         	str	r2, [r3, #0x14]
; 	memset(kf->MeasurementMap, 0, sizeof(uint8_t) * zSize);
 8000fba: 687b         	ldr	r3, [r7, #0x4]
 8000fbc: 695b         	ldr	r3, [r3, #0x14]
 8000fbe: 787a         	ldrb	r2, [r7, #0x1]
 8000fc0: 2100         	movs	r1, #0x0
 8000fc2: 4618         	mov	r0, r3
 8000fc4: f01c fc12    	bl	0x801d7ec <memset>      @ imm = #0x1c824
; 	kf->MeasurementDegree = (float *)user_malloc(sizeof_float * zSize);
 8000fc8: 4ba9         	ldr	r3, [pc, #0x2a4]        @ 0x8001270 <Kalman_Filter_Init+0x304>
 8000fca: 881b         	ldrh	r3, [r3]
 8000fcc: 461a         	mov	r2, r3
 8000fce: 787b         	ldrb	r3, [r7, #0x1]
 8000fd0: fb02 f303    	mul	r3, r2, r3
 8000fd4: 4618         	mov	r0, r3
 8000fd6: f005 f8b5    	bl	0x8006144 <malloc>      @ imm = #0x516a
 8000fda: 4603         	mov	r3, r0
 8000fdc: 461a         	mov	r2, r3
 8000fde: 687b         	ldr	r3, [r7, #0x4]
 8000fe0: 619a         	str	r2, [r3, #0x18]
; 	memset(kf->MeasurementDegree, 0, sizeof_float * zSize);
 8000fe2: 687b         	ldr	r3, [r7, #0x4]
 8000fe4: 6998         	ldr	r0, [r3, #0x18]
 8000fe6: 4ba2         	ldr	r3, [pc, #0x288]        @ 0x8001270 <Kalman_Filter_Init+0x304>
 8000fe8: 881b         	ldrh	r3, [r3]
 8000fea: 461a         	mov	r2, r3
 8000fec: 787b         	ldrb	r3, [r7, #0x1]
 8000fee: fb02 f303    	mul	r3, r2, r3
 8000ff2: 461a         	mov	r2, r3
 8000ff4: 2100         	movs	r1, #0x0
 8000ff6: f01c fbf9    	bl	0x801d7ec <memset>      @ imm = #0x1c7f2
; 	kf->MatR_DiagonalElements = (float *)user_malloc(sizeof_float * zSize);
 8000ffa: 4b9d         	ldr	r3, [pc, #0x274]        @ 0x8001270 <Kalman_Filter_Init+0x304>
 8000ffc: 881b         	ldrh	r3, [r3]
 8000ffe: 461a         	mov	r2, r3
 8001000: 787b         	ldrb	r3, [r7, #0x1]
 8001002: fb02 f303    	mul	r3, r2, r3
 8001006: 4618         	mov	r0, r3
 8001008: f005 f89c    	bl	0x8006144 <malloc>      @ imm = #0x5138
 800100c: 4603         	mov	r3, r0
 800100e: 461a         	mov	r2, r3
 8001010: 687b         	ldr	r3, [r7, #0x4]
 8001012: 61da         	str	r2, [r3, #0x1c]
; 	memset(kf->MatR_DiagonalElements, 0, sizeof_float * zSize);
 8001014: 687b         	ldr	r3, [r7, #0x4]
 8001016: 69d8         	ldr	r0, [r3, #0x1c]
 8001018: 4b95         	ldr	r3, [pc, #0x254]        @ 0x8001270 <Kalman_Filter_Init+0x304>
 800101a: 881b         	ldrh	r3, [r3]
 800101c: 461a         	mov	r2, r3
 800101e: 787b         	ldrb	r3, [r7, #0x1]
 8001020: fb02 f303    	mul	r3, r2, r3
 8001024: 461a         	mov	r2, r3
 8001026: 2100         	movs	r1, #0x0
 8001028: f01c fbe0    	bl	0x801d7ec <memset>      @ imm = #0x1c7c0
; 	kf->StateMinVariance = (float *)user_malloc(sizeof_float * xhatSize);
 800102c: 4b90         	ldr	r3, [pc, #0x240]        @ 0x8001270 <Kalman_Filter_Init+0x304>
 800102e: 881b         	ldrh	r3, [r3]
 8001030: 461a         	mov	r2, r3
 8001032: 78fb         	ldrb	r3, [r7, #0x3]
 8001034: fb02 f303    	mul	r3, r2, r3
 8001038: 4618         	mov	r0, r3
 800103a: f005 f883    	bl	0x8006144 <malloc>      @ imm = #0x5106
 800103e: 4603         	mov	r3, r0
 8001040: 461a         	mov	r2, r3
 8001042: 687b         	ldr	r3, [r7, #0x4]
 8001044: 621a         	str	r2, [r3, #0x20]
; 	memset(kf->StateMinVariance, 0, sizeof_float * xhatSize);
 8001046: 687b         	ldr	r3, [r7, #0x4]
 8001048: 6a18         	ldr	r0, [r3, #0x20]
 800104a: 4b89         	ldr	r3, [pc, #0x224]        @ 0x8001270 <Kalman_Filter_Init+0x304>
 800104c: 881b         	ldrh	r3, [r3]
 800104e: 461a         	mov	r2, r3
 8001050: 78fb         	ldrb	r3, [r7, #0x3]
 8001052: fb02 f303    	mul	r3, r2, r3
 8001056: 461a         	mov	r2, r3
 8001058: 2100         	movs	r1, #0x0
 800105a: f01c fbc7    	bl	0x801d7ec <memset>      @ imm = #0x1c78e
; 	kf->temp = (uint8_t *)user_malloc(sizeof(uint8_t) * zSize);
 800105e: 787b         	ldrb	r3, [r7, #0x1]
 8001060: 4618         	mov	r0, r3
 8001062: f005 f86f    	bl	0x8006144 <malloc>      @ imm = #0x50de
 8001066: 4603         	mov	r3, r0
 8001068: 461a         	mov	r2, r3
 800106a: 687b         	ldr	r3, [r7, #0x4]
 800106c: 625a         	str	r2, [r3, #0x24]
; 	memset(kf->temp, 0, sizeof(uint8_t) * zSize);
 800106e: 687b         	ldr	r3, [r7, #0x4]
 8001070: 6a5b         	ldr	r3, [r3, #0x24]
 8001072: 787a         	ldrb	r2, [r7, #0x1]
 8001074: 2100         	movs	r1, #0x0
 8001076: 4618         	mov	r0, r3
 8001078: f01c fbb8    	bl	0x801d7ec <memset>      @ imm = #0x1c770
; 	kf->FilteredValue = (float *)user_malloc(sizeof_float * xhatSize);
 800107c: 4b7c         	ldr	r3, [pc, #0x1f0]        @ 0x8001270 <Kalman_Filter_Init+0x304>
 800107e: 881b         	ldrh	r3, [r3]
 8001080: 461a         	mov	r2, r3
 8001082: 78fb         	ldrb	r3, [r7, #0x3]
 8001084: fb02 f303    	mul	r3, r2, r3
 8001088: 4618         	mov	r0, r3
 800108a: f005 f85b    	bl	0x8006144 <malloc>      @ imm = #0x50b6
 800108e: 4603         	mov	r3, r0
 8001090: 461a         	mov	r2, r3
 8001092: 687b         	ldr	r3, [r7, #0x4]
 8001094: 601a         	str	r2, [r3]
; 	memset(kf->FilteredValue, 0, sizeof_float * xhatSize);
 8001096: 687b         	ldr	r3, [r7, #0x4]
 8001098: 6818         	ldr	r0, [r3]
 800109a: 4b75         	ldr	r3, [pc, #0x1d4]        @ 0x8001270 <Kalman_Filter_Init+0x304>
 800109c: 881b         	ldrh	r3, [r3]
 800109e: 461a         	mov	r2, r3
 80010a0: 78fb         	ldrb	r3, [r7, #0x3]
 80010a2: fb02 f303    	mul	r3, r2, r3
 80010a6: 461a         	mov	r2, r3
 80010a8: 2100         	movs	r1, #0x0
 80010aa: f01c fb9f    	bl	0x801d7ec <memset>      @ imm = #0x1c73e
; 	kf->MeasuredVector = (float *)user_malloc(sizeof_float * zSize);
 80010ae: 4b70         	ldr	r3, [pc, #0x1c0]        @ 0x8001270 <Kalman_Filter_Init+0x304>
 80010b0: 881b         	ldrh	r3, [r3]
 80010b2: 461a         	mov	r2, r3
 80010b4: 787b         	ldrb	r3, [r7, #0x1]
 80010b6: fb02 f303    	mul	r3, r2, r3
 80010ba: 4618         	mov	r0, r3
 80010bc: f005 f842    	bl	0x8006144 <malloc>      @ imm = #0x5084
 80010c0: 4603         	mov	r3, r0
 80010c2: 461a         	mov	r2, r3
 80010c4: 687b         	ldr	r3, [r7, #0x4]
 80010c6: 605a         	str	r2, [r3, #0x4]
; 	memset(kf->MeasuredVector, 0, sizeof_float * zSize);
 80010c8: 687b         	ldr	r3, [r7, #0x4]
 80010ca: 6858         	ldr	r0, [r3, #0x4]
 80010cc: 4b68         	ldr	r3, [pc, #0x1a0]        @ 0x8001270 <Kalman_Filter_Init+0x304>
 80010ce: 881b         	ldrh	r3, [r3]
 80010d0: 461a         	mov	r2, r3
 80010d2: 787b         	ldrb	r3, [r7, #0x1]
 80010d4: fb02 f303    	mul	r3, r2, r3
 80010d8: 461a         	mov	r2, r3
 80010da: 2100         	movs	r1, #0x0
 80010dc: f01c fb86    	bl	0x801d7ec <memset>      @ imm = #0x1c70c
; 	kf->ControlVector = (float *)user_malloc(sizeof_float * uSize);
 80010e0: 4b63         	ldr	r3, [pc, #0x18c]        @ 0x8001270 <Kalman_Filter_Init+0x304>
 80010e2: 881b         	ldrh	r3, [r3]
 80010e4: 461a         	mov	r2, r3
 80010e6: 78bb         	ldrb	r3, [r7, #0x2]
 80010e8: fb02 f303    	mul	r3, r2, r3
 80010ec: 4618         	mov	r0, r3
 80010ee: f005 f829    	bl	0x8006144 <malloc>      @ imm = #0x5052
 80010f2: 4603         	mov	r3, r0
 80010f4: 461a         	mov	r2, r3
 80010f6: 687b         	ldr	r3, [r7, #0x4]
 80010f8: 609a         	str	r2, [r3, #0x8]
; 	memset(kf->ControlVector, 0, sizeof_float * uSize);
 80010fa: 687b         	ldr	r3, [r7, #0x4]
 80010fc: 6898         	ldr	r0, [r3, #0x8]
 80010fe: 4b5c         	ldr	r3, [pc, #0x170]        @ 0x8001270 <Kalman_Filter_Init+0x304>
 8001100: 881b         	ldrh	r3, [r3]
 8001102: 461a         	mov	r2, r3
 8001104: 78bb         	ldrb	r3, [r7, #0x2]
 8001106: fb02 f303    	mul	r3, r2, r3
 800110a: 461a         	mov	r2, r3
 800110c: 2100         	movs	r1, #0x0
 800110e: f01c fb6d    	bl	0x801d7ec <memset>      @ imm = #0x1c6da
; 	kf->xhat_data = (float *)user_malloc(sizeof_float * xhatSize);
 8001112: 4b57         	ldr	r3, [pc, #0x15c]        @ 0x8001270 <Kalman_Filter_Init+0x304>
 8001114: 881b         	ldrh	r3, [r3]
 8001116: 461a         	mov	r2, r3
 8001118: 78fb         	ldrb	r3, [r7, #0x3]
 800111a: fb02 f303    	mul	r3, r2, r3
 800111e: 4618         	mov	r0, r3
 8001120: f005 f810    	bl	0x8006144 <malloc>      @ imm = #0x5020
 8001124: 4603         	mov	r3, r0
 8001126: 461a         	mov	r2, r3
 8001128: 687b         	ldr	r3, [r7, #0x4]
 800112a: f8c3 20e8    	str.w	r2, [r3, #0xe8]
; 	memset(kf->xhat_data, 0, sizeof_float * xhatSize);
 800112e: 687b         	ldr	r3, [r7, #0x4]
 8001130: f8d3 00e8    	ldr.w	r0, [r3, #0xe8]
 8001134: 4b4e         	ldr	r3, [pc, #0x138]        @ 0x8001270 <Kalman_Filter_Init+0x304>
 8001136: 881b         	ldrh	r3, [r3]
 8001138: 461a         	mov	r2, r3
 800113a: 78fb         	ldrb	r3, [r7, #0x3]
 800113c: fb02 f303    	mul	r3, r2, r3
 8001140: 461a         	mov	r2, r3
 8001142: 2100         	movs	r1, #0x0
 8001144: f01c fb52    	bl	0x801d7ec <memset>      @ imm = #0x1c6a4
; 	Matrix_Init(&kf->xhat, kf->xhatSize, 1, (float *)kf->xhat_data);
 8001148: 687b         	ldr	r3, [r7, #0x4]
 800114a: f103 0030    	add.w	r0, r3, #0x30
 800114e: 687b         	ldr	r3, [r7, #0x4]
 8001150: 7b1b         	ldrb	r3, [r3, #0xc]
 8001152: 4619         	mov	r1, r3
 8001154: 687b         	ldr	r3, [r7, #0x4]
 8001156: f8d3 30e8    	ldr.w	r3, [r3, #0xe8]
 800115a: 2201         	movs	r2, #0x1
 800115c: f00b fcea    	bl	0x800cb34 <arm_mat_init_f32> @ imm = #0xb9d4
; 	kf->xhatminus_data = (float *)user_malloc(sizeof_float * xhatSize);
 8001160: 4b43         	ldr	r3, [pc, #0x10c]        @ 0x8001270 <Kalman_Filter_Init+0x304>
 8001162: 881b         	ldrh	r3, [r3]
 8001164: 461a         	mov	r2, r3
 8001166: 78fb         	ldrb	r3, [r7, #0x3]
 8001168: fb02 f303    	mul	r3, r2, r3
 800116c: 4618         	mov	r0, r3
 800116e: f004 ffe9    	bl	0x8006144 <malloc>      @ imm = #0x4fd2
 8001172: 4603         	mov	r3, r0
 8001174: 461a         	mov	r2, r3
 8001176: 687b         	ldr	r3, [r7, #0x4]
 8001178: f8c3 20ec    	str.w	r2, [r3, #0xec]
; 	memset(kf->xhatminus_data, 0, sizeof_float * xhatSize);
 800117c: 687b         	ldr	r3, [r7, #0x4]
 800117e: f8d3 00ec    	ldr.w	r0, [r3, #0xec]
 8001182: 4b3b         	ldr	r3, [pc, #0xec]         @ 0x8001270 <Kalman_Filter_Init+0x304>
 8001184: 881b         	ldrh	r3, [r3]
 8001186: 461a         	mov	r2, r3
 8001188: 78fb         	ldrb	r3, [r7, #0x3]
 800118a: fb02 f303    	mul	r3, r2, r3
 800118e: 461a         	mov	r2, r3
 8001190: 2100         	movs	r1, #0x0
 8001192: f01c fb2b    	bl	0x801d7ec <memset>      @ imm = #0x1c656
; 	Matrix_Init(&kf->xhatminus, kf->xhatSize, 1, (float *)kf->xhatminus_data);
 8001196: 687b         	ldr	r3, [r7, #0x4]
 8001198: f103 0038    	add.w	r0, r3, #0x38
 800119c: 687b         	ldr	r3, [r7, #0x4]
 800119e: 7b1b         	ldrb	r3, [r3, #0xc]
 80011a0: 4619         	mov	r1, r3
 80011a2: 687b         	ldr	r3, [r7, #0x4]
 80011a4: f8d3 30ec    	ldr.w	r3, [r3, #0xec]
 80011a8: 2201         	movs	r2, #0x1
 80011aa: f00b fcc3    	bl	0x800cb34 <arm_mat_init_f32> @ imm = #0xb986
; 	if (uSize != 0) {
 80011ae: 78bb         	ldrb	r3, [r7, #0x2]
 80011b0: 2b00         	cmp	r3, #0x0
 80011b2: d026         	beq	0x8001202 <Kalman_Filter_Init+0x296> @ imm = #0x4c
; 		kf->u_data = (float *)user_malloc(sizeof_float * uSize);
 80011b4: 4b2e         	ldr	r3, [pc, #0xb8]         @ 0x8001270 <Kalman_Filter_Init+0x304>
 80011b6: 881b         	ldrh	r3, [r3]
 80011b8: 461a         	mov	r2, r3
 80011ba: 78bb         	ldrb	r3, [r7, #0x2]
 80011bc: fb02 f303    	mul	r3, r2, r3
 80011c0: 4618         	mov	r0, r3
 80011c2: f004 ffbf    	bl	0x8006144 <malloc>      @ imm = #0x4f7e
 80011c6: 4603         	mov	r3, r0
 80011c8: 461a         	mov	r2, r3
 80011ca: 687b         	ldr	r3, [r7, #0x4]
 80011cc: f8c3 20f0    	str.w	r2, [r3, #0xf0]
; 		memset(kf->u_data, 0, sizeof_float * uSize);
 80011d0: 687b         	ldr	r3, [r7, #0x4]
 80011d2: f8d3 00f0    	ldr.w	r0, [r3, #0xf0]
 80011d6: 4b26         	ldr	r3, [pc, #0x98]         @ 0x8001270 <Kalman_Filter_Init+0x304>
 80011d8: 881b         	ldrh	r3, [r3]
 80011da: 461a         	mov	r2, r3
 80011dc: 78bb         	ldrb	r3, [r7, #0x2]
 80011de: fb02 f303    	mul	r3, r2, r3
 80011e2: 461a         	mov	r2, r3
 80011e4: 2100         	movs	r1, #0x0
 80011e6: f01c fb01    	bl	0x801d7ec <memset>      @ imm = #0x1c602
; 		Matrix_Init(&kf->u, kf->uSize, 1, (float *)kf->u_data);
 80011ea: 687b         	ldr	r3, [r7, #0x4]
 80011ec: f103 0040    	add.w	r0, r3, #0x40
 80011f0: 687b         	ldr	r3, [r7, #0x4]
 80011f2: 7b5b         	ldrb	r3, [r3, #0xd]
 80011f4: 4619         	mov	r1, r3
 80011f6: 687b         	ldr	r3, [r7, #0x4]
 80011f8: f8d3 30f0    	ldr.w	r3, [r3, #0xf0]
 80011fc: 2201         	movs	r2, #0x1
 80011fe: f00b fc99    	bl	0x800cb34 <arm_mat_init_f32> @ imm = #0xb932
; 	kf->z_data = (float *)user_malloc(sizeof_float * zSize);
 8001202: 4b1b         	ldr	r3, [pc, #0x6c]         @ 0x8001270 <Kalman_Filter_Init+0x304>
 8001204: 881b         	ldrh	r3, [r3]
 8001206: 461a         	mov	r2, r3
 8001208: 787b         	ldrb	r3, [r7, #0x1]
 800120a: fb02 f303    	mul	r3, r2, r3
 800120e: 4618         	mov	r0, r3
 8001210: f004 ff98    	bl	0x8006144 <malloc>      @ imm = #0x4f30
 8001214: 4603         	mov	r3, r0
 8001216: 461a         	mov	r2, r3
 8001218: 687b         	ldr	r3, [r7, #0x4]
 800121a: f8c3 20f4    	str.w	r2, [r3, #0xf4]
; 	memset(kf->z_data, 0, sizeof_float * zSize);
 800121e: 687b         	ldr	r3, [r7, #0x4]
 8001220: f8d3 00f4    	ldr.w	r0, [r3, #0xf4]
 8001224: 4b12         	ldr	r3, [pc, #0x48]         @ 0x8001270 <Kalman_Filter_Init+0x304>
 8001226: 881b         	ldrh	r3, [r3]
 8001228: 461a         	mov	r2, r3
 800122a: 787b         	ldrb	r3, [r7, #0x1]
 800122c: fb02 f303    	mul	r3, r2, r3
 8001230: 461a         	mov	r2, r3
 8001232: 2100         	movs	r1, #0x0
 8001234: f01c fada    	bl	0x801d7ec <memset>      @ imm = #0x1c5b4
; 	Matrix_Init(&kf->z, kf->zSize, 1, (float *)kf->z_data);
 8001238: 687b         	ldr	r3, [r7, #0x4]
 800123a: f103 0048    	add.w	r0, r3, #0x48
 800123e: 687b         	ldr	r3, [r7, #0x4]
 8001240: 7b9b         	ldrb	r3, [r3, #0xe]
 8001242: 4619         	mov	r1, r3
 8001244: 687b         	ldr	r3, [r7, #0x4]
 8001246: f8d3 30f4    	ldr.w	r3, [r3, #0xf4]
 800124a: 2201         	movs	r2, #0x1
 800124c: f00b fc72    	bl	0x800cb34 <arm_mat_init_f32> @ imm = #0xb8e4
; 	kf->P_data = (float *)user_malloc(sizeof_float * xhatSize * xhatSize);
 8001250: 4b07         	ldr	r3, [pc, #0x1c]         @ 0x8001270 <Kalman_Filter_Init+0x304>
 8001252: 881b         	ldrh	r3, [r3]
 8001254: 461a         	mov	r2, r3
 8001256: 78fb         	ldrb	r3, [r7, #0x3]
 8001258: fb02 f303    	mul	r3, r2, r3
 800125c: 78fa         	ldrb	r2, [r7, #0x3]
 800125e: fb02 f303    	mul	r3, r2, r3
 8001262: 4618         	mov	r0, r3
 8001264: f004 ff6e    	bl	0x8006144 <malloc>      @ imm = #0x4edc
 8001268: 4603         	mov	r3, r0
 800126a: 461a         	mov	r2, r3
 800126c: 687b         	ldr	r3, [r7, #0x4]
 800126e: e003         	b	0x8001278 <Kalman_Filter_Init+0x30c> @ imm = #0x6

08001270 <$d>:
 8001270: 84 1f 00 20  	.word	0x20001f84
 8001274: 86 1f 00 20  	.word	0x20001f86

08001278 <$t>:
 8001278: f8c3 20f8    	str.w	r2, [r3, #0xf8]
; 	memset(kf->P_data, 0, sizeof_float * xhatSize * xhatSize);
 800127c: 687b         	ldr	r3, [r7, #0x4]
 800127e: f8d3 00f8    	ldr.w	r0, [r3, #0xf8]
 8001282: 4bbd         	ldr	r3, [pc, #0x2f4]        @ 0x8001578 <Kalman_Filter_Init+0x60c>
 8001284: 881b         	ldrh	r3, [r3]
 8001286: 461a         	mov	r2, r3
 8001288: 78fb         	ldrb	r3, [r7, #0x3]
 800128a: fb02 f303    	mul	r3, r2, r3
 800128e: 78fa         	ldrb	r2, [r7, #0x3]
 8001290: fb02 f303    	mul	r3, r2, r3
 8001294: 461a         	mov	r2, r3
 8001296: 2100         	movs	r1, #0x0
 8001298: f01c faa8    	bl	0x801d7ec <memset>      @ imm = #0x1c550
; 	Matrix_Init(&kf->P, kf->xhatSize, kf->xhatSize, (float *)kf->P_data);
 800129c: 687b         	ldr	r3, [r7, #0x4]
 800129e: f103 0050    	add.w	r0, r3, #0x50
 80012a2: 687b         	ldr	r3, [r7, #0x4]
 80012a4: 7b1b         	ldrb	r3, [r3, #0xc]
 80012a6: 4619         	mov	r1, r3
 80012a8: 687b         	ldr	r3, [r7, #0x4]
 80012aa: 7b1b         	ldrb	r3, [r3, #0xc]
 80012ac: 461a         	mov	r2, r3
 80012ae: 687b         	ldr	r3, [r7, #0x4]
 80012b0: f8d3 30f8    	ldr.w	r3, [r3, #0xf8]
 80012b4: f00b fc3e    	bl	0x800cb34 <arm_mat_init_f32> @ imm = #0xb87c
; 	kf->Pminus_data = (float *)user_malloc(sizeof_float * xhatSize * xhatSize);
 80012b8: 4baf         	ldr	r3, [pc, #0x2bc]        @ 0x8001578 <Kalman_Filter_Init+0x60c>
 80012ba: 881b         	ldrh	r3, [r3]
 80012bc: 461a         	mov	r2, r3
 80012be: 78fb         	ldrb	r3, [r7, #0x3]
 80012c0: fb02 f303    	mul	r3, r2, r3
 80012c4: 78fa         	ldrb	r2, [r7, #0x3]
 80012c6: fb02 f303    	mul	r3, r2, r3
 80012ca: 4618         	mov	r0, r3
 80012cc: f004 ff3a    	bl	0x8006144 <malloc>      @ imm = #0x4e74
 80012d0: 4603         	mov	r3, r0
 80012d2: 461a         	mov	r2, r3
 80012d4: 687b         	ldr	r3, [r7, #0x4]
 80012d6: f8c3 20fc    	str.w	r2, [r3, #0xfc]
; 	memset(kf->Pminus_data, 0, sizeof_float * xhatSize * xhatSize);
 80012da: 687b         	ldr	r3, [r7, #0x4]
 80012dc: f8d3 00fc    	ldr.w	r0, [r3, #0xfc]
 80012e0: 4ba5         	ldr	r3, [pc, #0x294]        @ 0x8001578 <Kalman_Filter_Init+0x60c>
 80012e2: 881b         	ldrh	r3, [r3]
 80012e4: 461a         	mov	r2, r3
 80012e6: 78fb         	ldrb	r3, [r7, #0x3]
 80012e8: fb02 f303    	mul	r3, r2, r3
 80012ec: 78fa         	ldrb	r2, [r7, #0x3]
 80012ee: fb02 f303    	mul	r3, r2, r3
 80012f2: 461a         	mov	r2, r3
 80012f4: 2100         	movs	r1, #0x0
 80012f6: f01c fa79    	bl	0x801d7ec <memset>      @ imm = #0x1c4f2
; 	Matrix_Init(&kf->Pminus, kf->xhatSize, kf->xhatSize, (float *)kf->Pminus_data);
 80012fa: 687b         	ldr	r3, [r7, #0x4]
 80012fc: f103 0058    	add.w	r0, r3, #0x58
 8001300: 687b         	ldr	r3, [r7, #0x4]
 8001302: 7b1b         	ldrb	r3, [r3, #0xc]
 8001304: 4619         	mov	r1, r3
 8001306: 687b         	ldr	r3, [r7, #0x4]
 8001308: 7b1b         	ldrb	r3, [r3, #0xc]
 800130a: 461a         	mov	r2, r3
 800130c: 687b         	ldr	r3, [r7, #0x4]
 800130e: f8d3 30fc    	ldr.w	r3, [r3, #0xfc]
 8001312: f00b fc0f    	bl	0x800cb34 <arm_mat_init_f32> @ imm = #0xb81e
; 	kf->F_data = (float *)user_malloc(sizeof_float * xhatSize * xhatSize);
 8001316: 4b98         	ldr	r3, [pc, #0x260]        @ 0x8001578 <Kalman_Filter_Init+0x60c>
 8001318: 881b         	ldrh	r3, [r3]
 800131a: 461a         	mov	r2, r3
 800131c: 78fb         	ldrb	r3, [r7, #0x3]
 800131e: fb02 f303    	mul	r3, r2, r3
 8001322: 78fa         	ldrb	r2, [r7, #0x3]
 8001324: fb02 f303    	mul	r3, r2, r3
 8001328: 4618         	mov	r0, r3
 800132a: f004 ff0b    	bl	0x8006144 <malloc>      @ imm = #0x4e16
 800132e: 4603         	mov	r3, r0
 8001330: 461a         	mov	r2, r3
 8001332: 687b         	ldr	r3, [r7, #0x4]
 8001334: f8c3 2100    	str.w	r2, [r3, #0x100]
; 	kf->FT_data = (float *)user_malloc(sizeof_float * xhatSize * xhatSize);
 8001338: 4b8f         	ldr	r3, [pc, #0x23c]        @ 0x8001578 <Kalman_Filter_Init+0x60c>
 800133a: 881b         	ldrh	r3, [r3]
 800133c: 461a         	mov	r2, r3
 800133e: 78fb         	ldrb	r3, [r7, #0x3]
 8001340: fb02 f303    	mul	r3, r2, r3
 8001344: 78fa         	ldrb	r2, [r7, #0x3]
 8001346: fb02 f303    	mul	r3, r2, r3
 800134a: 4618         	mov	r0, r3
 800134c: f004 fefa    	bl	0x8006144 <malloc>      @ imm = #0x4df4
 8001350: 4603         	mov	r3, r0
 8001352: 461a         	mov	r2, r3
 8001354: 687b         	ldr	r3, [r7, #0x4]
 8001356: f8c3 2104    	str.w	r2, [r3, #0x104]
; 	memset(kf->F_data, 0, sizeof_float * xhatSize * xhatSize);
 800135a: 687b         	ldr	r3, [r7, #0x4]
 800135c: f8d3 0100    	ldr.w	r0, [r3, #0x100]
 8001360: 4b85         	ldr	r3, [pc, #0x214]        @ 0x8001578 <Kalman_Filter_Init+0x60c>
 8001362: 881b         	ldrh	r3, [r3]
 8001364: 461a         	mov	r2, r3
 8001366: 78fb         	ldrb	r3, [r7, #0x3]
 8001368: fb02 f303    	mul	r3, r2, r3
 800136c: 78fa         	ldrb	r2, [r7, #0x3]
 800136e: fb02 f303    	mul	r3, r2, r3
 8001372: 461a         	mov	r2, r3
 8001374: 2100         	movs	r1, #0x0
 8001376: f01c fa39    	bl	0x801d7ec <memset>      @ imm = #0x1c472
; 	memset(kf->FT_data, 0, sizeof_float * xhatSize * xhatSize);
 800137a: 687b         	ldr	r3, [r7, #0x4]
 800137c: f8d3 0104    	ldr.w	r0, [r3, #0x104]
 8001380: 4b7d         	ldr	r3, [pc, #0x1f4]        @ 0x8001578 <Kalman_Filter_Init+0x60c>
 8001382: 881b         	ldrh	r3, [r3]
 8001384: 461a         	mov	r2, r3
 8001386: 78fb         	ldrb	r3, [r7, #0x3]
 8001388: fb02 f303    	mul	r3, r2, r3
 800138c: 78fa         	ldrb	r2, [r7, #0x3]
 800138e: fb02 f303    	mul	r3, r2, r3
 8001392: 461a         	mov	r2, r3
 8001394: 2100         	movs	r1, #0x0
 8001396: f01c fa29    	bl	0x801d7ec <memset>      @ imm = #0x1c452
; 	Matrix_Init(&kf->F, kf->xhatSize, kf->xhatSize, (float *)kf->F_data);
 800139a: 687b         	ldr	r3, [r7, #0x4]
 800139c: f103 0060    	add.w	r0, r3, #0x60
 80013a0: 687b         	ldr	r3, [r7, #0x4]
 80013a2: 7b1b         	ldrb	r3, [r3, #0xc]
 80013a4: 4619         	mov	r1, r3
 80013a6: 687b         	ldr	r3, [r7, #0x4]
 80013a8: 7b1b         	ldrb	r3, [r3, #0xc]
 80013aa: 461a         	mov	r2, r3
 80013ac: 687b         	ldr	r3, [r7, #0x4]
 80013ae: f8d3 3100    	ldr.w	r3, [r3, #0x100]
 80013b2: f00b fbbf    	bl	0x800cb34 <arm_mat_init_f32> @ imm = #0xb77e
; 	Matrix_Init(&kf->FT, kf->xhatSize, kf->xhatSize, (float *)kf->FT_data);
 80013b6: 687b         	ldr	r3, [r7, #0x4]
 80013b8: f103 0068    	add.w	r0, r3, #0x68
 80013bc: 687b         	ldr	r3, [r7, #0x4]
 80013be: 7b1b         	ldrb	r3, [r3, #0xc]
 80013c0: 4619         	mov	r1, r3
 80013c2: 687b         	ldr	r3, [r7, #0x4]
 80013c4: 7b1b         	ldrb	r3, [r3, #0xc]
 80013c6: 461a         	mov	r2, r3
 80013c8: 687b         	ldr	r3, [r7, #0x4]
 80013ca: f8d3 3104    	ldr.w	r3, [r3, #0x104]
 80013ce: f00b fbb1    	bl	0x800cb34 <arm_mat_init_f32> @ imm = #0xb762
; 	if (uSize != 0) {
 80013d2: 78bb         	ldrb	r3, [r7, #0x2]
 80013d4: 2b00         	cmp	r3, #0x0
 80013d6: d02e         	beq	0x8001436 <Kalman_Filter_Init+0x4ca> @ imm = #0x5c
; 		kf->B_data = (float *)user_malloc(sizeof_float * xhatSize * uSize);
 80013d8: 4b67         	ldr	r3, [pc, #0x19c]        @ 0x8001578 <Kalman_Filter_Init+0x60c>
 80013da: 881b         	ldrh	r3, [r3]
 80013dc: 461a         	mov	r2, r3
 80013de: 78fb         	ldrb	r3, [r7, #0x3]
 80013e0: fb02 f303    	mul	r3, r2, r3
 80013e4: 78ba         	ldrb	r2, [r7, #0x2]
 80013e6: fb02 f303    	mul	r3, r2, r3
 80013ea: 4618         	mov	r0, r3
 80013ec: f004 feaa    	bl	0x8006144 <malloc>      @ imm = #0x4d54
 80013f0: 4603         	mov	r3, r0
 80013f2: 461a         	mov	r2, r3
 80013f4: 687b         	ldr	r3, [r7, #0x4]
 80013f6: f8c3 2108    	str.w	r2, [r3, #0x108]
; 		memset(kf->B_data, 0, sizeof_float * xhatSize * uSize);
 80013fa: 687b         	ldr	r3, [r7, #0x4]
 80013fc: f8d3 0108    	ldr.w	r0, [r3, #0x108]
 8001400: 4b5d         	ldr	r3, [pc, #0x174]        @ 0x8001578 <Kalman_Filter_Init+0x60c>
 8001402: 881b         	ldrh	r3, [r3]
 8001404: 461a         	mov	r2, r3
 8001406: 78fb         	ldrb	r3, [r7, #0x3]
 8001408: fb02 f303    	mul	r3, r2, r3
 800140c: 78ba         	ldrb	r2, [r7, #0x2]
 800140e: fb02 f303    	mul	r3, r2, r3
 8001412: 461a         	mov	r2, r3
 8001414: 2100         	movs	r1, #0x0
 8001416: f01c f9e9    	bl	0x801d7ec <memset>      @ imm = #0x1c3d2
; 		Matrix_Init(&kf->B, kf->xhatSize, kf->uSize, (float *)kf->B_data);
 800141a: 687b         	ldr	r3, [r7, #0x4]
 800141c: f103 0070    	add.w	r0, r3, #0x70
 8001420: 687b         	ldr	r3, [r7, #0x4]
 8001422: 7b1b         	ldrb	r3, [r3, #0xc]
 8001424: 4619         	mov	r1, r3
 8001426: 687b         	ldr	r3, [r7, #0x4]
 8001428: 7b5b         	ldrb	r3, [r3, #0xd]
 800142a: 461a         	mov	r2, r3
 800142c: 687b         	ldr	r3, [r7, #0x4]
 800142e: f8d3 3108    	ldr.w	r3, [r3, #0x108]
 8001432: f00b fb7f    	bl	0x800cb34 <arm_mat_init_f32> @ imm = #0xb6fe
; 	kf->H_data = (float *)user_malloc(sizeof_float * zSize * xhatSize);
 8001436: 4b50         	ldr	r3, [pc, #0x140]        @ 0x8001578 <Kalman_Filter_Init+0x60c>
 8001438: 881b         	ldrh	r3, [r3]
 800143a: 461a         	mov	r2, r3
 800143c: 787b         	ldrb	r3, [r7, #0x1]
 800143e: fb02 f303    	mul	r3, r2, r3
 8001442: 78fa         	ldrb	r2, [r7, #0x3]
 8001444: fb02 f303    	mul	r3, r2, r3
 8001448: 4618         	mov	r0, r3
 800144a: f004 fe7b    	bl	0x8006144 <malloc>      @ imm = #0x4cf6
 800144e: 4603         	mov	r3, r0
 8001450: 461a         	mov	r2, r3
 8001452: 687b         	ldr	r3, [r7, #0x4]
 8001454: f8c3 210c    	str.w	r2, [r3, #0x10c]
; 	kf->HT_data = (float *)user_malloc(sizeof_float * xhatSize * zSize);
 8001458: 4b47         	ldr	r3, [pc, #0x11c]        @ 0x8001578 <Kalman_Filter_Init+0x60c>
 800145a: 881b         	ldrh	r3, [r3]
 800145c: 461a         	mov	r2, r3
 800145e: 78fb         	ldrb	r3, [r7, #0x3]
 8001460: fb02 f303    	mul	r3, r2, r3
 8001464: 787a         	ldrb	r2, [r7, #0x1]
 8001466: fb02 f303    	mul	r3, r2, r3
 800146a: 4618         	mov	r0, r3
 800146c: f004 fe6a    	bl	0x8006144 <malloc>      @ imm = #0x4cd4
 8001470: 4603         	mov	r3, r0
 8001472: 461a         	mov	r2, r3
 8001474: 687b         	ldr	r3, [r7, #0x4]
 8001476: f8c3 2110    	str.w	r2, [r3, #0x110]
; 	memset(kf->H_data, 0, sizeof_float * zSize * xhatSize);
 800147a: 687b         	ldr	r3, [r7, #0x4]
 800147c: f8d3 010c    	ldr.w	r0, [r3, #0x10c]
 8001480: 4b3d         	ldr	r3, [pc, #0xf4]         @ 0x8001578 <Kalman_Filter_Init+0x60c>
 8001482: 881b         	ldrh	r3, [r3]
 8001484: 461a         	mov	r2, r3
 8001486: 787b         	ldrb	r3, [r7, #0x1]
 8001488: fb02 f303    	mul	r3, r2, r3
 800148c: 78fa         	ldrb	r2, [r7, #0x3]
 800148e: fb02 f303    	mul	r3, r2, r3
 8001492: 461a         	mov	r2, r3
 8001494: 2100         	movs	r1, #0x0
 8001496: f01c f9a9    	bl	0x801d7ec <memset>      @ imm = #0x1c352
; 	memset(kf->HT_data, 0, sizeof_float * xhatSize * zSize);
 800149a: 687b         	ldr	r3, [r7, #0x4]
 800149c: f8d3 0110    	ldr.w	r0, [r3, #0x110]
 80014a0: 4b35         	ldr	r3, [pc, #0xd4]         @ 0x8001578 <Kalman_Filter_Init+0x60c>
 80014a2: 881b         	ldrh	r3, [r3]
 80014a4: 461a         	mov	r2, r3
 80014a6: 78fb         	ldrb	r3, [r7, #0x3]
 80014a8: fb02 f303    	mul	r3, r2, r3
 80014ac: 787a         	ldrb	r2, [r7, #0x1]
 80014ae: fb02 f303    	mul	r3, r2, r3
 80014b2: 461a         	mov	r2, r3
 80014b4: 2100         	movs	r1, #0x0
 80014b6: f01c f999    	bl	0x801d7ec <memset>      @ imm = #0x1c332
; 	Matrix_Init(&kf->H, kf->zSize, kf->xhatSize, (float *)kf->H_data);
 80014ba: 687b         	ldr	r3, [r7, #0x4]
 80014bc: f103 0078    	add.w	r0, r3, #0x78
 80014c0: 687b         	ldr	r3, [r7, #0x4]
 80014c2: 7b9b         	ldrb	r3, [r3, #0xe]
 80014c4: 4619         	mov	r1, r3
 80014c6: 687b         	ldr	r3, [r7, #0x4]
 80014c8: 7b1b         	ldrb	r3, [r3, #0xc]
 80014ca: 461a         	mov	r2, r3
 80014cc: 687b         	ldr	r3, [r7, #0x4]
 80014ce: f8d3 310c    	ldr.w	r3, [r3, #0x10c]
 80014d2: f00b fb2f    	bl	0x800cb34 <arm_mat_init_f32> @ imm = #0xb65e
; 	Matrix_Init(&kf->HT, kf->xhatSize, kf->zSize, (float *)kf->HT_data);
 80014d6: 687b         	ldr	r3, [r7, #0x4]
 80014d8: f103 0080    	add.w	r0, r3, #0x80
 80014dc: 687b         	ldr	r3, [r7, #0x4]
 80014de: 7b1b         	ldrb	r3, [r3, #0xc]
 80014e0: 4619         	mov	r1, r3
 80014e2: 687b         	ldr	r3, [r7, #0x4]
 80014e4: 7b9b         	ldrb	r3, [r3, #0xe]
 80014e6: 461a         	mov	r2, r3
 80014e8: 687b         	ldr	r3, [r7, #0x4]
 80014ea: f8d3 3110    	ldr.w	r3, [r3, #0x110]
 80014ee: f00b fb21    	bl	0x800cb34 <arm_mat_init_f32> @ imm = #0xb642
; 	kf->Q_data = (float *)user_malloc(sizeof_float * xhatSize * xhatSize);
 80014f2: 4b21         	ldr	r3, [pc, #0x84]         @ 0x8001578 <Kalman_Filter_Init+0x60c>
 80014f4: 881b         	ldrh	r3, [r3]
 80014f6: 461a         	mov	r2, r3
 80014f8: 78fb         	ldrb	r3, [r7, #0x3]
 80014fa: fb02 f303    	mul	r3, r2, r3
 80014fe: 78fa         	ldrb	r2, [r7, #0x3]
 8001500: fb02 f303    	mul	r3, r2, r3
 8001504: 4618         	mov	r0, r3
 8001506: f004 fe1d    	bl	0x8006144 <malloc>      @ imm = #0x4c3a
 800150a: 4603         	mov	r3, r0
 800150c: 461a         	mov	r2, r3
 800150e: 687b         	ldr	r3, [r7, #0x4]
 8001510: f8c3 2114    	str.w	r2, [r3, #0x114]
; 	memset(kf->Q_data, 0, sizeof_float * xhatSize * xhatSize);
 8001514: 687b         	ldr	r3, [r7, #0x4]
 8001516: f8d3 0114    	ldr.w	r0, [r3, #0x114]
 800151a: 4b17         	ldr	r3, [pc, #0x5c]         @ 0x8001578 <Kalman_Filter_Init+0x60c>
 800151c: 881b         	ldrh	r3, [r3]
 800151e: 461a         	mov	r2, r3
 8001520: 78fb         	ldrb	r3, [r7, #0x3]
 8001522: fb02 f303    	mul	r3, r2, r3
 8001526: 78fa         	ldrb	r2, [r7, #0x3]
 8001528: fb02 f303    	mul	r3, r2, r3
 800152c: 461a         	mov	r2, r3
 800152e: 2100         	movs	r1, #0x0
 8001530: f01c f95c    	bl	0x801d7ec <memset>      @ imm = #0x1c2b8
; 	Matrix_Init(&kf->Q, kf->xhatSize, kf->xhatSize, (float *)kf->Q_data);
 8001534: 687b         	ldr	r3, [r7, #0x4]
 8001536: f103 0088    	add.w	r0, r3, #0x88
 800153a: 687b         	ldr	r3, [r7, #0x4]
 800153c: 7b1b         	ldrb	r3, [r3, #0xc]
 800153e: 4619         	mov	r1, r3
 8001540: 687b         	ldr	r3, [r7, #0x4]
 8001542: 7b1b         	ldrb	r3, [r3, #0xc]
 8001544: 461a         	mov	r2, r3
 8001546: 687b         	ldr	r3, [r7, #0x4]
 8001548: f8d3 3114    	ldr.w	r3, [r3, #0x114]
 800154c: f00b faf2    	bl	0x800cb34 <arm_mat_init_f32> @ imm = #0xb5e4
; 	kf->R_data = (float *)user_malloc(sizeof_float * zSize * zSize);
 8001550: 4b09         	ldr	r3, [pc, #0x24]         @ 0x8001578 <Kalman_Filter_Init+0x60c>
 8001552: 881b         	ldrh	r3, [r3]
 8001554: 461a         	mov	r2, r3
 8001556: 787b         	ldrb	r3, [r7, #0x1]
 8001558: fb02 f303    	mul	r3, r2, r3
 800155c: 787a         	ldrb	r2, [r7, #0x1]
 800155e: fb02 f303    	mul	r3, r2, r3
 8001562: 4618         	mov	r0, r3
 8001564: f004 fdee    	bl	0x8006144 <malloc>      @ imm = #0x4bdc
 8001568: 4603         	mov	r3, r0
 800156a: 461a         	mov	r2, r3
 800156c: 687b         	ldr	r3, [r7, #0x4]
 800156e: f8c3 2118    	str.w	r2, [r3, #0x118]
; 	memset(kf->R_data, 0, sizeof_float * zSize * zSize);
 8001572: 687b         	ldr	r3, [r7, #0x4]
 8001574: e002         	b	0x800157c <Kalman_Filter_Init+0x610> @ imm = #0x4
 8001576: bf00         	nop

08001578 <$d>:
 8001578: 84 1f 00 20  	.word	0x20001f84

0800157c <$t>:
 800157c: f8d3 0118    	ldr.w	r0, [r3, #0x118]
 8001580: 4b7d         	ldr	r3, [pc, #0x1f4]        @ 0x8001778 <Kalman_Filter_Init+0x80c>
 8001582: 881b         	ldrh	r3, [r3]
 8001584: 461a         	mov	r2, r3
 8001586: 787b         	ldrb	r3, [r7, #0x1]
 8001588: fb02 f303    	mul	r3, r2, r3
 800158c: 787a         	ldrb	r2, [r7, #0x1]
 800158e: fb02 f303    	mul	r3, r2, r3
 8001592: 461a         	mov	r2, r3
 8001594: 2100         	movs	r1, #0x0
 8001596: f01c f929    	bl	0x801d7ec <memset>      @ imm = #0x1c252
; 	Matrix_Init(&kf->R, kf->zSize, kf->zSize, (float *)kf->R_data);
 800159a: 687b         	ldr	r3, [r7, #0x4]
 800159c: f103 0090    	add.w	r0, r3, #0x90
 80015a0: 687b         	ldr	r3, [r7, #0x4]
 80015a2: 7b9b         	ldrb	r3, [r3, #0xe]
 80015a4: 4619         	mov	r1, r3
 80015a6: 687b         	ldr	r3, [r7, #0x4]
 80015a8: 7b9b         	ldrb	r3, [r3, #0xe]
 80015aa: 461a         	mov	r2, r3
 80015ac: 687b         	ldr	r3, [r7, #0x4]
 80015ae: f8d3 3118    	ldr.w	r3, [r3, #0x118]
 80015b2: f00b fabf    	bl	0x800cb34 <arm_mat_init_f32> @ imm = #0xb57e
; 	kf->K_data = (float *)user_malloc(sizeof_float * xhatSize * zSize);
 80015b6: 4b70         	ldr	r3, [pc, #0x1c0]        @ 0x8001778 <Kalman_Filter_Init+0x80c>
 80015b8: 881b         	ldrh	r3, [r3]
 80015ba: 461a         	mov	r2, r3
 80015bc: 78fb         	ldrb	r3, [r7, #0x3]
 80015be: fb02 f303    	mul	r3, r2, r3
 80015c2: 787a         	ldrb	r2, [r7, #0x1]
 80015c4: fb02 f303    	mul	r3, r2, r3
 80015c8: 4618         	mov	r0, r3
 80015ca: f004 fdbb    	bl	0x8006144 <malloc>      @ imm = #0x4b76
 80015ce: 4603         	mov	r3, r0
 80015d0: 461a         	mov	r2, r3
 80015d2: 687b         	ldr	r3, [r7, #0x4]
 80015d4: f8c3 211c    	str.w	r2, [r3, #0x11c]
; 	memset(kf->K_data, 0, sizeof_float * xhatSize * zSize);
 80015d8: 687b         	ldr	r3, [r7, #0x4]
 80015da: f8d3 011c    	ldr.w	r0, [r3, #0x11c]
 80015de: 4b66         	ldr	r3, [pc, #0x198]        @ 0x8001778 <Kalman_Filter_Init+0x80c>
 80015e0: 881b         	ldrh	r3, [r3]
 80015e2: 461a         	mov	r2, r3
 80015e4: 78fb         	ldrb	r3, [r7, #0x3]
 80015e6: fb02 f303    	mul	r3, r2, r3
 80015ea: 787a         	ldrb	r2, [r7, #0x1]
 80015ec: fb02 f303    	mul	r3, r2, r3
 80015f0: 461a         	mov	r2, r3
 80015f2: 2100         	movs	r1, #0x0
 80015f4: f01c f8fa    	bl	0x801d7ec <memset>      @ imm = #0x1c1f4
; 	Matrix_Init(&kf->K, kf->xhatSize, kf->zSize, (float *)kf->K_data);
 80015f8: 687b         	ldr	r3, [r7, #0x4]
 80015fa: f103 0098    	add.w	r0, r3, #0x98
 80015fe: 687b         	ldr	r3, [r7, #0x4]
 8001600: 7b1b         	ldrb	r3, [r3, #0xc]
 8001602: 4619         	mov	r1, r3
 8001604: 687b         	ldr	r3, [r7, #0x4]
 8001606: 7b9b         	ldrb	r3, [r3, #0xe]
 8001608: 461a         	mov	r2, r3
 800160a: 687b         	ldr	r3, [r7, #0x4]
 800160c: f8d3 311c    	ldr.w	r3, [r3, #0x11c]
 8001610: f00b fa90    	bl	0x800cb34 <arm_mat_init_f32> @ imm = #0xb520
; 	kf->S_data = (float *)user_malloc(sizeof_float * kf->xhatSize * kf->xhatSize);
 8001614: 4b58         	ldr	r3, [pc, #0x160]        @ 0x8001778 <Kalman_Filter_Init+0x80c>
 8001616: 881b         	ldrh	r3, [r3]
 8001618: 461a         	mov	r2, r3
 800161a: 687b         	ldr	r3, [r7, #0x4]
 800161c: 7b1b         	ldrb	r3, [r3, #0xc]
 800161e: fb02 f303    	mul	r3, r2, r3
 8001622: 687a         	ldr	r2, [r7, #0x4]
 8001624: 7b12         	ldrb	r2, [r2, #0xc]
 8001626: fb02 f303    	mul	r3, r2, r3
 800162a: 4618         	mov	r0, r3
 800162c: f004 fd8a    	bl	0x8006144 <malloc>      @ imm = #0x4b14
 8001630: 4603         	mov	r3, r0
 8001632: 461a         	mov	r2, r3
 8001634: 687b         	ldr	r3, [r7, #0x4]
 8001636: f8c3 2120    	str.w	r2, [r3, #0x120]
; 	kf->temp_matrix_data = (float *)user_malloc(sizeof_float * kf->xhatSize * kf->xhatSize);
 800163a: 4b4f         	ldr	r3, [pc, #0x13c]        @ 0x8001778 <Kalman_Filter_Init+0x80c>
 800163c: 881b         	ldrh	r3, [r3]
 800163e: 461a         	mov	r2, r3
 8001640: 687b         	ldr	r3, [r7, #0x4]
 8001642: 7b1b         	ldrb	r3, [r3, #0xc]
 8001644: fb02 f303    	mul	r3, r2, r3
 8001648: 687a         	ldr	r2, [r7, #0x4]
 800164a: 7b12         	ldrb	r2, [r2, #0xc]
 800164c: fb02 f303    	mul	r3, r2, r3
 8001650: 4618         	mov	r0, r3
 8001652: f004 fd77    	bl	0x8006144 <malloc>      @ imm = #0x4aee
 8001656: 4603         	mov	r3, r0
 8001658: 461a         	mov	r2, r3
 800165a: 687b         	ldr	r3, [r7, #0x4]
 800165c: f8c3 2124    	str.w	r2, [r3, #0x124]
; 	kf->temp_matrix_data1 = (float *)user_malloc(sizeof_float * kf->xhatSize * kf->xhatSize);
 8001660: 4b45         	ldr	r3, [pc, #0x114]        @ 0x8001778 <Kalman_Filter_Init+0x80c>
 8001662: 881b         	ldrh	r3, [r3]
 8001664: 461a         	mov	r2, r3
 8001666: 687b         	ldr	r3, [r7, #0x4]
 8001668: 7b1b         	ldrb	r3, [r3, #0xc]
 800166a: fb02 f303    	mul	r3, r2, r3
 800166e: 687a         	ldr	r2, [r7, #0x4]
 8001670: 7b12         	ldrb	r2, [r2, #0xc]
 8001672: fb02 f303    	mul	r3, r2, r3
 8001676: 4618         	mov	r0, r3
 8001678: f004 fd64    	bl	0x8006144 <malloc>      @ imm = #0x4ac8
 800167c: 4603         	mov	r3, r0
 800167e: 461a         	mov	r2, r3
 8001680: 687b         	ldr	r3, [r7, #0x4]
 8001682: f8c3 2128    	str.w	r2, [r3, #0x128]
; 	kf->temp_vector_data = (float *)user_malloc(sizeof_float * kf->xhatSize);
 8001686: 4b3c         	ldr	r3, [pc, #0xf0]         @ 0x8001778 <Kalman_Filter_Init+0x80c>
 8001688: 881b         	ldrh	r3, [r3]
 800168a: 461a         	mov	r2, r3
 800168c: 687b         	ldr	r3, [r7, #0x4]
 800168e: 7b1b         	ldrb	r3, [r3, #0xc]
 8001690: fb02 f303    	mul	r3, r2, r3
 8001694: 4618         	mov	r0, r3
 8001696: f004 fd55    	bl	0x8006144 <malloc>      @ imm = #0x4aaa
 800169a: 4603         	mov	r3, r0
 800169c: 461a         	mov	r2, r3
 800169e: 687b         	ldr	r3, [r7, #0x4]
 80016a0: f8c3 212c    	str.w	r2, [r3, #0x12c]
; 	kf->temp_vector_data1 = (float *)user_malloc(sizeof_float * kf->xhatSize);
 80016a4: 4b34         	ldr	r3, [pc, #0xd0]         @ 0x8001778 <Kalman_Filter_Init+0x80c>
 80016a6: 881b         	ldrh	r3, [r3]
 80016a8: 461a         	mov	r2, r3
 80016aa: 687b         	ldr	r3, [r7, #0x4]
 80016ac: 7b1b         	ldrb	r3, [r3, #0xc]
 80016ae: fb02 f303    	mul	r3, r2, r3
 80016b2: 4618         	mov	r0, r3
 80016b4: f004 fd46    	bl	0x8006144 <malloc>      @ imm = #0x4a8c
 80016b8: 4603         	mov	r3, r0
 80016ba: 461a         	mov	r2, r3
 80016bc: 687b         	ldr	r3, [r7, #0x4]
 80016be: f8c3 2130    	str.w	r2, [r3, #0x130]
; 	Matrix_Init(&kf->S, kf->xhatSize, kf->xhatSize, (float *)kf->S_data);
 80016c2: 687b         	ldr	r3, [r7, #0x4]
 80016c4: f103 00a0    	add.w	r0, r3, #0xa0
 80016c8: 687b         	ldr	r3, [r7, #0x4]
 80016ca: 7b1b         	ldrb	r3, [r3, #0xc]
 80016cc: 4619         	mov	r1, r3
 80016ce: 687b         	ldr	r3, [r7, #0x4]
 80016d0: 7b1b         	ldrb	r3, [r3, #0xc]
 80016d2: 461a         	mov	r2, r3
 80016d4: 687b         	ldr	r3, [r7, #0x4]
 80016d6: f8d3 3120    	ldr.w	r3, [r3, #0x120]
 80016da: f00b fa2b    	bl	0x800cb34 <arm_mat_init_f32> @ imm = #0xb456
; 	Matrix_Init(&kf->temp_matrix, kf->xhatSize, kf->xhatSize, (float *)kf->temp_matrix_data);
 80016de: 687b         	ldr	r3, [r7, #0x4]
 80016e0: f103 00a8    	add.w	r0, r3, #0xa8
 80016e4: 687b         	ldr	r3, [r7, #0x4]
 80016e6: 7b1b         	ldrb	r3, [r3, #0xc]
 80016e8: 4619         	mov	r1, r3
 80016ea: 687b         	ldr	r3, [r7, #0x4]
 80016ec: 7b1b         	ldrb	r3, [r3, #0xc]
 80016ee: 461a         	mov	r2, r3
 80016f0: 687b         	ldr	r3, [r7, #0x4]
 80016f2: f8d3 3124    	ldr.w	r3, [r3, #0x124]
 80016f6: f00b fa1d    	bl	0x800cb34 <arm_mat_init_f32> @ imm = #0xb43a
; 	Matrix_Init(&kf->temp_matrix1, kf->xhatSize, kf->xhatSize, (float *)kf->temp_matrix_data1);
 80016fa: 687b         	ldr	r3, [r7, #0x4]
 80016fc: f103 00b0    	add.w	r0, r3, #0xb0
 8001700: 687b         	ldr	r3, [r7, #0x4]
 8001702: 7b1b         	ldrb	r3, [r3, #0xc]
 8001704: 4619         	mov	r1, r3
 8001706: 687b         	ldr	r3, [r7, #0x4]
 8001708: 7b1b         	ldrb	r3, [r3, #0xc]
 800170a: 461a         	mov	r2, r3
 800170c: 687b         	ldr	r3, [r7, #0x4]
 800170e: f8d3 3128    	ldr.w	r3, [r3, #0x128]
 8001712: f00b fa0f    	bl	0x800cb34 <arm_mat_init_f32> @ imm = #0xb41e
; 	Matrix_Init(&kf->temp_vector, kf->xhatSize, 1, (float *)kf->temp_vector_data);
 8001716: 687b         	ldr	r3, [r7, #0x4]
 8001718: f103 00b8    	add.w	r0, r3, #0xb8
 800171c: 687b         	ldr	r3, [r7, #0x4]
 800171e: 7b1b         	ldrb	r3, [r3, #0xc]
 8001720: 4619         	mov	r1, r3
 8001722: 687b         	ldr	r3, [r7, #0x4]
 8001724: f8d3 312c    	ldr.w	r3, [r3, #0x12c]
 8001728: 2201         	movs	r2, #0x1
 800172a: f00b fa03    	bl	0x800cb34 <arm_mat_init_f32> @ imm = #0xb406
; 	Matrix_Init(&kf->temp_vector1, kf->xhatSize, 1, (float *)kf->temp_vector_data1);
 800172e: 687b         	ldr	r3, [r7, #0x4]
 8001730: f103 00c0    	add.w	r0, r3, #0xc0
 8001734: 687b         	ldr	r3, [r7, #0x4]
 8001736: 7b1b         	ldrb	r3, [r3, #0xc]
 8001738: 4619         	mov	r1, r3
 800173a: 687b         	ldr	r3, [r7, #0x4]
 800173c: f8d3 3130    	ldr.w	r3, [r3, #0x130]
 8001740: 2201         	movs	r2, #0x1
 8001742: f00b f9f7    	bl	0x800cb34 <arm_mat_init_f32> @ imm = #0xb3ee
; 	kf->SkipEq1 = 0;
 8001746: 687b         	ldr	r3, [r7, #0x4]
 8001748: 2200         	movs	r2, #0x0
 800174a: f883 2028    	strb.w	r2, [r3, #0x28]
; 	kf->SkipEq2 = 0;
 800174e: 687b         	ldr	r3, [r7, #0x4]
 8001750: 2200         	movs	r2, #0x0
 8001752: f883 2029    	strb.w	r2, [r3, #0x29]
; 	kf->SkipEq3 = 0;
 8001756: 687b         	ldr	r3, [r7, #0x4]
 8001758: 2200         	movs	r2, #0x0
 800175a: f883 202a    	strb.w	r2, [r3, #0x2a]
; 	kf->SkipEq4 = 0;
 800175e: 687b         	ldr	r3, [r7, #0x4]
 8001760: 2200         	movs	r2, #0x0
 8001762: f883 202b    	strb.w	r2, [r3, #0x2b]
; 	kf->SkipEq5 = 0;
 8001766: 687b         	ldr	r3, [r7, #0x4]
 8001768: 2200         	movs	r2, #0x0
 800176a: f883 202c    	strb.w	r2, [r3, #0x2c]
; }
 800176e: bf00         	nop
 8001770: 3708         	adds	r7, #0x8
 8001772: 46bd         	mov	sp, r7
 8001774: bd80         	pop	{r7, pc}
 8001776: bf00         	nop

08001778 <$d>:
 8001778: 84 1f 00 20  	.word	0x20001f84

0800177c <Kalman_Filter_Measure>:
; {
 800177c: b580         	push	{r7, lr}
 800177e: b082         	sub	sp, #0x8
 8001780: af00         	add	r7, sp, #0x0
 8001782: 6078         	str	r0, [r7, #0x4]
; 	if (kf->UseAutoAdjustment != 0) {
 8001784: 687b         	ldr	r3, [r7, #0x4]
 8001786: 7bdb         	ldrb	r3, [r3, #0xf]
 8001788: 2b00         	cmp	r3, #0x0
 800178a: d003         	beq	0x8001794 <Kalman_Filter_Measure+0x18> @ imm = #0x6
; 		H_K_R_Adjustment(kf);
 800178c: 6878         	ldr	r0, [r7, #0x4]
 800178e: f000 f90b    	bl	0x80019a8 <H_K_R_Adjustment> @ imm = #0x216
 8001792: e01b         	b	0x80017cc <Kalman_Filter_Measure+0x50> @ imm = #0x36
; 		memcpy(kf->z_data, kf->MeasuredVector, sizeof_float * kf->zSize);
 8001794: 687b         	ldr	r3, [r7, #0x4]
 8001796: f8d3 00f4    	ldr.w	r0, [r3, #0xf4]
 800179a: 687b         	ldr	r3, [r7, #0x4]
 800179c: 6859         	ldr	r1, [r3, #0x4]
 800179e: 4b15         	ldr	r3, [pc, #0x54]         @ 0x80017f4 <Kalman_Filter_Measure+0x78>
 80017a0: 881b         	ldrh	r3, [r3]
 80017a2: 461a         	mov	r2, r3
 80017a4: 687b         	ldr	r3, [r7, #0x4]
 80017a6: 7b9b         	ldrb	r3, [r3, #0xe]
 80017a8: fb02 f303    	mul	r3, r2, r3
 80017ac: 461a         	mov	r2, r3
 80017ae: f01c f80f    	bl	0x801d7d0 <memcpy>      @ imm = #0x1c01e
; 		memset(kf->MeasuredVector, 0, sizeof_float * kf->zSize);
 80017b2: 687b         	ldr	r3, [r7, #0x4]
 80017b4: 6858         	ldr	r0, [r3, #0x4]
 80017b6: 4b0f         	ldr	r3, [pc, #0x3c]         @ 0x80017f4 <Kalman_Filter_Measure+0x78>
 80017b8: 881b         	ldrh	r3, [r3]
 80017ba: 461a         	mov	r2, r3
 80017bc: 687b         	ldr	r3, [r7, #0x4]
 80017be: 7b9b         	ldrb	r3, [r3, #0xe]
 80017c0: fb02 f303    	mul	r3, r2, r3
 80017c4: 461a         	mov	r2, r3
 80017c6: 2100         	movs	r1, #0x0
 80017c8: f01c f810    	bl	0x801d7ec <memset>      @ imm = #0x1c020
; 	memcpy(kf->u_data, kf->ControlVector, sizeof_float * kf->uSize);
 80017cc: 687b         	ldr	r3, [r7, #0x4]
 80017ce: f8d3 00f0    	ldr.w	r0, [r3, #0xf0]
 80017d2: 687b         	ldr	r3, [r7, #0x4]
 80017d4: 6899         	ldr	r1, [r3, #0x8]
 80017d6: 4b07         	ldr	r3, [pc, #0x1c]         @ 0x80017f4 <Kalman_Filter_Measure+0x78>
 80017d8: 881b         	ldrh	r3, [r3]
 80017da: 461a         	mov	r2, r3
 80017dc: 687b         	ldr	r3, [r7, #0x4]
 80017de: 7b5b         	ldrb	r3, [r3, #0xd]
 80017e0: fb02 f303    	mul	r3, r2, r3
 80017e4: 461a         	mov	r2, r3
 80017e6: f01b fff3    	bl	0x801d7d0 <memcpy>      @ imm = #0x1bfe6
; }
 80017ea: bf00         	nop
 80017ec: 3708         	adds	r7, #0x8
 80017ee: 46bd         	mov	sp, r7
 80017f0: bd80         	pop	{r7, pc}
 80017f2: bf00         	nop

080017f4 <$d>:
 80017f4: 84 1f 00 20  	.word	0x20001f84

080017f8 <Kalman_Filter_Update>:
; {
 80017f8: b580         	push	{r7, lr}
 80017fa: b084         	sub	sp, #0x10
 80017fc: af00         	add	r7, sp, #0x0
 80017fe: 6078         	str	r0, [r7, #0x4]
; 	Kalman_Filter_Measure(kf);
 8001800: 6878         	ldr	r0, [r7, #0x4]
 8001802: f7ff ffbb    	bl	0x800177c <Kalman_Filter_Measure> @ imm = #-0x8a
; 	if (kf->User_Func0_f != NULL) {
 8001806: 687b         	ldr	r3, [r7, #0x4]
 8001808: f8d3 30cc    	ldr.w	r3, [r3, #0xcc]
 800180c: 2b00         	cmp	r3, #0x0
 800180e: d004         	beq	0x800181a <Kalman_Filter_Update+0x22> @ imm = #0x8
; 		kf->User_Func0_f(kf);
 8001810: 687b         	ldr	r3, [r7, #0x4]
 8001812: f8d3 30cc    	ldr.w	r3, [r3, #0xcc]
 8001816: 6878         	ldr	r0, [r7, #0x4]
 8001818: 4798         	blx	r3
; 	Kalman_Filter_xhatMinusUpdate(kf);
 800181a: 6878         	ldr	r0, [r7, #0x4]
 800181c: f012 f99d    	bl	0x8013b5a <Kalman_Filter_xhatMinusUpdate> @ imm = #0x1233a
; 	if (kf->User_Func1_f != NULL) {
 8001820: 687b         	ldr	r3, [r7, #0x4]
 8001822: f8d3 30d0    	ldr.w	r3, [r3, #0xd0]
 8001826: 2b00         	cmp	r3, #0x0
 8001828: d004         	beq	0x8001834 <Kalman_Filter_Update+0x3c> @ imm = #0x8
; 		kf->User_Func1_f(kf);
 800182a: 687b         	ldr	r3, [r7, #0x4]
 800182c: f8d3 30d0    	ldr.w	r3, [r3, #0xd0]
 8001830: 6878         	ldr	r0, [r7, #0x4]
 8001832: 4798         	blx	r3
; 	Kalman_Filter_PminusUpdate(kf);
 8001834: 6878         	ldr	r0, [r7, #0x4]
 8001836: f012 f9f6    	bl	0x8013c26 <Kalman_Filter_PminusUpdate> @ imm = #0x123ec
; 	if (kf->User_Func2_f != NULL) {
 800183a: 687b         	ldr	r3, [r7, #0x4]
 800183c: f8d3 30d4    	ldr.w	r3, [r3, #0xd4]
 8001840: 2b00         	cmp	r3, #0x0
 8001842: d004         	beq	0x800184e <Kalman_Filter_Update+0x56> @ imm = #0x8
; 		kf->User_Func2_f(kf);
 8001844: 687b         	ldr	r3, [r7, #0x4]
 8001846: f8d3 30d4    	ldr.w	r3, [r3, #0xd4]
 800184a: 6878         	ldr	r0, [r7, #0x4]
 800184c: 4798         	blx	r3
; 	if (kf->MeasurementValidNum != 0 || kf->UseAutoAdjustment == 0) {
 800184e: 687b         	ldr	r3, [r7, #0x4]
 8001850: 7c1b         	ldrb	r3, [r3, #0x10]
 8001852: 2b00         	cmp	r3, #0x0
 8001854: d103         	bne	0x800185e <Kalman_Filter_Update+0x66> @ imm = #0x6
 8001856: 687b         	ldr	r3, [r7, #0x4]
 8001858: 7bdb         	ldrb	r3, [r3, #0xf]
 800185a: 2b00         	cmp	r3, #0x0
 800185c: d11d         	bne	0x800189a <Kalman_Filter_Update+0xa2> @ imm = #0x3a
; 		Kalman_Filter_SetK(kf);
 800185e: 6878         	ldr	r0, [r7, #0x4]
 8001860: f012 fa38    	bl	0x8013cd4 <Kalman_Filter_SetK> @ imm = #0x12470
; 		if (kf->User_Func3_f != NULL) {
 8001864: 687b         	ldr	r3, [r7, #0x4]
 8001866: f8d3 30d8    	ldr.w	r3, [r3, #0xd8]
 800186a: 2b00         	cmp	r3, #0x0
 800186c: d004         	beq	0x8001878 <Kalman_Filter_Update+0x80> @ imm = #0x8
; 			kf->User_Func3_f(kf);
 800186e: 687b         	ldr	r3, [r7, #0x4]
 8001870: f8d3 30d8    	ldr.w	r3, [r3, #0xd8]
 8001874: 6878         	ldr	r0, [r7, #0x4]
 8001876: 4798         	blx	r3
; 		Kalman_Filter_xhatUpdate(kf);
 8001878: 6878         	ldr	r0, [r7, #0x4]
 800187a: f012 fad5    	bl	0x8013e28 <Kalman_Filter_xhatUpdate> @ imm = #0x125aa
; 		if (kf->User_Func4_f != NULL) {
 800187e: 687b         	ldr	r3, [r7, #0x4]
 8001880: f8d3 30dc    	ldr.w	r3, [r3, #0xdc]
 8001884: 2b00         	cmp	r3, #0x0
 8001886: d004         	beq	0x8001892 <Kalman_Filter_Update+0x9a> @ imm = #0x8
; 			kf->User_Func4_f(kf);
 8001888: 687b         	ldr	r3, [r7, #0x4]
 800188a: f8d3 30dc    	ldr.w	r3, [r3, #0xdc]
 800188e: 6878         	ldr	r0, [r7, #0x4]
 8001890: 4798         	blx	r3
; 		Kalman_Filter_P_Update(kf);
 8001892: 6878         	ldr	r0, [r7, #0x4]
 8001894: f012 fb33    	bl	0x8013efe <Kalman_Filter_P_Update> @ imm = #0x12666
 8001898: e023         	b	0x80018e2 <Kalman_Filter_Update+0xea> @ imm = #0x46
; 		memcpy(kf->xhat_data, kf->xhatminus_data, sizeof_float * kf->xhatSize);
 800189a: 687b         	ldr	r3, [r7, #0x4]
 800189c: f8d3 00e8    	ldr.w	r0, [r3, #0xe8]
 80018a0: 687b         	ldr	r3, [r7, #0x4]
 80018a2: f8d3 10ec    	ldr.w	r1, [r3, #0xec]
 80018a6: 4b3f         	ldr	r3, [pc, #0xfc]         @ 0x80019a4 <Kalman_Filter_Update+0x1ac>
 80018a8: 881b         	ldrh	r3, [r3]
 80018aa: 461a         	mov	r2, r3
 80018ac: 687b         	ldr	r3, [r7, #0x4]
 80018ae: 7b1b         	ldrb	r3, [r3, #0xc]
 80018b0: fb02 f303    	mul	r3, r2, r3
 80018b4: 461a         	mov	r2, r3
 80018b6: f01b ff8b    	bl	0x801d7d0 <memcpy>      @ imm = #0x1bf16
; 		memcpy(kf->P_data, kf->Pminus_data, sizeof_float * kf->xhatSize * kf->xhatSize);
 80018ba: 687b         	ldr	r3, [r7, #0x4]
 80018bc: f8d3 00f8    	ldr.w	r0, [r3, #0xf8]
 80018c0: 687b         	ldr	r3, [r7, #0x4]
 80018c2: f8d3 10fc    	ldr.w	r1, [r3, #0xfc]
 80018c6: 4b37         	ldr	r3, [pc, #0xdc]         @ 0x80019a4 <Kalman_Filter_Update+0x1ac>
 80018c8: 881b         	ldrh	r3, [r3]
 80018ca: 461a         	mov	r2, r3
 80018cc: 687b         	ldr	r3, [r7, #0x4]
 80018ce: 7b1b         	ldrb	r3, [r3, #0xc]
 80018d0: fb02 f303    	mul	r3, r2, r3
 80018d4: 687a         	ldr	r2, [r7, #0x4]
 80018d6: 7b12         	ldrb	r2, [r2, #0xc]
 80018d8: fb02 f303    	mul	r3, r2, r3
 80018dc: 461a         	mov	r2, r3
 80018de: f01b ff77    	bl	0x801d7d0 <memcpy>      @ imm = #0x1beee
; 	if (kf->User_Func5_f != NULL) {
 80018e2: 687b         	ldr	r3, [r7, #0x4]
 80018e4: f8d3 30e0    	ldr.w	r3, [r3, #0xe0]
 80018e8: 2b00         	cmp	r3, #0x0
 80018ea: d004         	beq	0x80018f6 <Kalman_Filter_Update+0xfe> @ imm = #0x8
; 		kf->User_Func5_f(kf);
 80018ec: 687b         	ldr	r3, [r7, #0x4]
 80018ee: f8d3 30e0    	ldr.w	r3, [r3, #0xe0]
 80018f2: 6878         	ldr	r0, [r7, #0x4]
 80018f4: 4798         	blx	r3
; 	for (uint8_t i = 0; i < kf->xhatSize; ++i) {
 80018f6: 2300         	movs	r3, #0x0
 80018f8: 73fb         	strb	r3, [r7, #0xf]
 80018fa: e02e         	b	0x800195a <Kalman_Filter_Update+0x162> @ imm = #0x5c
; 		if (kf->P_data[i * kf->xhatSize + i] < kf->StateMinVariance[i]) {
 80018fc: 687b         	ldr	r3, [r7, #0x4]
 80018fe: f8d3 20f8    	ldr.w	r2, [r3, #0xf8]
 8001902: 7bfb         	ldrb	r3, [r7, #0xf]
 8001904: 6879         	ldr	r1, [r7, #0x4]
 8001906: 7b09         	ldrb	r1, [r1, #0xc]
 8001908: fb03 f101    	mul	r1, r3, r1
 800190c: 7bfb         	ldrb	r3, [r7, #0xf]
 800190e: 440b         	add	r3, r1
 8001910: 009b         	lsls	r3, r3, #0x2
 8001912: 4413         	add	r3, r2
 8001914: 6818         	ldr	r0, [r3]
 8001916: 687b         	ldr	r3, [r7, #0x4]
 8001918: 6a1a         	ldr	r2, [r3, #0x20]
 800191a: 7bfb         	ldrb	r3, [r7, #0xf]
 800191c: 009b         	lsls	r3, r3, #0x2
 800191e: 4413         	add	r3, r2
 8001920: 681b         	ldr	r3, [r3]
 8001922: 4619         	mov	r1, r3
 8001924: f7fe fedc    	bl	0x80006e0 <__aeabi_fcmplt> @ imm = #-0x1248
 8001928: 4603         	mov	r3, r0
 800192a: 2b00         	cmp	r3, #0x0
 800192c: d012         	beq	0x8001954 <Kalman_Filter_Update+0x15c> @ imm = #0x24
; 			kf->P_data[i * kf->xhatSize + i] = kf->StateMinVariance[i];
 800192e: 687b         	ldr	r3, [r7, #0x4]
 8001930: 6a1a         	ldr	r2, [r3, #0x20]
 8001932: 7bfb         	ldrb	r3, [r7, #0xf]
 8001934: 009b         	lsls	r3, r3, #0x2
 8001936: 441a         	add	r2, r3
 8001938: 687b         	ldr	r3, [r7, #0x4]
 800193a: f8d3 10f8    	ldr.w	r1, [r3, #0xf8]
 800193e: 7bfb         	ldrb	r3, [r7, #0xf]
 8001940: 6878         	ldr	r0, [r7, #0x4]
 8001942: 7b00         	ldrb	r0, [r0, #0xc]
 8001944: fb03 f000    	mul	r0, r3, r0
 8001948: 7bfb         	ldrb	r3, [r7, #0xf]
 800194a: 4403         	add	r3, r0
 800194c: 009b         	lsls	r3, r3, #0x2
 800194e: 440b         	add	r3, r1
 8001950: 6812         	ldr	r2, [r2]
 8001952: 601a         	str	r2, [r3]
; 	for (uint8_t i = 0; i < kf->xhatSize; ++i) {
 8001954: 7bfb         	ldrb	r3, [r7, #0xf]
 8001956: 3301         	adds	r3, #0x1
 8001958: 73fb         	strb	r3, [r7, #0xf]
 800195a: 687b         	ldr	r3, [r7, #0x4]
 800195c: 7b1b         	ldrb	r3, [r3, #0xc]
 800195e: 7bfa         	ldrb	r2, [r7, #0xf]
 8001960: 429a         	cmp	r2, r3
 8001962: d3cb         	blo	0x80018fc <Kalman_Filter_Update+0x104> @ imm = #-0x6a
; 	memcpy(kf->FilteredValue, kf->xhat_data, sizeof_float * kf->xhatSize);
 8001964: 687b         	ldr	r3, [r7, #0x4]
 8001966: 6818         	ldr	r0, [r3]
 8001968: 687b         	ldr	r3, [r7, #0x4]
 800196a: f8d3 10e8    	ldr.w	r1, [r3, #0xe8]
 800196e: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x80019a4 <Kalman_Filter_Update+0x1ac>
 8001970: 881b         	ldrh	r3, [r3]
 8001972: 461a         	mov	r2, r3
 8001974: 687b         	ldr	r3, [r7, #0x4]
 8001976: 7b1b         	ldrb	r3, [r3, #0xc]
 8001978: fb02 f303    	mul	r3, r2, r3
 800197c: 461a         	mov	r2, r3
 800197e: f01b ff27    	bl	0x801d7d0 <memcpy>      @ imm = #0x1be4e
; 	if (kf->User_Func6_f != NULL) {
 8001982: 687b         	ldr	r3, [r7, #0x4]
 8001984: f8d3 30e4    	ldr.w	r3, [r3, #0xe4]
 8001988: 2b00         	cmp	r3, #0x0
 800198a: d004         	beq	0x8001996 <Kalman_Filter_Update+0x19e> @ imm = #0x8
; 		kf->User_Func6_f(kf);
 800198c: 687b         	ldr	r3, [r7, #0x4]
 800198e: f8d3 30e4    	ldr.w	r3, [r3, #0xe4]
 8001992: 6878         	ldr	r0, [r7, #0x4]
 8001994: 4798         	blx	r3
; 	return kf->FilteredValue;
 8001996: 687b         	ldr	r3, [r7, #0x4]
 8001998: 681b         	ldr	r3, [r3]
; }
 800199a: 4618         	mov	r0, r3
 800199c: 3710         	adds	r7, #0x10
 800199e: 46bd         	mov	sp, r7
 80019a0: bd80         	pop	{r7, pc}
 80019a2: bf00         	nop

080019a4 <$d>:
 80019a4: 84 1f 00 20  	.word	0x20001f84

080019a8 <H_K_R_Adjustment>:
; {
 80019a8: b590         	push	{r4, r7, lr}
 80019aa: b085         	sub	sp, #0x14
 80019ac: af00         	add	r7, sp, #0x0
 80019ae: 6078         	str	r0, [r7, #0x4]
; 	kf->MeasurementValidNum = 0;
 80019b0: 687b         	ldr	r3, [r7, #0x4]
 80019b2: 2200         	movs	r2, #0x0
 80019b4: 741a         	strb	r2, [r3, #0x10]
; 	memcpy(kf->z_data, kf->MeasuredVector, sizeof_float * kf->zSize);
 80019b6: 687b         	ldr	r3, [r7, #0x4]
 80019b8: f8d3 00f4    	ldr.w	r0, [r3, #0xf4]
 80019bc: 687b         	ldr	r3, [r7, #0x4]
 80019be: 6859         	ldr	r1, [r3, #0x4]
 80019c0: 4b74         	ldr	r3, [pc, #0x1d0]        @ 0x8001b94 <H_K_R_Adjustment+0x1ec>
 80019c2: 881b         	ldrh	r3, [r3]
 80019c4: 461a         	mov	r2, r3
 80019c6: 687b         	ldr	r3, [r7, #0x4]
 80019c8: 7b9b         	ldrb	r3, [r3, #0xe]
 80019ca: fb02 f303    	mul	r3, r2, r3
 80019ce: 461a         	mov	r2, r3
 80019d0: f01b fefe    	bl	0x801d7d0 <memcpy>      @ imm = #0x1bdfc
; 	memset(kf->MeasuredVector, 0, sizeof_float * kf->zSize);
 80019d4: 687b         	ldr	r3, [r7, #0x4]
 80019d6: 6858         	ldr	r0, [r3, #0x4]
 80019d8: 4b6e         	ldr	r3, [pc, #0x1b8]        @ 0x8001b94 <H_K_R_Adjustment+0x1ec>
 80019da: 881b         	ldrh	r3, [r3]
 80019dc: 461a         	mov	r2, r3
 80019de: 687b         	ldr	r3, [r7, #0x4]
 80019e0: 7b9b         	ldrb	r3, [r3, #0xe]
 80019e2: fb02 f303    	mul	r3, r2, r3
 80019e6: 461a         	mov	r2, r3
 80019e8: 2100         	movs	r1, #0x0
 80019ea: f01b feff    	bl	0x801d7ec <memset>      @ imm = #0x1bdfe
; 	memset(kf->R_data, 0, sizeof_float * kf->zSize * kf->zSize);
 80019ee: 687b         	ldr	r3, [r7, #0x4]
 80019f0: f8d3 0118    	ldr.w	r0, [r3, #0x118]
 80019f4: 4b67         	ldr	r3, [pc, #0x19c]        @ 0x8001b94 <H_K_R_Adjustment+0x1ec>
 80019f6: 881b         	ldrh	r3, [r3]
 80019f8: 461a         	mov	r2, r3
 80019fa: 687b         	ldr	r3, [r7, #0x4]
 80019fc: 7b9b         	ldrb	r3, [r3, #0xe]
 80019fe: fb02 f303    	mul	r3, r2, r3
 8001a02: 687a         	ldr	r2, [r7, #0x4]
 8001a04: 7b92         	ldrb	r2, [r2, #0xe]
 8001a06: fb02 f303    	mul	r3, r2, r3
 8001a0a: 461a         	mov	r2, r3
 8001a0c: 2100         	movs	r1, #0x0
 8001a0e: f01b feed    	bl	0x801d7ec <memset>      @ imm = #0x1bdda
; 	memset(kf->H_data, 0, sizeof_float * kf->xhatSize * kf->zSize);
 8001a12: 687b         	ldr	r3, [r7, #0x4]
 8001a14: f8d3 010c    	ldr.w	r0, [r3, #0x10c]
 8001a18: 4b5e         	ldr	r3, [pc, #0x178]        @ 0x8001b94 <H_K_R_Adjustment+0x1ec>
 8001a1a: 881b         	ldrh	r3, [r3]
 8001a1c: 461a         	mov	r2, r3
 8001a1e: 687b         	ldr	r3, [r7, #0x4]
 8001a20: 7b1b         	ldrb	r3, [r3, #0xc]
 8001a22: fb02 f303    	mul	r3, r2, r3
 8001a26: 687a         	ldr	r2, [r7, #0x4]
 8001a28: 7b92         	ldrb	r2, [r2, #0xe]
 8001a2a: fb02 f303    	mul	r3, r2, r3
 8001a2e: 461a         	mov	r2, r3
 8001a30: 2100         	movs	r1, #0x0
 8001a32: f01b fedb    	bl	0x801d7ec <memset>      @ imm = #0x1bdb6
; 	for (uint8_t i = 0; i < kf->zSize; ++i) {
 8001a36: 2300         	movs	r3, #0x0
 8001a38: 73fb         	strb	r3, [r7, #0xf]
 8001a3a: e049         	b	0x8001ad0 <H_K_R_Adjustment+0x128> @ imm = #0x92
; 		if (kf->z_data[i] != 0) {
 8001a3c: 687b         	ldr	r3, [r7, #0x4]
 8001a3e: f8d3 20f4    	ldr.w	r2, [r3, #0xf4]
 8001a42: 7bfb         	ldrb	r3, [r7, #0xf]
 8001a44: 009b         	lsls	r3, r3, #0x2
 8001a46: 4413         	add	r3, r2
 8001a48: 681b         	ldr	r3, [r3]
 8001a4a: f04f 0100    	mov.w	r1, #0x0
 8001a4e: 4618         	mov	r0, r3
 8001a50: f7fe fe3c    	bl	0x80006cc <__aeabi_fcmpeq> @ imm = #-0x1388
 8001a54: 4603         	mov	r3, r0
 8001a56: 2b00         	cmp	r3, #0x0
 8001a58: d137         	bne	0x8001aca <H_K_R_Adjustment+0x122> @ imm = #0x6e
; 			kf->z_data[kf->MeasurementValidNum] = kf->z_data[i];
 8001a5a: 687b         	ldr	r3, [r7, #0x4]
 8001a5c: f8d3 20f4    	ldr.w	r2, [r3, #0xf4]
 8001a60: 7bfb         	ldrb	r3, [r7, #0xf]
 8001a62: 009b         	lsls	r3, r3, #0x2
 8001a64: 441a         	add	r2, r3
 8001a66: 687b         	ldr	r3, [r7, #0x4]
 8001a68: f8d3 10f4    	ldr.w	r1, [r3, #0xf4]
 8001a6c: 687b         	ldr	r3, [r7, #0x4]
 8001a6e: 7c1b         	ldrb	r3, [r3, #0x10]
 8001a70: 009b         	lsls	r3, r3, #0x2
 8001a72: 440b         	add	r3, r1
 8001a74: 6812         	ldr	r2, [r2]
 8001a76: 601a         	str	r2, [r3]
; 			kf->temp[kf->MeasurementValidNum] = i;
 8001a78: 687b         	ldr	r3, [r7, #0x4]
 8001a7a: 6a5b         	ldr	r3, [r3, #0x24]
 8001a7c: 687a         	ldr	r2, [r7, #0x4]
 8001a7e: 7c12         	ldrb	r2, [r2, #0x10]
 8001a80: 4413         	add	r3, r2
 8001a82: 7bfa         	ldrb	r2, [r7, #0xf]
 8001a84: 701a         	strb	r2, [r3]
; 				   1] = kf->MeasurementDegree[i];
 8001a86: 687b         	ldr	r3, [r7, #0x4]
 8001a88: 699a         	ldr	r2, [r3, #0x18]
 8001a8a: 7bfb         	ldrb	r3, [r7, #0xf]
 8001a8c: 009b         	lsls	r3, r3, #0x2
 8001a8e: 441a         	add	r2, r3
; 			kf->H_data[kf->xhatSize * kf->MeasurementValidNum + kf->MeasurementMap[i] -
 8001a90: 687b         	ldr	r3, [r7, #0x4]
 8001a92: f8d3 110c    	ldr.w	r1, [r3, #0x10c]
 8001a96: 687b         	ldr	r3, [r7, #0x4]
 8001a98: 7b1b         	ldrb	r3, [r3, #0xc]
 8001a9a: 4618         	mov	r0, r3
 8001a9c: 687b         	ldr	r3, [r7, #0x4]
 8001a9e: 7c1b         	ldrb	r3, [r3, #0x10]
 8001aa0: fb00 f303    	mul	r3, r0, r3
 8001aa4: 6878         	ldr	r0, [r7, #0x4]
 8001aa6: 6944         	ldr	r4, [r0, #0x14]
 8001aa8: 7bf8         	ldrb	r0, [r7, #0xf]
 8001aaa: 4420         	add	r0, r4
 8001aac: 7800         	ldrb	r0, [r0]
 8001aae: 4403         	add	r3, r0
 8001ab0: f103 4380    	add.w	r3, r3, #0x40000000
 8001ab4: 3b01         	subs	r3, #0x1
 8001ab6: 009b         	lsls	r3, r3, #0x2
 8001ab8: 440b         	add	r3, r1
; 				   1] = kf->MeasurementDegree[i];
 8001aba: 6812         	ldr	r2, [r2]
 8001abc: 601a         	str	r2, [r3]
; 			kf->MeasurementValidNum++;
 8001abe: 687b         	ldr	r3, [r7, #0x4]
 8001ac0: 7c1b         	ldrb	r3, [r3, #0x10]
 8001ac2: 3301         	adds	r3, #0x1
 8001ac4: b2da         	uxtb	r2, r3
 8001ac6: 687b         	ldr	r3, [r7, #0x4]
 8001ac8: 741a         	strb	r2, [r3, #0x10]
; 	for (uint8_t i = 0; i < kf->zSize; ++i) {
 8001aca: 7bfb         	ldrb	r3, [r7, #0xf]
 8001acc: 3301         	adds	r3, #0x1
 8001ace: 73fb         	strb	r3, [r7, #0xf]
 8001ad0: 687b         	ldr	r3, [r7, #0x4]
 8001ad2: 7b9b         	ldrb	r3, [r3, #0xe]
 8001ad4: 7bfa         	ldrb	r2, [r7, #0xf]
 8001ad6: 429a         	cmp	r2, r3
 8001ad8: d3b0         	blo	0x8001a3c <H_K_R_Adjustment+0x94> @ imm = #-0xa0
; 	for (uint8_t i = 0; i < kf->MeasurementValidNum; ++i) {
 8001ada: 2300         	movs	r3, #0x0
 8001adc: 73bb         	strb	r3, [r7, #0xe]
 8001ade: e019         	b	0x8001b14 <H_K_R_Adjustment+0x16c> @ imm = #0x32
; 			kf->MatR_DiagonalElements[kf->temp[i]];
 8001ae0: 687b         	ldr	r3, [r7, #0x4]
 8001ae2: 69da         	ldr	r2, [r3, #0x1c]
 8001ae4: 687b         	ldr	r3, [r7, #0x4]
 8001ae6: 6a59         	ldr	r1, [r3, #0x24]
 8001ae8: 7bbb         	ldrb	r3, [r7, #0xe]
 8001aea: 440b         	add	r3, r1
 8001aec: 781b         	ldrb	r3, [r3]
 8001aee: 009b         	lsls	r3, r3, #0x2
 8001af0: 441a         	add	r2, r3
; 		kf->R_data[i * kf->MeasurementValidNum + i] =
 8001af2: 687b         	ldr	r3, [r7, #0x4]
 8001af4: f8d3 1118    	ldr.w	r1, [r3, #0x118]
 8001af8: 7bbb         	ldrb	r3, [r7, #0xe]
 8001afa: 6878         	ldr	r0, [r7, #0x4]
 8001afc: 7c00         	ldrb	r0, [r0, #0x10]
 8001afe: fb03 f000    	mul	r0, r3, r0
 8001b02: 7bbb         	ldrb	r3, [r7, #0xe]
 8001b04: 4403         	add	r3, r0
 8001b06: 009b         	lsls	r3, r3, #0x2
 8001b08: 440b         	add	r3, r1
; 			kf->MatR_DiagonalElements[kf->temp[i]];
 8001b0a: 6812         	ldr	r2, [r2]
; 		kf->R_data[i * kf->MeasurementValidNum + i] =
 8001b0c: 601a         	str	r2, [r3]
; 	for (uint8_t i = 0; i < kf->MeasurementValidNum; ++i) {
 8001b0e: 7bbb         	ldrb	r3, [r7, #0xe]
 8001b10: 3301         	adds	r3, #0x1
 8001b12: 73bb         	strb	r3, [r7, #0xe]
 8001b14: 687b         	ldr	r3, [r7, #0x4]
 8001b16: 7c1b         	ldrb	r3, [r3, #0x10]
 8001b18: 7bba         	ldrb	r2, [r7, #0xe]
 8001b1a: 429a         	cmp	r2, r3
 8001b1c: d3e0         	blo	0x8001ae0 <H_K_R_Adjustment+0x138> @ imm = #-0x40
; 	kf->H.numRows = kf->MeasurementValidNum;
 8001b1e: 687b         	ldr	r3, [r7, #0x4]
 8001b20: 7c1b         	ldrb	r3, [r3, #0x10]
 8001b22: 461a         	mov	r2, r3
 8001b24: 687b         	ldr	r3, [r7, #0x4]
 8001b26: f8a3 2078    	strh.w	r2, [r3, #0x78]
; 	kf->H.numCols = kf->xhatSize;
 8001b2a: 687b         	ldr	r3, [r7, #0x4]
 8001b2c: 7b1b         	ldrb	r3, [r3, #0xc]
 8001b2e: 461a         	mov	r2, r3
 8001b30: 687b         	ldr	r3, [r7, #0x4]
 8001b32: f8a3 207a    	strh.w	r2, [r3, #0x7a]
; 	kf->HT.numRows = kf->xhatSize;
 8001b36: 687b         	ldr	r3, [r7, #0x4]
 8001b38: 7b1b         	ldrb	r3, [r3, #0xc]
 8001b3a: 461a         	mov	r2, r3
 8001b3c: 687b         	ldr	r3, [r7, #0x4]
 8001b3e: f8a3 2080    	strh.w	r2, [r3, #0x80]
; 	kf->HT.numCols = kf->MeasurementValidNum;
 8001b42: 687b         	ldr	r3, [r7, #0x4]
 8001b44: 7c1b         	ldrb	r3, [r3, #0x10]
 8001b46: 461a         	mov	r2, r3
 8001b48: 687b         	ldr	r3, [r7, #0x4]
 8001b4a: f8a3 2082    	strh.w	r2, [r3, #0x82]
; 	kf->R.numRows = kf->MeasurementValidNum;
 8001b4e: 687b         	ldr	r3, [r7, #0x4]
 8001b50: 7c1b         	ldrb	r3, [r3, #0x10]
 8001b52: 461a         	mov	r2, r3
 8001b54: 687b         	ldr	r3, [r7, #0x4]
 8001b56: f8a3 2090    	strh.w	r2, [r3, #0x90]
; 	kf->R.numCols = kf->MeasurementValidNum;
 8001b5a: 687b         	ldr	r3, [r7, #0x4]
 8001b5c: 7c1b         	ldrb	r3, [r3, #0x10]
 8001b5e: 461a         	mov	r2, r3
 8001b60: 687b         	ldr	r3, [r7, #0x4]
 8001b62: f8a3 2092    	strh.w	r2, [r3, #0x92]
; 	kf->K.numRows = kf->xhatSize;
 8001b66: 687b         	ldr	r3, [r7, #0x4]
 8001b68: 7b1b         	ldrb	r3, [r3, #0xc]
 8001b6a: 461a         	mov	r2, r3
 8001b6c: 687b         	ldr	r3, [r7, #0x4]
 8001b6e: f8a3 2098    	strh.w	r2, [r3, #0x98]
; 	kf->K.numCols = kf->MeasurementValidNum;
 8001b72: 687b         	ldr	r3, [r7, #0x4]
 8001b74: 7c1b         	ldrb	r3, [r3, #0x10]
 8001b76: 461a         	mov	r2, r3
 8001b78: 687b         	ldr	r3, [r7, #0x4]
 8001b7a: f8a3 209a    	strh.w	r2, [r3, #0x9a]
; 	kf->z.numRows = kf->MeasurementValidNum;
 8001b7e: 687b         	ldr	r3, [r7, #0x4]
 8001b80: 7c1b         	ldrb	r3, [r3, #0x10]
 8001b82: 461a         	mov	r2, r3
 8001b84: 687b         	ldr	r3, [r7, #0x4]
 8001b86: f8a3 2048    	strh.w	r2, [r3, #0x48]
; }
 8001b8a: bf00         	nop
 8001b8c: 3714         	adds	r7, #0x14
 8001b8e: 46bd         	mov	sp, r7
 8001b90: bd90         	pop	{r4, r7, pc}
 8001b92: bf00         	nop

08001b94 <$d>:
 8001b94: 84 1f 00 20  	.word	0x20001f84

08001b98 <IMU_QuaternionEKF_Init>:
; {
 8001b98: b580         	push	{r7, lr}
 8001b9a: b086         	sub	sp, #0x18
 8001b9c: af00         	add	r7, sp, #0x0
 8001b9e: 60f8         	str	r0, [r7, #0xc]
 8001ba0: 60b9         	str	r1, [r7, #0x8]
 8001ba2: 607a         	str	r2, [r7, #0x4]
 8001ba4: 603b         	str	r3, [r7]
; 	QEKF_INS.Initialized = 1;
 8001ba6: 4b42         	ldr	r3, [pc, #0x108]        @ 0x8001cb0 <IMU_QuaternionEKF_Init+0x118>
 8001ba8: 2201         	movs	r2, #0x1
 8001baa: 701a         	strb	r2, [r3]
; 	QEKF_INS.Q1 = process_noise1;
 8001bac: 4a40         	ldr	r2, [pc, #0x100]        @ 0x8001cb0 <IMU_QuaternionEKF_Init+0x118>
 8001bae: 68bb         	ldr	r3, [r7, #0x8]
 8001bb0: f8c2 31b0    	str.w	r3, [r2, #0x1b0]
; 	QEKF_INS.Q2 = process_noise2;
 8001bb4: 4a3e         	ldr	r2, [pc, #0xf8]         @ 0x8001cb0 <IMU_QuaternionEKF_Init+0x118>
 8001bb6: 687b         	ldr	r3, [r7, #0x4]
 8001bb8: f8c2 31b4    	str.w	r3, [r2, #0x1b4]
; 	QEKF_INS.R = measure_noise;
 8001bbc: 4a3c         	ldr	r2, [pc, #0xf0]         @ 0x8001cb0 <IMU_QuaternionEKF_Init+0x118>
 8001bbe: 683b         	ldr	r3, [r7]
 8001bc0: f8c2 31b8    	str.w	r3, [r2, #0x1b8]
; 	QEKF_INS.ChiSquareTestThreshold = 1e-8;
 8001bc4: 4b3a         	ldr	r3, [pc, #0xe8]         @ 0x8001cb0 <IMU_QuaternionEKF_Init+0x118>
 8001bc6: 4a3b         	ldr	r2, [pc, #0xec]         @ 0x8001cb4 <IMU_QuaternionEKF_Init+0x11c>
 8001bc8: f8c3 21cc    	str.w	r2, [r3, #0x1cc]
; 	QEKF_INS.ConvergeFlag = 0;
 8001bcc: 4b38         	ldr	r3, [pc, #0xe0]         @ 0x8001cb0 <IMU_QuaternionEKF_Init+0x118>
 8001bce: 2200         	movs	r2, #0x0
 8001bd0: f883 2138    	strb.w	r2, [r3, #0x138]
; 	QEKF_INS.ErrorCount = 0;
 8001bd4: 4936         	ldr	r1, [pc, #0xd8]         @ 0x8001cb0 <IMU_QuaternionEKF_Init+0x118>
 8001bd6: f04f 0200    	mov.w	r2, #0x0
 8001bda: f04f 0300    	mov.w	r3, #0x0
 8001bde: e9c1 2350    	strd	r2, r3, [r1, #320]
; 	QEKF_INS.UpdateCount = 0;
 8001be2: 4933         	ldr	r1, [pc, #0xcc]         @ 0x8001cb0 <IMU_QuaternionEKF_Init+0x118>
 8001be4: f04f 0200    	mov.w	r2, #0x0
 8001be8: f04f 0300    	mov.w	r3, #0x0
 8001bec: e9c1 2352    	strd	r2, r3, [r1, #328]
; 	if (lambda > 1) {
 8001bf0: f04f 517e    	mov.w	r1, #0x3f800000
 8001bf4: 6a38         	ldr	r0, [r7, #0x20]
 8001bf6: f7fe fd91    	bl	0x800071c <__aeabi_fcmpgt> @ imm = #-0x14de
 8001bfa: 4603         	mov	r3, r0
 8001bfc: 2b00         	cmp	r3, #0x0
 8001bfe: d002         	beq	0x8001c06 <IMU_QuaternionEKF_Init+0x6e> @ imm = #0x4
; 		lambda = 1;
 8001c00: f04f 537e    	mov.w	r3, #0x3f800000
 8001c04: 623b         	str	r3, [r7, #0x20]
; 	QEKF_INS.lambda = lambda;
 8001c06: 4a2a         	ldr	r2, [pc, #0xa8]         @ 0x8001cb0 <IMU_QuaternionEKF_Init+0x118>
 8001c08: 6a3b         	ldr	r3, [r7, #0x20]
 8001c0a: f8c2 31d0    	str.w	r3, [r2, #0x1d0]
; 	QEKF_INS.accLPFcoef = lpf;
 8001c0e: 4a28         	ldr	r2, [pc, #0xa0]         @ 0x8001cb0 <IMU_QuaternionEKF_Init+0x118>
 8001c10: 6a7b         	ldr	r3, [r7, #0x24]
 8001c12: f8c2 3190    	str.w	r3, [r2, #0x190]
; 	Kalman_Filter_Init(&QEKF_INS.IMU_QuaternionEKF, 6, 0, 3);
 8001c16: 2303         	movs	r3, #0x3
 8001c18: 2200         	movs	r2, #0x0
 8001c1a: 2106         	movs	r1, #0x6
 8001c1c: 4826         	ldr	r0, [pc, #0x98]         @ 0x8001cb8 <IMU_QuaternionEKF_Init+0x120>
 8001c1e: f7ff f9a5    	bl	0x8000f6c <Kalman_Filter_Init> @ imm = #-0xcb6
; 	Matrix_Init(&QEKF_INS.ChiSquare, 1, 1, (float *)QEKF_INS.ChiSquare_Data);
 8001c22: 4b26         	ldr	r3, [pc, #0x98]         @ 0x8001cbc <IMU_QuaternionEKF_Init+0x124>
 8001c24: 2201         	movs	r2, #0x1
 8001c26: 2101         	movs	r1, #0x1
 8001c28: 4825         	ldr	r0, [pc, #0x94]         @ 0x8001cc0 <IMU_QuaternionEKF_Init+0x128>
 8001c2a: f00a ff83    	bl	0x800cb34 <arm_mat_init_f32> @ imm = #0xaf06
; 	for (int i = 0; i < 4; i++) {
 8001c2e: 2300         	movs	r3, #0x0
 8001c30: 617b         	str	r3, [r7, #0x14]
 8001c32: e00e         	b	0x8001c52 <IMU_QuaternionEKF_Init+0xba> @ imm = #0x1c
; 		QEKF_INS.IMU_QuaternionEKF.xhat_data[i] = init_quaternion[i];
 8001c34: 697b         	ldr	r3, [r7, #0x14]
 8001c36: 009b         	lsls	r3, r3, #0x2
 8001c38: 68fa         	ldr	r2, [r7, #0xc]
 8001c3a: 441a         	add	r2, r3
 8001c3c: 4b1c         	ldr	r3, [pc, #0x70]         @ 0x8001cb0 <IMU_QuaternionEKF_Init+0x118>
 8001c3e: f8d3 10ec    	ldr.w	r1, [r3, #0xec]
 8001c42: 697b         	ldr	r3, [r7, #0x14]
 8001c44: 009b         	lsls	r3, r3, #0x2
 8001c46: 440b         	add	r3, r1
 8001c48: 6812         	ldr	r2, [r2]
 8001c4a: 601a         	str	r2, [r3]
; 	for (int i = 0; i < 4; i++) {
 8001c4c: 697b         	ldr	r3, [r7, #0x14]
 8001c4e: 3301         	adds	r3, #0x1
 8001c50: 617b         	str	r3, [r7, #0x14]
 8001c52: 697b         	ldr	r3, [r7, #0x14]
 8001c54: 2b03         	cmp	r3, #0x3
 8001c56: dded         	ble	0x8001c34 <IMU_QuaternionEKF_Init+0x9c> @ imm = #-0x26
; 	QEKF_INS.IMU_QuaternionEKF.User_Func0_f = IMU_QuaternionEKF_Observe;
 8001c58: 4b15         	ldr	r3, [pc, #0x54]         @ 0x8001cb0 <IMU_QuaternionEKF_Init+0x118>
 8001c5a: 4a1a         	ldr	r2, [pc, #0x68]         @ 0x8001cc4 <IMU_QuaternionEKF_Init+0x12c>
 8001c5c: f8c3 20d0    	str.w	r2, [r3, #0xd0]
; 	QEKF_INS.IMU_QuaternionEKF.User_Func1_f = IMU_QuaternionEKF_F_Linearization_P_Fading;
 8001c60: 4b13         	ldr	r3, [pc, #0x4c]         @ 0x8001cb0 <IMU_QuaternionEKF_Init+0x118>
 8001c62: 4a19         	ldr	r2, [pc, #0x64]         @ 0x8001cc8 <IMU_QuaternionEKF_Init+0x130>
 8001c64: f8c3 20d4    	str.w	r2, [r3, #0xd4]
; 	QEKF_INS.IMU_QuaternionEKF.User_Func2_f = IMU_QuaternionEKF_SetH;
 8001c68: 4b11         	ldr	r3, [pc, #0x44]         @ 0x8001cb0 <IMU_QuaternionEKF_Init+0x118>
 8001c6a: 4a18         	ldr	r2, [pc, #0x60]         @ 0x8001ccc <IMU_QuaternionEKF_Init+0x134>
 8001c6c: f8c3 20d8    	str.w	r2, [r3, #0xd8]
; 	QEKF_INS.IMU_QuaternionEKF.User_Func3_f = IMU_QuaternionEKF_xhatUpdate;
 8001c70: 4b0f         	ldr	r3, [pc, #0x3c]         @ 0x8001cb0 <IMU_QuaternionEKF_Init+0x118>
 8001c72: 4a17         	ldr	r2, [pc, #0x5c]         @ 0x8001cd0 <IMU_QuaternionEKF_Init+0x138>
 8001c74: f8c3 20dc    	str.w	r2, [r3, #0xdc]
; 	QEKF_INS.IMU_QuaternionEKF.SkipEq3 = TRUE;
 8001c78: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x8001cb0 <IMU_QuaternionEKF_Init+0x118>
 8001c7a: 2201         	movs	r2, #0x1
 8001c7c: f883 202e    	strb.w	r2, [r3, #0x2e]
; 	QEKF_INS.IMU_QuaternionEKF.SkipEq4 = TRUE;
 8001c80: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x8001cb0 <IMU_QuaternionEKF_Init+0x118>
 8001c82: 2201         	movs	r2, #0x1
 8001c84: f883 202f    	strb.w	r2, [r3, #0x2f]
; 	memcpy(QEKF_INS.IMU_QuaternionEKF.F_data, IMU_QuaternionEKF_F, sizeof(IMU_QuaternionEKF_F));
 8001c88: 4b09         	ldr	r3, [pc, #0x24]         @ 0x8001cb0 <IMU_QuaternionEKF_Init+0x118>
 8001c8a: f8d3 3104    	ldr.w	r3, [r3, #0x104]
 8001c8e: 2290         	movs	r2, #0x90
 8001c90: 4910         	ldr	r1, [pc, #0x40]         @ 0x8001cd4 <IMU_QuaternionEKF_Init+0x13c>
 8001c92: 4618         	mov	r0, r3
 8001c94: f01b fd9c    	bl	0x801d7d0 <memcpy>      @ imm = #0x1bb38
; 	memcpy(QEKF_INS.IMU_QuaternionEKF.P_data, IMU_QuaternionEKF_P, sizeof(IMU_QuaternionEKF_P));
 8001c98: 4b05         	ldr	r3, [pc, #0x14]         @ 0x8001cb0 <IMU_QuaternionEKF_Init+0x118>
 8001c9a: f8d3 30fc    	ldr.w	r3, [r3, #0xfc]
 8001c9e: 2290         	movs	r2, #0x90
 8001ca0: 490d         	ldr	r1, [pc, #0x34]         @ 0x8001cd8 <IMU_QuaternionEKF_Init+0x140>
 8001ca2: 4618         	mov	r0, r3
 8001ca4: f01b fd94    	bl	0x801d7d0 <memcpy>      @ imm = #0x1bb28
; }
 8001ca8: bf00         	nop
 8001caa: 3718         	adds	r7, #0x18
 8001cac: 46bd         	mov	sp, r7
 8001cae: bd80         	pop	{r7, pc}

08001cb0 <$d>:
 8001cb0: f8 06 00 20  	.word	0x200006f8
 8001cb4: 77 cc 2b 32  	.word	0x322bcc77
 8001cb8: fc 06 00 20  	.word	0x200006fc
 8001cbc: c0 08 00 20  	.word	0x200008c0
 8001cc0: b8 08 00 20  	.word	0x200008b8
 8001cc4: 0d 31 00 08  	.word	0x0800310d
 8001cc8: 6d 25 00 08  	.word	0x0800256d
 8001ccc: a1 28 00 08  	.word	0x080028a1
 8001cd0: 05 2a 00 08  	.word	0x08002a05
 8001cd4: 54 fe 01 08  	.word	0x0801fe54
 8001cd8: 08 04 00 20  	.word	0x20000408

08001cdc <IMU_QuaternionEKF_Update>:
; {
 8001cdc: e92d 41f0    	push.w	{r4, r5, r6, r7, r8, lr}
 8001ce0: b086         	sub	sp, #0x18
 8001ce2: af00         	add	r7, sp, #0x0
 8001ce4: 60f8         	str	r0, [r7, #0xc]
 8001ce6: 60b9         	str	r1, [r7, #0x8]
 8001ce8: 607a         	str	r2, [r7, #0x4]
 8001cea: 603b         	str	r3, [r7]
; 	QEKF_INS.dt = gyro_dt;
 8001cec: 4aa7         	ldr	r2, [pc, #0x29c]        @ 0x8001f8c <IMU_QuaternionEKF_Update+0x2b0>
 8001cee: 6bfb         	ldr	r3, [r7, #0x3c]
 8001cf0: f8c2 31bc    	str.w	r3, [r2, #0x1bc]
; 	QEKF_INS.Gyro[0] = gx - QEKF_INS.GyroBias[0];
 8001cf4: 4ba5         	ldr	r3, [pc, #0x294]        @ 0x8001f8c <IMU_QuaternionEKF_Update+0x2b0>
 8001cf6: f8d3 3160    	ldr.w	r3, [r3, #0x160]
 8001cfa: 4619         	mov	r1, r3
 8001cfc: 68f8         	ldr	r0, [r7, #0xc]
 8001cfe: f7fe fa47    	bl	0x8000190 <__subsf3>    @ imm = #-0x1b72
 8001d02: 4603         	mov	r3, r0
 8001d04: 461a         	mov	r2, r3
 8001d06: 4ba1         	ldr	r3, [pc, #0x284]        @ 0x8001f8c <IMU_QuaternionEKF_Update+0x2b0>
 8001d08: f8c3 216c    	str.w	r2, [r3, #0x16c]
; 	QEKF_INS.Gyro[1] = gy - QEKF_INS.GyroBias[1];
 8001d0c: 4b9f         	ldr	r3, [pc, #0x27c]        @ 0x8001f8c <IMU_QuaternionEKF_Update+0x2b0>
 8001d0e: f8d3 3164    	ldr.w	r3, [r3, #0x164]
 8001d12: 4619         	mov	r1, r3
 8001d14: 68b8         	ldr	r0, [r7, #0x8]
 8001d16: f7fe fa3b    	bl	0x8000190 <__subsf3>    @ imm = #-0x1b8a
 8001d1a: 4603         	mov	r3, r0
 8001d1c: 461a         	mov	r2, r3
 8001d1e: 4b9b         	ldr	r3, [pc, #0x26c]        @ 0x8001f8c <IMU_QuaternionEKF_Update+0x2b0>
 8001d20: f8c3 2170    	str.w	r2, [r3, #0x170]
; 	QEKF_INS.Gyro[2] = gz - QEKF_INS.GyroBias[2];
 8001d24: 4b99         	ldr	r3, [pc, #0x264]        @ 0x8001f8c <IMU_QuaternionEKF_Update+0x2b0>
 8001d26: f8d3 3168    	ldr.w	r3, [r3, #0x168]
 8001d2a: 4619         	mov	r1, r3
 8001d2c: 6878         	ldr	r0, [r7, #0x4]
 8001d2e: f7fe fa2f    	bl	0x8000190 <__subsf3>    @ imm = #-0x1ba2
 8001d32: 4603         	mov	r3, r0
 8001d34: 461a         	mov	r2, r3
 8001d36: 4b95         	ldr	r3, [pc, #0x254]        @ 0x8001f8c <IMU_QuaternionEKF_Update+0x2b0>
 8001d38: f8c3 2174    	str.w	r2, [r3, #0x174]
; 	halfgxdt = 0.5f * QEKF_INS.Gyro[0] * gyro_dt;
 8001d3c: 4b93         	ldr	r3, [pc, #0x24c]        @ 0x8001f8c <IMU_QuaternionEKF_Update+0x2b0>
 8001d3e: f8d3 316c    	ldr.w	r3, [r3, #0x16c]
 8001d42: f04f 517c    	mov.w	r1, #0x3f000000
 8001d46: 4618         	mov	r0, r3
 8001d48: f7fe fb2c    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x19a8
 8001d4c: 4603         	mov	r3, r0
 8001d4e: 6bf9         	ldr	r1, [r7, #0x3c]
 8001d50: 4618         	mov	r0, r3
 8001d52: f7fe fb27    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x19b2
 8001d56: 4603         	mov	r3, r0
 8001d58: 461a         	mov	r2, r3
 8001d5a: 4b8d         	ldr	r3, [pc, #0x234]        @ 0x8001f90 <IMU_QuaternionEKF_Update+0x2b4>
 8001d5c: 601a         	str	r2, [r3]
; 	halfgydt = 0.5f * QEKF_INS.Gyro[1] * gyro_dt;
 8001d5e: 4b8b         	ldr	r3, [pc, #0x22c]        @ 0x8001f8c <IMU_QuaternionEKF_Update+0x2b0>
 8001d60: f8d3 3170    	ldr.w	r3, [r3, #0x170]
 8001d64: f04f 517c    	mov.w	r1, #0x3f000000
 8001d68: 4618         	mov	r0, r3
 8001d6a: f7fe fb1b    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x19ca
 8001d6e: 4603         	mov	r3, r0
 8001d70: 6bf9         	ldr	r1, [r7, #0x3c]
 8001d72: 4618         	mov	r0, r3
 8001d74: f7fe fb16    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x19d4
 8001d78: 4603         	mov	r3, r0
 8001d7a: 461a         	mov	r2, r3
 8001d7c: 4b85         	ldr	r3, [pc, #0x214]        @ 0x8001f94 <IMU_QuaternionEKF_Update+0x2b8>
 8001d7e: 601a         	str	r2, [r3]
; 	halfgzdt = 0.5f * QEKF_INS.Gyro[2] * gyro_dt;
 8001d80: 4b82         	ldr	r3, [pc, #0x208]        @ 0x8001f8c <IMU_QuaternionEKF_Update+0x2b0>
 8001d82: f8d3 3174    	ldr.w	r3, [r3, #0x174]
 8001d86: f04f 517c    	mov.w	r1, #0x3f000000
 8001d8a: 4618         	mov	r0, r3
 8001d8c: f7fe fb0a    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x19ec
 8001d90: 4603         	mov	r3, r0
 8001d92: 6bf9         	ldr	r1, [r7, #0x3c]
 8001d94: 4618         	mov	r0, r3
 8001d96: f7fe fb05    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x19f6
 8001d9a: 4603         	mov	r3, r0
 8001d9c: 461a         	mov	r2, r3
 8001d9e: 4b7e         	ldr	r3, [pc, #0x1f8]        @ 0x8001f98 <IMU_QuaternionEKF_Update+0x2bc>
 8001da0: 601a         	str	r2, [r3]
; 	memcpy(QEKF_INS.IMU_QuaternionEKF.F_data, IMU_QuaternionEKF_F, sizeof(IMU_QuaternionEKF_F));
 8001da2: 4b7a         	ldr	r3, [pc, #0x1e8]        @ 0x8001f8c <IMU_QuaternionEKF_Update+0x2b0>
 8001da4: f8d3 3104    	ldr.w	r3, [r3, #0x104]
 8001da8: 2290         	movs	r2, #0x90
 8001daa: 497c         	ldr	r1, [pc, #0x1f0]        @ 0x8001f9c <IMU_QuaternionEKF_Update+0x2c0>
 8001dac: 4618         	mov	r0, r3
 8001dae: f01b fd0f    	bl	0x801d7d0 <memcpy>      @ imm = #0x1ba1e
; 	QEKF_INS.IMU_QuaternionEKF.F_data[1] = -halfgxdt;
 8001db2: 4b77         	ldr	r3, [pc, #0x1dc]        @ 0x8001f90 <IMU_QuaternionEKF_Update+0x2b4>
 8001db4: 681a         	ldr	r2, [r3]
 8001db6: 4b75         	ldr	r3, [pc, #0x1d4]        @ 0x8001f8c <IMU_QuaternionEKF_Update+0x2b0>
 8001db8: f8d3 3104    	ldr.w	r3, [r3, #0x104]
 8001dbc: 3304         	adds	r3, #0x4
 8001dbe: f082 4200    	eor	r2, r2, #0x80000000
 8001dc2: 601a         	str	r2, [r3]
; 	QEKF_INS.IMU_QuaternionEKF.F_data[2] = -halfgydt;
 8001dc4: 4b73         	ldr	r3, [pc, #0x1cc]        @ 0x8001f94 <IMU_QuaternionEKF_Update+0x2b8>
 8001dc6: 681a         	ldr	r2, [r3]
 8001dc8: 4b70         	ldr	r3, [pc, #0x1c0]        @ 0x8001f8c <IMU_QuaternionEKF_Update+0x2b0>
 8001dca: f8d3 3104    	ldr.w	r3, [r3, #0x104]
 8001dce: 3308         	adds	r3, #0x8
 8001dd0: f082 4200    	eor	r2, r2, #0x80000000
 8001dd4: 601a         	str	r2, [r3]
; 	QEKF_INS.IMU_QuaternionEKF.F_data[3] = -halfgzdt;
 8001dd6: 4b70         	ldr	r3, [pc, #0x1c0]        @ 0x8001f98 <IMU_QuaternionEKF_Update+0x2bc>
 8001dd8: 681a         	ldr	r2, [r3]
 8001dda: 4b6c         	ldr	r3, [pc, #0x1b0]        @ 0x8001f8c <IMU_QuaternionEKF_Update+0x2b0>
 8001ddc: f8d3 3104    	ldr.w	r3, [r3, #0x104]
 8001de0: 330c         	adds	r3, #0xc
 8001de2: f082 4200    	eor	r2, r2, #0x80000000
 8001de6: 601a         	str	r2, [r3]
; 	QEKF_INS.IMU_QuaternionEKF.F_data[6] = halfgxdt;
 8001de8: 4b68         	ldr	r3, [pc, #0x1a0]        @ 0x8001f8c <IMU_QuaternionEKF_Update+0x2b0>
 8001dea: f8d3 3104    	ldr.w	r3, [r3, #0x104]
 8001dee: 3318         	adds	r3, #0x18
 8001df0: 4a67         	ldr	r2, [pc, #0x19c]        @ 0x8001f90 <IMU_QuaternionEKF_Update+0x2b4>
 8001df2: 6812         	ldr	r2, [r2]
 8001df4: 601a         	str	r2, [r3]
; 	QEKF_INS.IMU_QuaternionEKF.F_data[8] = halfgzdt;
 8001df6: 4b65         	ldr	r3, [pc, #0x194]        @ 0x8001f8c <IMU_QuaternionEKF_Update+0x2b0>
 8001df8: f8d3 3104    	ldr.w	r3, [r3, #0x104]
 8001dfc: 3320         	adds	r3, #0x20
 8001dfe: 4a66         	ldr	r2, [pc, #0x198]        @ 0x8001f98 <IMU_QuaternionEKF_Update+0x2bc>
 8001e00: 6812         	ldr	r2, [r2]
 8001e02: 601a         	str	r2, [r3]
; 	QEKF_INS.IMU_QuaternionEKF.F_data[9] = -halfgydt;
 8001e04: 4b63         	ldr	r3, [pc, #0x18c]        @ 0x8001f94 <IMU_QuaternionEKF_Update+0x2b8>
 8001e06: 681a         	ldr	r2, [r3]
 8001e08: 4b60         	ldr	r3, [pc, #0x180]        @ 0x8001f8c <IMU_QuaternionEKF_Update+0x2b0>
 8001e0a: f8d3 3104    	ldr.w	r3, [r3, #0x104]
 8001e0e: 3324         	adds	r3, #0x24
 8001e10: f082 4200    	eor	r2, r2, #0x80000000
 8001e14: 601a         	str	r2, [r3]
; 	QEKF_INS.IMU_QuaternionEKF.F_data[12] = halfgydt;
 8001e16: 4b5d         	ldr	r3, [pc, #0x174]        @ 0x8001f8c <IMU_QuaternionEKF_Update+0x2b0>
 8001e18: f8d3 3104    	ldr.w	r3, [r3, #0x104]
 8001e1c: 3330         	adds	r3, #0x30
 8001e1e: 4a5d         	ldr	r2, [pc, #0x174]        @ 0x8001f94 <IMU_QuaternionEKF_Update+0x2b8>
 8001e20: 6812         	ldr	r2, [r2]
 8001e22: 601a         	str	r2, [r3]
; 	QEKF_INS.IMU_QuaternionEKF.F_data[13] = -halfgzdt;
 8001e24: 4b5c         	ldr	r3, [pc, #0x170]        @ 0x8001f98 <IMU_QuaternionEKF_Update+0x2bc>
 8001e26: 681a         	ldr	r2, [r3]
 8001e28: 4b58         	ldr	r3, [pc, #0x160]        @ 0x8001f8c <IMU_QuaternionEKF_Update+0x2b0>
 8001e2a: f8d3 3104    	ldr.w	r3, [r3, #0x104]
 8001e2e: 3334         	adds	r3, #0x34
 8001e30: f082 4200    	eor	r2, r2, #0x80000000
 8001e34: 601a         	str	r2, [r3]
; 	QEKF_INS.IMU_QuaternionEKF.F_data[15] = halfgxdt;
 8001e36: 4b55         	ldr	r3, [pc, #0x154]        @ 0x8001f8c <IMU_QuaternionEKF_Update+0x2b0>
 8001e38: f8d3 3104    	ldr.w	r3, [r3, #0x104]
 8001e3c: 333c         	adds	r3, #0x3c
 8001e3e: 4a54         	ldr	r2, [pc, #0x150]        @ 0x8001f90 <IMU_QuaternionEKF_Update+0x2b4>
 8001e40: 6812         	ldr	r2, [r2]
 8001e42: 601a         	str	r2, [r3]
; 	QEKF_INS.IMU_QuaternionEKF.F_data[18] = halfgzdt;
 8001e44: 4b51         	ldr	r3, [pc, #0x144]        @ 0x8001f8c <IMU_QuaternionEKF_Update+0x2b0>
 8001e46: f8d3 3104    	ldr.w	r3, [r3, #0x104]
 8001e4a: 3348         	adds	r3, #0x48
 8001e4c: 4a52         	ldr	r2, [pc, #0x148]        @ 0x8001f98 <IMU_QuaternionEKF_Update+0x2bc>
 8001e4e: 6812         	ldr	r2, [r2]
 8001e50: 601a         	str	r2, [r3]
; 	QEKF_INS.IMU_QuaternionEKF.F_data[19] = halfgydt;
 8001e52: 4b4e         	ldr	r3, [pc, #0x138]        @ 0x8001f8c <IMU_QuaternionEKF_Update+0x2b0>
 8001e54: f8d3 3104    	ldr.w	r3, [r3, #0x104]
 8001e58: 334c         	adds	r3, #0x4c
 8001e5a: 4a4e         	ldr	r2, [pc, #0x138]        @ 0x8001f94 <IMU_QuaternionEKF_Update+0x2b8>
 8001e5c: 6812         	ldr	r2, [r2]
 8001e5e: 601a         	str	r2, [r3]
; 	QEKF_INS.IMU_QuaternionEKF.F_data[20] = -halfgxdt;
 8001e60: 4b4b         	ldr	r3, [pc, #0x12c]        @ 0x8001f90 <IMU_QuaternionEKF_Update+0x2b4>
 8001e62: 681a         	ldr	r2, [r3]
 8001e64: 4b49         	ldr	r3, [pc, #0x124]        @ 0x8001f8c <IMU_QuaternionEKF_Update+0x2b0>
 8001e66: f8d3 3104    	ldr.w	r3, [r3, #0x104]
 8001e6a: 3350         	adds	r3, #0x50
 8001e6c: f082 4200    	eor	r2, r2, #0x80000000
 8001e70: 601a         	str	r2, [r3]
; 	if (QEKF_INS.UpdateCount == 0) // 如果是第一次进入,需要初始化低通滤波
 8001e72: 4b46         	ldr	r3, [pc, #0x118]        @ 0x8001f8c <IMU_QuaternionEKF_Update+0x2b0>
 8001e74: e9d3 2352    	ldrd	r2, r3, [r3, #328]
 8001e78: 4313         	orrs	r3, r2
 8001e7a: d10b         	bne	0x8001e94 <IMU_QuaternionEKF_Update+0x1b8> @ imm = #0x16
; 		QEKF_INS.Accel[0] = ax;
 8001e7c: 4a43         	ldr	r2, [pc, #0x10c]        @ 0x8001f8c <IMU_QuaternionEKF_Update+0x2b0>
 8001e7e: 683b         	ldr	r3, [r7]
 8001e80: f8c2 3178    	str.w	r3, [r2, #0x178]
; 		QEKF_INS.Accel[1] = ay;
 8001e84: 4a41         	ldr	r2, [pc, #0x104]        @ 0x8001f8c <IMU_QuaternionEKF_Update+0x2b0>
 8001e86: 6b3b         	ldr	r3, [r7, #0x30]
 8001e88: f8c2 317c    	str.w	r3, [r2, #0x17c]
; 		QEKF_INS.Accel[2] = az;
 8001e8c: 4a3f         	ldr	r2, [pc, #0xfc]         @ 0x8001f8c <IMU_QuaternionEKF_Update+0x2b0>
 8001e8e: 6b7b         	ldr	r3, [r7, #0x34]
 8001e90: f8c2 3180    	str.w	r3, [r2, #0x180]
; 		QEKF_INS.Accel[0] * QEKF_INS.accLPFcoef / (accel_dt + QEKF_INS.accLPFcoef) +
 8001e94: 4b3d         	ldr	r3, [pc, #0xf4]         @ 0x8001f8c <IMU_QuaternionEKF_Update+0x2b0>
 8001e96: f8d3 3178    	ldr.w	r3, [r3, #0x178]
 8001e9a: 4a3c         	ldr	r2, [pc, #0xf0]         @ 0x8001f8c <IMU_QuaternionEKF_Update+0x2b0>
 8001e9c: f8d2 2190    	ldr.w	r2, [r2, #0x190]
 8001ea0: 4611         	mov	r1, r2
 8001ea2: 4618         	mov	r0, r3
 8001ea4: f7fe fa7e    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x1b04
 8001ea8: 4603         	mov	r3, r0
 8001eaa: 461e         	mov	r6, r3
 8001eac: 4b37         	ldr	r3, [pc, #0xdc]         @ 0x8001f8c <IMU_QuaternionEKF_Update+0x2b0>
 8001eae: f8d3 3190    	ldr.w	r3, [r3, #0x190]
 8001eb2: 6bb9         	ldr	r1, [r7, #0x38]
 8001eb4: 4618         	mov	r0, r3
 8001eb6: f7fe f96d    	bl	0x8000194 <__aeabi_fadd> @ imm = #-0x1d26
 8001eba: 4603         	mov	r3, r0
 8001ebc: 4619         	mov	r1, r3
 8001ebe: 4630         	mov	r0, r6
 8001ec0: f7fe fb24    	bl	0x800050c <__divsf3>    @ imm = #-0x19b8
 8001ec4: 4603         	mov	r3, r0
 8001ec6: 461e         	mov	r6, r3
; 		ax * accel_dt / (accel_dt + QEKF_INS.accLPFcoef);
 8001ec8: 6bb9         	ldr	r1, [r7, #0x38]
 8001eca: 6838         	ldr	r0, [r7]
 8001ecc: f7fe fa6a    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x1b2c
 8001ed0: 4603         	mov	r3, r0
 8001ed2: 4698         	mov	r8, r3
 8001ed4: 4b2d         	ldr	r3, [pc, #0xb4]         @ 0x8001f8c <IMU_QuaternionEKF_Update+0x2b0>
 8001ed6: f8d3 3190    	ldr.w	r3, [r3, #0x190]
 8001eda: 6bb9         	ldr	r1, [r7, #0x38]
 8001edc: 4618         	mov	r0, r3
 8001ede: f7fe f959    	bl	0x8000194 <__aeabi_fadd> @ imm = #-0x1d4e
 8001ee2: 4603         	mov	r3, r0
 8001ee4: 4619         	mov	r1, r3
 8001ee6: 4640         	mov	r0, r8
 8001ee8: f7fe fb10    	bl	0x800050c <__divsf3>    @ imm = #-0x19e0
 8001eec: 4603         	mov	r3, r0
; 		QEKF_INS.Accel[0] * QEKF_INS.accLPFcoef / (accel_dt + QEKF_INS.accLPFcoef) +
 8001eee: 4619         	mov	r1, r3
 8001ef0: 4630         	mov	r0, r6
 8001ef2: f7fe f94f    	bl	0x8000194 <__aeabi_fadd> @ imm = #-0x1d62
 8001ef6: 4603         	mov	r3, r0
 8001ef8: 461a         	mov	r2, r3
; 	QEKF_INS.Accel[0] =
 8001efa: 4b24         	ldr	r3, [pc, #0x90]         @ 0x8001f8c <IMU_QuaternionEKF_Update+0x2b0>
 8001efc: f8c3 2178    	str.w	r2, [r3, #0x178]
; 		QEKF_INS.Accel[1] * QEKF_INS.accLPFcoef / (accel_dt + QEKF_INS.accLPFcoef) +
 8001f00: 4b22         	ldr	r3, [pc, #0x88]         @ 0x8001f8c <IMU_QuaternionEKF_Update+0x2b0>
 8001f02: f8d3 317c    	ldr.w	r3, [r3, #0x17c]
 8001f06: 4a21         	ldr	r2, [pc, #0x84]         @ 0x8001f8c <IMU_QuaternionEKF_Update+0x2b0>
 8001f08: f8d2 2190    	ldr.w	r2, [r2, #0x190]
 8001f0c: 4611         	mov	r1, r2
 8001f0e: 4618         	mov	r0, r3
 8001f10: f7fe fa48    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x1b70
 8001f14: 4603         	mov	r3, r0
 8001f16: 461e         	mov	r6, r3
 8001f18: 4b1c         	ldr	r3, [pc, #0x70]         @ 0x8001f8c <IMU_QuaternionEKF_Update+0x2b0>
 8001f1a: f8d3 3190    	ldr.w	r3, [r3, #0x190]
 8001f1e: 6bb9         	ldr	r1, [r7, #0x38]
 8001f20: 4618         	mov	r0, r3
 8001f22: f7fe f937    	bl	0x8000194 <__aeabi_fadd> @ imm = #-0x1d92
 8001f26: 4603         	mov	r3, r0
 8001f28: 4619         	mov	r1, r3
 8001f2a: 4630         	mov	r0, r6
 8001f2c: f7fe faee    	bl	0x800050c <__divsf3>    @ imm = #-0x1a24
 8001f30: 4603         	mov	r3, r0
 8001f32: 461e         	mov	r6, r3
; 		ay * accel_dt / (QEKF_INS.dt + QEKF_INS.accLPFcoef);
 8001f34: 6bb9         	ldr	r1, [r7, #0x38]
 8001f36: 6b38         	ldr	r0, [r7, #0x30]
 8001f38: f7fe fa34    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x1b98
 8001f3c: 4603         	mov	r3, r0
 8001f3e: 4698         	mov	r8, r3
 8001f40: 4b12         	ldr	r3, [pc, #0x48]         @ 0x8001f8c <IMU_QuaternionEKF_Update+0x2b0>
 8001f42: f8d3 31bc    	ldr.w	r3, [r3, #0x1bc]
 8001f46: 4a11         	ldr	r2, [pc, #0x44]         @ 0x8001f8c <IMU_QuaternionEKF_Update+0x2b0>
 8001f48: f8d2 2190    	ldr.w	r2, [r2, #0x190]
 8001f4c: 4611         	mov	r1, r2
 8001f4e: 4618         	mov	r0, r3
 8001f50: f7fe f920    	bl	0x8000194 <__aeabi_fadd> @ imm = #-0x1dc0
 8001f54: 4603         	mov	r3, r0
 8001f56: 4619         	mov	r1, r3
 8001f58: 4640         	mov	r0, r8
 8001f5a: f7fe fad7    	bl	0x800050c <__divsf3>    @ imm = #-0x1a52
 8001f5e: 4603         	mov	r3, r0
; 		QEKF_INS.Accel[1] * QEKF_INS.accLPFcoef / (accel_dt + QEKF_INS.accLPFcoef) +
 8001f60: 4619         	mov	r1, r3
 8001f62: 4630         	mov	r0, r6
 8001f64: f7fe f916    	bl	0x8000194 <__aeabi_fadd> @ imm = #-0x1dd4
 8001f68: 4603         	mov	r3, r0
 8001f6a: 461a         	mov	r2, r3
; 	QEKF_INS.Accel[1] =
 8001f6c: 4b07         	ldr	r3, [pc, #0x1c]         @ 0x8001f8c <IMU_QuaternionEKF_Update+0x2b0>
 8001f6e: f8c3 217c    	str.w	r2, [r3, #0x17c]
; 		QEKF_INS.Accel[2] * QEKF_INS.accLPFcoef / (accel_dt + QEKF_INS.accLPFcoef) +
 8001f72: 4b06         	ldr	r3, [pc, #0x18]         @ 0x8001f8c <IMU_QuaternionEKF_Update+0x2b0>
 8001f74: f8d3 3180    	ldr.w	r3, [r3, #0x180]
 8001f78: 4a04         	ldr	r2, [pc, #0x10]         @ 0x8001f8c <IMU_QuaternionEKF_Update+0x2b0>
 8001f7a: f8d2 2190    	ldr.w	r2, [r2, #0x190]
 8001f7e: 4611         	mov	r1, r2
 8001f80: 4618         	mov	r0, r3
 8001f82: f7fe fa0f    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x1be2
 8001f86: 4603         	mov	r3, r0
 8001f88: e00a         	b	0x8001fa0 <IMU_QuaternionEKF_Update+0x2c4> @ imm = #0x14
 8001f8a: bf00         	nop

08001f8c <$d>:
 8001f8c: f8 06 00 20  	.word	0x200006f8
 8001f90: 9c 1b 00 20  	.word	0x20001b9c
 8001f94: a0 1b 00 20  	.word	0x20001ba0
 8001f98: a4 1b 00 20  	.word	0x20001ba4
 8001f9c: 54 fe 01 08  	.word	0x0801fe54

08001fa0 <$t>:
 8001fa0: 461e         	mov	r6, r3
 8001fa2: 4b70         	ldr	r3, [pc, #0x1c0]        @ 0x8002164 <IMU_QuaternionEKF_Update+0x488>
 8001fa4: f8d3 3190    	ldr.w	r3, [r3, #0x190]
 8001fa8: 6bb9         	ldr	r1, [r7, #0x38]
 8001faa: 4618         	mov	r0, r3
 8001fac: f7fe f8f2    	bl	0x8000194 <__aeabi_fadd> @ imm = #-0x1e1c
 8001fb0: 4603         	mov	r3, r0
 8001fb2: 4619         	mov	r1, r3
 8001fb4: 4630         	mov	r0, r6
 8001fb6: f7fe faa9    	bl	0x800050c <__divsf3>    @ imm = #-0x1aae
 8001fba: 4603         	mov	r3, r0
 8001fbc: 461e         	mov	r6, r3
; 		az * accel_dt / (accel_dt + QEKF_INS.accLPFcoef);
 8001fbe: 6bb9         	ldr	r1, [r7, #0x38]
 8001fc0: 6b78         	ldr	r0, [r7, #0x34]
 8001fc2: f7fe f9ef    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x1c22
 8001fc6: 4603         	mov	r3, r0
 8001fc8: 4698         	mov	r8, r3
 8001fca: 4b66         	ldr	r3, [pc, #0x198]        @ 0x8002164 <IMU_QuaternionEKF_Update+0x488>
 8001fcc: f8d3 3190    	ldr.w	r3, [r3, #0x190]
 8001fd0: 6bb9         	ldr	r1, [r7, #0x38]
 8001fd2: 4618         	mov	r0, r3
 8001fd4: f7fe f8de    	bl	0x8000194 <__aeabi_fadd> @ imm = #-0x1e44
 8001fd8: 4603         	mov	r3, r0
 8001fda: 4619         	mov	r1, r3
 8001fdc: 4640         	mov	r0, r8
 8001fde: f7fe fa95    	bl	0x800050c <__divsf3>    @ imm = #-0x1ad6
 8001fe2: 4603         	mov	r3, r0
; 		QEKF_INS.Accel[2] * QEKF_INS.accLPFcoef / (accel_dt + QEKF_INS.accLPFcoef) +
 8001fe4: 4619         	mov	r1, r3
 8001fe6: 4630         	mov	r0, r6
 8001fe8: f7fe f8d4    	bl	0x8000194 <__aeabi_fadd> @ imm = #-0x1e58
 8001fec: 4603         	mov	r3, r0
 8001fee: 461a         	mov	r2, r3
; 	QEKF_INS.Accel[2] =
 8001ff0: 4b5c         	ldr	r3, [pc, #0x170]        @ 0x8002164 <IMU_QuaternionEKF_Update+0x488>
 8001ff2: f8c3 2180    	str.w	r2, [r3, #0x180]
; 	accelInvNorm = invSqrt(QEKF_INS.Accel[0] * QEKF_INS.Accel[0] +
 8001ff6: 4b5b         	ldr	r3, [pc, #0x16c]        @ 0x8002164 <IMU_QuaternionEKF_Update+0x488>
 8001ff8: f8d3 3178    	ldr.w	r3, [r3, #0x178]
 8001ffc: 4a59         	ldr	r2, [pc, #0x164]        @ 0x8002164 <IMU_QuaternionEKF_Update+0x488>
 8001ffe: f8d2 2178    	ldr.w	r2, [r2, #0x178]
 8002002: 4611         	mov	r1, r2
 8002004: 4618         	mov	r0, r3
 8002006: f7fe f9cd    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x1c66
 800200a: 4603         	mov	r3, r0
 800200c: 461e         	mov	r6, r3
; 			       QEKF_INS.Accel[1] * QEKF_INS.Accel[1] +
 800200e: 4b55         	ldr	r3, [pc, #0x154]        @ 0x8002164 <IMU_QuaternionEKF_Update+0x488>
 8002010: f8d3 317c    	ldr.w	r3, [r3, #0x17c]
 8002014: 4a53         	ldr	r2, [pc, #0x14c]        @ 0x8002164 <IMU_QuaternionEKF_Update+0x488>
 8002016: f8d2 217c    	ldr.w	r2, [r2, #0x17c]
 800201a: 4611         	mov	r1, r2
 800201c: 4618         	mov	r0, r3
 800201e: f7fe f9c1    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x1c7e
 8002022: 4603         	mov	r3, r0
; 	accelInvNorm = invSqrt(QEKF_INS.Accel[0] * QEKF_INS.Accel[0] +
 8002024: 4619         	mov	r1, r3
 8002026: 4630         	mov	r0, r6
 8002028: f7fe f8b4    	bl	0x8000194 <__aeabi_fadd> @ imm = #-0x1e98
 800202c: 4603         	mov	r3, r0
 800202e: 461e         	mov	r6, r3
; 			       QEKF_INS.Accel[2] * QEKF_INS.Accel[2]);
 8002030: 4b4c         	ldr	r3, [pc, #0x130]        @ 0x8002164 <IMU_QuaternionEKF_Update+0x488>
 8002032: f8d3 3180    	ldr.w	r3, [r3, #0x180]
 8002036: 4a4b         	ldr	r2, [pc, #0x12c]        @ 0x8002164 <IMU_QuaternionEKF_Update+0x488>
 8002038: f8d2 2180    	ldr.w	r2, [r2, #0x180]
 800203c: 4611         	mov	r1, r2
 800203e: 4618         	mov	r0, r3
 8002040: f7fe f9b0    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x1ca0
 8002044: 4603         	mov	r3, r0
; 	accelInvNorm = invSqrt(QEKF_INS.Accel[0] * QEKF_INS.Accel[0] +
 8002046: 4619         	mov	r1, r3
 8002048: 4630         	mov	r0, r6
 800204a: f7fe f8a3    	bl	0x8000194 <__aeabi_fadd> @ imm = #-0x1eba
 800204e: 4603         	mov	r3, r0
 8002050: 4618         	mov	r0, r3
 8002052: f001 f881    	bl	0x8003158 <invSqrt>     @ imm = #0x1102
 8002056: 4603         	mov	r3, r0
 8002058: 4a43         	ldr	r2, [pc, #0x10c]        @ 0x8002168 <IMU_QuaternionEKF_Update+0x48c>
 800205a: 6013         	str	r3, [r2]
; 	for (uint8_t i = 0; i < 3; ++i) {
 800205c: 2300         	movs	r3, #0x0
 800205e: 75fb         	strb	r3, [r7, #0x17]
 8002060: e012         	b	0x8002088 <IMU_QuaternionEKF_Update+0x3ac> @ imm = #0x24
; 			QEKF_INS.Accel[i] * accelInvNorm; // 用加速度向量更新量测值
 8002062: 7dfb         	ldrb	r3, [r7, #0x17]
 8002064: 4a3f         	ldr	r2, [pc, #0xfc]         @ 0x8002164 <IMU_QuaternionEKF_Update+0x488>
 8002066: 335e         	adds	r3, #0x5e
 8002068: f852 0023    	ldr.w	r0, [r2, r3, lsl #2]
 800206c: 4b3e         	ldr	r3, [pc, #0xf8]         @ 0x8002168 <IMU_QuaternionEKF_Update+0x48c>
 800206e: 6819         	ldr	r1, [r3]
; 		QEKF_INS.IMU_QuaternionEKF.MeasuredVector[i] =
 8002070: 4b3c         	ldr	r3, [pc, #0xf0]         @ 0x8002164 <IMU_QuaternionEKF_Update+0x488>
 8002072: 689a         	ldr	r2, [r3, #0x8]
 8002074: 7dfb         	ldrb	r3, [r7, #0x17]
 8002076: 009b         	lsls	r3, r3, #0x2
 8002078: 18d6         	adds	r6, r2, r3
; 			QEKF_INS.Accel[i] * accelInvNorm; // 用加速度向量更新量测值
 800207a: f7fe f993    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x1cda
 800207e: 4603         	mov	r3, r0
; 		QEKF_INS.IMU_QuaternionEKF.MeasuredVector[i] =
 8002080: 6033         	str	r3, [r6]
; 	for (uint8_t i = 0; i < 3; ++i) {
 8002082: 7dfb         	ldrb	r3, [r7, #0x17]
 8002084: 3301         	adds	r3, #0x1
 8002086: 75fb         	strb	r3, [r7, #0x17]
 8002088: 7dfb         	ldrb	r3, [r7, #0x17]
 800208a: 2b02         	cmp	r3, #0x2
 800208c: d9e9         	bls	0x8002062 <IMU_QuaternionEKF_Update+0x386> @ imm = #-0x2e
; 	QEKF_INS.gyro_norm = 1.0f / invSqrt(QEKF_INS.Gyro[0] * QEKF_INS.Gyro[0] +
 800208e: 4b35         	ldr	r3, [pc, #0xd4]         @ 0x8002164 <IMU_QuaternionEKF_Update+0x488>
 8002090: f8d3 316c    	ldr.w	r3, [r3, #0x16c]
 8002094: 4a33         	ldr	r2, [pc, #0xcc]         @ 0x8002164 <IMU_QuaternionEKF_Update+0x488>
 8002096: f8d2 216c    	ldr.w	r2, [r2, #0x16c]
 800209a: 4611         	mov	r1, r2
 800209c: 4618         	mov	r0, r3
 800209e: f7fe f981    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x1cfe
 80020a2: 4603         	mov	r3, r0
 80020a4: 461e         	mov	r6, r3
; 					    QEKF_INS.Gyro[1] * QEKF_INS.Gyro[1] +
 80020a6: 4b2f         	ldr	r3, [pc, #0xbc]         @ 0x8002164 <IMU_QuaternionEKF_Update+0x488>
 80020a8: f8d3 3170    	ldr.w	r3, [r3, #0x170]
 80020ac: 4a2d         	ldr	r2, [pc, #0xb4]         @ 0x8002164 <IMU_QuaternionEKF_Update+0x488>
 80020ae: f8d2 2170    	ldr.w	r2, [r2, #0x170]
 80020b2: 4611         	mov	r1, r2
 80020b4: 4618         	mov	r0, r3
 80020b6: f7fe f975    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x1d16
 80020ba: 4603         	mov	r3, r0
; 	QEKF_INS.gyro_norm = 1.0f / invSqrt(QEKF_INS.Gyro[0] * QEKF_INS.Gyro[0] +
 80020bc: 4619         	mov	r1, r3
 80020be: 4630         	mov	r0, r6
 80020c0: f7fe f868    	bl	0x8000194 <__aeabi_fadd> @ imm = #-0x1f30
 80020c4: 4603         	mov	r3, r0
 80020c6: 461e         	mov	r6, r3
; 					    QEKF_INS.Gyro[2] * QEKF_INS.Gyro[2]);
 80020c8: 4b26         	ldr	r3, [pc, #0x98]         @ 0x8002164 <IMU_QuaternionEKF_Update+0x488>
 80020ca: f8d3 3174    	ldr.w	r3, [r3, #0x174]
 80020ce: 4a25         	ldr	r2, [pc, #0x94]         @ 0x8002164 <IMU_QuaternionEKF_Update+0x488>
 80020d0: f8d2 2174    	ldr.w	r2, [r2, #0x174]
 80020d4: 4611         	mov	r1, r2
 80020d6: 4618         	mov	r0, r3
 80020d8: f7fe f964    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x1d38
 80020dc: 4603         	mov	r3, r0
; 	QEKF_INS.gyro_norm = 1.0f / invSqrt(QEKF_INS.Gyro[0] * QEKF_INS.Gyro[0] +
 80020de: 4619         	mov	r1, r3
 80020e0: 4630         	mov	r0, r6
 80020e2: f7fe f857    	bl	0x8000194 <__aeabi_fadd> @ imm = #-0x1f52
 80020e6: 4603         	mov	r3, r0
 80020e8: 4618         	mov	r0, r3
 80020ea: f001 f835    	bl	0x8003158 <invSqrt>     @ imm = #0x106a
 80020ee: 4603         	mov	r3, r0
 80020f0: 4619         	mov	r1, r3
 80020f2: f04f 507e    	mov.w	r0, #0x3f800000
 80020f6: f7fe fa09    	bl	0x800050c <__divsf3>    @ imm = #-0x1bee
 80020fa: 4603         	mov	r3, r0
 80020fc: 461a         	mov	r2, r3
 80020fe: 4b19         	ldr	r3, [pc, #0x64]         @ 0x8002164 <IMU_QuaternionEKF_Update+0x488>
 8002100: f8c3 2194    	str.w	r2, [r3, #0x194]
; 	QEKF_INS.accl_norm = 1.0f / accelInvNorm;
 8002104: 4b18         	ldr	r3, [pc, #0x60]         @ 0x8002168 <IMU_QuaternionEKF_Update+0x48c>
 8002106: 681b         	ldr	r3, [r3]
 8002108: 4619         	mov	r1, r3
 800210a: f04f 507e    	mov.w	r0, #0x3f800000
 800210e: f7fe f9fd    	bl	0x800050c <__divsf3>    @ imm = #-0x1c06
 8002112: 4603         	mov	r3, r0
 8002114: 461a         	mov	r2, r3
 8002116: 4b13         	ldr	r3, [pc, #0x4c]         @ 0x8002164 <IMU_QuaternionEKF_Update+0x488>
 8002118: f8c3 2198    	str.w	r2, [r3, #0x198]
; 	if (QEKF_INS.gyro_norm < 0.3f && QEKF_INS.accl_norm > 9.8f - 0.5f &&
 800211c: 4b11         	ldr	r3, [pc, #0x44]         @ 0x8002164 <IMU_QuaternionEKF_Update+0x488>
 800211e: f8d3 3194    	ldr.w	r3, [r3, #0x194]
 8002122: 4912         	ldr	r1, [pc, #0x48]         @ 0x800216c <IMU_QuaternionEKF_Update+0x490>
 8002124: 4618         	mov	r0, r3
 8002126: f7fe fadb    	bl	0x80006e0 <__aeabi_fcmplt> @ imm = #-0x1a4a
 800212a: 4603         	mov	r3, r0
 800212c: 2b00         	cmp	r3, #0x0
 800212e: d023         	beq	0x8002178 <IMU_QuaternionEKF_Update+0x49c> @ imm = #0x46
 8002130: 4b0c         	ldr	r3, [pc, #0x30]         @ 0x8002164 <IMU_QuaternionEKF_Update+0x488>
 8002132: f8d3 3198    	ldr.w	r3, [r3, #0x198]
 8002136: 490e         	ldr	r1, [pc, #0x38]         @ 0x8002170 <IMU_QuaternionEKF_Update+0x494>
 8002138: 4618         	mov	r0, r3
 800213a: f7fe faef    	bl	0x800071c <__aeabi_fcmpgt> @ imm = #-0x1a22
 800213e: 4603         	mov	r3, r0
 8002140: 2b00         	cmp	r3, #0x0
 8002142: d019         	beq	0x8002178 <IMU_QuaternionEKF_Update+0x49c> @ imm = #0x32
; 	    QEKF_INS.accl_norm < 9.8f + 0.5f) {
 8002144: 4b07         	ldr	r3, [pc, #0x1c]         @ 0x8002164 <IMU_QuaternionEKF_Update+0x488>
 8002146: f8d3 3198    	ldr.w	r3, [r3, #0x198]
; 	if (QEKF_INS.gyro_norm < 0.3f && QEKF_INS.accl_norm > 9.8f - 0.5f &&
 800214a: 490a         	ldr	r1, [pc, #0x28]         @ 0x8002174 <IMU_QuaternionEKF_Update+0x498>
 800214c: 4618         	mov	r0, r3
 800214e: f7fe fac7    	bl	0x80006e0 <__aeabi_fcmplt> @ imm = #-0x1a72
 8002152: 4603         	mov	r3, r0
 8002154: 2b00         	cmp	r3, #0x0
 8002156: d00f         	beq	0x8002178 <IMU_QuaternionEKF_Update+0x49c> @ imm = #0x1e
; 		QEKF_INS.StableFlag = 1;
 8002158: 4b02         	ldr	r3, [pc, #0x8]          @ 0x8002164 <IMU_QuaternionEKF_Update+0x488>
 800215a: 2201         	movs	r2, #0x1
 800215c: f883 2139    	strb.w	r2, [r3, #0x139]
 8002160: e00e         	b	0x8002180 <IMU_QuaternionEKF_Update+0x4a4> @ imm = #0x1c
 8002162: bf00         	nop

08002164 <$d>:
 8002164: f8 06 00 20  	.word	0x200006f8
 8002168: a8 1b 00 20  	.word	0x20001ba8
 800216c: 9a 99 99 3e  	.word	0x3e99999a
 8002170: cd cc 14 41  	.word	0x4114cccd
 8002174: cd cc 24 41  	.word	0x4124cccd

08002178 <$t>:
; 		QEKF_INS.StableFlag = 0;
 8002178: 4bab         	ldr	r3, [pc, #0x2ac]        @ 0x8002428 <IMU_QuaternionEKF_Update+0x74c>
 800217a: 2200         	movs	r2, #0x0
 800217c: f883 2139    	strb.w	r2, [r3, #0x139]
; 	QEKF_INS.IMU_QuaternionEKF.Q_data[0] = QEKF_INS.Q1 * QEKF_INS.dt;
 8002180: 4ba9         	ldr	r3, [pc, #0x2a4]        @ 0x8002428 <IMU_QuaternionEKF_Update+0x74c>
 8002182: f8d3 31b0    	ldr.w	r3, [r3, #0x1b0]
 8002186: 4aa8         	ldr	r2, [pc, #0x2a0]        @ 0x8002428 <IMU_QuaternionEKF_Update+0x74c>
 8002188: f8d2 21bc    	ldr.w	r2, [r2, #0x1bc]
 800218c: 49a6         	ldr	r1, [pc, #0x298]        @ 0x8002428 <IMU_QuaternionEKF_Update+0x74c>
 800218e: f8d1 6118    	ldr.w	r6, [r1, #0x118]
 8002192: 4611         	mov	r1, r2
 8002194: 4618         	mov	r0, r3
 8002196: f7fe f905    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x1df6
 800219a: 4603         	mov	r3, r0
 800219c: 6033         	str	r3, [r6]
; 	QEKF_INS.IMU_QuaternionEKF.Q_data[7] = QEKF_INS.Q1 * QEKF_INS.dt;
 800219e: 4ba2         	ldr	r3, [pc, #0x288]        @ 0x8002428 <IMU_QuaternionEKF_Update+0x74c>
 80021a0: f8d3 21b0    	ldr.w	r2, [r3, #0x1b0]
 80021a4: 4ba0         	ldr	r3, [pc, #0x280]        @ 0x8002428 <IMU_QuaternionEKF_Update+0x74c>
 80021a6: f8d3 11bc    	ldr.w	r1, [r3, #0x1bc]
 80021aa: 4b9f         	ldr	r3, [pc, #0x27c]        @ 0x8002428 <IMU_QuaternionEKF_Update+0x74c>
 80021ac: f8d3 3118    	ldr.w	r3, [r3, #0x118]
 80021b0: f103 061c    	add.w	r6, r3, #0x1c
 80021b4: 4610         	mov	r0, r2
 80021b6: f7fe f8f5    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x1e16
 80021ba: 4603         	mov	r3, r0
 80021bc: 6033         	str	r3, [r6]
; 	QEKF_INS.IMU_QuaternionEKF.Q_data[14] = QEKF_INS.Q1 * QEKF_INS.dt;
 80021be: 4b9a         	ldr	r3, [pc, #0x268]        @ 0x8002428 <IMU_QuaternionEKF_Update+0x74c>
 80021c0: f8d3 21b0    	ldr.w	r2, [r3, #0x1b0]
 80021c4: 4b98         	ldr	r3, [pc, #0x260]        @ 0x8002428 <IMU_QuaternionEKF_Update+0x74c>
 80021c6: f8d3 11bc    	ldr.w	r1, [r3, #0x1bc]
 80021ca: 4b97         	ldr	r3, [pc, #0x25c]        @ 0x8002428 <IMU_QuaternionEKF_Update+0x74c>
 80021cc: f8d3 3118    	ldr.w	r3, [r3, #0x118]
 80021d0: f103 0638    	add.w	r6, r3, #0x38
 80021d4: 4610         	mov	r0, r2
 80021d6: f7fe f8e5    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x1e36
 80021da: 4603         	mov	r3, r0
 80021dc: 6033         	str	r3, [r6]
; 	QEKF_INS.IMU_QuaternionEKF.Q_data[21] = QEKF_INS.Q1 * QEKF_INS.dt;
 80021de: 4b92         	ldr	r3, [pc, #0x248]        @ 0x8002428 <IMU_QuaternionEKF_Update+0x74c>
 80021e0: f8d3 21b0    	ldr.w	r2, [r3, #0x1b0]
 80021e4: 4b90         	ldr	r3, [pc, #0x240]        @ 0x8002428 <IMU_QuaternionEKF_Update+0x74c>
 80021e6: f8d3 11bc    	ldr.w	r1, [r3, #0x1bc]
 80021ea: 4b8f         	ldr	r3, [pc, #0x23c]        @ 0x8002428 <IMU_QuaternionEKF_Update+0x74c>
 80021ec: f8d3 3118    	ldr.w	r3, [r3, #0x118]
 80021f0: f103 0654    	add.w	r6, r3, #0x54
 80021f4: 4610         	mov	r0, r2
 80021f6: f7fe f8d5    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x1e56
 80021fa: 4603         	mov	r3, r0
 80021fc: 6033         	str	r3, [r6]
; 	QEKF_INS.IMU_QuaternionEKF.Q_data[28] = QEKF_INS.Q2 * QEKF_INS.dt;
 80021fe: 4b8a         	ldr	r3, [pc, #0x228]        @ 0x8002428 <IMU_QuaternionEKF_Update+0x74c>
 8002200: f8d3 21b4    	ldr.w	r2, [r3, #0x1b4]
 8002204: 4b88         	ldr	r3, [pc, #0x220]        @ 0x8002428 <IMU_QuaternionEKF_Update+0x74c>
 8002206: f8d3 11bc    	ldr.w	r1, [r3, #0x1bc]
 800220a: 4b87         	ldr	r3, [pc, #0x21c]        @ 0x8002428 <IMU_QuaternionEKF_Update+0x74c>
 800220c: f8d3 3118    	ldr.w	r3, [r3, #0x118]
 8002210: f103 0670    	add.w	r6, r3, #0x70
 8002214: 4610         	mov	r0, r2
 8002216: f7fe f8c5    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x1e76
 800221a: 4603         	mov	r3, r0
 800221c: 6033         	str	r3, [r6]
; 	QEKF_INS.IMU_QuaternionEKF.Q_data[35] = QEKF_INS.Q2 * QEKF_INS.dt;
 800221e: 4b82         	ldr	r3, [pc, #0x208]        @ 0x8002428 <IMU_QuaternionEKF_Update+0x74c>
 8002220: f8d3 21b4    	ldr.w	r2, [r3, #0x1b4]
 8002224: 4b80         	ldr	r3, [pc, #0x200]        @ 0x8002428 <IMU_QuaternionEKF_Update+0x74c>
 8002226: f8d3 11bc    	ldr.w	r1, [r3, #0x1bc]
 800222a: 4b7f         	ldr	r3, [pc, #0x1fc]        @ 0x8002428 <IMU_QuaternionEKF_Update+0x74c>
 800222c: f8d3 3118    	ldr.w	r3, [r3, #0x118]
 8002230: f103 068c    	add.w	r6, r3, #0x8c
 8002234: 4610         	mov	r0, r2
 8002236: f7fe f8b5    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x1e96
 800223a: 4603         	mov	r3, r0
 800223c: 6033         	str	r3, [r6]
; 	QEKF_INS.IMU_QuaternionEKF.R_data[0] = QEKF_INS.R;
 800223e: 4b7a         	ldr	r3, [pc, #0x1e8]        @ 0x8002428 <IMU_QuaternionEKF_Update+0x74c>
 8002240: f8d3 311c    	ldr.w	r3, [r3, #0x11c]
 8002244: 4a78         	ldr	r2, [pc, #0x1e0]        @ 0x8002428 <IMU_QuaternionEKF_Update+0x74c>
 8002246: f8d2 21b8    	ldr.w	r2, [r2, #0x1b8]
 800224a: 601a         	str	r2, [r3]
; 	QEKF_INS.IMU_QuaternionEKF.R_data[4] = QEKF_INS.R;
 800224c: 4b76         	ldr	r3, [pc, #0x1d8]        @ 0x8002428 <IMU_QuaternionEKF_Update+0x74c>
 800224e: f8d3 311c    	ldr.w	r3, [r3, #0x11c]
 8002252: 3310         	adds	r3, #0x10
 8002254: 4a74         	ldr	r2, [pc, #0x1d0]        @ 0x8002428 <IMU_QuaternionEKF_Update+0x74c>
 8002256: f8d2 21b8    	ldr.w	r2, [r2, #0x1b8]
 800225a: 601a         	str	r2, [r3]
; 	QEKF_INS.IMU_QuaternionEKF.R_data[8] = QEKF_INS.R;
 800225c: 4b72         	ldr	r3, [pc, #0x1c8]        @ 0x8002428 <IMU_QuaternionEKF_Update+0x74c>
 800225e: f8d3 311c    	ldr.w	r3, [r3, #0x11c]
 8002262: 3320         	adds	r3, #0x20
 8002264: 4a70         	ldr	r2, [pc, #0x1c0]        @ 0x8002428 <IMU_QuaternionEKF_Update+0x74c>
 8002266: f8d2 21b8    	ldr.w	r2, [r2, #0x1b8]
 800226a: 601a         	str	r2, [r3]
; 	Kalman_Filter_Update(&QEKF_INS.IMU_QuaternionEKF);
 800226c: 486f         	ldr	r0, [pc, #0x1bc]        @ 0x800242c <IMU_QuaternionEKF_Update+0x750>
 800226e: f7ff fac3    	bl	0x80017f8 <Kalman_Filter_Update> @ imm = #-0xa7a
; 	QEKF_INS.q[0] = QEKF_INS.IMU_QuaternionEKF.FilteredValue[0];
 8002272: 4b6d         	ldr	r3, [pc, #0x1b4]        @ 0x8002428 <IMU_QuaternionEKF_Update+0x74c>
 8002274: 685b         	ldr	r3, [r3, #0x4]
 8002276: 681b         	ldr	r3, [r3]
 8002278: 4a6b         	ldr	r2, [pc, #0x1ac]        @ 0x8002428 <IMU_QuaternionEKF_Update+0x74c>
 800227a: f8c2 3150    	str.w	r3, [r2, #0x150]
; 	QEKF_INS.q[1] = QEKF_INS.IMU_QuaternionEKF.FilteredValue[1];
 800227e: 4b6a         	ldr	r3, [pc, #0x1a8]        @ 0x8002428 <IMU_QuaternionEKF_Update+0x74c>
 8002280: 685b         	ldr	r3, [r3, #0x4]
 8002282: 685b         	ldr	r3, [r3, #0x4]
 8002284: 4a68         	ldr	r2, [pc, #0x1a0]        @ 0x8002428 <IMU_QuaternionEKF_Update+0x74c>
 8002286: f8c2 3154    	str.w	r3, [r2, #0x154]
; 	QEKF_INS.q[2] = QEKF_INS.IMU_QuaternionEKF.FilteredValue[2];
 800228a: 4b67         	ldr	r3, [pc, #0x19c]        @ 0x8002428 <IMU_QuaternionEKF_Update+0x74c>
 800228c: 685b         	ldr	r3, [r3, #0x4]
 800228e: 689b         	ldr	r3, [r3, #0x8]
 8002290: 4a65         	ldr	r2, [pc, #0x194]        @ 0x8002428 <IMU_QuaternionEKF_Update+0x74c>
 8002292: f8c2 3158    	str.w	r3, [r2, #0x158]
; 	QEKF_INS.q[3] = QEKF_INS.IMU_QuaternionEKF.FilteredValue[3];
 8002296: 4b64         	ldr	r3, [pc, #0x190]        @ 0x8002428 <IMU_QuaternionEKF_Update+0x74c>
 8002298: 685b         	ldr	r3, [r3, #0x4]
 800229a: 68db         	ldr	r3, [r3, #0xc]
 800229c: 4a62         	ldr	r2, [pc, #0x188]        @ 0x8002428 <IMU_QuaternionEKF_Update+0x74c>
 800229e: f8c2 315c    	str.w	r3, [r2, #0x15c]
; 	QEKF_INS.GyroBias[0] = QEKF_INS.IMU_QuaternionEKF.FilteredValue[4];
 80022a2: 4b61         	ldr	r3, [pc, #0x184]        @ 0x8002428 <IMU_QuaternionEKF_Update+0x74c>
 80022a4: 685b         	ldr	r3, [r3, #0x4]
 80022a6: 691b         	ldr	r3, [r3, #0x10]
 80022a8: 4a5f         	ldr	r2, [pc, #0x17c]        @ 0x8002428 <IMU_QuaternionEKF_Update+0x74c>
 80022aa: f8c2 3160    	str.w	r3, [r2, #0x160]
; 	QEKF_INS.GyroBias[1] = QEKF_INS.IMU_QuaternionEKF.FilteredValue[5];
 80022ae: 4b5e         	ldr	r3, [pc, #0x178]        @ 0x8002428 <IMU_QuaternionEKF_Update+0x74c>
 80022b0: 685b         	ldr	r3, [r3, #0x4]
 80022b2: 695b         	ldr	r3, [r3, #0x14]
 80022b4: 4a5c         	ldr	r2, [pc, #0x170]        @ 0x8002428 <IMU_QuaternionEKF_Update+0x74c>
 80022b6: f8c2 3164    	str.w	r3, [r2, #0x164]
; 	QEKF_INS.GyroBias[2] = 0; // 大部分时候z轴通天,无法观测yaw的漂移
 80022ba: 4b5b         	ldr	r3, [pc, #0x16c]        @ 0x8002428 <IMU_QuaternionEKF_Update+0x74c>
 80022bc: f04f 0200    	mov.w	r2, #0x0
 80022c0: f8c3 2168    	str.w	r2, [r3, #0x168]
; 		atan2f(2.0f * (QEKF_INS.q[0] * QEKF_INS.q[3] + QEKF_INS.q[1] * QEKF_INS.q[2]),
 80022c4: 4b58         	ldr	r3, [pc, #0x160]        @ 0x8002428 <IMU_QuaternionEKF_Update+0x74c>
 80022c6: f8d3 3150    	ldr.w	r3, [r3, #0x150]
 80022ca: 4a57         	ldr	r2, [pc, #0x15c]        @ 0x8002428 <IMU_QuaternionEKF_Update+0x74c>
 80022cc: f8d2 215c    	ldr.w	r2, [r2, #0x15c]
 80022d0: 4611         	mov	r1, r2
 80022d2: 4618         	mov	r0, r3
 80022d4: f7fe f866    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x1f34
 80022d8: 4603         	mov	r3, r0
 80022da: 461e         	mov	r6, r3
 80022dc: 4b52         	ldr	r3, [pc, #0x148]        @ 0x8002428 <IMU_QuaternionEKF_Update+0x74c>
 80022de: f8d3 3154    	ldr.w	r3, [r3, #0x154]
 80022e2: 4a51         	ldr	r2, [pc, #0x144]        @ 0x8002428 <IMU_QuaternionEKF_Update+0x74c>
 80022e4: f8d2 2158    	ldr.w	r2, [r2, #0x158]
 80022e8: 4611         	mov	r1, r2
 80022ea: 4618         	mov	r0, r3
 80022ec: f7fe f85a    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x1f4c
 80022f0: 4603         	mov	r3, r0
 80022f2: 4619         	mov	r1, r3
 80022f4: 4630         	mov	r0, r6
 80022f6: f7fd ff4d    	bl	0x8000194 <__aeabi_fadd> @ imm = #-0x2166
 80022fa: 4603         	mov	r3, r0
 80022fc: 4619         	mov	r1, r3
 80022fe: 4618         	mov	r0, r3
 8002300: f7fd ff48    	bl	0x8000194 <__aeabi_fadd> @ imm = #-0x2170
 8002304: 4603         	mov	r3, r0
 8002306: 461e         	mov	r6, r3
; 		       2.0f * (QEKF_INS.q[0] * QEKF_INS.q[0] + QEKF_INS.q[1] * QEKF_INS.q[1]) -
 8002308: 4b47         	ldr	r3, [pc, #0x11c]        @ 0x8002428 <IMU_QuaternionEKF_Update+0x74c>
 800230a: f8d3 3150    	ldr.w	r3, [r3, #0x150]
 800230e: 4a46         	ldr	r2, [pc, #0x118]        @ 0x8002428 <IMU_QuaternionEKF_Update+0x74c>
 8002310: f8d2 2150    	ldr.w	r2, [r2, #0x150]
 8002314: 4611         	mov	r1, r2
 8002316: 4618         	mov	r0, r3
 8002318: f7fe f844    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x1f78
 800231c: 4603         	mov	r3, r0
 800231e: 4698         	mov	r8, r3
 8002320: 4b41         	ldr	r3, [pc, #0x104]        @ 0x8002428 <IMU_QuaternionEKF_Update+0x74c>
 8002322: f8d3 3154    	ldr.w	r3, [r3, #0x154]
 8002326: 4a40         	ldr	r2, [pc, #0x100]        @ 0x8002428 <IMU_QuaternionEKF_Update+0x74c>
 8002328: f8d2 2154    	ldr.w	r2, [r2, #0x154]
 800232c: 4611         	mov	r1, r2
 800232e: 4618         	mov	r0, r3
 8002330: f7fe f838    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x1f90
 8002334: 4603         	mov	r3, r0
 8002336: 4619         	mov	r1, r3
 8002338: 4640         	mov	r0, r8
 800233a: f7fd ff2b    	bl	0x8000194 <__aeabi_fadd> @ imm = #-0x21aa
 800233e: 4603         	mov	r3, r0
 8002340: 4619         	mov	r1, r3
 8002342: 4618         	mov	r0, r3
 8002344: f7fd ff26    	bl	0x8000194 <__aeabi_fadd> @ imm = #-0x21b4
 8002348: 4603         	mov	r3, r0
; 		atan2f(2.0f * (QEKF_INS.q[0] * QEKF_INS.q[3] + QEKF_INS.q[1] * QEKF_INS.q[2]),
 800234a: f04f 517e    	mov.w	r1, #0x3f800000
 800234e: 4618         	mov	r0, r3
 8002350: f7fd ff1e    	bl	0x8000190 <__subsf3>    @ imm = #-0x21c4
 8002354: 4603         	mov	r3, r0
 8002356: 4619         	mov	r1, r3
 8002358: 4630         	mov	r0, r6
 800235a: f010 fb21    	bl	0x80129a0 <atan2f>      @ imm = #0x10642
 800235e: 4603         	mov	r3, r0
; 			       1.0f) *
 8002360: 4933         	ldr	r1, [pc, #0xcc]         @ 0x8002430 <IMU_QuaternionEKF_Update+0x754>
 8002362: 4618         	mov	r0, r3
 8002364: f7fe f81e    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x1fc4
 8002368: 4603         	mov	r3, r0
 800236a: 461a         	mov	r2, r3
; 	QEKF_INS.Yaw =
 800236c: 4b2e         	ldr	r3, [pc, #0xb8]         @ 0x8002428 <IMU_QuaternionEKF_Update+0x74c>
 800236e: f8c3 21a8    	str.w	r2, [r3, #0x1a8]
; 		atan2f(2.0f * (QEKF_INS.q[0] * QEKF_INS.q[1] + QEKF_INS.q[2] * QEKF_INS.q[3]),
 8002372: 4b2d         	ldr	r3, [pc, #0xb4]         @ 0x8002428 <IMU_QuaternionEKF_Update+0x74c>
 8002374: f8d3 3150    	ldr.w	r3, [r3, #0x150]
 8002378: 4a2b         	ldr	r2, [pc, #0xac]         @ 0x8002428 <IMU_QuaternionEKF_Update+0x74c>
 800237a: f8d2 2154    	ldr.w	r2, [r2, #0x154]
 800237e: 4611         	mov	r1, r2
 8002380: 4618         	mov	r0, r3
 8002382: f7fe f80f    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x1fe2
 8002386: 4603         	mov	r3, r0
 8002388: 461e         	mov	r6, r3
 800238a: 4b27         	ldr	r3, [pc, #0x9c]         @ 0x8002428 <IMU_QuaternionEKF_Update+0x74c>
 800238c: f8d3 3158    	ldr.w	r3, [r3, #0x158]
 8002390: 4a25         	ldr	r2, [pc, #0x94]         @ 0x8002428 <IMU_QuaternionEKF_Update+0x74c>
 8002392: f8d2 215c    	ldr.w	r2, [r2, #0x15c]
 8002396: 4611         	mov	r1, r2
 8002398: 4618         	mov	r0, r3
 800239a: f7fe f803    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x1ffa
 800239e: 4603         	mov	r3, r0
 80023a0: 4619         	mov	r1, r3
 80023a2: 4630         	mov	r0, r6
 80023a4: f7fd fef6    	bl	0x8000194 <__aeabi_fadd> @ imm = #-0x2214
 80023a8: 4603         	mov	r3, r0
 80023aa: 4619         	mov	r1, r3
 80023ac: 4618         	mov	r0, r3
 80023ae: f7fd fef1    	bl	0x8000194 <__aeabi_fadd> @ imm = #-0x221e
 80023b2: 4603         	mov	r3, r0
 80023b4: 461e         	mov	r6, r3
; 		       2.0f * (QEKF_INS.q[0] * QEKF_INS.q[0] + QEKF_INS.q[3] * QEKF_INS.q[3]) -
 80023b6: 4b1c         	ldr	r3, [pc, #0x70]         @ 0x8002428 <IMU_QuaternionEKF_Update+0x74c>
 80023b8: f8d3 3150    	ldr.w	r3, [r3, #0x150]
 80023bc: 4a1a         	ldr	r2, [pc, #0x68]         @ 0x8002428 <IMU_QuaternionEKF_Update+0x74c>
 80023be: f8d2 2150    	ldr.w	r2, [r2, #0x150]
 80023c2: 4611         	mov	r1, r2
 80023c4: 4618         	mov	r0, r3
 80023c6: f7fd ffed    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x2026
 80023ca: 4603         	mov	r3, r0
 80023cc: 4698         	mov	r8, r3
 80023ce: 4b16         	ldr	r3, [pc, #0x58]         @ 0x8002428 <IMU_QuaternionEKF_Update+0x74c>
 80023d0: f8d3 315c    	ldr.w	r3, [r3, #0x15c]
 80023d4: 4a14         	ldr	r2, [pc, #0x50]         @ 0x8002428 <IMU_QuaternionEKF_Update+0x74c>
 80023d6: f8d2 215c    	ldr.w	r2, [r2, #0x15c]
 80023da: 4611         	mov	r1, r2
 80023dc: 4618         	mov	r0, r3
 80023de: f7fd ffe1    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x203e
 80023e2: 4603         	mov	r3, r0
 80023e4: 4619         	mov	r1, r3
 80023e6: 4640         	mov	r0, r8
 80023e8: f7fd fed4    	bl	0x8000194 <__aeabi_fadd> @ imm = #-0x2258
 80023ec: 4603         	mov	r3, r0
 80023ee: 4619         	mov	r1, r3
 80023f0: 4618         	mov	r0, r3
 80023f2: f7fd fecf    	bl	0x8000194 <__aeabi_fadd> @ imm = #-0x2262
 80023f6: 4603         	mov	r3, r0
; 		atan2f(2.0f * (QEKF_INS.q[0] * QEKF_INS.q[1] + QEKF_INS.q[2] * QEKF_INS.q[3]),
 80023f8: f04f 517e    	mov.w	r1, #0x3f800000
 80023fc: 4618         	mov	r0, r3
 80023fe: f7fd fec7    	bl	0x8000190 <__subsf3>    @ imm = #-0x2272
 8002402: 4603         	mov	r3, r0
 8002404: 4619         	mov	r1, r3
 8002406: 4630         	mov	r0, r6
 8002408: f010 faca    	bl	0x80129a0 <atan2f>      @ imm = #0x10594
 800240c: 4603         	mov	r3, r0
; 			       1.0f) *
 800240e: 4908         	ldr	r1, [pc, #0x20]         @ 0x8002430 <IMU_QuaternionEKF_Update+0x754>
 8002410: 4618         	mov	r0, r3
 8002412: f7fd ffc7    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x2072
 8002416: 4603         	mov	r3, r0
 8002418: 461a         	mov	r2, r3
; 	QEKF_INS.Pitch =
 800241a: 4b03         	ldr	r3, [pc, #0xc]          @ 0x8002428 <IMU_QuaternionEKF_Update+0x74c>
 800241c: f8c3 21a4    	str.w	r2, [r3, #0x1a4]
; 		asinf(-2.0f * (QEKF_INS.q[1] * QEKF_INS.q[3] - QEKF_INS.q[0] * QEKF_INS.q[2])) *
 8002420: 4b01         	ldr	r3, [pc, #0x4]          @ 0x8002428 <IMU_QuaternionEKF_Update+0x74c>
 8002422: f8d3 3154    	ldr.w	r3, [r3, #0x154]
 8002426: e005         	b	0x8002434 <IMU_QuaternionEKF_Update+0x758> @ imm = #0xa

08002428 <$d>:
 8002428: f8 06 00 20  	.word	0x200006f8
 800242c: fc 06 00 20  	.word	0x200006fc
 8002430: e1 2e 65 42  	.word	0x42652ee1

08002434 <$t>:
 8002434: 4a48         	ldr	r2, [pc, #0x120]        @ 0x8002558 <IMU_QuaternionEKF_Update+0x87c>
 8002436: f8d2 215c    	ldr.w	r2, [r2, #0x15c]
 800243a: 4611         	mov	r1, r2
 800243c: 4618         	mov	r0, r3
 800243e: f7fd ffb1    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x209e
 8002442: 4603         	mov	r3, r0
 8002444: 461e         	mov	r6, r3
 8002446: 4b44         	ldr	r3, [pc, #0x110]        @ 0x8002558 <IMU_QuaternionEKF_Update+0x87c>
 8002448: f8d3 3150    	ldr.w	r3, [r3, #0x150]
 800244c: 4a42         	ldr	r2, [pc, #0x108]        @ 0x8002558 <IMU_QuaternionEKF_Update+0x87c>
 800244e: f8d2 2158    	ldr.w	r2, [r2, #0x158]
 8002452: 4611         	mov	r1, r2
 8002454: 4618         	mov	r0, r3
 8002456: f7fd ffa5    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x20b6
 800245a: 4603         	mov	r3, r0
 800245c: 4619         	mov	r1, r3
 800245e: 4630         	mov	r0, r6
 8002460: f7fd fe96    	bl	0x8000190 <__subsf3>    @ imm = #-0x22d4
 8002464: 4603         	mov	r3, r0
 8002466: f04f 4140    	mov.w	r1, #0xc0000000
 800246a: 4618         	mov	r0, r3
 800246c: f7fd ff9a    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x20cc
 8002470: 4603         	mov	r3, r0
 8002472: 4618         	mov	r0, r3
 8002474: f010 f956    	bl	0x8012724 <asinf>       @ imm = #0x102ac
 8002478: 4603         	mov	r3, r0
 800247a: 4938         	ldr	r1, [pc, #0xe0]         @ 0x800255c <IMU_QuaternionEKF_Update+0x880>
 800247c: 4618         	mov	r0, r3
 800247e: f7fd ff91    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x20de
 8002482: 4603         	mov	r3, r0
 8002484: 461a         	mov	r2, r3
; 	QEKF_INS.Roll =
 8002486: 4b34         	ldr	r3, [pc, #0xd0]         @ 0x8002558 <IMU_QuaternionEKF_Update+0x87c>
 8002488: f8c3 21a0    	str.w	r2, [r3, #0x1a0]
; 	if (QEKF_INS.Yaw - QEKF_INS.YawAngleLast > 180.0f) {
 800248c: 4b32         	ldr	r3, [pc, #0xc8]         @ 0x8002558 <IMU_QuaternionEKF_Update+0x87c>
 800248e: f8d3 31a8    	ldr.w	r3, [r3, #0x1a8]
 8002492: 4a31         	ldr	r2, [pc, #0xc4]         @ 0x8002558 <IMU_QuaternionEKF_Update+0x87c>
 8002494: f8d2 21d8    	ldr.w	r2, [r2, #0x1d8]
 8002498: 4611         	mov	r1, r2
 800249a: 4618         	mov	r0, r3
 800249c: f7fd fe78    	bl	0x8000190 <__subsf3>    @ imm = #-0x2310
 80024a0: 4603         	mov	r3, r0
 80024a2: 492f         	ldr	r1, [pc, #0xbc]         @ 0x8002560 <IMU_QuaternionEKF_Update+0x884>
 80024a4: 4618         	mov	r0, r3
 80024a6: f7fe f939    	bl	0x800071c <__aeabi_fcmpgt> @ imm = #-0x1d8e
 80024aa: 4603         	mov	r3, r0
 80024ac: 2b00         	cmp	r3, #0x0
 80024ae: d00a         	beq	0x80024c6 <IMU_QuaternionEKF_Update+0x7ea> @ imm = #0x14
; 		QEKF_INS.YawRoundCount--;
 80024b0: 4b29         	ldr	r3, [pc, #0xa4]         @ 0x8002558 <IMU_QuaternionEKF_Update+0x87c>
 80024b2: f9b3 31d4    	ldrsh.w	r3, [r3, #0x1d4]
 80024b6: b29b         	uxth	r3, r3
 80024b8: 3b01         	subs	r3, #0x1
 80024ba: b29b         	uxth	r3, r3
 80024bc: b21a         	sxth	r2, r3
 80024be: 4b26         	ldr	r3, [pc, #0x98]         @ 0x8002558 <IMU_QuaternionEKF_Update+0x87c>
 80024c0: f8a3 21d4    	strh.w	r2, [r3, #0x1d4]
 80024c4: e01b         	b	0x80024fe <IMU_QuaternionEKF_Update+0x822> @ imm = #0x36
; 	} else if (QEKF_INS.Yaw - QEKF_INS.YawAngleLast < -180.0f) {
 80024c6: 4b24         	ldr	r3, [pc, #0x90]         @ 0x8002558 <IMU_QuaternionEKF_Update+0x87c>
 80024c8: f8d3 31a8    	ldr.w	r3, [r3, #0x1a8]
 80024cc: 4a22         	ldr	r2, [pc, #0x88]         @ 0x8002558 <IMU_QuaternionEKF_Update+0x87c>
 80024ce: f8d2 21d8    	ldr.w	r2, [r2, #0x1d8]
 80024d2: 4611         	mov	r1, r2
 80024d4: 4618         	mov	r0, r3
 80024d6: f7fd fe5b    	bl	0x8000190 <__subsf3>    @ imm = #-0x234a
 80024da: 4603         	mov	r3, r0
 80024dc: 4921         	ldr	r1, [pc, #0x84]         @ 0x8002564 <IMU_QuaternionEKF_Update+0x888>
 80024de: 4618         	mov	r0, r3
 80024e0: f7fe f8fe    	bl	0x80006e0 <__aeabi_fcmplt> @ imm = #-0x1e04
 80024e4: 4603         	mov	r3, r0
 80024e6: 2b00         	cmp	r3, #0x0
 80024e8: d009         	beq	0x80024fe <IMU_QuaternionEKF_Update+0x822> @ imm = #0x12
; 		QEKF_INS.YawRoundCount++;
 80024ea: 4b1b         	ldr	r3, [pc, #0x6c]         @ 0x8002558 <IMU_QuaternionEKF_Update+0x87c>
 80024ec: f9b3 31d4    	ldrsh.w	r3, [r3, #0x1d4]
 80024f0: b29b         	uxth	r3, r3
 80024f2: 3301         	adds	r3, #0x1
 80024f4: b29b         	uxth	r3, r3
 80024f6: b21a         	sxth	r2, r3
 80024f8: 4b17         	ldr	r3, [pc, #0x5c]         @ 0x8002558 <IMU_QuaternionEKF_Update+0x87c>
 80024fa: f8a3 21d4    	strh.w	r2, [r3, #0x1d4]
; 	QEKF_INS.YawTotalAngle = 360.0f * QEKF_INS.YawRoundCount + QEKF_INS.Yaw;
 80024fe: 4b16         	ldr	r3, [pc, #0x58]         @ 0x8002558 <IMU_QuaternionEKF_Update+0x87c>
 8002500: f9b3 31d4    	ldrsh.w	r3, [r3, #0x1d4]
 8002504: 4618         	mov	r0, r3
 8002506: f7fd fef9    	bl	0x80002fc <__floatsisf> @ imm = #-0x220e
 800250a: 4603         	mov	r3, r0
 800250c: 4916         	ldr	r1, [pc, #0x58]         @ 0x8002568 <IMU_QuaternionEKF_Update+0x88c>
 800250e: 4618         	mov	r0, r3
 8002510: f7fd ff48    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x2170
 8002514: 4603         	mov	r3, r0
 8002516: 461a         	mov	r2, r3
 8002518: 4b0f         	ldr	r3, [pc, #0x3c]         @ 0x8002558 <IMU_QuaternionEKF_Update+0x87c>
 800251a: f8d3 31a8    	ldr.w	r3, [r3, #0x1a8]
 800251e: 4619         	mov	r1, r3
 8002520: 4610         	mov	r0, r2
 8002522: f7fd fe37    	bl	0x8000194 <__aeabi_fadd> @ imm = #-0x2392
 8002526: 4603         	mov	r3, r0
 8002528: 461a         	mov	r2, r3
 800252a: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x8002558 <IMU_QuaternionEKF_Update+0x87c>
 800252c: f8c3 21ac    	str.w	r2, [r3, #0x1ac]
; 	QEKF_INS.YawAngleLast = QEKF_INS.Yaw;
 8002530: 4b09         	ldr	r3, [pc, #0x24]         @ 0x8002558 <IMU_QuaternionEKF_Update+0x87c>
 8002532: f8d3 31a8    	ldr.w	r3, [r3, #0x1a8]
 8002536: 4a08         	ldr	r2, [pc, #0x20]         @ 0x8002558 <IMU_QuaternionEKF_Update+0x87c>
 8002538: f8c2 31d8    	str.w	r3, [r2, #0x1d8]
; 	QEKF_INS.UpdateCount++; // 初始化低通滤波用,计数测试用
 800253c: 4b06         	ldr	r3, [pc, #0x18]         @ 0x8002558 <IMU_QuaternionEKF_Update+0x87c>
 800253e: e9d3 2352    	ldrd	r2, r3, [r3, #328]
 8002542: 1c54         	adds	r4, r2, #0x1
 8002544: f143 0500    	adc	r5, r3, #0x0
 8002548: 4b03         	ldr	r3, [pc, #0xc]          @ 0x8002558 <IMU_QuaternionEKF_Update+0x87c>
 800254a: e9c3 4552    	strd	r4, r5, [r3, #328]
; }
 800254e: bf00         	nop
 8002550: 3718         	adds	r7, #0x18
 8002552: 46bd         	mov	sp, r7
 8002554: e8bd 81f0    	pop.w	{r4, r5, r6, r7, r8, pc}

08002558 <$d>:
 8002558: f8 06 00 20  	.word	0x200006f8
 800255c: e1 2e 65 42  	.word	0x42652ee1
 8002560: 00 00 34 43  	.word	0x43340000
 8002564: 00 00 34 c3  	.word	0xc3340000
 8002568: 00 00 b4 43  	.word	0x43b40000

0800256c <IMU_QuaternionEKF_F_Linearization_P_Fading>:
; {
 800256c: b590         	push	{r4, r7, lr}
 800256e: b085         	sub	sp, #0x14
 8002570: af00         	add	r7, sp, #0x0
 8002572: 6078         	str	r0, [r7, #0x4]
; 	q0 = kf->xhatminus_data[0];
 8002574: 687b         	ldr	r3, [r7, #0x4]
 8002576: f8d3 30ec    	ldr.w	r3, [r3, #0xec]
 800257a: 681b         	ldr	r3, [r3]
 800257c: 4a29         	ldr	r2, [pc, #0xa4]         @ 0x8002624 <IMU_QuaternionEKF_F_Linearization_P_Fading+0xb8>
 800257e: 6013         	str	r3, [r2]
; 	q1 = kf->xhatminus_data[1];
 8002580: 687b         	ldr	r3, [r7, #0x4]
 8002582: f8d3 30ec    	ldr.w	r3, [r3, #0xec]
 8002586: 685b         	ldr	r3, [r3, #0x4]
 8002588: 4a27         	ldr	r2, [pc, #0x9c]         @ 0x8002628 <IMU_QuaternionEKF_F_Linearization_P_Fading+0xbc>
 800258a: 6013         	str	r3, [r2]
; 	q2 = kf->xhatminus_data[2];
 800258c: 687b         	ldr	r3, [r7, #0x4]
 800258e: f8d3 30ec    	ldr.w	r3, [r3, #0xec]
 8002592: 689b         	ldr	r3, [r3, #0x8]
 8002594: 4a25         	ldr	r2, [pc, #0x94]         @ 0x800262c <IMU_QuaternionEKF_F_Linearization_P_Fading+0xc0>
 8002596: 6013         	str	r3, [r2]
; 	q3 = kf->xhatminus_data[3];
 8002598: 687b         	ldr	r3, [r7, #0x4]
 800259a: f8d3 30ec    	ldr.w	r3, [r3, #0xec]
 800259e: 68db         	ldr	r3, [r3, #0xc]
 80025a0: 4a23         	ldr	r2, [pc, #0x8c]         @ 0x8002630 <IMU_QuaternionEKF_F_Linearization_P_Fading+0xc4>
 80025a2: 6013         	str	r3, [r2]
; 	qInvNorm = invSqrt(q0 * q0 + q1 * q1 + q2 * q2 + q3 * q3);
 80025a4: 4b1f         	ldr	r3, [pc, #0x7c]         @ 0x8002624 <IMU_QuaternionEKF_F_Linearization_P_Fading+0xb8>
 80025a6: 681b         	ldr	r3, [r3]
 80025a8: 4a1e         	ldr	r2, [pc, #0x78]         @ 0x8002624 <IMU_QuaternionEKF_F_Linearization_P_Fading+0xb8>
 80025aa: 6812         	ldr	r2, [r2]
 80025ac: 4611         	mov	r1, r2
 80025ae: 4618         	mov	r0, r3
 80025b0: f7fd fef8    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x2210
 80025b4: 4603         	mov	r3, r0
 80025b6: 461c         	mov	r4, r3
 80025b8: 4b1b         	ldr	r3, [pc, #0x6c]         @ 0x8002628 <IMU_QuaternionEKF_F_Linearization_P_Fading+0xbc>
 80025ba: 681b         	ldr	r3, [r3]
 80025bc: 4a1a         	ldr	r2, [pc, #0x68]         @ 0x8002628 <IMU_QuaternionEKF_F_Linearization_P_Fading+0xbc>
 80025be: 6812         	ldr	r2, [r2]
 80025c0: 4611         	mov	r1, r2
 80025c2: 4618         	mov	r0, r3
 80025c4: f7fd feee    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x2224
 80025c8: 4603         	mov	r3, r0
 80025ca: 4619         	mov	r1, r3
 80025cc: 4620         	mov	r0, r4
 80025ce: f7fd fde1    	bl	0x8000194 <__aeabi_fadd> @ imm = #-0x243e
 80025d2: 4603         	mov	r3, r0
 80025d4: 461c         	mov	r4, r3
 80025d6: 4b15         	ldr	r3, [pc, #0x54]         @ 0x800262c <IMU_QuaternionEKF_F_Linearization_P_Fading+0xc0>
 80025d8: 681b         	ldr	r3, [r3]
 80025da: 4a14         	ldr	r2, [pc, #0x50]         @ 0x800262c <IMU_QuaternionEKF_F_Linearization_P_Fading+0xc0>
 80025dc: 6812         	ldr	r2, [r2]
 80025de: 4611         	mov	r1, r2
 80025e0: 4618         	mov	r0, r3
 80025e2: f7fd fedf    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x2242
 80025e6: 4603         	mov	r3, r0
 80025e8: 4619         	mov	r1, r3
 80025ea: 4620         	mov	r0, r4
 80025ec: f7fd fdd2    	bl	0x8000194 <__aeabi_fadd> @ imm = #-0x245c
 80025f0: 4603         	mov	r3, r0
 80025f2: 461c         	mov	r4, r3
 80025f4: 4b0e         	ldr	r3, [pc, #0x38]         @ 0x8002630 <IMU_QuaternionEKF_F_Linearization_P_Fading+0xc4>
 80025f6: 681b         	ldr	r3, [r3]
 80025f8: 4a0d         	ldr	r2, [pc, #0x34]         @ 0x8002630 <IMU_QuaternionEKF_F_Linearization_P_Fading+0xc4>
 80025fa: 6812         	ldr	r2, [r2]
 80025fc: 4611         	mov	r1, r2
 80025fe: 4618         	mov	r0, r3
 8002600: f7fd fed0    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x2260
 8002604: 4603         	mov	r3, r0
 8002606: 4619         	mov	r1, r3
 8002608: 4620         	mov	r0, r4
 800260a: f7fd fdc3    	bl	0x8000194 <__aeabi_fadd> @ imm = #-0x247a
 800260e: 4603         	mov	r3, r0
 8002610: 4618         	mov	r0, r3
 8002612: f000 fda1    	bl	0x8003158 <invSqrt>     @ imm = #0xb42
 8002616: 4603         	mov	r3, r0
 8002618: 4a06         	ldr	r2, [pc, #0x18]         @ 0x8002634 <IMU_QuaternionEKF_F_Linearization_P_Fading+0xc8>
 800261a: 6013         	str	r3, [r2]
; 	for (uint8_t i = 0; i < 4; ++i) {
 800261c: 2300         	movs	r3, #0x0
 800261e: 73fb         	strb	r3, [r7, #0xf]
 8002620: e020         	b	0x8002664 <IMU_QuaternionEKF_F_Linearization_P_Fading+0xf8> @ imm = #0x40
 8002622: bf00         	nop

08002624 <$d>:
 8002624: ac 1b 00 20  	.word	0x20001bac
 8002628: b0 1b 00 20  	.word	0x20001bb0
 800262c: b4 1b 00 20  	.word	0x20001bb4
 8002630: b8 1b 00 20  	.word	0x20001bb8
 8002634: bc 1b 00 20  	.word	0x20001bbc

08002638 <$t>:
; 		kf->xhatminus_data[i] *= qInvNorm;
 8002638: 687b         	ldr	r3, [r7, #0x4]
 800263a: f8d3 20ec    	ldr.w	r2, [r3, #0xec]
 800263e: 7bfb         	ldrb	r3, [r7, #0xf]
 8002640: 009b         	lsls	r3, r3, #0x2
 8002642: 4413         	add	r3, r2
 8002644: 6818         	ldr	r0, [r3]
 8002646: 4b8f         	ldr	r3, [pc, #0x23c]        @ 0x8002884 <IMU_QuaternionEKF_F_Linearization_P_Fading+0x318>
 8002648: 6819         	ldr	r1, [r3]
 800264a: 687b         	ldr	r3, [r7, #0x4]
 800264c: f8d3 20ec    	ldr.w	r2, [r3, #0xec]
 8002650: 7bfb         	ldrb	r3, [r7, #0xf]
 8002652: 009b         	lsls	r3, r3, #0x2
 8002654: 18d4         	adds	r4, r2, r3
 8002656: f7fd fea5    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x22b6
 800265a: 4603         	mov	r3, r0
 800265c: 6023         	str	r3, [r4]
; 	for (uint8_t i = 0; i < 4; ++i) {
 800265e: 7bfb         	ldrb	r3, [r7, #0xf]
 8002660: 3301         	adds	r3, #0x1
 8002662: 73fb         	strb	r3, [r7, #0xf]
 8002664: 7bfb         	ldrb	r3, [r7, #0xf]
 8002666: 2b03         	cmp	r3, #0x3
 8002668: d9e6         	bls	0x8002638 <IMU_QuaternionEKF_F_Linearization_P_Fading+0xcc> @ imm = #-0x34
; 	kf->F_data[4] = q1 * QEKF_INS.dt / 2;
 800266a: 4b87         	ldr	r3, [pc, #0x21c]        @ 0x8002888 <IMU_QuaternionEKF_F_Linearization_P_Fading+0x31c>
 800266c: f8d3 31bc    	ldr.w	r3, [r3, #0x1bc]
 8002670: 4a86         	ldr	r2, [pc, #0x218]        @ 0x800288c <IMU_QuaternionEKF_F_Linearization_P_Fading+0x320>
 8002672: 6812         	ldr	r2, [r2]
 8002674: 4611         	mov	r1, r2
 8002676: 4618         	mov	r0, r3
 8002678: f7fd fe94    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x22d8
 800267c: 4603         	mov	r3, r0
 800267e: 461a         	mov	r2, r3
 8002680: 687b         	ldr	r3, [r7, #0x4]
 8002682: f8d3 3100    	ldr.w	r3, [r3, #0x100]
 8002686: f103 0410    	add.w	r4, r3, #0x10
 800268a: f04f 4180    	mov.w	r1, #0x40000000
 800268e: 4610         	mov	r0, r2
 8002690: f7fd ff3c    	bl	0x800050c <__divsf3>    @ imm = #-0x2188
 8002694: 4603         	mov	r3, r0
 8002696: 6023         	str	r3, [r4]
; 	kf->F_data[5] = q2 * QEKF_INS.dt / 2;
 8002698: 4b7b         	ldr	r3, [pc, #0x1ec]        @ 0x8002888 <IMU_QuaternionEKF_F_Linearization_P_Fading+0x31c>
 800269a: f8d3 31bc    	ldr.w	r3, [r3, #0x1bc]
 800269e: 4a7c         	ldr	r2, [pc, #0x1f0]        @ 0x8002890 <IMU_QuaternionEKF_F_Linearization_P_Fading+0x324>
 80026a0: 6812         	ldr	r2, [r2]
 80026a2: 4611         	mov	r1, r2
 80026a4: 4618         	mov	r0, r3
 80026a6: f7fd fe7d    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x2306
 80026aa: 4603         	mov	r3, r0
 80026ac: 461a         	mov	r2, r3
 80026ae: 687b         	ldr	r3, [r7, #0x4]
 80026b0: f8d3 3100    	ldr.w	r3, [r3, #0x100]
 80026b4: f103 0414    	add.w	r4, r3, #0x14
 80026b8: f04f 4180    	mov.w	r1, #0x40000000
 80026bc: 4610         	mov	r0, r2
 80026be: f7fd ff25    	bl	0x800050c <__divsf3>    @ imm = #-0x21b6
 80026c2: 4603         	mov	r3, r0
 80026c4: 6023         	str	r3, [r4]
; 	kf->F_data[10] = -q0 * QEKF_INS.dt / 2;
 80026c6: 4b73         	ldr	r3, [pc, #0x1cc]        @ 0x8002894 <IMU_QuaternionEKF_F_Linearization_P_Fading+0x328>
 80026c8: 681b         	ldr	r3, [r3]
 80026ca: f083 4300    	eor	r3, r3, #0x80000000
 80026ce: 4a6e         	ldr	r2, [pc, #0x1b8]        @ 0x8002888 <IMU_QuaternionEKF_F_Linearization_P_Fading+0x31c>
 80026d0: f8d2 21bc    	ldr.w	r2, [r2, #0x1bc]
 80026d4: 4611         	mov	r1, r2
 80026d6: 4618         	mov	r0, r3
 80026d8: f7fd fe64    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x2338
 80026dc: 4603         	mov	r3, r0
 80026de: 461a         	mov	r2, r3
 80026e0: 687b         	ldr	r3, [r7, #0x4]
 80026e2: f8d3 3100    	ldr.w	r3, [r3, #0x100]
 80026e6: f103 0428    	add.w	r4, r3, #0x28
 80026ea: f04f 4180    	mov.w	r1, #0x40000000
 80026ee: 4610         	mov	r0, r2
 80026f0: f7fd ff0c    	bl	0x800050c <__divsf3>    @ imm = #-0x21e8
 80026f4: 4603         	mov	r3, r0
 80026f6: 6023         	str	r3, [r4]
; 	kf->F_data[11] = q3 * QEKF_INS.dt / 2;
 80026f8: 4b63         	ldr	r3, [pc, #0x18c]        @ 0x8002888 <IMU_QuaternionEKF_F_Linearization_P_Fading+0x31c>
 80026fa: f8d3 31bc    	ldr.w	r3, [r3, #0x1bc]
 80026fe: 4a66         	ldr	r2, [pc, #0x198]        @ 0x8002898 <IMU_QuaternionEKF_F_Linearization_P_Fading+0x32c>
 8002700: 6812         	ldr	r2, [r2]
 8002702: 4611         	mov	r1, r2
 8002704: 4618         	mov	r0, r3
 8002706: f7fd fe4d    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x2366
 800270a: 4603         	mov	r3, r0
 800270c: 461a         	mov	r2, r3
 800270e: 687b         	ldr	r3, [r7, #0x4]
 8002710: f8d3 3100    	ldr.w	r3, [r3, #0x100]
 8002714: f103 042c    	add.w	r4, r3, #0x2c
 8002718: f04f 4180    	mov.w	r1, #0x40000000
 800271c: 4610         	mov	r0, r2
 800271e: f7fd fef5    	bl	0x800050c <__divsf3>    @ imm = #-0x2216
 8002722: 4603         	mov	r3, r0
 8002724: 6023         	str	r3, [r4]
; 	kf->F_data[16] = -q3 * QEKF_INS.dt / 2;
 8002726: 4b5c         	ldr	r3, [pc, #0x170]        @ 0x8002898 <IMU_QuaternionEKF_F_Linearization_P_Fading+0x32c>
 8002728: 681b         	ldr	r3, [r3]
 800272a: f083 4300    	eor	r3, r3, #0x80000000
 800272e: 4a56         	ldr	r2, [pc, #0x158]        @ 0x8002888 <IMU_QuaternionEKF_F_Linearization_P_Fading+0x31c>
 8002730: f8d2 21bc    	ldr.w	r2, [r2, #0x1bc]
 8002734: 4611         	mov	r1, r2
 8002736: 4618         	mov	r0, r3
 8002738: f7fd fe34    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x2398
 800273c: 4603         	mov	r3, r0
 800273e: 461a         	mov	r2, r3
 8002740: 687b         	ldr	r3, [r7, #0x4]
 8002742: f8d3 3100    	ldr.w	r3, [r3, #0x100]
 8002746: f103 0440    	add.w	r4, r3, #0x40
 800274a: f04f 4180    	mov.w	r1, #0x40000000
 800274e: 4610         	mov	r0, r2
 8002750: f7fd fedc    	bl	0x800050c <__divsf3>    @ imm = #-0x2248
 8002754: 4603         	mov	r3, r0
 8002756: 6023         	str	r3, [r4]
; 	kf->F_data[17] = -q0 * QEKF_INS.dt / 2;
 8002758: 4b4e         	ldr	r3, [pc, #0x138]        @ 0x8002894 <IMU_QuaternionEKF_F_Linearization_P_Fading+0x328>
 800275a: 681b         	ldr	r3, [r3]
 800275c: f083 4300    	eor	r3, r3, #0x80000000
 8002760: 4a49         	ldr	r2, [pc, #0x124]        @ 0x8002888 <IMU_QuaternionEKF_F_Linearization_P_Fading+0x31c>
 8002762: f8d2 21bc    	ldr.w	r2, [r2, #0x1bc]
 8002766: 4611         	mov	r1, r2
 8002768: 4618         	mov	r0, r3
 800276a: f7fd fe1b    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x23ca
 800276e: 4603         	mov	r3, r0
 8002770: 461a         	mov	r2, r3
 8002772: 687b         	ldr	r3, [r7, #0x4]
 8002774: f8d3 3100    	ldr.w	r3, [r3, #0x100]
 8002778: f103 0444    	add.w	r4, r3, #0x44
 800277c: f04f 4180    	mov.w	r1, #0x40000000
 8002780: 4610         	mov	r0, r2
 8002782: f7fd fec3    	bl	0x800050c <__divsf3>    @ imm = #-0x227a
 8002786: 4603         	mov	r3, r0
 8002788: 6023         	str	r3, [r4]
; 	kf->F_data[22] = q2 * QEKF_INS.dt / 2;
 800278a: 4b3f         	ldr	r3, [pc, #0xfc]         @ 0x8002888 <IMU_QuaternionEKF_F_Linearization_P_Fading+0x31c>
 800278c: f8d3 31bc    	ldr.w	r3, [r3, #0x1bc]
 8002790: 4a3f         	ldr	r2, [pc, #0xfc]         @ 0x8002890 <IMU_QuaternionEKF_F_Linearization_P_Fading+0x324>
 8002792: 6812         	ldr	r2, [r2]
 8002794: 4611         	mov	r1, r2
 8002796: 4618         	mov	r0, r3
 8002798: f7fd fe04    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x23f8
 800279c: 4603         	mov	r3, r0
 800279e: 461a         	mov	r2, r3
 80027a0: 687b         	ldr	r3, [r7, #0x4]
 80027a2: f8d3 3100    	ldr.w	r3, [r3, #0x100]
 80027a6: f103 0458    	add.w	r4, r3, #0x58
 80027aa: f04f 4180    	mov.w	r1, #0x40000000
 80027ae: 4610         	mov	r0, r2
 80027b0: f7fd feac    	bl	0x800050c <__divsf3>    @ imm = #-0x22a8
 80027b4: 4603         	mov	r3, r0
 80027b6: 6023         	str	r3, [r4]
; 	kf->F_data[23] = -q1 * QEKF_INS.dt / 2;
 80027b8: 4b34         	ldr	r3, [pc, #0xd0]         @ 0x800288c <IMU_QuaternionEKF_F_Linearization_P_Fading+0x320>
 80027ba: 681b         	ldr	r3, [r3]
 80027bc: f083 4300    	eor	r3, r3, #0x80000000
 80027c0: 4a31         	ldr	r2, [pc, #0xc4]         @ 0x8002888 <IMU_QuaternionEKF_F_Linearization_P_Fading+0x31c>
 80027c2: f8d2 21bc    	ldr.w	r2, [r2, #0x1bc]
 80027c6: 4611         	mov	r1, r2
 80027c8: 4618         	mov	r0, r3
 80027ca: f7fd fdeb    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x242a
 80027ce: 4603         	mov	r3, r0
 80027d0: 461a         	mov	r2, r3
 80027d2: 687b         	ldr	r3, [r7, #0x4]
 80027d4: f8d3 3100    	ldr.w	r3, [r3, #0x100]
 80027d8: f103 045c    	add.w	r4, r3, #0x5c
 80027dc: f04f 4180    	mov.w	r1, #0x40000000
 80027e0: 4610         	mov	r0, r2
 80027e2: f7fd fe93    	bl	0x800050c <__divsf3>    @ imm = #-0x22da
 80027e6: 4603         	mov	r3, r0
 80027e8: 6023         	str	r3, [r4]
; 	kf->P_data[28] /= QEKF_INS.lambda;
 80027ea: 687b         	ldr	r3, [r7, #0x4]
 80027ec: f8d3 30f8    	ldr.w	r3, [r3, #0xf8]
 80027f0: 3370         	adds	r3, #0x70
 80027f2: 681a         	ldr	r2, [r3]
 80027f4: 4b24         	ldr	r3, [pc, #0x90]         @ 0x8002888 <IMU_QuaternionEKF_F_Linearization_P_Fading+0x31c>
 80027f6: f8d3 11d0    	ldr.w	r1, [r3, #0x1d0]
 80027fa: 687b         	ldr	r3, [r7, #0x4]
 80027fc: f8d3 30f8    	ldr.w	r3, [r3, #0xf8]
 8002800: f103 0470    	add.w	r4, r3, #0x70
 8002804: 4610         	mov	r0, r2
 8002806: f7fd fe81    	bl	0x800050c <__divsf3>    @ imm = #-0x22fe
 800280a: 4603         	mov	r3, r0
 800280c: 6023         	str	r3, [r4]
; 	kf->P_data[35] /= QEKF_INS.lambda;
 800280e: 687b         	ldr	r3, [r7, #0x4]
 8002810: f8d3 30f8    	ldr.w	r3, [r3, #0xf8]
 8002814: 338c         	adds	r3, #0x8c
 8002816: 681a         	ldr	r2, [r3]
 8002818: 4b1b         	ldr	r3, [pc, #0x6c]         @ 0x8002888 <IMU_QuaternionEKF_F_Linearization_P_Fading+0x31c>
 800281a: f8d3 11d0    	ldr.w	r1, [r3, #0x1d0]
 800281e: 687b         	ldr	r3, [r7, #0x4]
 8002820: f8d3 30f8    	ldr.w	r3, [r3, #0xf8]
 8002824: f103 048c    	add.w	r4, r3, #0x8c
 8002828: 4610         	mov	r0, r2
 800282a: f7fd fe6f    	bl	0x800050c <__divsf3>    @ imm = #-0x2322
 800282e: 4603         	mov	r3, r0
 8002830: 6023         	str	r3, [r4]
; 	if (kf->P_data[28] > 10000) {
 8002832: 687b         	ldr	r3, [r7, #0x4]
 8002834: f8d3 30f8    	ldr.w	r3, [r3, #0xf8]
 8002838: 3370         	adds	r3, #0x70
 800283a: 681b         	ldr	r3, [r3]
 800283c: 4917         	ldr	r1, [pc, #0x5c]         @ 0x800289c <IMU_QuaternionEKF_F_Linearization_P_Fading+0x330>
 800283e: 4618         	mov	r0, r3
 8002840: f7fd ff6c    	bl	0x800071c <__aeabi_fcmpgt> @ imm = #-0x2128
 8002844: 4603         	mov	r3, r0
 8002846: 2b00         	cmp	r3, #0x0
 8002848: d005         	beq	0x8002856 <IMU_QuaternionEKF_F_Linearization_P_Fading+0x2ea> @ imm = #0xa
; 		kf->P_data[28] = 10000;
 800284a: 687b         	ldr	r3, [r7, #0x4]
 800284c: f8d3 30f8    	ldr.w	r3, [r3, #0xf8]
 8002850: 3370         	adds	r3, #0x70
 8002852: 4a12         	ldr	r2, [pc, #0x48]         @ 0x800289c <IMU_QuaternionEKF_F_Linearization_P_Fading+0x330>
 8002854: 601a         	str	r2, [r3]
; 	if (kf->P_data[35] > 10000) {
 8002856: 687b         	ldr	r3, [r7, #0x4]
 8002858: f8d3 30f8    	ldr.w	r3, [r3, #0xf8]
 800285c: 338c         	adds	r3, #0x8c
 800285e: 681b         	ldr	r3, [r3]
 8002860: 490e         	ldr	r1, [pc, #0x38]         @ 0x800289c <IMU_QuaternionEKF_F_Linearization_P_Fading+0x330>
 8002862: 4618         	mov	r0, r3
 8002864: f7fd ff5a    	bl	0x800071c <__aeabi_fcmpgt> @ imm = #-0x214c
 8002868: 4603         	mov	r3, r0
 800286a: 2b00         	cmp	r3, #0x0
 800286c: d100         	bne	0x8002870 <IMU_QuaternionEKF_F_Linearization_P_Fading+0x304> @ imm = #0x0
; }
 800286e: e005         	b	0x800287c <IMU_QuaternionEKF_F_Linearization_P_Fading+0x310> @ imm = #0xa
; 		kf->P_data[35] = 10000;
 8002870: 687b         	ldr	r3, [r7, #0x4]
 8002872: f8d3 30f8    	ldr.w	r3, [r3, #0xf8]
 8002876: 338c         	adds	r3, #0x8c
 8002878: 4a08         	ldr	r2, [pc, #0x20]         @ 0x800289c <IMU_QuaternionEKF_F_Linearization_P_Fading+0x330>
 800287a: 601a         	str	r2, [r3]
; }
 800287c: bf00         	nop
 800287e: 3714         	adds	r7, #0x14
 8002880: 46bd         	mov	sp, r7
 8002882: bd90         	pop	{r4, r7, pc}

08002884 <$d>:
 8002884: bc 1b 00 20  	.word	0x20001bbc
 8002888: f8 06 00 20  	.word	0x200006f8
 800288c: b0 1b 00 20  	.word	0x20001bb0
 8002890: b4 1b 00 20  	.word	0x20001bb4
 8002894: ac 1b 00 20  	.word	0x20001bac
 8002898: b8 1b 00 20  	.word	0x20001bb8
 800289c: 00 40 1c 46  	.word	0x461c4000

080028a0 <IMU_QuaternionEKF_SetH>:
; {
 80028a0: b580         	push	{r7, lr}
 80028a2: b082         	sub	sp, #0x8
 80028a4: af00         	add	r7, sp, #0x0
 80028a6: 6078         	str	r0, [r7, #0x4]
; 	doubleq0 = 2 * kf->xhatminus_data[0];
 80028a8: 687b         	ldr	r3, [r7, #0x4]
 80028aa: f8d3 30ec    	ldr.w	r3, [r3, #0xec]
 80028ae: 681b         	ldr	r3, [r3]
 80028b0: 4619         	mov	r1, r3
 80028b2: 4618         	mov	r0, r3
 80028b4: f7fd fc6e    	bl	0x8000194 <__aeabi_fadd> @ imm = #-0x2724
 80028b8: 4603         	mov	r3, r0
 80028ba: 461a         	mov	r2, r3
 80028bc: 4b4c         	ldr	r3, [pc, #0x130]        @ 0x80029f0 <IMU_QuaternionEKF_SetH+0x150>
 80028be: 601a         	str	r2, [r3]
; 	doubleq1 = 2 * kf->xhatminus_data[1];
 80028c0: 687b         	ldr	r3, [r7, #0x4]
 80028c2: f8d3 30ec    	ldr.w	r3, [r3, #0xec]
 80028c6: 3304         	adds	r3, #0x4
 80028c8: 681b         	ldr	r3, [r3]
 80028ca: 4619         	mov	r1, r3
 80028cc: 4618         	mov	r0, r3
 80028ce: f7fd fc61    	bl	0x8000194 <__aeabi_fadd> @ imm = #-0x273e
 80028d2: 4603         	mov	r3, r0
 80028d4: 461a         	mov	r2, r3
 80028d6: 4b47         	ldr	r3, [pc, #0x11c]        @ 0x80029f4 <IMU_QuaternionEKF_SetH+0x154>
 80028d8: 601a         	str	r2, [r3]
; 	doubleq2 = 2 * kf->xhatminus_data[2];
 80028da: 687b         	ldr	r3, [r7, #0x4]
 80028dc: f8d3 30ec    	ldr.w	r3, [r3, #0xec]
 80028e0: 3308         	adds	r3, #0x8
 80028e2: 681b         	ldr	r3, [r3]
 80028e4: 4619         	mov	r1, r3
 80028e6: 4618         	mov	r0, r3
 80028e8: f7fd fc54    	bl	0x8000194 <__aeabi_fadd> @ imm = #-0x2758
 80028ec: 4603         	mov	r3, r0
 80028ee: 461a         	mov	r2, r3
 80028f0: 4b41         	ldr	r3, [pc, #0x104]        @ 0x80029f8 <IMU_QuaternionEKF_SetH+0x158>
 80028f2: 601a         	str	r2, [r3]
; 	doubleq3 = 2 * kf->xhatminus_data[3];
 80028f4: 687b         	ldr	r3, [r7, #0x4]
 80028f6: f8d3 30ec    	ldr.w	r3, [r3, #0xec]
 80028fa: 330c         	adds	r3, #0xc
 80028fc: 681b         	ldr	r3, [r3]
 80028fe: 4619         	mov	r1, r3
 8002900: 4618         	mov	r0, r3
 8002902: f7fd fc47    	bl	0x8000194 <__aeabi_fadd> @ imm = #-0x2772
 8002906: 4603         	mov	r3, r0
 8002908: 461a         	mov	r2, r3
 800290a: 4b3c         	ldr	r3, [pc, #0xf0]         @ 0x80029fc <IMU_QuaternionEKF_SetH+0x15c>
 800290c: 601a         	str	r2, [r3]
; 	memset(kf->H_data, 0, sizeof_float * kf->zSize * kf->xhatSize);
 800290e: 687b         	ldr	r3, [r7, #0x4]
 8002910: f8d3 010c    	ldr.w	r0, [r3, #0x10c]
 8002914: 4b3a         	ldr	r3, [pc, #0xe8]         @ 0x8002a00 <IMU_QuaternionEKF_SetH+0x160>
 8002916: 881b         	ldrh	r3, [r3]
 8002918: 461a         	mov	r2, r3
 800291a: 687b         	ldr	r3, [r7, #0x4]
 800291c: 7b9b         	ldrb	r3, [r3, #0xe]
 800291e: fb02 f303    	mul	r3, r2, r3
 8002922: 687a         	ldr	r2, [r7, #0x4]
 8002924: 7b12         	ldrb	r2, [r2, #0xc]
 8002926: fb02 f303    	mul	r3, r2, r3
 800292a: 461a         	mov	r2, r3
 800292c: 2100         	movs	r1, #0x0
 800292e: f01a ff5d    	bl	0x801d7ec <memset>      @ imm = #0x1aeba
; 	kf->H_data[0] = -doubleq2;
 8002932: 4b31         	ldr	r3, [pc, #0xc4]         @ 0x80029f8 <IMU_QuaternionEKF_SetH+0x158>
 8002934: 681a         	ldr	r2, [r3]
 8002936: 687b         	ldr	r3, [r7, #0x4]
 8002938: f8d3 310c    	ldr.w	r3, [r3, #0x10c]
 800293c: f082 4200    	eor	r2, r2, #0x80000000
 8002940: 601a         	str	r2, [r3]
; 	kf->H_data[1] = doubleq3;
 8002942: 687b         	ldr	r3, [r7, #0x4]
 8002944: f8d3 310c    	ldr.w	r3, [r3, #0x10c]
 8002948: 3304         	adds	r3, #0x4
 800294a: 4a2c         	ldr	r2, [pc, #0xb0]         @ 0x80029fc <IMU_QuaternionEKF_SetH+0x15c>
 800294c: 6812         	ldr	r2, [r2]
 800294e: 601a         	str	r2, [r3]
; 	kf->H_data[2] = -doubleq0;
 8002950: 4b27         	ldr	r3, [pc, #0x9c]         @ 0x80029f0 <IMU_QuaternionEKF_SetH+0x150>
 8002952: 681a         	ldr	r2, [r3]
 8002954: 687b         	ldr	r3, [r7, #0x4]
 8002956: f8d3 310c    	ldr.w	r3, [r3, #0x10c]
 800295a: 3308         	adds	r3, #0x8
 800295c: f082 4200    	eor	r2, r2, #0x80000000
 8002960: 601a         	str	r2, [r3]
; 	kf->H_data[3] = doubleq1;
 8002962: 687b         	ldr	r3, [r7, #0x4]
 8002964: f8d3 310c    	ldr.w	r3, [r3, #0x10c]
 8002968: 330c         	adds	r3, #0xc
 800296a: 4a22         	ldr	r2, [pc, #0x88]         @ 0x80029f4 <IMU_QuaternionEKF_SetH+0x154>
 800296c: 6812         	ldr	r2, [r2]
 800296e: 601a         	str	r2, [r3]
; 	kf->H_data[6] = doubleq1;
 8002970: 687b         	ldr	r3, [r7, #0x4]
 8002972: f8d3 310c    	ldr.w	r3, [r3, #0x10c]
 8002976: 3318         	adds	r3, #0x18
 8002978: 4a1e         	ldr	r2, [pc, #0x78]         @ 0x80029f4 <IMU_QuaternionEKF_SetH+0x154>
 800297a: 6812         	ldr	r2, [r2]
 800297c: 601a         	str	r2, [r3]
; 	kf->H_data[7] = doubleq0;
 800297e: 687b         	ldr	r3, [r7, #0x4]
 8002980: f8d3 310c    	ldr.w	r3, [r3, #0x10c]
 8002984: 331c         	adds	r3, #0x1c
 8002986: 4a1a         	ldr	r2, [pc, #0x68]         @ 0x80029f0 <IMU_QuaternionEKF_SetH+0x150>
 8002988: 6812         	ldr	r2, [r2]
 800298a: 601a         	str	r2, [r3]
; 	kf->H_data[8] = doubleq3;
 800298c: 687b         	ldr	r3, [r7, #0x4]
 800298e: f8d3 310c    	ldr.w	r3, [r3, #0x10c]
 8002992: 3320         	adds	r3, #0x20
 8002994: 4a19         	ldr	r2, [pc, #0x64]         @ 0x80029fc <IMU_QuaternionEKF_SetH+0x15c>
 8002996: 6812         	ldr	r2, [r2]
 8002998: 601a         	str	r2, [r3]
; 	kf->H_data[9] = doubleq2;
 800299a: 687b         	ldr	r3, [r7, #0x4]
 800299c: f8d3 310c    	ldr.w	r3, [r3, #0x10c]
 80029a0: 3324         	adds	r3, #0x24
 80029a2: 4a15         	ldr	r2, [pc, #0x54]         @ 0x80029f8 <IMU_QuaternionEKF_SetH+0x158>
 80029a4: 6812         	ldr	r2, [r2]
 80029a6: 601a         	str	r2, [r3]
; 	kf->H_data[12] = doubleq0;
 80029a8: 687b         	ldr	r3, [r7, #0x4]
 80029aa: f8d3 310c    	ldr.w	r3, [r3, #0x10c]
 80029ae: 3330         	adds	r3, #0x30
 80029b0: 4a0f         	ldr	r2, [pc, #0x3c]         @ 0x80029f0 <IMU_QuaternionEKF_SetH+0x150>
 80029b2: 6812         	ldr	r2, [r2]
 80029b4: 601a         	str	r2, [r3]
; 	kf->H_data[13] = -doubleq1;
 80029b6: 4b0f         	ldr	r3, [pc, #0x3c]         @ 0x80029f4 <IMU_QuaternionEKF_SetH+0x154>
 80029b8: 681a         	ldr	r2, [r3]
 80029ba: 687b         	ldr	r3, [r7, #0x4]
 80029bc: f8d3 310c    	ldr.w	r3, [r3, #0x10c]
 80029c0: 3334         	adds	r3, #0x34
 80029c2: f082 4200    	eor	r2, r2, #0x80000000
 80029c6: 601a         	str	r2, [r3]
; 	kf->H_data[14] = -doubleq2;
 80029c8: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x80029f8 <IMU_QuaternionEKF_SetH+0x158>
 80029ca: 681a         	ldr	r2, [r3]
 80029cc: 687b         	ldr	r3, [r7, #0x4]
 80029ce: f8d3 310c    	ldr.w	r3, [r3, #0x10c]
 80029d2: 3338         	adds	r3, #0x38
 80029d4: f082 4200    	eor	r2, r2, #0x80000000
 80029d8: 601a         	str	r2, [r3]
; 	kf->H_data[15] = doubleq3;
 80029da: 687b         	ldr	r3, [r7, #0x4]
 80029dc: f8d3 310c    	ldr.w	r3, [r3, #0x10c]
 80029e0: 333c         	adds	r3, #0x3c
 80029e2: 4a06         	ldr	r2, [pc, #0x18]         @ 0x80029fc <IMU_QuaternionEKF_SetH+0x15c>
 80029e4: 6812         	ldr	r2, [r2]
 80029e6: 601a         	str	r2, [r3]
; }
 80029e8: bf00         	nop
 80029ea: 3708         	adds	r7, #0x8
 80029ec: 46bd         	mov	sp, r7
 80029ee: bd80         	pop	{r7, pc}

080029f0 <$d>:
 80029f0: c0 1b 00 20  	.word	0x20001bc0
 80029f4: c4 1b 00 20  	.word	0x20001bc4
 80029f8: c8 1b 00 20  	.word	0x20001bc8
 80029fc: cc 1b 00 20  	.word	0x20001bcc
 8002a00: 84 1f 00 20  	.word	0x20001f84

08002a04 <IMU_QuaternionEKF_xhatUpdate>:
; {
 8002a04: e92d 41f0    	push.w	{r4, r5, r6, r7, r8, lr}
 8002a08: b084         	sub	sp, #0x10
 8002a0a: af00         	add	r7, sp, #0x0
 8002a0c: 6078         	str	r0, [r7, #0x4]
; 	kf->MatStatus = Matrix_Transpose(&kf->H, &kf->HT); // z|x => x|z
 8002a0e: 687b         	ldr	r3, [r7, #0x4]
 8002a10: f103 0278    	add.w	r2, r3, #0x78
 8002a14: 687b         	ldr	r3, [r7, #0x4]
 8002a16: 3380         	adds	r3, #0x80
 8002a18: 4619         	mov	r1, r3
 8002a1a: 4610         	mov	r0, r2
 8002a1c: f00a fae2    	bl	0x800cfe4 <arm_mat_trans_f32> @ imm = #0xa5c4
 8002a20: 4603         	mov	r3, r0
 8002a22: 461a         	mov	r2, r3
 8002a24: 687b         	ldr	r3, [r7, #0x4]
 8002a26: f883 20c8    	strb.w	r2, [r3, #0xc8]
; 	kf->temp_matrix.numRows = kf->H.numRows;
 8002a2a: 687b         	ldr	r3, [r7, #0x4]
 8002a2c: f8b3 2078    	ldrh.w	r2, [r3, #0x78]
 8002a30: 687b         	ldr	r3, [r7, #0x4]
 8002a32: f8a3 20a8    	strh.w	r2, [r3, #0xa8]
; 	kf->temp_matrix.numCols = kf->Pminus.numCols;
 8002a36: 687b         	ldr	r3, [r7, #0x4]
 8002a38: f8b3 205a    	ldrh.w	r2, [r3, #0x5a]
 8002a3c: 687b         	ldr	r3, [r7, #0x4]
 8002a3e: f8a3 20aa    	strh.w	r2, [r3, #0xaa]
; 		Matrix_Multiply(&kf->H, &kf->Pminus, &kf->temp_matrix); // temp_matrix = H·P'(k)
 8002a42: 687b         	ldr	r3, [r7, #0x4]
 8002a44: f103 0078    	add.w	r0, r3, #0x78
 8002a48: 687b         	ldr	r3, [r7, #0x4]
 8002a4a: f103 0158    	add.w	r1, r3, #0x58
 8002a4e: 687b         	ldr	r3, [r7, #0x4]
 8002a50: 33a8         	adds	r3, #0xa8
 8002a52: 461a         	mov	r2, r3
 8002a54: f00a fa2c    	bl	0x800ceb0 <arm_mat_mult_f32> @ imm = #0xa458
 8002a58: 4603         	mov	r3, r0
 8002a5a: 461a         	mov	r2, r3
; 	kf->MatStatus =
 8002a5c: 687b         	ldr	r3, [r7, #0x4]
 8002a5e: f883 20c8    	strb.w	r2, [r3, #0xc8]
; 	kf->temp_matrix1.numRows = kf->temp_matrix.numRows;
 8002a62: 687b         	ldr	r3, [r7, #0x4]
 8002a64: f8b3 20a8    	ldrh.w	r2, [r3, #0xa8]
 8002a68: 687b         	ldr	r3, [r7, #0x4]
 8002a6a: f8a3 20b0    	strh.w	r2, [r3, #0xb0]
; 	kf->temp_matrix1.numCols = kf->HT.numCols;
 8002a6e: 687b         	ldr	r3, [r7, #0x4]
 8002a70: f8b3 2082    	ldrh.w	r2, [r3, #0x82]
 8002a74: 687b         	ldr	r3, [r7, #0x4]
 8002a76: f8a3 20b2    	strh.w	r2, [r3, #0xb2]
; 	kf->MatStatus = Matrix_Multiply(&kf->temp_matrix, &kf->HT,
 8002a7a: 687b         	ldr	r3, [r7, #0x4]
 8002a7c: f103 00a8    	add.w	r0, r3, #0xa8
 8002a80: 687b         	ldr	r3, [r7, #0x4]
 8002a82: f103 0180    	add.w	r1, r3, #0x80
 8002a86: 687b         	ldr	r3, [r7, #0x4]
 8002a88: 33b0         	adds	r3, #0xb0
 8002a8a: 461a         	mov	r2, r3
 8002a8c: f00a fa10    	bl	0x800ceb0 <arm_mat_mult_f32> @ imm = #0xa420
 8002a90: 4603         	mov	r3, r0
 8002a92: 461a         	mov	r2, r3
 8002a94: 687b         	ldr	r3, [r7, #0x4]
 8002a96: f883 20c8    	strb.w	r2, [r3, #0xc8]
; 	kf->S.numRows = kf->R.numRows;
 8002a9a: 687b         	ldr	r3, [r7, #0x4]
 8002a9c: f8b3 2090    	ldrh.w	r2, [r3, #0x90]
 8002aa0: 687b         	ldr	r3, [r7, #0x4]
 8002aa2: f8a3 20a0    	strh.w	r2, [r3, #0xa0]
; 	kf->S.numCols = kf->R.numCols;
 8002aa6: 687b         	ldr	r3, [r7, #0x4]
 8002aa8: f8b3 2092    	ldrh.w	r2, [r3, #0x92]
 8002aac: 687b         	ldr	r3, [r7, #0x4]
 8002aae: f8a3 20a2    	strh.w	r2, [r3, #0xa2]
; 	kf->MatStatus = Matrix_Add(&kf->temp_matrix1, &kf->R, &kf->S); // S = H P'(k) HT + R
 8002ab2: 687b         	ldr	r3, [r7, #0x4]
 8002ab4: f103 00b0    	add.w	r0, r3, #0xb0
 8002ab8: 687b         	ldr	r3, [r7, #0x4]
 8002aba: f103 0190    	add.w	r1, r3, #0x90
 8002abe: 687b         	ldr	r3, [r7, #0x4]
 8002ac0: 33a0         	adds	r3, #0xa0
 8002ac2: 461a         	mov	r2, r3
 8002ac4: f00a f820    	bl	0x800cb08 <arm_mat_add_f32> @ imm = #0xa040
 8002ac8: 4603         	mov	r3, r0
 8002aca: 461a         	mov	r2, r3
 8002acc: 687b         	ldr	r3, [r7, #0x4]
 8002ace: f883 20c8    	strb.w	r2, [r3, #0xc8]
; 		Matrix_Inverse(&kf->S, &kf->temp_matrix1); // temp_matrix1 = inv(H·P'(k)·HT + R)
 8002ad2: 687b         	ldr	r3, [r7, #0x4]
 8002ad4: f103 02a0    	add.w	r2, r3, #0xa0
 8002ad8: 687b         	ldr	r3, [r7, #0x4]
 8002ada: 33b0         	adds	r3, #0xb0
 8002adc: 4619         	mov	r1, r3
 8002ade: 4610         	mov	r0, r2
 8002ae0: f00a f82c    	bl	0x800cb3c <arm_mat_inverse_f32> @ imm = #0xa058
 8002ae4: 4603         	mov	r3, r0
 8002ae6: 461a         	mov	r2, r3
; 	kf->MatStatus =
 8002ae8: 687b         	ldr	r3, [r7, #0x4]
 8002aea: f883 20c8    	strb.w	r2, [r3, #0xc8]
; 	q0 = kf->xhatminus_data[0];
 8002aee: 687b         	ldr	r3, [r7, #0x4]
 8002af0: f8d3 30ec    	ldr.w	r3, [r3, #0xec]
 8002af4: 681b         	ldr	r3, [r3]
 8002af6: 4aa7         	ldr	r2, [pc, #0x29c]        @ 0x8002d94 <IMU_QuaternionEKF_xhatUpdate+0x390>
 8002af8: 6013         	str	r3, [r2]
; 	q1 = kf->xhatminus_data[1];
 8002afa: 687b         	ldr	r3, [r7, #0x4]
 8002afc: f8d3 30ec    	ldr.w	r3, [r3, #0xec]
 8002b00: 685b         	ldr	r3, [r3, #0x4]
 8002b02: 4aa5         	ldr	r2, [pc, #0x294]        @ 0x8002d98 <IMU_QuaternionEKF_xhatUpdate+0x394>
 8002b04: 6013         	str	r3, [r2]
; 	q2 = kf->xhatminus_data[2];
 8002b06: 687b         	ldr	r3, [r7, #0x4]
 8002b08: f8d3 30ec    	ldr.w	r3, [r3, #0xec]
 8002b0c: 689b         	ldr	r3, [r3, #0x8]
 8002b0e: 4aa3         	ldr	r2, [pc, #0x28c]        @ 0x8002d9c <IMU_QuaternionEKF_xhatUpdate+0x398>
 8002b10: 6013         	str	r3, [r2]
; 	q3 = kf->xhatminus_data[3];
 8002b12: 687b         	ldr	r3, [r7, #0x4]
 8002b14: f8d3 30ec    	ldr.w	r3, [r3, #0xec]
 8002b18: 68db         	ldr	r3, [r3, #0xc]
 8002b1a: 4aa1         	ldr	r2, [pc, #0x284]        @ 0x8002da0 <IMU_QuaternionEKF_xhatUpdate+0x39c>
 8002b1c: 6013         	str	r3, [r2]
; 	kf->temp_vector.numRows = kf->H.numRows;
 8002b1e: 687b         	ldr	r3, [r7, #0x4]
 8002b20: f8b3 2078    	ldrh.w	r2, [r3, #0x78]
 8002b24: 687b         	ldr	r3, [r7, #0x4]
 8002b26: f8a3 20b8    	strh.w	r2, [r3, #0xb8]
; 	kf->temp_vector.numCols = 1;
 8002b2a: 687b         	ldr	r3, [r7, #0x4]
 8002b2c: 2201         	movs	r2, #0x1
 8002b2e: f8a3 20ba    	strh.w	r2, [r3, #0xba]
; 	kf->temp_vector_data[0] = 2 * (q1 * q3 - q0 * q2);
 8002b32: 4b99         	ldr	r3, [pc, #0x264]        @ 0x8002d98 <IMU_QuaternionEKF_xhatUpdate+0x394>
 8002b34: 681b         	ldr	r3, [r3]
 8002b36: 4a9a         	ldr	r2, [pc, #0x268]        @ 0x8002da0 <IMU_QuaternionEKF_xhatUpdate+0x39c>
 8002b38: 6812         	ldr	r2, [r2]
 8002b3a: 4611         	mov	r1, r2
 8002b3c: 4618         	mov	r0, r3
 8002b3e: f7fd fc31    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x279e
 8002b42: 4603         	mov	r3, r0
 8002b44: 461e         	mov	r6, r3
 8002b46: 4b93         	ldr	r3, [pc, #0x24c]        @ 0x8002d94 <IMU_QuaternionEKF_xhatUpdate+0x390>
 8002b48: 681b         	ldr	r3, [r3]
 8002b4a: 4a94         	ldr	r2, [pc, #0x250]        @ 0x8002d9c <IMU_QuaternionEKF_xhatUpdate+0x398>
 8002b4c: 6812         	ldr	r2, [r2]
 8002b4e: 4611         	mov	r1, r2
 8002b50: 4618         	mov	r0, r3
 8002b52: f7fd fc27    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x27b2
 8002b56: 4603         	mov	r3, r0
 8002b58: 4619         	mov	r1, r3
 8002b5a: 4630         	mov	r0, r6
 8002b5c: f7fd fb18    	bl	0x8000190 <__subsf3>    @ imm = #-0x29d0
 8002b60: 4603         	mov	r3, r0
 8002b62: 461a         	mov	r2, r3
 8002b64: 687b         	ldr	r3, [r7, #0x4]
 8002b66: f8d3 612c    	ldr.w	r6, [r3, #0x12c]
 8002b6a: 4611         	mov	r1, r2
 8002b6c: 4610         	mov	r0, r2
 8002b6e: f7fd fb11    	bl	0x8000194 <__aeabi_fadd> @ imm = #-0x29de
 8002b72: 4603         	mov	r3, r0
 8002b74: 6033         	str	r3, [r6]
; 	kf->temp_vector_data[1] = 2 * (q0 * q1 + q2 * q3);
 8002b76: 4b87         	ldr	r3, [pc, #0x21c]        @ 0x8002d94 <IMU_QuaternionEKF_xhatUpdate+0x390>
 8002b78: 681b         	ldr	r3, [r3]
 8002b7a: 4a87         	ldr	r2, [pc, #0x21c]        @ 0x8002d98 <IMU_QuaternionEKF_xhatUpdate+0x394>
 8002b7c: 6812         	ldr	r2, [r2]
 8002b7e: 4611         	mov	r1, r2
 8002b80: 4618         	mov	r0, r3
 8002b82: f7fd fc0f    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x27e2
 8002b86: 4603         	mov	r3, r0
 8002b88: 461e         	mov	r6, r3
 8002b8a: 4b84         	ldr	r3, [pc, #0x210]        @ 0x8002d9c <IMU_QuaternionEKF_xhatUpdate+0x398>
 8002b8c: 681b         	ldr	r3, [r3]
 8002b8e: 4a84         	ldr	r2, [pc, #0x210]        @ 0x8002da0 <IMU_QuaternionEKF_xhatUpdate+0x39c>
 8002b90: 6812         	ldr	r2, [r2]
 8002b92: 4611         	mov	r1, r2
 8002b94: 4618         	mov	r0, r3
 8002b96: f7fd fc05    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x27f6
 8002b9a: 4603         	mov	r3, r0
 8002b9c: 4619         	mov	r1, r3
 8002b9e: 4630         	mov	r0, r6
 8002ba0: f7fd faf8    	bl	0x8000194 <__aeabi_fadd> @ imm = #-0x2a10
 8002ba4: 4603         	mov	r3, r0
 8002ba6: 461a         	mov	r2, r3
 8002ba8: 687b         	ldr	r3, [r7, #0x4]
 8002baa: f8d3 312c    	ldr.w	r3, [r3, #0x12c]
 8002bae: 1d1e         	adds	r6, r3, #0x4
 8002bb0: 4611         	mov	r1, r2
 8002bb2: 4610         	mov	r0, r2
 8002bb4: f7fd faee    	bl	0x8000194 <__aeabi_fadd> @ imm = #-0x2a24
 8002bb8: 4603         	mov	r3, r0
 8002bba: 6033         	str	r3, [r6]
; 		q0 * q0 - q1 * q1 - q2 * q2 + q3 * q3; // temp_vector = h(xhat'(k))
 8002bbc: 4b75         	ldr	r3, [pc, #0x1d4]        @ 0x8002d94 <IMU_QuaternionEKF_xhatUpdate+0x390>
 8002bbe: 681b         	ldr	r3, [r3]
 8002bc0: 4a74         	ldr	r2, [pc, #0x1d0]        @ 0x8002d94 <IMU_QuaternionEKF_xhatUpdate+0x390>
 8002bc2: 6812         	ldr	r2, [r2]
 8002bc4: 4611         	mov	r1, r2
 8002bc6: 4618         	mov	r0, r3
 8002bc8: f7fd fbec    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x2828
 8002bcc: 4603         	mov	r3, r0
 8002bce: 461e         	mov	r6, r3
 8002bd0: 4b71         	ldr	r3, [pc, #0x1c4]        @ 0x8002d98 <IMU_QuaternionEKF_xhatUpdate+0x394>
 8002bd2: 681b         	ldr	r3, [r3]
 8002bd4: 4a70         	ldr	r2, [pc, #0x1c0]        @ 0x8002d98 <IMU_QuaternionEKF_xhatUpdate+0x394>
 8002bd6: 6812         	ldr	r2, [r2]
 8002bd8: 4611         	mov	r1, r2
 8002bda: 4618         	mov	r0, r3
 8002bdc: f7fd fbe2    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x283c
 8002be0: 4603         	mov	r3, r0
 8002be2: 4619         	mov	r1, r3
 8002be4: 4630         	mov	r0, r6
 8002be6: f7fd fad3    	bl	0x8000190 <__subsf3>    @ imm = #-0x2a5a
 8002bea: 4603         	mov	r3, r0
 8002bec: 461e         	mov	r6, r3
 8002bee: 4b6b         	ldr	r3, [pc, #0x1ac]        @ 0x8002d9c <IMU_QuaternionEKF_xhatUpdate+0x398>
 8002bf0: 681b         	ldr	r3, [r3]
 8002bf2: 4a6a         	ldr	r2, [pc, #0x1a8]        @ 0x8002d9c <IMU_QuaternionEKF_xhatUpdate+0x398>
 8002bf4: 6812         	ldr	r2, [r2]
 8002bf6: 4611         	mov	r1, r2
 8002bf8: 4618         	mov	r0, r3
 8002bfa: f7fd fbd3    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x285a
 8002bfe: 4603         	mov	r3, r0
 8002c00: 4619         	mov	r1, r3
 8002c02: 4630         	mov	r0, r6
 8002c04: f7fd fac4    	bl	0x8000190 <__subsf3>    @ imm = #-0x2a78
 8002c08: 4603         	mov	r3, r0
 8002c0a: 4698         	mov	r8, r3
 8002c0c: 4b64         	ldr	r3, [pc, #0x190]        @ 0x8002da0 <IMU_QuaternionEKF_xhatUpdate+0x39c>
 8002c0e: 681b         	ldr	r3, [r3]
 8002c10: 4a63         	ldr	r2, [pc, #0x18c]        @ 0x8002da0 <IMU_QuaternionEKF_xhatUpdate+0x39c>
 8002c12: 6812         	ldr	r2, [r2]
 8002c14: 4611         	mov	r1, r2
 8002c16: 4618         	mov	r0, r3
 8002c18: f7fd fbc4    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x2878
 8002c1c: 4603         	mov	r3, r0
 8002c1e: 461a         	mov	r2, r3
; 	kf->temp_vector_data[2] =
 8002c20: 687b         	ldr	r3, [r7, #0x4]
 8002c22: f8d3 312c    	ldr.w	r3, [r3, #0x12c]
 8002c26: f103 0608    	add.w	r6, r3, #0x8
; 		q0 * q0 - q1 * q1 - q2 * q2 + q3 * q3; // temp_vector = h(xhat'(k))
 8002c2a: 4611         	mov	r1, r2
 8002c2c: 4640         	mov	r0, r8
 8002c2e: f7fd fab1    	bl	0x8000194 <__aeabi_fadd> @ imm = #-0x2a9e
 8002c32: 4603         	mov	r3, r0
; 	kf->temp_vector_data[2] =
 8002c34: 6033         	str	r3, [r6]
; 	for (uint8_t i = 0; i < 3; ++i) {
 8002c36: 2300         	movs	r3, #0x0
 8002c38: 73fb         	strb	r3, [r7, #0xf]
 8002c3a: e016         	b	0x8002c6a <IMU_QuaternionEKF_xhatUpdate+0x266> @ imm = #0x2c
; 		QEKF_INS.OrientationCosine[i] = acosf(fabsf(kf->temp_vector_data[i]));
 8002c3c: 687b         	ldr	r3, [r7, #0x4]
 8002c3e: f8d3 212c    	ldr.w	r2, [r3, #0x12c]
 8002c42: 7bfb         	ldrb	r3, [r7, #0xf]
 8002c44: 009b         	lsls	r3, r3, #0x2
 8002c46: 4413         	add	r3, r2
 8002c48: 681b         	ldr	r3, [r3]
 8002c4a: f023 4300    	bic	r3, r3, #0x80000000
 8002c4e: 7bfe         	ldrb	r6, [r7, #0xf]
 8002c50: 4618         	mov	r0, r3
 8002c52: f00f fc09    	bl	0x8012468 <acosf>       @ imm = #0xf812
 8002c56: 4602         	mov	r2, r0
 8002c58: 4952         	ldr	r1, [pc, #0x148]        @ 0x8002da4 <IMU_QuaternionEKF_xhatUpdate+0x3a0>
 8002c5a: f106 0360    	add.w	r3, r6, #0x60
 8002c5e: 009b         	lsls	r3, r3, #0x2
 8002c60: 440b         	add	r3, r1
 8002c62: 605a         	str	r2, [r3, #0x4]
; 	for (uint8_t i = 0; i < 3; ++i) {
 8002c64: 7bfb         	ldrb	r3, [r7, #0xf]
 8002c66: 3301         	adds	r3, #0x1
 8002c68: 73fb         	strb	r3, [r7, #0xf]
 8002c6a: 7bfb         	ldrb	r3, [r7, #0xf]
 8002c6c: 2b02         	cmp	r3, #0x2
 8002c6e: d9e5         	bls	0x8002c3c <IMU_QuaternionEKF_xhatUpdate+0x238> @ imm = #-0x36
; 	kf->temp_vector1.numRows = kf->z.numRows;
 8002c70: 687b         	ldr	r3, [r7, #0x4]
 8002c72: f8b3 2048    	ldrh.w	r2, [r3, #0x48]
 8002c76: 687b         	ldr	r3, [r7, #0x4]
 8002c78: f8a3 20c0    	strh.w	r2, [r3, #0xc0]
; 	kf->temp_vector1.numCols = 1;
 8002c7c: 687b         	ldr	r3, [r7, #0x4]
 8002c7e: 2201         	movs	r2, #0x1
 8002c80: f8a3 20c2    	strh.w	r2, [r3, #0xc2]
; 	kf->MatStatus = Matrix_Subtract(&kf->z, &kf->temp_vector,
 8002c84: 687b         	ldr	r3, [r7, #0x4]
 8002c86: f103 0048    	add.w	r0, r3, #0x48
 8002c8a: 687b         	ldr	r3, [r7, #0x4]
 8002c8c: f103 01b8    	add.w	r1, r3, #0xb8
 8002c90: 687b         	ldr	r3, [r7, #0x4]
 8002c92: 33c0         	adds	r3, #0xc0
 8002c94: 461a         	mov	r2, r3
 8002c96: f00a f98f    	bl	0x800cfb8 <arm_mat_sub_f32> @ imm = #0xa31e
 8002c9a: 4603         	mov	r3, r0
 8002c9c: 461a         	mov	r2, r3
 8002c9e: 687b         	ldr	r3, [r7, #0x4]
 8002ca0: f883 20c8    	strb.w	r2, [r3, #0xc8]
; 	kf->temp_matrix.numRows = kf->temp_vector1.numRows;
 8002ca4: 687b         	ldr	r3, [r7, #0x4]
 8002ca6: f8b3 20c0    	ldrh.w	r2, [r3, #0xc0]
 8002caa: 687b         	ldr	r3, [r7, #0x4]
 8002cac: f8a3 20a8    	strh.w	r2, [r3, #0xa8]
; 	kf->temp_matrix.numCols = 1;
 8002cb0: 687b         	ldr	r3, [r7, #0x4]
 8002cb2: 2201         	movs	r2, #0x1
 8002cb4: f8a3 20aa    	strh.w	r2, [r3, #0xaa]
; 		&kf->temp_matrix1, &kf->temp_vector1,
 8002cb8: 687b         	ldr	r3, [r7, #0x4]
 8002cba: f103 00b0    	add.w	r0, r3, #0xb0
 8002cbe: 687b         	ldr	r3, [r7, #0x4]
 8002cc0: f103 01c0    	add.w	r1, r3, #0xc0
; 	kf->MatStatus = Matrix_Multiply(
 8002cc4: 687b         	ldr	r3, [r7, #0x4]
 8002cc6: 33a8         	adds	r3, #0xa8
 8002cc8: 461a         	mov	r2, r3
 8002cca: f00a f8f1    	bl	0x800ceb0 <arm_mat_mult_f32> @ imm = #0xa1e2
 8002cce: 4603         	mov	r3, r0
 8002cd0: 461a         	mov	r2, r3
 8002cd2: 687b         	ldr	r3, [r7, #0x4]
 8002cd4: f883 20c8    	strb.w	r2, [r3, #0xc8]
; 	kf->temp_vector.numRows = 1;
 8002cd8: 687b         	ldr	r3, [r7, #0x4]
 8002cda: 2201         	movs	r2, #0x1
 8002cdc: f8a3 20b8    	strh.w	r2, [r3, #0xb8]
; 	kf->temp_vector.numCols = kf->temp_vector1.numRows;
 8002ce0: 687b         	ldr	r3, [r7, #0x4]
 8002ce2: f8b3 20c0    	ldrh.w	r2, [r3, #0xc0]
 8002ce6: 687b         	ldr	r3, [r7, #0x4]
 8002ce8: f8a3 20ba    	strh.w	r2, [r3, #0xba]
; 	kf->MatStatus = Matrix_Transpose(&kf->temp_vector1,
 8002cec: 687b         	ldr	r3, [r7, #0x4]
 8002cee: f103 02c0    	add.w	r2, r3, #0xc0
 8002cf2: 687b         	ldr	r3, [r7, #0x4]
 8002cf4: 33b8         	adds	r3, #0xb8
 8002cf6: 4619         	mov	r1, r3
 8002cf8: 4610         	mov	r0, r2
 8002cfa: f00a f973    	bl	0x800cfe4 <arm_mat_trans_f32> @ imm = #0xa2e6
 8002cfe: 4603         	mov	r3, r0
 8002d00: 461a         	mov	r2, r3
 8002d02: 687b         	ldr	r3, [r7, #0x4]
 8002d04: f883 20c8    	strb.w	r2, [r3, #0xc8]
; 	kf->MatStatus = Matrix_Multiply(&kf->temp_vector, &kf->temp_matrix, &QEKF_INS.ChiSquare);
 8002d08: 687b         	ldr	r3, [r7, #0x4]
 8002d0a: f103 00b8    	add.w	r0, r3, #0xb8
 8002d0e: 687b         	ldr	r3, [r7, #0x4]
 8002d10: 33a8         	adds	r3, #0xa8
 8002d12: 4a25         	ldr	r2, [pc, #0x94]         @ 0x8002da8 <IMU_QuaternionEKF_xhatUpdate+0x3a4>
 8002d14: 4619         	mov	r1, r3
 8002d16: f00a f8cb    	bl	0x800ceb0 <arm_mat_mult_f32> @ imm = #0xa196
 8002d1a: 4603         	mov	r3, r0
 8002d1c: 461a         	mov	r2, r3
 8002d1e: 687b         	ldr	r3, [r7, #0x4]
 8002d20: f883 20c8    	strb.w	r2, [r3, #0xc8]
; 	if (QEKF_INS.ChiSquare_Data[0] < 0.5f * QEKF_INS.ChiSquareTestThreshold) {
 8002d24: 4b1f         	ldr	r3, [pc, #0x7c]         @ 0x8002da4 <IMU_QuaternionEKF_xhatUpdate+0x3a0>
 8002d26: f8d3 61c8    	ldr.w	r6, [r3, #0x1c8]
 8002d2a: 4b1e         	ldr	r3, [pc, #0x78]         @ 0x8002da4 <IMU_QuaternionEKF_xhatUpdate+0x3a0>
 8002d2c: f8d3 31cc    	ldr.w	r3, [r3, #0x1cc]
 8002d30: f04f 517c    	mov.w	r1, #0x3f000000
 8002d34: 4618         	mov	r0, r3
 8002d36: f7fd fb35    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x2996
 8002d3a: 4603         	mov	r3, r0
 8002d3c: 4619         	mov	r1, r3
 8002d3e: 4630         	mov	r0, r6
 8002d40: f7fd fcce    	bl	0x80006e0 <__aeabi_fcmplt> @ imm = #-0x2664
 8002d44: 4603         	mov	r3, r0
 8002d46: 2b00         	cmp	r3, #0x0
 8002d48: d003         	beq	0x8002d52 <IMU_QuaternionEKF_xhatUpdate+0x34e> @ imm = #0x6
; 		QEKF_INS.ConvergeFlag = 1;
 8002d4a: 4b16         	ldr	r3, [pc, #0x58]         @ 0x8002da4 <IMU_QuaternionEKF_xhatUpdate+0x3a0>
 8002d4c: 2201         	movs	r2, #0x1
 8002d4e: f883 2138    	strb.w	r2, [r3, #0x138]
; 	if (QEKF_INS.ChiSquare_Data[0] > QEKF_INS.ChiSquareTestThreshold && QEKF_INS.ConvergeFlag) {
 8002d52: 4b14         	ldr	r3, [pc, #0x50]         @ 0x8002da4 <IMU_QuaternionEKF_xhatUpdate+0x3a0>
 8002d54: f8d3 31c8    	ldr.w	r3, [r3, #0x1c8]
 8002d58: 4a12         	ldr	r2, [pc, #0x48]         @ 0x8002da4 <IMU_QuaternionEKF_xhatUpdate+0x3a0>
 8002d5a: f8d2 21cc    	ldr.w	r2, [r2, #0x1cc]
 8002d5e: 4611         	mov	r1, r2
 8002d60: 4618         	mov	r0, r3
 8002d62: f7fd fcdb    	bl	0x800071c <__aeabi_fcmpgt> @ imm = #-0x264a
 8002d66: 4603         	mov	r3, r0
 8002d68: 2b00         	cmp	r3, #0x0
 8002d6a: d05f         	beq	0x8002e2c <IMU_QuaternionEKF_xhatUpdate+0x428> @ imm = #0xbe
 8002d6c: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x8002da4 <IMU_QuaternionEKF_xhatUpdate+0x3a0>
 8002d6e: f893 3138    	ldrb.w	r3, [r3, #0x138]
 8002d72: 2b00         	cmp	r3, #0x0
 8002d74: d05a         	beq	0x8002e2c <IMU_QuaternionEKF_xhatUpdate+0x428> @ imm = #0xb4
; 		if (QEKF_INS.StableFlag) {
 8002d76: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x8002da4 <IMU_QuaternionEKF_xhatUpdate+0x3a0>
 8002d78: f893 3139    	ldrb.w	r3, [r3, #0x139]
 8002d7c: 2b00         	cmp	r3, #0x0
 8002d7e: d015         	beq	0x8002dac <IMU_QuaternionEKF_xhatUpdate+0x3a8> @ imm = #0x2a
; 			QEKF_INS.ErrorCount++; // 载体静止时仍无法通过卡方检验
 8002d80: 4b08         	ldr	r3, [pc, #0x20]         @ 0x8002da4 <IMU_QuaternionEKF_xhatUpdate+0x3a0>
 8002d82: e9d3 2350    	ldrd	r2, r3, [r3, #320]
 8002d86: 1c54         	adds	r4, r2, #0x1
 8002d88: f143 0500    	adc	r5, r3, #0x0
 8002d8c: 4b05         	ldr	r3, [pc, #0x14]         @ 0x8002da4 <IMU_QuaternionEKF_xhatUpdate+0x3a0>
 8002d8e: e9c3 4550    	strd	r4, r5, [r3, #320]
 8002d92: e012         	b	0x8002dba <IMU_QuaternionEKF_xhatUpdate+0x3b6> @ imm = #0x24

08002d94 <$d>:
 8002d94: d0 1b 00 20  	.word	0x20001bd0
 8002d98: d4 1b 00 20  	.word	0x20001bd4
 8002d9c: d8 1b 00 20  	.word	0x20001bd8
 8002da0: dc 1b 00 20  	.word	0x20001bdc
 8002da4: f8 06 00 20  	.word	0x200006f8
 8002da8: b8 08 00 20  	.word	0x200008b8

08002dac <$t>:
; 			QEKF_INS.ErrorCount = 0;
 8002dac: 499a         	ldr	r1, [pc, #0x268]        @ 0x8003018 <IMU_QuaternionEKF_xhatUpdate+0x614>
 8002dae: f04f 0200    	mov.w	r2, #0x0
 8002db2: f04f 0300    	mov.w	r3, #0x0
 8002db6: e9c1 2350    	strd	r2, r3, [r1, #320]
; 		if (QEKF_INS.ErrorCount > 50) {
 8002dba: 4b97         	ldr	r3, [pc, #0x25c]        @ 0x8003018 <IMU_QuaternionEKF_xhatUpdate+0x614>
 8002dbc: e9d3 2350    	ldrd	r2, r3, [r3, #320]
 8002dc0: 2a33         	cmp	r2, #0x33
 8002dc2: f173 0300    	sbcs	r3, r3, #0x0
 8002dc6: d308         	blo	0x8002dda <IMU_QuaternionEKF_xhatUpdate+0x3d6> @ imm = #0x10
; 			QEKF_INS.ConvergeFlag = 0;
 8002dc8: 4b93         	ldr	r3, [pc, #0x24c]        @ 0x8003018 <IMU_QuaternionEKF_xhatUpdate+0x614>
 8002dca: 2200         	movs	r2, #0x0
 8002dcc: f883 2138    	strb.w	r2, [r3, #0x138]
; 			kf->SkipEq5 = FALSE; // step-5 is cov mat P updating
 8002dd0: 687b         	ldr	r3, [r7, #0x4]
 8002dd2: 2200         	movs	r2, #0x0
 8002dd4: f883 202c    	strb.w	r2, [r3, #0x2c]
; 		if (QEKF_INS.ErrorCount > 50) {
 8002dd8: e06d         	b	0x8002eb6 <IMU_QuaternionEKF_xhatUpdate+0x4b2> @ imm = #0xda
; 			memcpy(kf->xhat_data, kf->xhatminus_data, sizeof_float * kf->xhatSize);
 8002dda: 687b         	ldr	r3, [r7, #0x4]
 8002ddc: f8d3 00e8    	ldr.w	r0, [r3, #0xe8]
 8002de0: 687b         	ldr	r3, [r7, #0x4]
 8002de2: f8d3 10ec    	ldr.w	r1, [r3, #0xec]
 8002de6: 4b8d         	ldr	r3, [pc, #0x234]        @ 0x800301c <IMU_QuaternionEKF_xhatUpdate+0x618>
 8002de8: 881b         	ldrh	r3, [r3]
 8002dea: 461a         	mov	r2, r3
 8002dec: 687b         	ldr	r3, [r7, #0x4]
 8002dee: 7b1b         	ldrb	r3, [r3, #0xc]
 8002df0: fb02 f303    	mul	r3, r2, r3
 8002df4: 461a         	mov	r2, r3
 8002df6: f01a fceb    	bl	0x801d7d0 <memcpy>      @ imm = #0x1a9d6
; 			memcpy(kf->P_data, kf->Pminus_data,
 8002dfa: 687b         	ldr	r3, [r7, #0x4]
 8002dfc: f8d3 00f8    	ldr.w	r0, [r3, #0xf8]
 8002e00: 687b         	ldr	r3, [r7, #0x4]
 8002e02: f8d3 10fc    	ldr.w	r1, [r3, #0xfc]
; 			       sizeof_float * kf->xhatSize * kf->xhatSize);
 8002e06: 4b85         	ldr	r3, [pc, #0x214]        @ 0x800301c <IMU_QuaternionEKF_xhatUpdate+0x618>
 8002e08: 881b         	ldrh	r3, [r3]
 8002e0a: 461a         	mov	r2, r3
 8002e0c: 687b         	ldr	r3, [r7, #0x4]
 8002e0e: 7b1b         	ldrb	r3, [r3, #0xc]
 8002e10: fb02 f303    	mul	r3, r2, r3
 8002e14: 687a         	ldr	r2, [r7, #0x4]
 8002e16: 7b12         	ldrb	r2, [r2, #0xc]
 8002e18: fb02 f303    	mul	r3, r2, r3
; 			memcpy(kf->P_data, kf->Pminus_data,
 8002e1c: 461a         	mov	r2, r3
 8002e1e: f01a fcd7    	bl	0x801d7d0 <memcpy>      @ imm = #0x1a9ae
; 			kf->SkipEq5 = TRUE; // part5 is P updating
 8002e22: 687b         	ldr	r3, [r7, #0x4]
 8002e24: 2201         	movs	r2, #0x1
 8002e26: f883 202c    	strb.w	r2, [r3, #0x2c]
; 			return;
 8002e2a: e164         	b	0x80030f6 <IMU_QuaternionEKF_xhatUpdate+0x6f2> @ imm = #0x2c8
; 		if (QEKF_INS.ChiSquare_Data[0] > 0.1f * QEKF_INS.ChiSquareTestThreshold &&
 8002e2c: 4b7a         	ldr	r3, [pc, #0x1e8]        @ 0x8003018 <IMU_QuaternionEKF_xhatUpdate+0x614>
 8002e2e: f8d3 41c8    	ldr.w	r4, [r3, #0x1c8]
 8002e32: 4b79         	ldr	r3, [pc, #0x1e4]        @ 0x8003018 <IMU_QuaternionEKF_xhatUpdate+0x614>
 8002e34: f8d3 31cc    	ldr.w	r3, [r3, #0x1cc]
 8002e38: 4979         	ldr	r1, [pc, #0x1e4]        @ 0x8003020 <IMU_QuaternionEKF_xhatUpdate+0x61c>
 8002e3a: 4618         	mov	r0, r3
 8002e3c: f7fd fab2    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x2a9c
 8002e40: 4603         	mov	r3, r0
 8002e42: 4619         	mov	r1, r3
 8002e44: 4620         	mov	r0, r4
 8002e46: f7fd fc69    	bl	0x800071c <__aeabi_fcmpgt> @ imm = #-0x272e
 8002e4a: 4603         	mov	r3, r0
 8002e4c: 2b00         	cmp	r3, #0x0
 8002e4e: d022         	beq	0x8002e96 <IMU_QuaternionEKF_xhatUpdate+0x492> @ imm = #0x44
; 		    QEKF_INS.ConvergeFlag) {
 8002e50: 4b71         	ldr	r3, [pc, #0x1c4]        @ 0x8003018 <IMU_QuaternionEKF_xhatUpdate+0x614>
 8002e52: f893 3138    	ldrb.w	r3, [r3, #0x138]
; 		if (QEKF_INS.ChiSquare_Data[0] > 0.1f * QEKF_INS.ChiSquareTestThreshold &&
 8002e56: 2b00         	cmp	r3, #0x0
 8002e58: d01d         	beq	0x8002e96 <IMU_QuaternionEKF_xhatUpdate+0x492> @ imm = #0x3a
; 				(QEKF_INS.ChiSquareTestThreshold - QEKF_INS.ChiSquare_Data[0]) /
 8002e5a: 4b6f         	ldr	r3, [pc, #0x1bc]        @ 0x8003018 <IMU_QuaternionEKF_xhatUpdate+0x614>
 8002e5c: f8d3 31cc    	ldr.w	r3, [r3, #0x1cc]
 8002e60: 4a6d         	ldr	r2, [pc, #0x1b4]        @ 0x8003018 <IMU_QuaternionEKF_xhatUpdate+0x614>
 8002e62: f8d2 21c8    	ldr.w	r2, [r2, #0x1c8]
 8002e66: 4611         	mov	r1, r2
 8002e68: 4618         	mov	r0, r3
 8002e6a: f7fd f991    	bl	0x8000190 <__subsf3>    @ imm = #-0x2cde
 8002e6e: 4603         	mov	r3, r0
 8002e70: 461c         	mov	r4, r3
; 				(0.9f * QEKF_INS.ChiSquareTestThreshold);
 8002e72: 4b69         	ldr	r3, [pc, #0x1a4]        @ 0x8003018 <IMU_QuaternionEKF_xhatUpdate+0x614>
 8002e74: f8d3 31cc    	ldr.w	r3, [r3, #0x1cc]
 8002e78: 496a         	ldr	r1, [pc, #0x1a8]        @ 0x8003024 <IMU_QuaternionEKF_xhatUpdate+0x620>
 8002e7a: 4618         	mov	r0, r3
 8002e7c: f7fd fa92    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x2adc
 8002e80: 4603         	mov	r3, r0
; 				(QEKF_INS.ChiSquareTestThreshold - QEKF_INS.ChiSquare_Data[0]) /
 8002e82: 4619         	mov	r1, r3
 8002e84: 4620         	mov	r0, r4
 8002e86: f7fd fb41    	bl	0x800050c <__divsf3>    @ imm = #-0x297e
 8002e8a: 4603         	mov	r3, r0
 8002e8c: 461a         	mov	r2, r3
; 			QEKF_INS.AdaptiveGainScale =
 8002e8e: 4b62         	ldr	r3, [pc, #0x188]        @ 0x8003018 <IMU_QuaternionEKF_xhatUpdate+0x614>
 8002e90: f8c3 219c    	str.w	r2, [r3, #0x19c]
 8002e94: e004         	b	0x8002ea0 <IMU_QuaternionEKF_xhatUpdate+0x49c> @ imm = #0x8
; 			QEKF_INS.AdaptiveGainScale = 1;
 8002e96: 4b60         	ldr	r3, [pc, #0x180]        @ 0x8003018 <IMU_QuaternionEKF_xhatUpdate+0x614>
 8002e98: f04f 527e    	mov.w	r2, #0x3f800000
 8002e9c: f8c3 219c    	str.w	r2, [r3, #0x19c]
; 		QEKF_INS.ErrorCount = 0;
 8002ea0: 495d         	ldr	r1, [pc, #0x174]        @ 0x8003018 <IMU_QuaternionEKF_xhatUpdate+0x614>
 8002ea2: f04f 0200    	mov.w	r2, #0x0
 8002ea6: f04f 0300    	mov.w	r3, #0x0
 8002eaa: e9c1 2350    	strd	r2, r3, [r1, #320]
; 		kf->SkipEq5 = FALSE;
 8002eae: 687b         	ldr	r3, [r7, #0x4]
 8002eb0: 2200         	movs	r2, #0x0
 8002eb2: f883 202c    	strb.w	r2, [r3, #0x2c]
; 	kf->temp_matrix.numRows = kf->Pminus.numRows;
 8002eb6: 687b         	ldr	r3, [r7, #0x4]
 8002eb8: f8b3 2058    	ldrh.w	r2, [r3, #0x58]
 8002ebc: 687b         	ldr	r3, [r7, #0x4]
 8002ebe: f8a3 20a8    	strh.w	r2, [r3, #0xa8]
; 	kf->temp_matrix.numCols = kf->HT.numCols;
 8002ec2: 687b         	ldr	r3, [r7, #0x4]
 8002ec4: f8b3 2082    	ldrh.w	r2, [r3, #0x82]
 8002ec8: 687b         	ldr	r3, [r7, #0x4]
 8002eca: f8a3 20aa    	strh.w	r2, [r3, #0xaa]
; 		Matrix_Multiply(&kf->Pminus, &kf->HT, &kf->temp_matrix); // temp_matrix = P'(k)·HT
 8002ece: 687b         	ldr	r3, [r7, #0x4]
 8002ed0: f103 0058    	add.w	r0, r3, #0x58
 8002ed4: 687b         	ldr	r3, [r7, #0x4]
 8002ed6: f103 0180    	add.w	r1, r3, #0x80
 8002eda: 687b         	ldr	r3, [r7, #0x4]
 8002edc: 33a8         	adds	r3, #0xa8
 8002ede: 461a         	mov	r2, r3
 8002ee0: f009 ffe6    	bl	0x800ceb0 <arm_mat_mult_f32> @ imm = #0x9fcc
 8002ee4: 4603         	mov	r3, r0
 8002ee6: 461a         	mov	r2, r3
; 	kf->MatStatus =
 8002ee8: 687b         	ldr	r3, [r7, #0x4]
 8002eea: f883 20c8    	strb.w	r2, [r3, #0xc8]
; 	kf->MatStatus = Matrix_Multiply(&kf->temp_matrix, &kf->temp_matrix1, &kf->K);
 8002eee: 687b         	ldr	r3, [r7, #0x4]
 8002ef0: f103 00a8    	add.w	r0, r3, #0xa8
 8002ef4: 687b         	ldr	r3, [r7, #0x4]
 8002ef6: f103 01b0    	add.w	r1, r3, #0xb0
 8002efa: 687b         	ldr	r3, [r7, #0x4]
 8002efc: 3398         	adds	r3, #0x98
 8002efe: 461a         	mov	r2, r3
 8002f00: f009 ffd6    	bl	0x800ceb0 <arm_mat_mult_f32> @ imm = #0x9fac
 8002f04: 4603         	mov	r3, r0
 8002f06: 461a         	mov	r2, r3
 8002f08: 687b         	ldr	r3, [r7, #0x4]
 8002f0a: f883 20c8    	strb.w	r2, [r3, #0xc8]
; 	for (uint8_t i = 0; i < kf->K.numRows * kf->K.numCols; ++i) {
 8002f0e: 2300         	movs	r3, #0x0
 8002f10: 73bb         	strb	r3, [r7, #0xe]
 8002f12: e016         	b	0x8002f42 <IMU_QuaternionEKF_xhatUpdate+0x53e> @ imm = #0x2c
; 		kf->K_data[i] *= QEKF_INS.AdaptiveGainScale;
 8002f14: 687b         	ldr	r3, [r7, #0x4]
 8002f16: f8d3 211c    	ldr.w	r2, [r3, #0x11c]
 8002f1a: 7bbb         	ldrb	r3, [r7, #0xe]
 8002f1c: 009b         	lsls	r3, r3, #0x2
 8002f1e: 4413         	add	r3, r2
 8002f20: 6818         	ldr	r0, [r3]
 8002f22: 4b3d         	ldr	r3, [pc, #0xf4]         @ 0x8003018 <IMU_QuaternionEKF_xhatUpdate+0x614>
 8002f24: f8d3 119c    	ldr.w	r1, [r3, #0x19c]
 8002f28: 687b         	ldr	r3, [r7, #0x4]
 8002f2a: f8d3 211c    	ldr.w	r2, [r3, #0x11c]
 8002f2e: 7bbb         	ldrb	r3, [r7, #0xe]
 8002f30: 009b         	lsls	r3, r3, #0x2
 8002f32: 18d4         	adds	r4, r2, r3
 8002f34: f7fd fa36    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x2b94
 8002f38: 4603         	mov	r3, r0
 8002f3a: 6023         	str	r3, [r4]
; 	for (uint8_t i = 0; i < kf->K.numRows * kf->K.numCols; ++i) {
 8002f3c: 7bbb         	ldrb	r3, [r7, #0xe]
 8002f3e: 3301         	adds	r3, #0x1
 8002f40: 73bb         	strb	r3, [r7, #0xe]
 8002f42: 7bba         	ldrb	r2, [r7, #0xe]
 8002f44: 687b         	ldr	r3, [r7, #0x4]
 8002f46: f8b3 3098    	ldrh.w	r3, [r3, #0x98]
 8002f4a: 4619         	mov	r1, r3
 8002f4c: 687b         	ldr	r3, [r7, #0x4]
 8002f4e: f8b3 309a    	ldrh.w	r3, [r3, #0x9a]
 8002f52: fb01 f303    	mul	r3, r1, r3
 8002f56: 429a         	cmp	r2, r3
 8002f58: dbdc         	blt	0x8002f14 <IMU_QuaternionEKF_xhatUpdate+0x510> @ imm = #-0x48
; 	for (uint8_t i = 4; i < 6; ++i) {
 8002f5a: 2304         	movs	r3, #0x4
 8002f5c: 737b         	strb	r3, [r7, #0xd]
 8002f5e: e035         	b	0x8002fcc <IMU_QuaternionEKF_xhatUpdate+0x5c8> @ imm = #0x6a
; 		for (uint8_t j = 0; j < 3; ++j) {
 8002f60: 2300         	movs	r3, #0x0
 8002f62: 733b         	strb	r3, [r7, #0xc]
 8002f64: e02c         	b	0x8002fc0 <IMU_QuaternionEKF_xhatUpdate+0x5bc> @ imm = #0x58
; 			kf->K_data[i * 3 + j] *=
 8002f66: 687b         	ldr	r3, [r7, #0x4]
 8002f68: f8d3 111c    	ldr.w	r1, [r3, #0x11c]
 8002f6c: 7b7a         	ldrb	r2, [r7, #0xd]
 8002f6e: 4613         	mov	r3, r2
 8002f70: 005b         	lsls	r3, r3, #0x1
 8002f72: 441a         	add	r2, r3
 8002f74: 7b3b         	ldrb	r3, [r7, #0xc]
 8002f76: 4413         	add	r3, r2
 8002f78: 009b         	lsls	r3, r3, #0x2
 8002f7a: 440b         	add	r3, r1
 8002f7c: 681d         	ldr	r5, [r3]
; 				QEKF_INS.OrientationCosine[i - 4] / 1.5707963f; // 1 rad
 8002f7e: 7b7b         	ldrb	r3, [r7, #0xd]
 8002f80: 3b04         	subs	r3, #0x4
 8002f82: 4a25         	ldr	r2, [pc, #0x94]         @ 0x8003018 <IMU_QuaternionEKF_xhatUpdate+0x614>
 8002f84: 3360         	adds	r3, #0x60
 8002f86: 009b         	lsls	r3, r3, #0x2
 8002f88: 4413         	add	r3, r2
 8002f8a: 685b         	ldr	r3, [r3, #0x4]
 8002f8c: 4926         	ldr	r1, [pc, #0x98]         @ 0x8003028 <IMU_QuaternionEKF_xhatUpdate+0x624>
 8002f8e: 4618         	mov	r0, r3
 8002f90: f7fd fabc    	bl	0x800050c <__divsf3>    @ imm = #-0x2a88
 8002f94: 4603         	mov	r3, r0
 8002f96: 4618         	mov	r0, r3
; 			kf->K_data[i * 3 + j] *=
 8002f98: 687b         	ldr	r3, [r7, #0x4]
 8002f9a: f8d3 111c    	ldr.w	r1, [r3, #0x11c]
 8002f9e: 7b7a         	ldrb	r2, [r7, #0xd]
 8002fa0: 4613         	mov	r3, r2
 8002fa2: 005b         	lsls	r3, r3, #0x1
 8002fa4: 441a         	add	r2, r3
 8002fa6: 7b3b         	ldrb	r3, [r7, #0xc]
 8002fa8: 4413         	add	r3, r2
 8002faa: 009b         	lsls	r3, r3, #0x2
 8002fac: 18cc         	adds	r4, r1, r3
 8002fae: 4601         	mov	r1, r0
 8002fb0: 4628         	mov	r0, r5
 8002fb2: f7fd f9f7    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x2c12
 8002fb6: 4603         	mov	r3, r0
 8002fb8: 6023         	str	r3, [r4]
; 		for (uint8_t j = 0; j < 3; ++j) {
 8002fba: 7b3b         	ldrb	r3, [r7, #0xc]
 8002fbc: 3301         	adds	r3, #0x1
 8002fbe: 733b         	strb	r3, [r7, #0xc]
 8002fc0: 7b3b         	ldrb	r3, [r7, #0xc]
 8002fc2: 2b02         	cmp	r3, #0x2
 8002fc4: d9cf         	bls	0x8002f66 <IMU_QuaternionEKF_xhatUpdate+0x562> @ imm = #-0x62
; 	for (uint8_t i = 4; i < 6; ++i) {
 8002fc6: 7b7b         	ldrb	r3, [r7, #0xd]
 8002fc8: 3301         	adds	r3, #0x1
 8002fca: 737b         	strb	r3, [r7, #0xd]
 8002fcc: 7b7b         	ldrb	r3, [r7, #0xd]
 8002fce: 2b05         	cmp	r3, #0x5
 8002fd0: d9c6         	bls	0x8002f60 <IMU_QuaternionEKF_xhatUpdate+0x55c> @ imm = #-0x74
; 	kf->temp_vector.numRows = kf->K.numRows;
 8002fd2: 687b         	ldr	r3, [r7, #0x4]
 8002fd4: f8b3 2098    	ldrh.w	r2, [r3, #0x98]
 8002fd8: 687b         	ldr	r3, [r7, #0x4]
 8002fda: f8a3 20b8    	strh.w	r2, [r3, #0xb8]
; 	kf->temp_vector.numCols = 1;
 8002fde: 687b         	ldr	r3, [r7, #0x4]
 8002fe0: 2201         	movs	r2, #0x1
 8002fe2: f8a3 20ba    	strh.w	r2, [r3, #0xba]
; 	kf->MatStatus = Matrix_Multiply(&kf->K, &kf->temp_vector1,
 8002fe6: 687b         	ldr	r3, [r7, #0x4]
 8002fe8: f103 0098    	add.w	r0, r3, #0x98
 8002fec: 687b         	ldr	r3, [r7, #0x4]
 8002fee: f103 01c0    	add.w	r1, r3, #0xc0
 8002ff2: 687b         	ldr	r3, [r7, #0x4]
 8002ff4: 33b8         	adds	r3, #0xb8
 8002ff6: 461a         	mov	r2, r3
 8002ff8: f009 ff5a    	bl	0x800ceb0 <arm_mat_mult_f32> @ imm = #0x9eb4
 8002ffc: 4603         	mov	r3, r0
 8002ffe: 461a         	mov	r2, r3
 8003000: 687b         	ldr	r3, [r7, #0x4]
 8003002: f883 20c8    	strb.w	r2, [r3, #0xc8]
; 	if (QEKF_INS.ConvergeFlag) {
 8003006: 4b04         	ldr	r3, [pc, #0x10]         @ 0x8003018 <IMU_QuaternionEKF_xhatUpdate+0x614>
 8003008: f893 3138    	ldrb.w	r3, [r3, #0x138]
 800300c: 2b00         	cmp	r3, #0x0
 800300e: d05b         	beq	0x80030c8 <IMU_QuaternionEKF_xhatUpdate+0x6c4> @ imm = #0xb6
; 		for (uint8_t i = 4; i < 6; ++i) {
 8003010: 2304         	movs	r3, #0x4
 8003012: 72fb         	strb	r3, [r7, #0xb]
 8003014: e055         	b	0x80030c2 <IMU_QuaternionEKF_xhatUpdate+0x6be> @ imm = #0xaa
 8003016: bf00         	nop

08003018 <$d>:
 8003018: f8 06 00 20  	.word	0x200006f8
 800301c: 84 1f 00 20  	.word	0x20001f84
 8003020: cd cc cc 3d  	.word	0x3dcccccd
 8003024: 66 66 66 3f  	.word	0x3f666666
 8003028: da 0f c9 3f  	.word	0x3fc90fda

0800302c <$t>:
; 			if (kf->temp_vector.pData[i] > 1e-2f * QEKF_INS.dt) {
 800302c: 687b         	ldr	r3, [r7, #0x4]
 800302e: f8d3 20bc    	ldr.w	r2, [r3, #0xbc]
 8003032: 7afb         	ldrb	r3, [r7, #0xb]
 8003034: 009b         	lsls	r3, r3, #0x2
 8003036: 4413         	add	r3, r2
 8003038: 681c         	ldr	r4, [r3]
 800303a: 4b31         	ldr	r3, [pc, #0xc4]         @ 0x8003100 <IMU_QuaternionEKF_xhatUpdate+0x6fc>
 800303c: f8d3 31bc    	ldr.w	r3, [r3, #0x1bc]
 8003040: 4930         	ldr	r1, [pc, #0xc0]         @ 0x8003104 <IMU_QuaternionEKF_xhatUpdate+0x700>
 8003042: 4618         	mov	r0, r3
 8003044: f7fd f9ae    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x2ca4
 8003048: 4603         	mov	r3, r0
 800304a: 4619         	mov	r1, r3
 800304c: 4620         	mov	r0, r4
 800304e: f7fd fb65    	bl	0x800071c <__aeabi_fcmpgt> @ imm = #-0x2936
 8003052: 4603         	mov	r3, r0
 8003054: 2b00         	cmp	r3, #0x0
 8003056: d00d         	beq	0x8003074 <IMU_QuaternionEKF_xhatUpdate+0x670> @ imm = #0x1a
; 				kf->temp_vector.pData[i] = 1e-2f * QEKF_INS.dt;
 8003058: 4b29         	ldr	r3, [pc, #0xa4]         @ 0x8003100 <IMU_QuaternionEKF_xhatUpdate+0x6fc>
 800305a: f8d3 01bc    	ldr.w	r0, [r3, #0x1bc]
 800305e: 687b         	ldr	r3, [r7, #0x4]
 8003060: f8d3 20bc    	ldr.w	r2, [r3, #0xbc]
 8003064: 7afb         	ldrb	r3, [r7, #0xb]
 8003066: 009b         	lsls	r3, r3, #0x2
 8003068: 18d4         	adds	r4, r2, r3
 800306a: 4926         	ldr	r1, [pc, #0x98]         @ 0x8003104 <IMU_QuaternionEKF_xhatUpdate+0x700>
 800306c: f7fd f99a    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x2ccc
 8003070: 4603         	mov	r3, r0
 8003072: 6023         	str	r3, [r4]
; 			if (kf->temp_vector.pData[i] < -1e-2f * QEKF_INS.dt) {
 8003074: 687b         	ldr	r3, [r7, #0x4]
 8003076: f8d3 20bc    	ldr.w	r2, [r3, #0xbc]
 800307a: 7afb         	ldrb	r3, [r7, #0xb]
 800307c: 009b         	lsls	r3, r3, #0x2
 800307e: 4413         	add	r3, r2
 8003080: 681c         	ldr	r4, [r3]
 8003082: 4b1f         	ldr	r3, [pc, #0x7c]         @ 0x8003100 <IMU_QuaternionEKF_xhatUpdate+0x6fc>
 8003084: f8d3 31bc    	ldr.w	r3, [r3, #0x1bc]
 8003088: 491f         	ldr	r1, [pc, #0x7c]         @ 0x8003108 <IMU_QuaternionEKF_xhatUpdate+0x704>
 800308a: 4618         	mov	r0, r3
 800308c: f7fd f98a    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x2cec
 8003090: 4603         	mov	r3, r0
 8003092: 4619         	mov	r1, r3
 8003094: 4620         	mov	r0, r4
 8003096: f7fd fb23    	bl	0x80006e0 <__aeabi_fcmplt> @ imm = #-0x29ba
 800309a: 4603         	mov	r3, r0
 800309c: 2b00         	cmp	r3, #0x0
 800309e: d00d         	beq	0x80030bc <IMU_QuaternionEKF_xhatUpdate+0x6b8> @ imm = #0x1a
; 				kf->temp_vector.pData[i] = -1e-2f * QEKF_INS.dt;
 80030a0: 4b17         	ldr	r3, [pc, #0x5c]         @ 0x8003100 <IMU_QuaternionEKF_xhatUpdate+0x6fc>
 80030a2: f8d3 01bc    	ldr.w	r0, [r3, #0x1bc]
 80030a6: 687b         	ldr	r3, [r7, #0x4]
 80030a8: f8d3 20bc    	ldr.w	r2, [r3, #0xbc]
 80030ac: 7afb         	ldrb	r3, [r7, #0xb]
 80030ae: 009b         	lsls	r3, r3, #0x2
 80030b0: 18d4         	adds	r4, r2, r3
 80030b2: 4915         	ldr	r1, [pc, #0x54]         @ 0x8003108 <IMU_QuaternionEKF_xhatUpdate+0x704>
 80030b4: f7fd f976    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x2d14
 80030b8: 4603         	mov	r3, r0
 80030ba: 6023         	str	r3, [r4]
; 		for (uint8_t i = 4; i < 6; ++i) {
 80030bc: 7afb         	ldrb	r3, [r7, #0xb]
 80030be: 3301         	adds	r3, #0x1
 80030c0: 72fb         	strb	r3, [r7, #0xb]
 80030c2: 7afb         	ldrb	r3, [r7, #0xb]
 80030c4: 2b05         	cmp	r3, #0x5
 80030c6: d9b1         	bls	0x800302c <IMU_QuaternionEKF_xhatUpdate+0x628> @ imm = #-0x9e
; 	kf->temp_vector.pData[3] = 0;
 80030c8: 687b         	ldr	r3, [r7, #0x4]
 80030ca: f8d3 30bc    	ldr.w	r3, [r3, #0xbc]
 80030ce: 330c         	adds	r3, #0xc
 80030d0: f04f 0200    	mov.w	r2, #0x0
 80030d4: 601a         	str	r2, [r3]
; 	kf->MatStatus = Matrix_Add(&kf->xhatminus, &kf->temp_vector, &kf->xhat);
 80030d6: 687b         	ldr	r3, [r7, #0x4]
 80030d8: f103 0038    	add.w	r0, r3, #0x38
 80030dc: 687b         	ldr	r3, [r7, #0x4]
 80030de: f103 01b8    	add.w	r1, r3, #0xb8
 80030e2: 687b         	ldr	r3, [r7, #0x4]
 80030e4: 3330         	adds	r3, #0x30
 80030e6: 461a         	mov	r2, r3
 80030e8: f009 fd0e    	bl	0x800cb08 <arm_mat_add_f32> @ imm = #0x9a1c
 80030ec: 4603         	mov	r3, r0
 80030ee: 461a         	mov	r2, r3
 80030f0: 687b         	ldr	r3, [r7, #0x4]
 80030f2: f883 20c8    	strb.w	r2, [r3, #0xc8]
; }
 80030f6: 3710         	adds	r7, #0x10
 80030f8: 46bd         	mov	sp, r7
 80030fa: e8bd 81f0    	pop.w	{r4, r5, r6, r7, r8, pc}
 80030fe: bf00         	nop

08003100 <$d>:
 8003100: f8 06 00 20  	.word	0x200006f8
 8003104: 0a d7 23 3c  	.word	0x3c23d70a
 8003108: 0a d7 23 bc  	.word	0xbc23d70a

0800310c <IMU_QuaternionEKF_Observe>:
; {
 800310c: b580         	push	{r7, lr}
 800310e: b082         	sub	sp, #0x8
 8003110: af00         	add	r7, sp, #0x0
 8003112: 6078         	str	r0, [r7, #0x4]
; 	memcpy(IMU_QuaternionEKF_P, kf->P_data, sizeof(IMU_QuaternionEKF_P));
 8003114: 687b         	ldr	r3, [r7, #0x4]
 8003116: f8d3 30f8    	ldr.w	r3, [r3, #0xf8]
 800311a: 2290         	movs	r2, #0x90
 800311c: 4619         	mov	r1, r3
 800311e: 480b         	ldr	r0, [pc, #0x2c]         @ 0x800314c <IMU_QuaternionEKF_Observe+0x40>
 8003120: f01a fb56    	bl	0x801d7d0 <memcpy>      @ imm = #0x1a6ac
; 	memcpy(IMU_QuaternionEKF_K, kf->K_data, sizeof(IMU_QuaternionEKF_K));
 8003124: 687b         	ldr	r3, [r7, #0x4]
 8003126: f8d3 311c    	ldr.w	r3, [r3, #0x11c]
 800312a: 2248         	movs	r2, #0x48
 800312c: 4619         	mov	r1, r3
 800312e: 4808         	ldr	r0, [pc, #0x20]         @ 0x8003150 <IMU_QuaternionEKF_Observe+0x44>
 8003130: f01a fb4e    	bl	0x801d7d0 <memcpy>      @ imm = #0x1a69c
; 	memcpy(IMU_QuaternionEKF_H, kf->H_data, sizeof(IMU_QuaternionEKF_H));
 8003134: 687b         	ldr	r3, [r7, #0x4]
 8003136: f8d3 310c    	ldr.w	r3, [r3, #0x10c]
 800313a: 2248         	movs	r2, #0x48
 800313c: 4619         	mov	r1, r3
 800313e: 4805         	ldr	r0, [pc, #0x14]         @ 0x8003154 <IMU_QuaternionEKF_Observe+0x48>
 8003140: f01a fb46    	bl	0x801d7d0 <memcpy>      @ imm = #0x1a68c
; }
 8003144: bf00         	nop
 8003146: 3708         	adds	r7, #0x8
 8003148: 46bd         	mov	sp, r7
 800314a: bd80         	pop	{r7, pc}

0800314c <$d>:
 800314c: 08 04 00 20  	.word	0x20000408
 8003150: b0 1a 00 20  	.word	0x20001ab0
 8003154: f8 1a 00 20  	.word	0x20001af8

08003158 <invSqrt>:
; {
 8003158: b580         	push	{r7, lr}
 800315a: b086         	sub	sp, #0x18
 800315c: af00         	add	r7, sp, #0x0
 800315e: 6078         	str	r0, [r7, #0x4]
; 	float halfx = 0.5f * x;
 8003160: f04f 517c    	mov.w	r1, #0x3f000000
 8003164: 6878         	ldr	r0, [r7, #0x4]
 8003166: f7fd f91d    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x2dc6
 800316a: 4603         	mov	r3, r0
 800316c: 617b         	str	r3, [r7, #0x14]
; 	float y = x;
 800316e: 687b         	ldr	r3, [r7, #0x4]
 8003170: 613b         	str	r3, [r7, #0x10]
; 	long i = *(long *)&y;
 8003172: f107 0310    	add.w	r3, r7, #0x10
 8003176: 681b         	ldr	r3, [r3]
 8003178: 60fb         	str	r3, [r7, #0xc]
; 	i = 0x5f375a86 - (i >> 1);
 800317a: 68fb         	ldr	r3, [r7, #0xc]
 800317c: 105a         	asrs	r2, r3, #0x1
 800317e: 4b13         	ldr	r3, [pc, #0x4c]         @ 0x80031cc <invSqrt+0x74>
 8003180: 1a9b         	subs	r3, r3, r2
 8003182: 60fb         	str	r3, [r7, #0xc]
; 	y = *(float *)&i;
 8003184: f107 030c    	add.w	r3, r7, #0xc
 8003188: 681b         	ldr	r3, [r3]
 800318a: 613b         	str	r3, [r7, #0x10]
; 	y = y * (1.5f - (halfx * y * y));
 800318c: 693b         	ldr	r3, [r7, #0x10]
 800318e: 6979         	ldr	r1, [r7, #0x14]
 8003190: 4618         	mov	r0, r3
 8003192: f7fd f907    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x2df2
 8003196: 4603         	mov	r3, r0
 8003198: 461a         	mov	r2, r3
 800319a: 693b         	ldr	r3, [r7, #0x10]
 800319c: 4619         	mov	r1, r3
 800319e: 4610         	mov	r0, r2
 80031a0: f7fd f900    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x2e00
 80031a4: 4603         	mov	r3, r0
 80031a6: 4619         	mov	r1, r3
 80031a8: f04f 507f    	mov.w	r0, #0x3fc00000
 80031ac: f7fc fff0    	bl	0x8000190 <__subsf3>    @ imm = #-0x3020
 80031b0: 4603         	mov	r3, r0
 80031b2: 461a         	mov	r2, r3
 80031b4: 693b         	ldr	r3, [r7, #0x10]
 80031b6: 4619         	mov	r1, r3
 80031b8: 4610         	mov	r0, r2
 80031ba: f7fd f8f3    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x2e1a
 80031be: 4603         	mov	r3, r0
 80031c0: 613b         	str	r3, [r7, #0x10]
; 	return y;
 80031c2: 693b         	ldr	r3, [r7, #0x10]
; }
 80031c4: 4618         	mov	r0, r3
 80031c6: 3718         	adds	r7, #0x18
 80031c8: 46bd         	mov	sp, r7
 80031ca: bd80         	pop	{r7, pc}

080031cc <$d>:
 80031cc: 86 5a 37 5f  	.word	0x5f375a86

080031d0 <Sqrt>:
; {
 80031d0: b580         	push	{r7, lr}
 80031d2: b086         	sub	sp, #0x18
 80031d4: af00         	add	r7, sp, #0x0
 80031d6: 6078         	str	r0, [r7, #0x4]
; 	if (x <= 0) {
 80031d8: f04f 0100    	mov.w	r1, #0x0
 80031dc: 6878         	ldr	r0, [r7, #0x4]
 80031de: f7fd fa89    	bl	0x80006f4 <__aeabi_fcmple> @ imm = #-0x2aee
 80031e2: 4603         	mov	r3, r0
 80031e4: 2b00         	cmp	r3, #0x0
 80031e6: d002         	beq	0x80031ee <Sqrt+0x1e>   @ imm = #0x4
; 		return 0;
 80031e8: f04f 0300    	mov.w	r3, #0x0
 80031ec: e03a         	b	0x8003264 <Sqrt+0x94>   @ imm = #0x74
; 	y = x / 2;
 80031ee: f04f 4180    	mov.w	r1, #0x40000000
 80031f2: 6878         	ldr	r0, [r7, #0x4]
 80031f4: f7fd f98a    	bl	0x800050c <__divsf3>    @ imm = #-0x2cec
 80031f8: 4603         	mov	r3, r0
 80031fa: 617b         	str	r3, [r7, #0x14]
; 	maxError = x * 0.001f;
 80031fc: 491b         	ldr	r1, [pc, #0x6c]         @ 0x800326c <Sqrt+0x9c>
 80031fe: 6878         	ldr	r0, [r7, #0x4]
 8003200: f7fd f8d0    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x2e60
 8003204: 4603         	mov	r3, r0
 8003206: 613b         	str	r3, [r7, #0x10]
; 		delta = (y * y) - x;
 8003208: 6979         	ldr	r1, [r7, #0x14]
 800320a: 6978         	ldr	r0, [r7, #0x14]
 800320c: f7fd f8ca    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x2e6c
 8003210: 4603         	mov	r3, r0
 8003212: 6879         	ldr	r1, [r7, #0x4]
 8003214: 4618         	mov	r0, r3
 8003216: f7fc ffbb    	bl	0x8000190 <__subsf3>    @ imm = #-0x308a
 800321a: 4603         	mov	r3, r0
 800321c: 60fb         	str	r3, [r7, #0xc]
; 		y -= delta / (2 * y);
 800321e: 697b         	ldr	r3, [r7, #0x14]
 8003220: 4619         	mov	r1, r3
 8003222: 4618         	mov	r0, r3
 8003224: f7fc ffb6    	bl	0x8000194 <__aeabi_fadd> @ imm = #-0x3094
 8003228: 4603         	mov	r3, r0
 800322a: 4619         	mov	r1, r3
 800322c: 68f8         	ldr	r0, [r7, #0xc]
 800322e: f7fd f96d    	bl	0x800050c <__divsf3>    @ imm = #-0x2d26
 8003232: 4603         	mov	r3, r0
 8003234: 4619         	mov	r1, r3
 8003236: 6978         	ldr	r0, [r7, #0x14]
 8003238: f7fc ffaa    	bl	0x8000190 <__subsf3>    @ imm = #-0x30ac
 800323c: 4603         	mov	r3, r0
 800323e: 617b         	str	r3, [r7, #0x14]
; 	} while (delta > maxError || delta < -maxError);
 8003240: 6939         	ldr	r1, [r7, #0x10]
 8003242: 68f8         	ldr	r0, [r7, #0xc]
 8003244: f7fd fa6a    	bl	0x800071c <__aeabi_fcmpgt> @ imm = #-0x2b2c
 8003248: 4603         	mov	r3, r0
 800324a: 2b00         	cmp	r3, #0x0
 800324c: d1dc         	bne	0x8003208 <Sqrt+0x38>   @ imm = #-0x48
 800324e: 693b         	ldr	r3, [r7, #0x10]
 8003250: f083 4300    	eor	r3, r3, #0x80000000
 8003254: 4619         	mov	r1, r3
 8003256: 68f8         	ldr	r0, [r7, #0xc]
 8003258: f7fd fa42    	bl	0x80006e0 <__aeabi_fcmplt> @ imm = #-0x2b7c
 800325c: 4603         	mov	r3, r0
 800325e: 2b00         	cmp	r3, #0x0
 8003260: d1d2         	bne	0x8003208 <Sqrt+0x38>   @ imm = #-0x5c
; 	return y;
 8003262: 697b         	ldr	r3, [r7, #0x14]
; }
 8003264: 4618         	mov	r0, r3
 8003266: 3718         	adds	r7, #0x18
 8003268: 46bd         	mov	sp, r7
 800326a: bd80         	pop	{r7, pc}

0800326c <$d>:
 800326c: 6f 12 83 3a  	.word	0x3a83126f

08003270 <IMU_Sensor_handle_update>:
; {
 8003270: e92d 4ff0    	push.w	{r4, r5, r6, r7, r8, r9, r10, r11, lr}
 8003274: b089         	sub	sp, #0x24
 8003276: af04         	add	r7, sp, #0x10
 8003278: 6078         	str	r0, [r7, #0x4]
; 	if (data->flag < 3) {
 800327a: 6879         	ldr	r1, [r7, #0x4]
 800327c: f891 1024    	ldrb.w	r1, [r1, #0x24]
 8003280: 2902         	cmp	r1, #0x2
 8003282: f240 8099    	bls.w	0x80033b8 <IMU_Sensor_handle_update+0x148> @ imm = #0x132
; 	data->flag = 0;
 8003286: 6879         	ldr	r1, [r7, #0x4]
 8003288: 2000         	movs	r0, #0x0
 800328a: f881 0024    	strb.w	r0, [r1, #0x24]
; 	count++;
 800328e: 494d         	ldr	r1, [pc, #0x134]        @ 0x80033c4 <IMU_Sensor_handle_update+0x154>
 8003290: 6809         	ldr	r1, [r1]
 8003292: 3101         	adds	r1, #0x1
 8003294: 484b         	ldr	r0, [pc, #0x12c]        @ 0x80033c4 <IMU_Sensor_handle_update+0x154>
 8003296: 6001         	str	r1, [r0]
; 		k_cyc_to_us_near32(data->accel_curr_cyc - data->accel_prev_cyc) * 0.000001f;
 8003298: 6879         	ldr	r1, [r7, #0x4]
 800329a: 6b88         	ldr	r0, [r1, #0x38]
 800329c: 6879         	ldr	r1, [r7, #0x4]
 800329e: 6ac9         	ldr	r1, [r1, #0x2c]
 80032a0: 1a41         	subs	r1, r0, r1
 80032a2: 2900         	cmp	r1, #0x0
 80032a4: db0f         	blt	0x80032c6 <IMU_Sensor_handle_update+0x56> @ imm = #0x1e
 80032a6: 687b         	ldr	r3, [r7, #0x4]
 80032a8: 6b9a         	ldr	r2, [r3, #0x38]
 80032aa: 687b         	ldr	r3, [r7, #0x4]
 80032ac: 6adb         	ldr	r3, [r3, #0x2c]
 80032ae: 1ad3         	subs	r3, r2, r3
 80032b0: 3354         	adds	r3, #0x54
 80032b2: 08db         	lsrs	r3, r3, #0x3
 80032b4: 4a44         	ldr	r2, [pc, #0x110]        @ 0x80033c8 <IMU_Sensor_handle_update+0x158>
 80032b6: fba2 2303    	umull	r2, r3, r2, r3
 80032ba: 085b         	lsrs	r3, r3, #0x1
 80032bc: 4618         	mov	r0, r3
 80032be: f7fd f819    	bl	0x80002f4 <__floatunsisf> @ imm = #-0x2fce
 80032c2: 4603         	mov	r3, r0
 80032c4: e01a         	b	0x80032fc <IMU_Sensor_handle_update+0x8c> @ imm = #0x34
 80032c6: 6879         	ldr	r1, [r7, #0x4]
 80032c8: 6b88         	ldr	r0, [r1, #0x38]
 80032ca: 6879         	ldr	r1, [r7, #0x4]
 80032cc: 6ac9         	ldr	r1, [r1, #0x2c]
 80032ce: 1a41         	subs	r1, r0, r1
 80032d0: 17c8         	asrs	r0, r1, #0x1f
 80032d2: 460a         	mov	r2, r1
 80032d4: 4603         	mov	r3, r0
 80032d6: f112 0a54    	adds.w	r10, r2, #0x54
 80032da: f143 0b00    	adc	r11, r3, #0x0
 80032de: f04f 02a8    	mov.w	r2, #0xa8
 80032e2: f04f 0300    	mov.w	r3, #0x0
 80032e6: 4650         	mov	r0, r10
 80032e8: 4659         	mov	r1, r11
 80032ea: f7fd fa97    	bl	0x800081c <__aeabi_uldivmod> @ imm = #-0x2ad2
 80032ee: 4602         	mov	r2, r0
 80032f0: 460b         	mov	r3, r1
 80032f2: 4613         	mov	r3, r2
 80032f4: 4618         	mov	r0, r3
 80032f6: f7fc fffd    	bl	0x80002f4 <__floatunsisf> @ imm = #-0x3006
 80032fa: 4603         	mov	r3, r0
; 	float accel_dt =
 80032fc: 4933         	ldr	r1, [pc, #0xcc]         @ 0x80033cc <IMU_Sensor_handle_update+0x15c>
 80032fe: 4618         	mov	r0, r3
 8003300: f7fd f850    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x2f60
 8003304: 4603         	mov	r3, r0
 8003306: 60fb         	str	r3, [r7, #0xc]
; 	float gyro_dt = k_cyc_to_us_near32(data->gyro_curr_cyc - data->gyro_prev_cyc) * 0.000001f;
 8003308: 687b         	ldr	r3, [r7, #0x4]
 800330a: 6b5a         	ldr	r2, [r3, #0x34]
 800330c: 687b         	ldr	r3, [r7, #0x4]
 800330e: 6a9b         	ldr	r3, [r3, #0x28]
 8003310: 1ad3         	subs	r3, r2, r3
 8003312: 2b00         	cmp	r3, #0x0
 8003314: db0f         	blt	0x8003336 <IMU_Sensor_handle_update+0xc6> @ imm = #0x1e
 8003316: 687b         	ldr	r3, [r7, #0x4]
 8003318: 6b5a         	ldr	r2, [r3, #0x34]
 800331a: 687b         	ldr	r3, [r7, #0x4]
 800331c: 6a9b         	ldr	r3, [r3, #0x28]
 800331e: 1ad3         	subs	r3, r2, r3
 8003320: 3354         	adds	r3, #0x54
 8003322: 08db         	lsrs	r3, r3, #0x3
 8003324: 4a28         	ldr	r2, [pc, #0xa0]         @ 0x80033c8 <IMU_Sensor_handle_update+0x158>
 8003326: fba2 2303    	umull	r2, r3, r2, r3
 800332a: 085b         	lsrs	r3, r3, #0x1
 800332c: 4618         	mov	r0, r3
 800332e: f7fc ffe1    	bl	0x80002f4 <__floatunsisf> @ imm = #-0x303e
 8003332: 4603         	mov	r3, r0
 8003334: e01a         	b	0x800336c <IMU_Sensor_handle_update+0xfc> @ imm = #0x34
 8003336: 687b         	ldr	r3, [r7, #0x4]
 8003338: 6b5a         	ldr	r2, [r3, #0x34]
 800333a: 687b         	ldr	r3, [r7, #0x4]
 800333c: 6a9b         	ldr	r3, [r3, #0x28]
 800333e: 1ad3         	subs	r3, r2, r3
 8003340: 17da         	asrs	r2, r3, #0x1f
 8003342: 461c         	mov	r4, r3
 8003344: 4615         	mov	r5, r2
 8003346: f114 0854    	adds.w	r8, r4, #0x54
 800334a: f145 0900    	adc	r9, r5, #0x0
 800334e: f04f 02a8    	mov.w	r2, #0xa8
 8003352: f04f 0300    	mov.w	r3, #0x0
 8003356: 4640         	mov	r0, r8
 8003358: 4649         	mov	r1, r9
 800335a: f7fd fa5f    	bl	0x800081c <__aeabi_uldivmod> @ imm = #-0x2b42
 800335e: 4602         	mov	r2, r0
 8003360: 460b         	mov	r3, r1
 8003362: 4613         	mov	r3, r2
 8003364: 4618         	mov	r0, r3
 8003366: f7fc ffc5    	bl	0x80002f4 <__floatunsisf> @ imm = #-0x3076
 800336a: 4603         	mov	r3, r0
 800336c: 4917         	ldr	r1, [pc, #0x5c]         @ 0x80033cc <IMU_Sensor_handle_update+0x15c>
 800336e: 4618         	mov	r0, r3
 8003370: f7fd f818    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x2fd0
 8003374: 4603         	mov	r3, r0
 8003376: 60bb         	str	r3, [r7, #0x8]
; 	IMU_QuaternionEKF_Update(INS.Gyro[X], INS.Gyro[Y], INS.Gyro[Z], INS.Accel[X], INS.Accel[Y],
 8003378: 4b15         	ldr	r3, [pc, #0x54]         @ 0x80033d0 <IMU_Sensor_handle_update+0x160>
 800337a: 6818         	ldr	r0, [r3]
 800337c: 4b14         	ldr	r3, [pc, #0x50]         @ 0x80033d0 <IMU_Sensor_handle_update+0x160>
 800337e: 685c         	ldr	r4, [r3, #0x4]
 8003380: 4b13         	ldr	r3, [pc, #0x4c]         @ 0x80033d0 <IMU_Sensor_handle_update+0x160>
 8003382: 689d         	ldr	r5, [r3, #0x8]
 8003384: 4b12         	ldr	r3, [pc, #0x48]         @ 0x80033d0 <IMU_Sensor_handle_update+0x160>
 8003386: 68de         	ldr	r6, [r3, #0xc]
 8003388: 4b11         	ldr	r3, [pc, #0x44]         @ 0x80033d0 <IMU_Sensor_handle_update+0x160>
 800338a: 691b         	ldr	r3, [r3, #0x10]
 800338c: 4a10         	ldr	r2, [pc, #0x40]         @ 0x80033d0 <IMU_Sensor_handle_update+0x160>
 800338e: 6952         	ldr	r2, [r2, #0x14]
 8003390: 68b9         	ldr	r1, [r7, #0x8]
 8003392: 9103         	str	r1, [sp, #0xc]
 8003394: 68f9         	ldr	r1, [r7, #0xc]
 8003396: 9102         	str	r1, [sp, #0x8]
 8003398: 9201         	str	r2, [sp, #0x4]
 800339a: 9300         	str	r3, [sp]
 800339c: 4633         	mov	r3, r6
 800339e: 462a         	mov	r2, r5
 80033a0: 4621         	mov	r1, r4
 80033a2: f7fe fc9b    	bl	0x8001cdc <IMU_QuaternionEKF_Update> @ imm = #-0x16ca
; 	data->gyro_prev_cyc = data->gyro_curr_cyc;
 80033a6: 687b         	ldr	r3, [r7, #0x4]
 80033a8: 6b5a         	ldr	r2, [r3, #0x34]
 80033aa: 687b         	ldr	r3, [r7, #0x4]
 80033ac: 629a         	str	r2, [r3, #0x28]
; 	data->accel_prev_cyc = data->accel_curr_cyc;
 80033ae: 687b         	ldr	r3, [r7, #0x4]
 80033b0: 6b9a         	ldr	r2, [r3, #0x38]
 80033b2: 687b         	ldr	r3, [r7, #0x4]
 80033b4: 62da         	str	r2, [r3, #0x2c]
 80033b6: e000         	b	0x80033ba <IMU_Sensor_handle_update+0x14a> @ imm = #0x0
; 		return;
 80033b8: bf00         	nop
; }
 80033ba: 3714         	adds	r7, #0x14
 80033bc: 46bd         	mov	sp, r7
 80033be: e8bd 8ff0    	pop.w	{r4, r5, r6, r7, r8, r9, r10, r11, pc}
 80033c2: bf00         	nop

080033c4 <$d>:
 80033c4: 98 1b 00 20  	.word	0x20001b98
 80033c8: 19 86 61 18  	.word	0x18618619
 80033cc: bd 37 86 35  	.word	0x358637bd
 80033d0: 5c 1b 00 20  	.word	0x20001b5c

080033d4 <InitQuaternion>:
; {
 80033d4: b5b0         	push	{r4, r5, r7, lr}
 80033d6: b096         	sub	sp, #0x58
 80033d8: af00         	add	r7, sp, #0x0
 80033da: 60f8         	str	r0, [r7, #0xc]
 80033dc: 60b9         	str	r1, [r7, #0x8]
 80033de: 607a         	str	r2, [r7, #0x4]
; 	float acc_init[3] = {0};
 80033e0: f107 0344    	add.w	r3, r7, #0x44
 80033e4: 2200         	movs	r2, #0x0
 80033e6: 601a         	str	r2, [r3]
 80033e8: 605a         	str	r2, [r3, #0x4]
 80033ea: 609a         	str	r2, [r3, #0x8]
; 	float gravity_norm[3] = {0, 0, 1}; // 导航系重力加速度矢量,归一化后为(0,0,1)
 80033ec: f04f 0300    	mov.w	r3, #0x0
 80033f0: 63bb         	str	r3, [r7, #0x38]
 80033f2: f04f 0300    	mov.w	r3, #0x0
 80033f6: 63fb         	str	r3, [r7, #0x3c]
 80033f8: f04f 537e    	mov.w	r3, #0x3f800000
 80033fc: 643b         	str	r3, [r7, #0x40]
; 	float axis_rot[3] = {0};           // 旋转轴
 80033fe: f107 032c    	add.w	r3, r7, #0x2c
 8003402: 2200         	movs	r2, #0x0
 8003404: 601a         	str	r2, [r3]
 8003406: 605a         	str	r2, [r3, #0x4]
 8003408: 609a         	str	r2, [r3, #0x8]
; 	for (uint8_t i = 0; i < 100; ++i) {
 800340a: 2300         	movs	r3, #0x0
 800340c: f887 3057    	strb.w	r3, [r7, #0x57]
 8003410: e03a         	b	0x8003488 <InitQuaternion+0xb4> @ imm = #0x74
; 		sensor_sample_fetch(dev);
 8003412: 68f8         	ldr	r0, [r7, #0xc]
 8003414: f010 fb49    	bl	0x8013aaa <sensor_sample_fetch> @ imm = #0x10692
; 		sensor_channel_get(dev, SENSOR_CHAN_ACCEL_XYZ, accel_data);
 8003418: f107 0314    	add.w	r3, r7, #0x14
 800341c: 461a         	mov	r2, r3
 800341e: 2103         	movs	r1, #0x3
 8003420: 68f8         	ldr	r0, [r7, #0xc]
 8003422: f010 fb4e    	bl	0x8013ac2 <sensor_channel_get> @ imm = #0x1069c
; 		acc_init[X] += sensor_value_to_float(&accel_data[X]);
 8003426: f107 0314    	add.w	r3, r7, #0x14
 800342a: 4618         	mov	r0, r3
 800342c: f7fd fcec    	bl	0x8000e08 <sensor_value_to_float> @ imm = #-0x2628
 8003430: 4602         	mov	r2, r0
 8003432: 6c7b         	ldr	r3, [r7, #0x44]
 8003434: 4619         	mov	r1, r3
 8003436: 4610         	mov	r0, r2
 8003438: f7fc feac    	bl	0x8000194 <__aeabi_fadd> @ imm = #-0x32a8
 800343c: 4603         	mov	r3, r0
 800343e: 647b         	str	r3, [r7, #0x44]
; 		acc_init[Y] += sensor_value_to_float(&accel_data[Y]);
 8003440: f107 0314    	add.w	r3, r7, #0x14
 8003444: 3308         	adds	r3, #0x8
 8003446: 4618         	mov	r0, r3
 8003448: f7fd fcde    	bl	0x8000e08 <sensor_value_to_float> @ imm = #-0x2644
 800344c: 4602         	mov	r2, r0
 800344e: 6cbb         	ldr	r3, [r7, #0x48]
 8003450: 4619         	mov	r1, r3
 8003452: 4610         	mov	r0, r2
 8003454: f7fc fe9e    	bl	0x8000194 <__aeabi_fadd> @ imm = #-0x32c4
 8003458: 4603         	mov	r3, r0
 800345a: 64bb         	str	r3, [r7, #0x48]
; 		acc_init[Z] += sensor_value_to_float(&accel_data[Z]);
 800345c: f107 0314    	add.w	r3, r7, #0x14
 8003460: 3310         	adds	r3, #0x10
 8003462: 4618         	mov	r0, r3
 8003464: f7fd fcd0    	bl	0x8000e08 <sensor_value_to_float> @ imm = #-0x2660
 8003468: 4602         	mov	r2, r0
 800346a: 6cfb         	ldr	r3, [r7, #0x4c]
 800346c: 4619         	mov	r1, r3
 800346e: 4610         	mov	r0, r2
 8003470: f7fc fe90    	bl	0x8000194 <__aeabi_fadd> @ imm = #-0x32e0
 8003474: 4603         	mov	r3, r0
 8003476: 64fb         	str	r3, [r7, #0x4c]
; 		k_msleep(1);
 8003478: 2001         	movs	r0, #0x1
 800347a: f010 fa74    	bl	0x8013966 <k_msleep>    @ imm = #0x104e8
; 	for (uint8_t i = 0; i < 100; ++i) {
 800347e: f897 3057    	ldrb.w	r3, [r7, #0x57]
 8003482: 3301         	adds	r3, #0x1
 8003484: f887 3057    	strb.w	r3, [r7, #0x57]
 8003488: f897 3057    	ldrb.w	r3, [r7, #0x57]
 800348c: 2b63         	cmp	r3, #0x63
 800348e: d9c0         	bls	0x8003412 <InitQuaternion+0x3e> @ imm = #-0x80
; 	for (uint8_t i = 0; i < 3; ++i) {
 8003490: 2300         	movs	r3, #0x0
 8003492: f887 3056    	strb.w	r3, [r7, #0x56]
 8003496: e018         	b	0x80034ca <InitQuaternion+0xf6> @ imm = #0x30
; 		acc_init[i] /= 100;
 8003498: f897 3056    	ldrb.w	r3, [r7, #0x56]
 800349c: 009b         	lsls	r3, r3, #0x2
 800349e: 3358         	adds	r3, #0x58
 80034a0: 443b         	add	r3, r7
 80034a2: f853 3c14    	ldr	r3, [r3, #-20]
 80034a6: f897 4056    	ldrb.w	r4, [r7, #0x56]
 80034aa: 493c         	ldr	r1, [pc, #0xf0]         @ 0x800359c <InitQuaternion+0x1c8>
 80034ac: 4618         	mov	r0, r3
 80034ae: f7fd f82d    	bl	0x800050c <__divsf3>    @ imm = #-0x2fa6
 80034b2: 4603         	mov	r3, r0
 80034b4: 461a         	mov	r2, r3
 80034b6: 00a3         	lsls	r3, r4, #0x2
 80034b8: 3358         	adds	r3, #0x58
 80034ba: 443b         	add	r3, r7
 80034bc: f843 2c14    	str	r2, [r3, #-20]
; 	for (uint8_t i = 0; i < 3; ++i) {
 80034c0: f897 3056    	ldrb.w	r3, [r7, #0x56]
 80034c4: 3301         	adds	r3, #0x1
 80034c6: f887 3056    	strb.w	r3, [r7, #0x56]
 80034ca: f897 3056    	ldrb.w	r3, [r7, #0x56]
 80034ce: 2b02         	cmp	r3, #0x2
 80034d0: d9e2         	bls	0x8003498 <InitQuaternion+0xc4> @ imm = #-0x3c
; 	accel[X] = acc_init[X];
 80034d2: 6c7a         	ldr	r2, [r7, #0x44]
 80034d4: 687b         	ldr	r3, [r7, #0x4]
 80034d6: 601a         	str	r2, [r3]
; 	accel[Y] = acc_init[Y];
 80034d8: 687b         	ldr	r3, [r7, #0x4]
 80034da: 3304         	adds	r3, #0x4
 80034dc: 6cba         	ldr	r2, [r7, #0x48]
 80034de: 601a         	str	r2, [r3]
; 	accel[Z] = acc_init[Z];
 80034e0: 687b         	ldr	r3, [r7, #0x4]
 80034e2: 3308         	adds	r3, #0x8
 80034e4: 6cfa         	ldr	r2, [r7, #0x4c]
 80034e6: 601a         	str	r2, [r3]
; 	Norm3d(acc_init);
 80034e8: f107 0344    	add.w	r3, r7, #0x44
 80034ec: 4618         	mov	r0, r3
 80034ee: f010 fd5b    	bl	0x8013fa8 <Norm3d>      @ imm = #0x10ab6
; 	float angle = acosf(Dot3d(acc_init, gravity_norm));
 80034f2: f107 0238    	add.w	r2, r7, #0x38
 80034f6: f107 0344    	add.w	r3, r7, #0x44
 80034fa: 4611         	mov	r1, r2
 80034fc: 4618         	mov	r0, r3
 80034fe: f010 fe12    	bl	0x8014126 <Dot3d>       @ imm = #0x10c24
 8003502: 4603         	mov	r3, r0
 8003504: 4618         	mov	r0, r3
 8003506: f00e ffaf    	bl	0x8012468 <acosf>       @ imm = #0xef5e
 800350a: 6538         	str	r0, [r7, #0x50]
; 	Cross3d(acc_init, gravity_norm, axis_rot);
 800350c: f107 022c    	add.w	r2, r7, #0x2c
 8003510: f107 0138    	add.w	r1, r7, #0x38
 8003514: f107 0344    	add.w	r3, r7, #0x44
 8003518: 4618         	mov	r0, r3
 800351a: f010 fd9e    	bl	0x801405a <Cross3d>     @ imm = #0x10b3c
; 	Norm3d(axis_rot);
 800351e: f107 032c    	add.w	r3, r7, #0x2c
 8003522: 4618         	mov	r0, r3
 8003524: f010 fd40    	bl	0x8013fa8 <Norm3d>      @ imm = #0x10a80
; 	init_q4[0] = cosf(angle / 2.0f);
 8003528: f04f 4180    	mov.w	r1, #0x40000000
 800352c: 6d38         	ldr	r0, [r7, #0x50]
 800352e: f7fc ffed    	bl	0x800050c <__divsf3>    @ imm = #-0x3026
 8003532: 4603         	mov	r3, r0
 8003534: 4618         	mov	r0, r3
 8003536: f00f fad9    	bl	0x8012aec <cosf>        @ imm = #0xf5b2
 800353a: 4602         	mov	r2, r0
 800353c: 68bb         	ldr	r3, [r7, #0x8]
 800353e: 601a         	str	r2, [r3]
; 	for (uint8_t i = 0; i < 2; ++i) {
 8003540: 2300         	movs	r3, #0x0
 8003542: f887 3055    	strb.w	r3, [r7, #0x55]
 8003546: e020         	b	0x800358a <InitQuaternion+0x1b6> @ imm = #0x40
; 			axis_rot[i] * sinf(angle / 2.0f); // 轴角公式,第三轴为0(没有z轴分量)
 8003548: f897 3055    	ldrb.w	r3, [r7, #0x55]
 800354c: 009b         	lsls	r3, r3, #0x2
 800354e: 3358         	adds	r3, #0x58
 8003550: 443b         	add	r3, r7
 8003552: f853 5c2c    	ldr	r5, [r3, #-44]
 8003556: f04f 4180    	mov.w	r1, #0x40000000
 800355a: 6d38         	ldr	r0, [r7, #0x50]
 800355c: f7fc ffd6    	bl	0x800050c <__divsf3>    @ imm = #-0x3054
 8003560: 4603         	mov	r3, r0
 8003562: 4618         	mov	r0, r3
 8003564: f00f fc62    	bl	0x8012e2c <sinf>        @ imm = #0xf8c4
 8003568: 4601         	mov	r1, r0
; 		init_q4[i + 1] =
 800356a: f897 3055    	ldrb.w	r3, [r7, #0x55]
 800356e: 3301         	adds	r3, #0x1
 8003570: 009b         	lsls	r3, r3, #0x2
 8003572: 68ba         	ldr	r2, [r7, #0x8]
 8003574: 18d4         	adds	r4, r2, r3
; 			axis_rot[i] * sinf(angle / 2.0f); // 轴角公式,第三轴为0(没有z轴分量)
 8003576: 4628         	mov	r0, r5
 8003578: f7fc ff14    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x31d8
 800357c: 4603         	mov	r3, r0
; 		init_q4[i + 1] =
 800357e: 6023         	str	r3, [r4]
; 	for (uint8_t i = 0; i < 2; ++i) {
 8003580: f897 3055    	ldrb.w	r3, [r7, #0x55]
 8003584: 3301         	adds	r3, #0x1
 8003586: f887 3055    	strb.w	r3, [r7, #0x55]
 800358a: f897 3055    	ldrb.w	r3, [r7, #0x55]
 800358e: 2b01         	cmp	r3, #0x1
 8003590: d9da         	bls	0x8003548 <InitQuaternion+0x174> @ imm = #-0x4c
; }
 8003592: bf00         	nop
 8003594: bf00         	nop
 8003596: 3758         	adds	r7, #0x58
 8003598: 46bd         	mov	sp, r7
 800359a: bdb0         	pop	{r4, r5, r7, pc}

0800359c <$d>:
 800359c: 00 00 c8 42  	.word	0x42c80000

080035a0 <IMU_Sensor_trig_handler>:
; {
 80035a0: b580         	push	{r7, lr}
 80035a2: b090         	sub	sp, #0x40
 80035a4: af00         	add	r7, sp, #0x0
 80035a6: 6078         	str	r0, [r7, #0x4]
 80035a8: 6039         	str	r1, [r7]
; 	if (trigger->type != SENSOR_TRIG_DATA_READY) {
 80035aa: 683b         	ldr	r3, [r7]
 80035ac: 881b         	ldrh	r3, [r3]
 80035ae: 2b01         	cmp	r3, #0x1
 80035b0: d16d         	bne	0x800368e <IMU_Sensor_trig_handler+0xee> @ imm = #0xda
; 	int current_cyc = k_cycle_get_32();
 80035b2: f010 fa04    	bl	0x80139be <k_cycle_get_32> @ imm = #0x10408
 80035b6: 4603         	mov	r3, r0
 80035b8: 63fb         	str	r3, [r7, #0x3c]
; 	sensor_sample_fetch(dev);
 80035ba: 6878         	ldr	r0, [r7, #0x4]
 80035bc: f010 fa75    	bl	0x8013aaa <sensor_sample_fetch> @ imm = #0x104ea
; 	if (trigger->chan == SENSOR_CHAN_ACCEL_XYZ) {
 80035c0: 683b         	ldr	r3, [r7]
 80035c2: 885b         	ldrh	r3, [r3, #0x2]
 80035c4: 2b03         	cmp	r3, #0x3
 80035c6: d12d         	bne	0x8003624 <IMU_Sensor_trig_handler+0x84> @ imm = #0x5a
; 		sensor_channel_get(dev, SENSOR_CHAN_ACCEL_XYZ, accel_data);
 80035c8: f107 0324    	add.w	r3, r7, #0x24
 80035cc: 461a         	mov	r2, r3
 80035ce: 2103         	movs	r1, #0x3
 80035d0: 6878         	ldr	r0, [r7, #0x4]
 80035d2: f010 fa76    	bl	0x8013ac2 <sensor_channel_get> @ imm = #0x104ec
; 		INS.flag |= 1;
 80035d6: 4b30         	ldr	r3, [pc, #0xc0]         @ 0x8003698 <IMU_Sensor_trig_handler+0xf8>
 80035d8: f893 3024    	ldrb.w	r3, [r3, #0x24]
 80035dc: f043 0301    	orr	r3, r3, #0x1
 80035e0: b2da         	uxtb	r2, r3
 80035e2: 4b2d         	ldr	r3, [pc, #0xb4]         @ 0x8003698 <IMU_Sensor_trig_handler+0xf8>
 80035e4: f883 2024    	strb.w	r2, [r3, #0x24]
; 		INS.accel_curr_cyc = current_cyc;
 80035e8: 4a2b         	ldr	r2, [pc, #0xac]         @ 0x8003698 <IMU_Sensor_trig_handler+0xf8>
 80035ea: 6bfb         	ldr	r3, [r7, #0x3c]
 80035ec: 6393         	str	r3, [r2, #0x38]
; 		INS.Accel[X] = sensor_value_to_float(&accel_data[X]);
 80035ee: f107 0324    	add.w	r3, r7, #0x24
 80035f2: 4618         	mov	r0, r3
 80035f4: f7fd fc08    	bl	0x8000e08 <sensor_value_to_float> @ imm = #-0x27f0
 80035f8: 4603         	mov	r3, r0
 80035fa: 4a27         	ldr	r2, [pc, #0x9c]         @ 0x8003698 <IMU_Sensor_trig_handler+0xf8>
 80035fc: 60d3         	str	r3, [r2, #0xc]
; 		INS.Accel[Y] = sensor_value_to_float(&accel_data[Y]);
 80035fe: f107 0324    	add.w	r3, r7, #0x24
 8003602: 3308         	adds	r3, #0x8
 8003604: 4618         	mov	r0, r3
 8003606: f7fd fbff    	bl	0x8000e08 <sensor_value_to_float> @ imm = #-0x2802
 800360a: 4603         	mov	r3, r0
 800360c: 4a22         	ldr	r2, [pc, #0x88]         @ 0x8003698 <IMU_Sensor_trig_handler+0xf8>
 800360e: 6113         	str	r3, [r2, #0x10]
; 		INS.Accel[Z] = sensor_value_to_float(&accel_data[Z]);
 8003610: f107 0324    	add.w	r3, r7, #0x24
 8003614: 3310         	adds	r3, #0x10
 8003616: 4618         	mov	r0, r3
 8003618: f7fd fbf6    	bl	0x8000e08 <sensor_value_to_float> @ imm = #-0x2814
 800361c: 4603         	mov	r3, r0
 800361e: 4a1e         	ldr	r2, [pc, #0x78]         @ 0x8003698 <IMU_Sensor_trig_handler+0xf8>
 8003620: 6153         	str	r3, [r2, #0x14]
 8003622: e030         	b	0x8003686 <IMU_Sensor_trig_handler+0xe6> @ imm = #0x60
; 	} else if (trigger->chan == SENSOR_CHAN_GYRO_XYZ) {
 8003624: 683b         	ldr	r3, [r7]
 8003626: 885b         	ldrh	r3, [r3, #0x2]
 8003628: 2b07         	cmp	r3, #0x7
 800362a: d12c         	bne	0x8003686 <IMU_Sensor_trig_handler+0xe6> @ imm = #0x58
; 		sensor_channel_get(dev, SENSOR_CHAN_GYRO_XYZ, gyro_data);
 800362c: f107 030c    	add.w	r3, r7, #0xc
 8003630: 461a         	mov	r2, r3
 8003632: 2107         	movs	r1, #0x7
 8003634: 6878         	ldr	r0, [r7, #0x4]
 8003636: f010 fa44    	bl	0x8013ac2 <sensor_channel_get> @ imm = #0x10488
; 		INS.flag |= 2;
 800363a: 4b17         	ldr	r3, [pc, #0x5c]         @ 0x8003698 <IMU_Sensor_trig_handler+0xf8>
 800363c: f893 3024    	ldrb.w	r3, [r3, #0x24]
 8003640: f043 0302    	orr	r3, r3, #0x2
 8003644: b2da         	uxtb	r2, r3
 8003646: 4b14         	ldr	r3, [pc, #0x50]         @ 0x8003698 <IMU_Sensor_trig_handler+0xf8>
 8003648: f883 2024    	strb.w	r2, [r3, #0x24]
; 		INS.gyro_curr_cyc = current_cyc;
 800364c: 4a12         	ldr	r2, [pc, #0x48]         @ 0x8003698 <IMU_Sensor_trig_handler+0xf8>
 800364e: 6bfb         	ldr	r3, [r7, #0x3c]
 8003650: 6353         	str	r3, [r2, #0x34]
; 		INS.Gyro[0] = sensor_value_to_float(&gyro_data[0]);
 8003652: f107 030c    	add.w	r3, r7, #0xc
 8003656: 4618         	mov	r0, r3
 8003658: f7fd fbd6    	bl	0x8000e08 <sensor_value_to_float> @ imm = #-0x2854
 800365c: 4603         	mov	r3, r0
 800365e: 4a0e         	ldr	r2, [pc, #0x38]         @ 0x8003698 <IMU_Sensor_trig_handler+0xf8>
 8003660: 6013         	str	r3, [r2]
; 		INS.Gyro[1] = sensor_value_to_float(&gyro_data[1]);
 8003662: f107 030c    	add.w	r3, r7, #0xc
 8003666: 3308         	adds	r3, #0x8
 8003668: 4618         	mov	r0, r3
 800366a: f7fd fbcd    	bl	0x8000e08 <sensor_value_to_float> @ imm = #-0x2866
 800366e: 4603         	mov	r3, r0
 8003670: 4a09         	ldr	r2, [pc, #0x24]         @ 0x8003698 <IMU_Sensor_trig_handler+0xf8>
 8003672: 6053         	str	r3, [r2, #0x4]
; 		INS.Gyro[2] = sensor_value_to_float(&gyro_data[2]);
 8003674: f107 030c    	add.w	r3, r7, #0xc
 8003678: 3310         	adds	r3, #0x10
 800367a: 4618         	mov	r0, r3
 800367c: f7fd fbc4    	bl	0x8000e08 <sensor_value_to_float> @ imm = #-0x2878
 8003680: 4603         	mov	r3, r0
 8003682: 4a05         	ldr	r2, [pc, #0x14]         @ 0x8003698 <IMU_Sensor_trig_handler+0xf8>
 8003684: 6093         	str	r3, [r2, #0x8]
; 	IMU_Sensor_handle_update(&INS);
 8003686: 4804         	ldr	r0, [pc, #0x10]         @ 0x8003698 <IMU_Sensor_trig_handler+0xf8>
 8003688: f7ff fdf2    	bl	0x8003270 <IMU_Sensor_handle_update> @ imm = #-0x41c
 800368c: e000         	b	0x8003690 <IMU_Sensor_trig_handler+0xf0> @ imm = #0x0
; 		return;
 800368e: bf00         	nop
; }
 8003690: 3740         	adds	r7, #0x40
 8003692: 46bd         	mov	sp, r7
 8003694: bd80         	pop	{r7, pc}
 8003696: bf00         	nop

08003698 <$d>:
 8003698: 5c 1b 00 20  	.word	0x20001b5c

0800369c <IMU_Sensor_trig_init>:
; {
 800369c: b580         	push	{r7, lr}
 800369e: b08a         	sub	sp, #0x28
 80036a0: af02         	add	r7, sp, #0x8
 80036a2: 6078         	str	r0, [r7, #0x4]
 80036a4: 6039         	str	r1, [r7]
; 	IMU_Param.scale[X] = 1;
 80036a6: 4b28         	ldr	r3, [pc, #0xa0]         @ 0x8003748 <IMU_Sensor_trig_init+0xac>
 80036a8: f04f 527e    	mov.w	r2, #0x3f800000
 80036ac: 605a         	str	r2, [r3, #0x4]
; 	IMU_Param.scale[Y] = 1;
 80036ae: 4b26         	ldr	r3, [pc, #0x98]         @ 0x8003748 <IMU_Sensor_trig_init+0xac>
 80036b0: f04f 527e    	mov.w	r2, #0x3f800000
 80036b4: 609a         	str	r2, [r3, #0x8]
; 	IMU_Param.scale[Z] = 1;
 80036b6: 4b24         	ldr	r3, [pc, #0x90]         @ 0x8003748 <IMU_Sensor_trig_init+0xac>
 80036b8: f04f 527e    	mov.w	r2, #0x3f800000
 80036bc: 60da         	str	r2, [r3, #0xc]
; 	IMU_Param.Yaw = 0;
 80036be: 4b22         	ldr	r3, [pc, #0x88]         @ 0x8003748 <IMU_Sensor_trig_init+0xac>
 80036c0: f04f 0200    	mov.w	r2, #0x0
 80036c4: 611a         	str	r2, [r3, #0x10]
; 	IMU_Param.Pitch = 0;
 80036c6: 4b20         	ldr	r3, [pc, #0x80]         @ 0x8003748 <IMU_Sensor_trig_init+0xac>
 80036c8: f04f 0200    	mov.w	r2, #0x0
 80036cc: 615a         	str	r2, [r3, #0x14]
; 	IMU_Param.Roll = 0;
 80036ce: 4b1e         	ldr	r3, [pc, #0x78]         @ 0x8003748 <IMU_Sensor_trig_init+0xac>
 80036d0: f04f 0200    	mov.w	r2, #0x0
 80036d4: 619a         	str	r2, [r3, #0x18]
; 	IMU_Param.flag = 1;
 80036d6: 4b1c         	ldr	r3, [pc, #0x70]         @ 0x8003748 <IMU_Sensor_trig_init+0xac>
 80036d8: 2201         	movs	r2, #0x1
 80036da: 701a         	strb	r2, [r3]
; 	float init_quaternion[4] = {0};
 80036dc: f107 030c    	add.w	r3, r7, #0xc
 80036e0: 2200         	movs	r2, #0x0
 80036e2: 601a         	str	r2, [r3]
 80036e4: 605a         	str	r2, [r3, #0x4]
 80036e6: 609a         	str	r2, [r3, #0x8]
 80036e8: 60da         	str	r2, [r3, #0xc]
; 	InitQuaternion(accel_dev, init_quaternion, INS.lpf_Accel);
 80036ea: f107 030c    	add.w	r3, r7, #0xc
 80036ee: 4a17         	ldr	r2, [pc, #0x5c]         @ 0x800374c <IMU_Sensor_trig_init+0xb0>
 80036f0: 4619         	mov	r1, r3
 80036f2: 6878         	ldr	r0, [r7, #0x4]
 80036f4: f7ff fe6e    	bl	0x80033d4 <InitQuaternion> @ imm = #-0x324
; 	IMU_QuaternionEKF_Init(init_quaternion, 10, 0.001, 100000, 1, 0.95);
 80036f8: f107 000c    	add.w	r0, r7, #0xc
 80036fc: 4b14         	ldr	r3, [pc, #0x50]         @ 0x8003750 <IMU_Sensor_trig_init+0xb4>
 80036fe: 9301         	str	r3, [sp, #0x4]
 8003700: f04f 537e    	mov.w	r3, #0x3f800000
 8003704: 9300         	str	r3, [sp]
 8003706: 4b13         	ldr	r3, [pc, #0x4c]         @ 0x8003754 <IMU_Sensor_trig_init+0xb8>
 8003708: 4a13         	ldr	r2, [pc, #0x4c]         @ 0x8003758 <IMU_Sensor_trig_init+0xbc>
 800370a: 4914         	ldr	r1, [pc, #0x50]         @ 0x800375c <IMU_Sensor_trig_init+0xc0>
 800370c: f7fe fa44    	bl	0x8001b98 <IMU_QuaternionEKF_Init> @ imm = #-0x1b78
; 	int current_cyc = k_cycle_get_32();
 8003710: f010 f955    	bl	0x80139be <k_cycle_get_32> @ imm = #0x102aa
 8003714: 4603         	mov	r3, r0
 8003716: 61fb         	str	r3, [r7, #0x1c]
; 	INS.gyro_prev_cyc = current_cyc;
 8003718: 4a11         	ldr	r2, [pc, #0x44]         @ 0x8003760 <IMU_Sensor_trig_init+0xc4>
 800371a: 69fb         	ldr	r3, [r7, #0x1c]
 800371c: 6293         	str	r3, [r2, #0x28]
; 	INS.accel_prev_cyc = current_cyc;
 800371e: 4a10         	ldr	r2, [pc, #0x40]         @ 0x8003760 <IMU_Sensor_trig_init+0xc4>
 8003720: 69fb         	ldr	r3, [r7, #0x1c]
 8003722: 62d3         	str	r3, [r2, #0x2c]
; 	INS.flag = 0;
 8003724: 4b0e         	ldr	r3, [pc, #0x38]         @ 0x8003760 <IMU_Sensor_trig_init+0xc4>
 8003726: 2200         	movs	r2, #0x0
 8003728: f883 2024    	strb.w	r2, [r3, #0x24]
; 	sensor_trigger_set(accel_dev, &accel_trig, IMU_Sensor_trig_handler);
 800372c: 4a0d         	ldr	r2, [pc, #0x34]         @ 0x8003764 <IMU_Sensor_trig_init+0xc8>
 800372e: 490e         	ldr	r1, [pc, #0x38]         @ 0x8003768 <IMU_Sensor_trig_init+0xcc>
 8003730: 6878         	ldr	r0, [r7, #0x4]
 8003732: f010 f979    	bl	0x8013a28 <sensor_trigger_set> @ imm = #0x102f2
; 	sensor_trigger_set(gyro_dev, &gyro_trig, IMU_Sensor_trig_handler);
 8003736: 4a0b         	ldr	r2, [pc, #0x2c]         @ 0x8003764 <IMU_Sensor_trig_init+0xc8>
 8003738: 490c         	ldr	r1, [pc, #0x30]         @ 0x800376c <IMU_Sensor_trig_init+0xd0>
 800373a: 6838         	ldr	r0, [r7]
 800373c: f010 f974    	bl	0x8013a28 <sensor_trigger_set> @ imm = #0x102e8
; }
 8003740: bf00         	nop
 8003742: 3720         	adds	r7, #0x20
 8003744: 46bd         	mov	sp, r7
 8003746: bd80         	pop	{r7, pc}

08003748 <$d>:
 8003748: 40 1b 00 20  	.word	0x20001b40
 800374c: 74 1b 00 20  	.word	0x20001b74
 8003750: 33 33 73 3f  	.word	0x3f733333
 8003754: 00 50 c3 47  	.word	0x47c35000
 8003758: 6f 12 83 3a  	.word	0x3a83126f
 800375c: 00 00 20 41  	.word	0x41200000
 8003760: 5c 1b 00 20  	.word	0x20001b5c
 8003764: a1 35 00 08  	.word	0x080035a1
 8003768: 98 04 00 20  	.word	0x20000498
 800376c: 9c 04 00 20  	.word	0x2000049c

08003770 <main>:
; {
 8003770: b580         	push	{r7, lr}
 8003772: b0be         	sub	sp, #0xf8
 8003774: af08         	add	r7, sp, #0x20
; 	struct JFData *data = jf_send_init(uart_dev, 15, 4);
 8003776: 4b22         	ldr	r3, [pc, #0x88]         @ 0x8003800 <main+0x90>
 8003778: 681b         	ldr	r3, [r3]
 800377a: 2204         	movs	r2, #0x4
 800377c: 210f         	movs	r1, #0xf
 800377e: 4618         	mov	r0, r3
 8003780: f7fd fba0    	bl	0x8000ec4 <jf_send_init> @ imm = #-0x28c0
 8003784: f8c7 00d0    	str.w	r0, [r7, #0xd0]
; 			NULL, 0, 0, K_MSEC(1000));
 8003788: f242 7210    	movw	r2, #0x2710
 800378c: f04f 0300    	mov.w	r3, #0x0
; 	k_thread_create(&feedback_thread_data, feedback_stack_area,
 8003790: 4638         	mov	r0, r7
 8003792: e9cd 2306    	strd	r2, r3, [sp, #24]
 8003796: 2300         	movs	r3, #0x0
 8003798: 9304         	str	r3, [sp, #0x10]
 800379a: 2300         	movs	r3, #0x0
 800379c: 9303         	str	r3, [sp, #0xc]
 800379e: 2300         	movs	r3, #0x0
 80037a0: 9302         	str	r3, [sp, #0x8]
 80037a2: 2300         	movs	r3, #0x0
 80037a4: 9301         	str	r3, [sp, #0x4]
 80037a6: 2300         	movs	r3, #0x0
 80037a8: 9300         	str	r3, [sp]
 80037aa: 4b16         	ldr	r3, [pc, #0x58]         @ 0x8003804 <main+0x94>
 80037ac: f44f 5280    	mov.w	r2, #0x1000
 80037b0: 4915         	ldr	r1, [pc, #0x54]         @ 0x8003808 <main+0x98>
 80037b2: f010 f90b    	bl	0x80139cc <k_thread_create> @ imm = #0x10216
; 	k_sleep(K_MSEC(50));
 80037b6: f44f 72fa    	mov.w	r2, #0x1f4
 80037ba: f04f 0300    	mov.w	r3, #0x0
 80037be: 4610         	mov	r0, r2
 80037c0: 4619         	mov	r1, r3
 80037c2: f010 f923    	bl	0x8013a0c <k_sleep>     @ imm = #0x10246
; 	IMU_Sensor_trig_init(accel_dev, gyro_dev);
 80037c6: 4b11         	ldr	r3, [pc, #0x44]         @ 0x800380c <main+0x9c>
 80037c8: 681b         	ldr	r3, [r3]
 80037ca: 4a11         	ldr	r2, [pc, #0x44]         @ 0x8003810 <main+0xa0>
 80037cc: 6812         	ldr	r2, [r2]
 80037ce: 4611         	mov	r1, r2
 80037d0: 4618         	mov	r0, r3
 80037d2: f7ff ff63    	bl	0x800369c <IMU_Sensor_trig_init> @ imm = #-0x13a
; 	int t = 0;
 80037d6: 2300         	movs	r3, #0x0
 80037d8: f8c7 30d4    	str.w	r3, [r7, #0xd4]
; 		memcpy(data->fdata, QEKF_INS.q, sizeof(QEKF_INS.q));
 80037dc: f8d7 30d0    	ldr.w	r3, [r7, #0xd0]
 80037e0: 685b         	ldr	r3, [r3, #0x4]
 80037e2: 2210         	movs	r2, #0x10
 80037e4: 490b         	ldr	r1, [pc, #0x2c]         @ 0x8003814 <main+0xa4>
 80037e6: 4618         	mov	r0, r3
 80037e8: f019 fff2    	bl	0x801d7d0 <memcpy>      @ imm = #0x19fe4
; 		k_msleep(15);
 80037ec: 200f         	movs	r0, #0xf
 80037ee: f010 f8ba    	bl	0x8013966 <k_msleep>    @ imm = #0x10174
; 		t += 50;
 80037f2: f8d7 30d4    	ldr.w	r3, [r7, #0xd4]
 80037f6: 3332         	adds	r3, #0x32
 80037f8: f8c7 30d4    	str.w	r3, [r7, #0xd4]
; 		memcpy(data->fdata, QEKF_INS.q, sizeof(QEKF_INS.q));
 80037fc: bf00         	nop
 80037fe: e7ed         	b	0x80037dc <main+0x6c>   @ imm = #-0x26

08003800 <$d>:
 8003800: a0 04 00 20  	.word	0x200004a0
 8003804: 8f 41 01 08  	.word	0x0801418f
 8003808: 90 22 00 20  	.word	0x20002290
 800380c: a4 04 00 20  	.word	0x200004a4
 8003810: a8 04 00 20  	.word	0x200004a8
 8003814: 48 08 00 20  	.word	0x20000848

08003818 <linker_is_in_rodata>:
; {
 8003818: b480         	push	{r7}
 800381a: b083         	sub	sp, #0xc
 800381c: af00         	add	r7, sp, #0x0
 800381e: 6078         	str	r0, [r7, #0x4]
; 	return (((const char *)addr >= (const char *)RO_START) &&
 8003820: 687b         	ldr	r3, [r7, #0x4]
 8003822: 4a09         	ldr	r2, [pc, #0x24]         @ 0x8003848 <linker_is_in_rodata+0x30>
 8003824: 4293         	cmp	r3, r2
 8003826: d305         	blo	0x8003834 <linker_is_in_rodata+0x1c> @ imm = #0xa
 8003828: 687b         	ldr	r3, [r7, #0x4]
 800382a: 4a08         	ldr	r2, [pc, #0x20]         @ 0x800384c <linker_is_in_rodata+0x34>
 800382c: 4293         	cmp	r3, r2
 800382e: d201         	bhs	0x8003834 <linker_is_in_rodata+0x1c> @ imm = #0x2
 8003830: 2301         	movs	r3, #0x1
 8003832: e000         	b	0x8003836 <linker_is_in_rodata+0x1e> @ imm = #0x0
 8003834: 2300         	movs	r3, #0x0
 8003836: f003 0301    	and	r3, r3, #0x1
 800383a: b2db         	uxtb	r3, r3
; }
 800383c: 4618         	mov	r0, r3
 800383e: 370c         	adds	r7, #0xc
 8003840: 46bd         	mov	sp, r7
 8003842: bc80         	pop	{r7}
 8003844: 4770         	bx	lr
 8003846: bf00         	nop

08003848 <$d>:
 8003848: 58 dc 01 08  	.word	0x0801dc58
 800384c: 10 0d 02 08  	.word	0x08020d10

08003850 <cbvprintf_package>:
; {
 8003850: b580         	push	{r7, lr}
 8003852: b0a4         	sub	sp, #0x90
 8003854: af00         	add	r7, sp, #0x0
 8003856: 60f8         	str	r0, [r7, #0xc]
 8003858: 60b9         	str	r1, [r7, #0x8]
 800385a: 607a         	str	r2, [r7, #0x4]
 800385c: 603b         	str	r3, [r7]
; 	uint8_t *buf0 = packaged;  /* buffer start (may be NULL) */
 800385e: 68fb         	ldr	r3, [r7, #0xc]
 8003860: 65fb         	str	r3, [r7, #0x5c]
; 	uintptr_t buf = (uintptr_t)buf0; /* current buffer position */
 8003862: 6dfb         	ldr	r3, [r7, #0x5c]
 8003864: f8c7 308c    	str.w	r3, [r7, #0x8c]
; 	unsigned int s_idx = 0;    /* index into str_ptr_pos[] */
 8003868: 2300         	movs	r3, #0x0
 800386a: f8c7 3080    	str.w	r3, [r7, #0x80]
; 	unsigned int s_rw_cnt = 0; /* number of rw strings */
 800386e: 2300         	movs	r3, #0x0
 8003870: 67fb         	str	r3, [r7, #0x7c]
; 	unsigned int s_ro_cnt = 0; /* number of ro strings */
 8003872: 2300         	movs	r3, #0x0
 8003874: 67bb         	str	r3, [r7, #0x78]
; 	int arg_idx	      = -1; /* Argument index. Preincremented thus starting from -1.*/
 8003876: f04f 33ff    	mov.w	r3, #0xffffffff
 800387a: 677b         	str	r3, [r7, #0x74]
; 	bool parsing = false;
 800387c: 2300         	movs	r3, #0x0
 800387e: f887 306b    	strb.w	r3, [r7, #0x6b]
; 	bool rws_pos_en = !!(flags & CBPRINTF_PACKAGE_ADD_RW_STR_POS);
 8003882: 687b         	ldr	r3, [r7, #0x4]
 8003884: f003 0304    	and	r3, r3, #0x4
 8003888: 2b00         	cmp	r3, #0x0
 800388a: bf14         	ite	ne
 800388c: 2301         	movne	r3, #0x1
 800388e: 2300         	moveq	r3, #0x0
 8003890: f887 305b    	strb.w	r3, [r7, #0x5b]
; 	int fros_cnt = 1 + Z_CBPRINTF_PACKAGE_FIRST_RO_STR_CNT_GET(flags);
 8003894: 687b         	ldr	r3, [r7, #0x4]
 8003896: 08db         	lsrs	r3, r3, #0x3
 8003898: f003 0307    	and	r3, r3, #0x7
 800389c: 3301         	adds	r3, #0x1
 800389e: 667b         	str	r3, [r7, #0x64]
; 	bool is_str_arg = false;
 80038a0: 2300         	movs	r3, #0x0
 80038a2: f887 3063    	strb.w	r3, [r7, #0x63]
; 	union cbprintf_package_hdr *pkg_hdr = packaged;
 80038a6: 68fb         	ldr	r3, [r7, #0xc]
 80038a8: 657b         	str	r3, [r7, #0x54]
; 	if ((uintptr_t)packaged % sizeof(void *)) {
 80038aa: 68fb         	ldr	r3, [r7, #0xc]
 80038ac: f003 0303    	and	r3, r3, #0x3
 80038b0: 2b00         	cmp	r3, #0x0
 80038b2: d002         	beq	0x80038ba <cbvprintf_package+0x6a> @ imm = #0x4
; 		return -EFAULT;
 80038b4: f06f 030d    	mvn	r3, #0xd
 80038b8: e3a2         	b	0x8004000 <cbvprintf_package+0x7b0> @ imm = #0x744
; 	buf += sizeof(*pkg_hdr);
 80038ba: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 80038be: 3304         	adds	r3, #0x4
 80038c0: f8c7 308c    	str.w	r3, [r7, #0x8c]
; 	if (buf0 == NULL) {
 80038c4: 6dfb         	ldr	r3, [r7, #0x5c]
 80038c6: 2b00         	cmp	r3, #0x0
 80038c8: d10d         	bne	0x80038e6 <cbvprintf_package+0x96> @ imm = #0x1a
; 		buf += len % CBPRINTF_PACKAGE_ALIGNMENT;
 80038ca: 68bb         	ldr	r3, [r7, #0x8]
 80038cc: f003 0307    	and	r3, r3, #0x7
 80038d0: f8d7 208c    	ldr.w	r2, [r7, #0x8c]
 80038d4: 4413         	add	r3, r2
 80038d6: f8c7 308c    	str.w	r3, [r7, #0x8c]
; 		len = CBPRINTF_PACKAGE_ALIGNMENT - (len % CBPRINTF_PACKAGE_ALIGNMENT);
 80038da: 68bb         	ldr	r3, [r7, #0x8]
 80038dc: f003 0307    	and	r3, r3, #0x7
 80038e0: f1c3 0308    	rsb.w	r3, r3, #0x8
 80038e4: 60bb         	str	r3, [r7, #0x8]
; 	if ((buf0 != NULL) && (BUF_OFFSET + sizeof(char *)) > len) {
 80038e6: 6dfb         	ldr	r3, [r7, #0x5c]
 80038e8: 2b00         	cmp	r3, #0x0
 80038ea: d00a         	beq	0x8003902 <cbvprintf_package+0xb2> @ imm = #0x14
 80038ec: 6dfb         	ldr	r3, [r7, #0x5c]
 80038ee: f8d7 208c    	ldr.w	r2, [r7, #0x8c]
 80038f2: 1ad3         	subs	r3, r2, r3
 80038f4: 3304         	adds	r3, #0x4
 80038f6: 68ba         	ldr	r2, [r7, #0x8]
 80038f8: 429a         	cmp	r2, r3
 80038fa: d202         	bhs	0x8003902 <cbvprintf_package+0xb2> @ imm = #0x4
; 		return -ENOSPC;
 80038fc: f06f 031b    	mvn	r3, #0x1b
 8003900: e37e         	b	0x8004000 <cbvprintf_package+0x7b0> @ imm = #0x6fc
; 	s = fmt;
 8003902: 683b         	ldr	r3, [r7]
 8003904: 66fb         	str	r3, [r7, #0x6c]
; 	--fmt;
 8003906: 683b         	ldr	r3, [r7]
 8003908: 3b01         	subs	r3, #0x1
 800390a: 603b         	str	r3, [r7]
; 	align = VA_STACK_ALIGN(char *);
 800390c: 2304         	movs	r3, #0x4
 800390e: f8c7 3084    	str.w	r3, [r7, #0x84]
; 	size = sizeof(char *);
 8003912: 2304         	movs	r3, #0x4
 8003914: f8c7 3088    	str.w	r3, [r7, #0x88]
; 	goto process_string;
 8003918: e197         	b	0x8003c4a <cbvprintf_package+0x3fa> @ imm = #0x32e
; 			if (!parsing) {
 800391a: f897 306b    	ldrb.w	r3, [r7, #0x6b]
 800391e: f083 0301    	eor	r3, r3, #0x1
 8003922: b2db         	uxtb	r3, r3
 8003924: 2b00         	cmp	r3, #0x0
 8003926: d011         	beq	0x800394c <cbvprintf_package+0xfc> @ imm = #0x22
; 				if (*fmt == '%') {
 8003928: 683b         	ldr	r3, [r7]
 800392a: 781b         	ldrb	r3, [r3]
 800392c: 2b25         	cmp	r3, #0x25
 800392e: f040 8278    	bne.w	0x8003e22 <cbvprintf_package+0x5d2> @ imm = #0x4f0
; 					parsing = true;
 8003932: 2301         	movs	r3, #0x1
 8003934: f887 306b    	strb.w	r3, [r7, #0x6b]
; 					arg_idx++;
 8003938: 6f7b         	ldr	r3, [r7, #0x74]
 800393a: 3301         	adds	r3, #0x1
 800393c: 677b         	str	r3, [r7, #0x74]
; 					align = VA_STACK_ALIGN(int);
 800393e: 2304         	movs	r3, #0x4
 8003940: f8c7 3084    	str.w	r3, [r7, #0x84]
; 					size = sizeof(int);
 8003944: 2304         	movs	r3, #0x4
 8003946: f8c7 3088    	str.w	r3, [r7, #0x88]
; 				continue;
 800394a: e26a         	b	0x8003e22 <cbvprintf_package+0x5d2> @ imm = #0x4d4
; 			switch (*fmt) {
 800394c: 683b         	ldr	r3, [r7]
 800394e: 781b         	ldrb	r3, [r3]
 8003950: 2b7a         	cmp	r3, #0x7a
 8003952: f300 8149    	bgt.w	0x8003be8 <cbvprintf_package+0x398> @ imm = #0x292
 8003956: 2b4c         	cmp	r3, #0x4c
 8003958: da11         	bge	0x800397e <cbvprintf_package+0x12e> @ imm = #0x22
 800395a: 2b47         	cmp	r3, #0x47
 800395c: f300 8144    	bgt.w	0x8003be8 <cbvprintf_package+0x398> @ imm = #0x288
 8003960: 2b2a         	cmp	r3, #0x2a
 8003962: da71         	bge	0x8003a48 <cbvprintf_package+0x1f8> @ imm = #0xe2
 8003964: 2b25         	cmp	r3, #0x25
 8003966: f000 8092    	beq.w	0x8003a8e <cbvprintf_package+0x23e> @ imm = #0x124
 800396a: 2b25         	cmp	r3, #0x25
 800396c: f300 813c    	bgt.w	0x8003be8 <cbvprintf_package+0x398> @ imm = #0x278
 8003970: 2b20         	cmp	r3, #0x20
 8003972: f000 8258    	beq.w	0x8003e26 <cbvprintf_package+0x5d6> @ imm = #0x4b0
 8003976: 2b23         	cmp	r3, #0x23
 8003978: f000 8255    	beq.w	0x8003e26 <cbvprintf_package+0x5d6> @ imm = #0x4aa
 800397c: e134         	b	0x8003be8 <cbvprintf_package+0x398> @ imm = #0x268
 800397e: 3b4c         	subs	r3, #0x4c
 8003980: 2b2e         	cmp	r3, #0x2e
 8003982: f200 8131    	bhi.w	0x8003be8 <cbvprintf_package+0x398> @ imm = #0x262
 8003986: a201         	adr	r2, #4 <cbvprintf_package+0x13b>
 8003988: f852 f023    	ldr.w	pc, [r2, r3, lsl #2]

0800398c <$d>:
 800398c: 27 3e 00 08  	.word	0x08003e27
 8003990: e9 3b 00 08  	.word	0x08003be9
 8003994: e9 3b 00 08  	.word	0x08003be9
 8003998: e9 3b 00 08  	.word	0x08003be9
 800399c: e9 3b 00 08  	.word	0x08003be9
 80039a0: e9 3b 00 08  	.word	0x08003be9
 80039a4: e9 3b 00 08  	.word	0x08003be9
 80039a8: e9 3b 00 08  	.word	0x08003be9
 80039ac: e9 3b 00 08  	.word	0x08003be9
 80039b0: e9 3b 00 08  	.word	0x08003be9
 80039b4: e9 3b 00 08  	.word	0x08003be9
 80039b8: e9 3b 00 08  	.word	0x08003be9
 80039bc: c7 3a 00 08  	.word	0x08003ac7
 80039c0: e9 3b 00 08  	.word	0x08003be9
 80039c4: e9 3b 00 08  	.word	0x08003be9
 80039c8: e9 3b 00 08  	.word	0x08003be9
 80039cc: e9 3b 00 08  	.word	0x08003be9
 80039d0: e9 3b 00 08  	.word	0x08003be9
 80039d4: e9 3b 00 08  	.word	0x08003be9
 80039d8: e9 3b 00 08  	.word	0x08003be9
 80039dc: e9 3b 00 08  	.word	0x08003be9
 80039e0: 17 3b 00 08  	.word	0x08003b17
 80039e4: e9 3b 00 08  	.word	0x08003be9
 80039e8: c7 3a 00 08  	.word	0x08003ac7
 80039ec: c7 3a 00 08  	.word	0x08003ac7
 80039f0: 17 3b 00 08  	.word	0x08003b17
 80039f4: 17 3b 00 08  	.word	0x08003b17
 80039f8: 17 3b 00 08  	.word	0x08003b17
 80039fc: 27 3e 00 08  	.word	0x08003e27
 8003a00: c7 3a 00 08  	.word	0x08003ac7
 8003a04: 9d 3a 00 08  	.word	0x08003a9d
 8003a08: e9 3b 00 08  	.word	0x08003be9
 8003a0c: 27 3e 00 08  	.word	0x08003e27
 8003a10: e9 3b 00 08  	.word	0x08003be9
 8003a14: 03 3b 00 08  	.word	0x08003b03
 8003a18: c7 3a 00 08  	.word	0x08003ac7
 8003a1c: 03 3b 00 08  	.word	0x08003b03
 8003a20: e9 3b 00 08  	.word	0x08003be9
 8003a24: e9 3b 00 08  	.word	0x08003be9
 8003a28: fd 3a 00 08  	.word	0x08003afd
 8003a2c: b9 3a 00 08  	.word	0x08003ab9
 8003a30: c7 3a 00 08  	.word	0x08003ac7
 8003a34: e9 3b 00 08  	.word	0x08003be9
 8003a38: e9 3b 00 08  	.word	0x08003be9
 8003a3c: c7 3a 00 08  	.word	0x08003ac7
 8003a40: e9 3b 00 08  	.word	0x08003be9
 8003a44: ab 3a 00 08  	.word	0x08003aab

08003a48 <$t>:
 8003a48: 3b2a         	subs	r3, #0x2a
 8003a4a: 2201         	movs	r2, #0x1
 8003a4c: fa02 f303    	lsl.w	r3, r2, r3
 8003a50: f64f 72da    	movw	r2, #0xffda
 8003a54: 401a         	ands	r2, r3
 8003a56: 2a00         	cmp	r2, #0x0
 8003a58: bf14         	ite	ne
 8003a5a: 2201         	movne	r2, #0x1
 8003a5c: 2200         	moveq	r2, #0x0
 8003a5e: b2d2         	uxtb	r2, r2
 8003a60: 2a00         	cmp	r2, #0x0
 8003a62: f040 81e0    	bne.w	0x8003e26 <cbvprintf_package+0x5d6> @ imm = #0x3c0
 8003a66: f003 5262    	and	r2, r3, #0x38800000
 8003a6a: 2a00         	cmp	r2, #0x0
 8003a6c: bf14         	ite	ne
 8003a6e: 2201         	movne	r2, #0x1
 8003a70: 2200         	moveq	r2, #0x0
 8003a72: b2d2         	uxtb	r2, r2
 8003a74: 2a00         	cmp	r2, #0x0
 8003a76: d14e         	bne	0x8003b16 <cbvprintf_package+0x2c6> @ imm = #0x9c
 8003a78: f003 0301    	and	r3, r3, #0x1
 8003a7c: 2b00         	cmp	r3, #0x0
 8003a7e: bf14         	ite	ne
 8003a80: 2301         	movne	r3, #0x1
 8003a82: 2300         	moveq	r3, #0x0
 8003a84: b2db         	uxtb	r3, r3
 8003a86: 2b00         	cmp	r3, #0x0
 8003a88: f040 80b2    	bne.w	0x8003bf0 <cbvprintf_package+0x3a0> @ imm = #0x164
 8003a8c: e0ac         	b	0x8003be8 <cbvprintf_package+0x398> @ imm = #0x158
; 				parsing = false;
 8003a8e: 2300         	movs	r3, #0x0
 8003a90: f887 306b    	strb.w	r3, [r7, #0x6b]
; 				arg_idx--;
 8003a94: 6f7b         	ldr	r3, [r7, #0x74]
 8003a96: 3b01         	subs	r3, #0x1
 8003a98: 677b         	str	r3, [r7, #0x74]
; 				continue;
 8003a9a: e1c5         	b	0x8003e28 <cbvprintf_package+0x5d8> @ imm = #0x38a
; 				align = VA_STACK_ALIGN(intmax_t);
 8003a9c: 2308         	movs	r3, #0x8
 8003a9e: f8c7 3084    	str.w	r3, [r7, #0x84]
; 				size = sizeof(intmax_t);
 8003aa2: 2308         	movs	r3, #0x8
 8003aa4: f8c7 3088    	str.w	r3, [r7, #0x88]
; 				continue;
 8003aa8: e1be         	b	0x8003e28 <cbvprintf_package+0x5d8> @ imm = #0x37c
; 				align = VA_STACK_ALIGN(size_t);
 8003aaa: 2304         	movs	r3, #0x4
 8003aac: f8c7 3084    	str.w	r3, [r7, #0x84]
; 				size = sizeof(size_t);
 8003ab0: 2304         	movs	r3, #0x4
 8003ab2: f8c7 3088    	str.w	r3, [r7, #0x88]
; 				continue;
 8003ab6: e1b7         	b	0x8003e28 <cbvprintf_package+0x5d8> @ imm = #0x36e
; 				align = VA_STACK_ALIGN(ptrdiff_t);
 8003ab8: 2304         	movs	r3, #0x4
 8003aba: f8c7 3084    	str.w	r3, [r7, #0x84]
; 				size = sizeof(ptrdiff_t);
 8003abe: 2304         	movs	r3, #0x4
 8003ac0: f8c7 3088    	str.w	r3, [r7, #0x88]
; 				continue;
 8003ac4: e1b0         	b	0x8003e28 <cbvprintf_package+0x5d8> @ imm = #0x360
; 				if (fmt[-1] == 'l') {
 8003ac6: 683b         	ldr	r3, [r7]
 8003ac8: 3b01         	subs	r3, #0x1
 8003aca: 781b         	ldrb	r3, [r3]
 8003acc: 2b6c         	cmp	r3, #0x6c
 8003ace: d111         	bne	0x8003af4 <cbvprintf_package+0x2a4> @ imm = #0x22
; 					if (fmt[-2] == 'l') {
 8003ad0: 683b         	ldr	r3, [r7]
 8003ad2: 3b02         	subs	r3, #0x2
 8003ad4: 781b         	ldrb	r3, [r3]
 8003ad6: 2b6c         	cmp	r3, #0x6c
 8003ad8: d106         	bne	0x8003ae8 <cbvprintf_package+0x298> @ imm = #0xc
; 						align = VA_STACK_ALIGN(long long);
 8003ada: 2308         	movs	r3, #0x8
 8003adc: f8c7 3084    	str.w	r3, [r7, #0x84]
; 						size = sizeof(long long);
 8003ae0: 2308         	movs	r3, #0x8
 8003ae2: f8c7 3088    	str.w	r3, [r7, #0x88]
 8003ae6: e005         	b	0x8003af4 <cbvprintf_package+0x2a4> @ imm = #0xa
; 						align = VA_STACK_ALIGN(long);
 8003ae8: 2304         	movs	r3, #0x4
 8003aea: f8c7 3084    	str.w	r3, [r7, #0x84]
; 						size = sizeof(long);
 8003aee: 2304         	movs	r3, #0x4
 8003af0: f8c7 3088    	str.w	r3, [r7, #0x88]
; 				parsing = false;
 8003af4: 2300         	movs	r3, #0x0
 8003af6: f887 306b    	strb.w	r3, [r7, #0x6b]
; 				break;
 8003afa: e07a         	b	0x8003bf2 <cbvprintf_package+0x3a2> @ imm = #0xf4
; 				is_str_arg = true;
 8003afc: 2301         	movs	r3, #0x1
 8003afe: f887 3063    	strb.w	r3, [r7, #0x63]
; 				align = VA_STACK_ALIGN(void *);
 8003b02: 2304         	movs	r3, #0x4
 8003b04: f8c7 3084    	str.w	r3, [r7, #0x84]
; 				size = sizeof(void *);
 8003b08: 2304         	movs	r3, #0x4
 8003b0a: f8c7 3088    	str.w	r3, [r7, #0x88]
; 				parsing = false;
 8003b0e: 2300         	movs	r3, #0x0
 8003b10: f887 306b    	strb.w	r3, [r7, #0x6b]
; 				break;
 8003b14: e06d         	b	0x8003bf2 <cbvprintf_package+0x3a2> @ imm = #0xda
; 				if (fmt[-1] == 'L') {
 8003b16: 683b         	ldr	r3, [r7]
 8003b18: 3b01         	subs	r3, #0x1
 8003b1a: 781b         	ldrb	r3, [r3]
 8003b1c: 2b4c         	cmp	r3, #0x4c
 8003b1e: d113         	bne	0x8003b48 <cbvprintf_package+0x2f8> @ imm = #0x26
; 					v.ld = va_arg(ap, long double);
 8003b20: f8d7 3098    	ldr.w	r3, [r7, #0x98]
 8003b24: 3307         	adds	r3, #0x7
 8003b26: f023 0307    	bic	r3, r3, #0x7
 8003b2a: f103 0208    	add.w	r2, r3, #0x8
 8003b2e: f8c7 2098    	str.w	r2, [r7, #0x98]
 8003b32: e9d3 2300    	ldrd	r2, r3, [r3]
 8003b36: e9c7 2306    	strd	r2, r3, [r7, #24]
; 					align = VA_STACK_ALIGN(long double);
 8003b3a: 2308         	movs	r3, #0x8
 8003b3c: f8c7 3084    	str.w	r3, [r7, #0x84]
; 					size = sizeof(long double);
 8003b40: 2308         	movs	r3, #0x8
 8003b42: f8c7 3088    	str.w	r3, [r7, #0x88]
 8003b46: e012         	b	0x8003b6e <cbvprintf_package+0x31e> @ imm = #0x24
; 					v.d = va_arg(ap, double);
 8003b48: f8d7 3098    	ldr.w	r3, [r7, #0x98]
 8003b4c: 3307         	adds	r3, #0x7
 8003b4e: f023 0307    	bic	r3, r3, #0x7
 8003b52: f103 0208    	add.w	r2, r3, #0x8
 8003b56: f8c7 2098    	str.w	r2, [r7, #0x98]
 8003b5a: e9d3 2300    	ldrd	r2, r3, [r3]
 8003b5e: e9c7 2306    	strd	r2, r3, [r7, #24]
; 					align = VA_STACK_ALIGN(double);
 8003b62: 2308         	movs	r3, #0x8
 8003b64: f8c7 3084    	str.w	r3, [r7, #0x84]
; 					size = sizeof(double);
 8003b68: 2308         	movs	r3, #0x8
 8003b6a: f8c7 3088    	str.w	r3, [r7, #0x88]
; 				buf = ROUND_UP(buf, align);
 8003b6e: f8d7 2084    	ldr.w	r2, [r7, #0x84]
 8003b72: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 8003b76: 4413         	add	r3, r2
 8003b78: 1e5a         	subs	r2, r3, #0x1
 8003b7a: f8d7 3084    	ldr.w	r3, [r7, #0x84]
 8003b7e: fbb2 f2f3    	udiv	r2, r2, r3
 8003b82: f8d7 3084    	ldr.w	r3, [r7, #0x84]
 8003b86: fb02 f303    	mul	r3, r2, r3
 8003b8a: f8c7 308c    	str.w	r3, [r7, #0x8c]
; 				if (buf0 != NULL) {
 8003b8e: 6dfb         	ldr	r3, [r7, #0x5c]
 8003b90: 2b00         	cmp	r3, #0x0
 8003b92: d01e         	beq	0x8003bd2 <cbvprintf_package+0x382> @ imm = #0x3c
; 					if (BUF_OFFSET + size > len) {
 8003b94: 6dfb         	ldr	r3, [r7, #0x5c]
 8003b96: f8d7 208c    	ldr.w	r2, [r7, #0x8c]
 8003b9a: 1ad2         	subs	r2, r2, r3
 8003b9c: f8d7 3088    	ldr.w	r3, [r7, #0x88]
 8003ba0: 4413         	add	r3, r2
 8003ba2: 68ba         	ldr	r2, [r7, #0x8]
 8003ba4: 429a         	cmp	r2, r3
 8003ba6: d202         	bhs	0x8003bae <cbvprintf_package+0x35e> @ imm = #0x4
; 						return -ENOSPC;
 8003ba8: f06f 031b    	mvn	r3, #0x1b
 8003bac: e228         	b	0x8004000 <cbvprintf_package+0x7b0> @ imm = #0x450
; 					} else if (fmt[-1] == 'L') {
 8003bae: 683b         	ldr	r3, [r7]
 8003bb0: 3b01         	subs	r3, #0x1
 8003bb2: 781b         	ldrb	r3, [r3]
 8003bb4: 2b4c         	cmp	r3, #0x4c
 8003bb6: d106         	bne	0x8003bc6 <cbvprintf_package+0x376> @ imm = #0xc
; 						*(long double *)buf = v.ld;
 8003bb8: f8d7 108c    	ldr.w	r1, [r7, #0x8c]
 8003bbc: e9d7 2306    	ldrd	r2, r3, [r7, #24]
 8003bc0: e9c1 2300    	strd	r2, r3, [r1]
 8003bc4: e005         	b	0x8003bd2 <cbvprintf_package+0x382> @ imm = #0xa
; 						*(double *)buf = v.d;
 8003bc6: f8d7 108c    	ldr.w	r1, [r7, #0x8c]
 8003bca: e9d7 2306    	ldrd	r2, r3, [r7, #24]
 8003bce: e9c1 2300    	strd	r2, r3, [r1]
; 				buf += size;
 8003bd2: f8d7 208c    	ldr.w	r2, [r7, #0x8c]
 8003bd6: f8d7 3088    	ldr.w	r3, [r7, #0x88]
 8003bda: 4413         	add	r3, r2
 8003bdc: f8c7 308c    	str.w	r3, [r7, #0x8c]
; 				parsing = false;
 8003be0: 2300         	movs	r3, #0x0
 8003be2: f887 306b    	strb.w	r3, [r7, #0x6b]
 8003be6: e11f         	b	0x8003e28 <cbvprintf_package+0x5d8> @ imm = #0x23e
; 				parsing = false;
 8003be8: 2300         	movs	r3, #0x0
 8003bea: f887 306b    	strb.w	r3, [r7, #0x6b]
; 				continue;
 8003bee: e11b         	b	0x8003e28 <cbvprintf_package+0x5d8> @ imm = #0x236
; 				break;
 8003bf0: bf00         	nop
; 		buf = ROUND_UP(buf, align);
 8003bf2: f8d7 2084    	ldr.w	r2, [r7, #0x84]
 8003bf6: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 8003bfa: 4413         	add	r3, r2
 8003bfc: 1e5a         	subs	r2, r3, #0x1
 8003bfe: f8d7 3084    	ldr.w	r3, [r7, #0x84]
 8003c02: fbb2 f2f3    	udiv	r2, r2, r3
 8003c06: f8d7 3084    	ldr.w	r3, [r7, #0x84]
 8003c0a: fb02 f303    	mul	r3, r2, r3
 8003c0e: f8c7 308c    	str.w	r3, [r7, #0x8c]
; 		if ((buf0 != NULL) && (BUF_OFFSET + size) > len) {
 8003c12: 6dfb         	ldr	r3, [r7, #0x5c]
 8003c14: 2b00         	cmp	r3, #0x0
 8003c16: d00c         	beq	0x8003c32 <cbvprintf_package+0x3e2> @ imm = #0x18
 8003c18: 6dfb         	ldr	r3, [r7, #0x5c]
 8003c1a: f8d7 208c    	ldr.w	r2, [r7, #0x8c]
 8003c1e: 1ad2         	subs	r2, r2, r3
 8003c20: f8d7 3088    	ldr.w	r3, [r7, #0x88]
 8003c24: 4413         	add	r3, r2
 8003c26: 68ba         	ldr	r2, [r7, #0x8]
 8003c28: 429a         	cmp	r2, r3
 8003c2a: d202         	bhs	0x8003c32 <cbvprintf_package+0x3e2> @ imm = #0x4
; 			return -ENOSPC;
 8003c2c: f06f 031b    	mvn	r3, #0x1b
 8003c30: e1e6         	b	0x8004000 <cbvprintf_package+0x7b0> @ imm = #0x3cc
; 		if (is_str_arg) {
 8003c32: f897 3063    	ldrb.w	r3, [r7, #0x63]
 8003c36: 2b00         	cmp	r3, #0x0
 8003c38: f000 80a0    	beq.w	0x8003d7c <cbvprintf_package+0x52c> @ imm = #0x140
; 			s = va_arg(ap, char *);
 8003c3c: f8d7 3098    	ldr.w	r3, [r7, #0x98]
 8003c40: 1d1a         	adds	r2, r3, #0x4
 8003c42: f8c7 2098    	str.w	r2, [r7, #0x98]
 8003c46: 681b         	ldr	r3, [r3]
 8003c48: 66fb         	str	r3, [r7, #0x6c]
; 			if (buf0 != NULL) {
 8003c4a: 6dfb         	ldr	r3, [r7, #0x5c]
 8003c4c: 2b00         	cmp	r3, #0x0
 8003c4e: d003         	beq	0x8003c58 <cbvprintf_package+0x408> @ imm = #0x6
; 				*(const char **)buf = s;
 8003c50: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 8003c54: 6efa         	ldr	r2, [r7, #0x6c]
 8003c56: 601a         	str	r2, [r3]
; 			bool is_ro = (fros_cnt-- > 0) ? true : ptr_in_rodata(s);
 8003c58: 6e7b         	ldr	r3, [r7, #0x64]
 8003c5a: 1e5a         	subs	r2, r3, #0x1
 8003c5c: 667a         	str	r2, [r7, #0x64]
 8003c5e: 2b00         	cmp	r3, #0x0
 8003c60: dc05         	bgt	0x8003c6e <cbvprintf_package+0x41e> @ imm = #0xa
 8003c62: 6ef8         	ldr	r0, [r7, #0x6c]
 8003c64: f010 ff4a    	bl	0x8014afc <ptr_in_rodata> @ imm = #0x10e94
 8003c68: 4603         	mov	r3, r0
 8003c6a: 2b00         	cmp	r3, #0x0
 8003c6c: d001         	beq	0x8003c72 <cbvprintf_package+0x422> @ imm = #0x2
 8003c6e: 2301         	movs	r3, #0x1
 8003c70: e000         	b	0x8003c74 <cbvprintf_package+0x424> @ imm = #0x0
 8003c72: 2300         	movs	r3, #0x0
 8003c74: f887 3053    	strb.w	r3, [r7, #0x53]
; 			bool do_ro = !!(flags & CBPRINTF_PACKAGE_ADD_RO_STR_POS);
 8003c78: 687b         	ldr	r3, [r7, #0x4]
 8003c7a: f003 0302    	and	r3, r3, #0x2
 8003c7e: 2b00         	cmp	r3, #0x0
 8003c80: bf14         	ite	ne
 8003c82: 2301         	movne	r3, #0x1
 8003c84: 2300         	moveq	r3, #0x0
 8003c86: f887 3052    	strb.w	r3, [r7, #0x52]
; 			if (is_ro && !do_ro) {
 8003c8a: f897 3053    	ldrb.w	r3, [r7, #0x53]
 8003c8e: 2b00         	cmp	r3, #0x0
 8003c90: d006         	beq	0x8003ca0 <cbvprintf_package+0x450> @ imm = #0xc
 8003c92: f897 3052    	ldrb.w	r3, [r7, #0x52]
 8003c96: f083 0301    	eor	r3, r3, #0x1
 8003c9a: b2db         	uxtb	r3, r3
 8003c9c: 2b00         	cmp	r3, #0x0
 8003c9e: d164         	bne	0x8003d6a <cbvprintf_package+0x51a> @ imm = #0xc8
; 				uint32_t s_ptr_idx = BUF_OFFSET / sizeof(int);
 8003ca0: 6dfb         	ldr	r3, [r7, #0x5c]
 8003ca2: f8d7 208c    	ldr.w	r2, [r7, #0x8c]
 8003ca6: 1ad3         	subs	r3, r2, r3
 8003ca8: 089b         	lsrs	r3, r3, #0x2
 8003caa: 64fb         	str	r3, [r7, #0x4c]
; 				if (do_ro && s_ptr_idx > STR_POS_MASK) {
 8003cac: f897 3052    	ldrb.w	r3, [r7, #0x52]
 8003cb0: 2b00         	cmp	r3, #0x0
 8003cb2: d005         	beq	0x8003cc0 <cbvprintf_package+0x470> @ imm = #0xa
 8003cb4: 6cfb         	ldr	r3, [r7, #0x4c]
 8003cb6: 2b7f         	cmp	r3, #0x7f
 8003cb8: d902         	bls	0x8003cc0 <cbvprintf_package+0x470> @ imm = #0x4
; 					return -EINVAL;
 8003cba: f06f 0315    	mvn	r3, #0x15
 8003cbe: e19f         	b	0x8004000 <cbvprintf_package+0x7b0> @ imm = #0x33e
; 				if (s_idx >= ARRAY_SIZE(str_ptr_pos)) {
 8003cc0: f8d7 3080    	ldr.w	r3, [r7, #0x80]
 8003cc4: 2b0f         	cmp	r3, #0xf
 8003cc6: d902         	bls	0x8003cce <cbvprintf_package+0x47e> @ imm = #0x4
; 					return -EINVAL;
 8003cc8: f06f 0315    	mvn	r3, #0x15
 8003ccc: e198         	b	0x8004000 <cbvprintf_package+0x7b0> @ imm = #0x330
; 				if (buf0 != NULL) {
 8003cce: 6dfb         	ldr	r3, [r7, #0x5c]
 8003cd0: 2b00         	cmp	r3, #0x0
 8003cd2: d02d         	beq	0x8003d30 <cbvprintf_package+0x4e0> @ imm = #0x5a
; 					str_ptr_pos[s_idx] = s_ptr_idx;
 8003cd4: 6cfb         	ldr	r3, [r7, #0x4c]
 8003cd6: b2d9         	uxtb	r1, r3
 8003cd8: f107 0230    	add.w	r2, r7, #0x30
 8003cdc: f8d7 3080    	ldr.w	r3, [r7, #0x80]
 8003ce0: 4413         	add	r3, r2
 8003ce2: 460a         	mov	r2, r1
 8003ce4: 701a         	strb	r2, [r3]
; 					str_ptr_arg[s_idx] = arg_idx;
 8003ce6: 6f7b         	ldr	r3, [r7, #0x74]
 8003ce8: b2d9         	uxtb	r1, r3
 8003cea: f107 0220    	add.w	r2, r7, #0x20
 8003cee: f8d7 3080    	ldr.w	r3, [r7, #0x80]
 8003cf2: 4413         	add	r3, r2
 8003cf4: 460a         	mov	r2, r1
 8003cf6: 701a         	strb	r2, [r3]
; 					if (is_ro) {
 8003cf8: f897 3053    	ldrb.w	r3, [r7, #0x53]
 8003cfc: 2b00         	cmp	r3, #0x0
 8003cfe: d013         	beq	0x8003d28 <cbvprintf_package+0x4d8> @ imm = #0x26
; 						str_ptr_pos[s_idx] |= STR_POS_RO_FLAG;
 8003d00: f107 0230    	add.w	r2, r7, #0x30
 8003d04: f8d7 3080    	ldr.w	r3, [r7, #0x80]
 8003d08: 4413         	add	r3, r2
 8003d0a: 781b         	ldrb	r3, [r3]
 8003d0c: f063 037f    	orn	r3, r3, #0x7f
 8003d10: b2d9         	uxtb	r1, r3
 8003d12: f107 0230    	add.w	r2, r7, #0x30
 8003d16: f8d7 3080    	ldr.w	r3, [r7, #0x80]
 8003d1a: 4413         	add	r3, r2
 8003d1c: 460a         	mov	r2, r1
 8003d1e: 701a         	strb	r2, [r3]
; 						s_ro_cnt++;
 8003d20: 6fbb         	ldr	r3, [r7, #0x78]
 8003d22: 3301         	adds	r3, #0x1
 8003d24: 67bb         	str	r3, [r7, #0x78]
 8003d26: e01b         	b	0x8003d60 <cbvprintf_package+0x510> @ imm = #0x36
; 						s_rw_cnt++;
 8003d28: 6ffb         	ldr	r3, [r7, #0x7c]
 8003d2a: 3301         	adds	r3, #0x1
 8003d2c: 67fb         	str	r3, [r7, #0x7c]
 8003d2e: e017         	b	0x8003d60 <cbvprintf_package+0x510> @ imm = #0x2e
; 				} else if (is_ro) {
 8003d30: f897 3053    	ldrb.w	r3, [r7, #0x53]
 8003d34: 2b00         	cmp	r3, #0x0
 8003d36: d003         	beq	0x8003d40 <cbvprintf_package+0x4f0> @ imm = #0x6
; 					len += 1;
 8003d38: 68bb         	ldr	r3, [r7, #0x8]
 8003d3a: 3301         	adds	r3, #0x1
 8003d3c: 60bb         	str	r3, [r7, #0x8]
 8003d3e: e00f         	b	0x8003d60 <cbvprintf_package+0x510> @ imm = #0x1e
; 				} else if (rws_pos_en) {
 8003d40: f897 305b    	ldrb.w	r3, [r7, #0x5b]
 8003d44: 2b00         	cmp	r3, #0x0
 8003d46: d003         	beq	0x8003d50 <cbvprintf_package+0x500> @ imm = #0x6
; 					len += 2;
 8003d48: 68bb         	ldr	r3, [r7, #0x8]
 8003d4a: 3302         	adds	r3, #0x2
 8003d4c: 60bb         	str	r3, [r7, #0x8]
 8003d4e: e007         	b	0x8003d60 <cbvprintf_package+0x510> @ imm = #0xe
; 					len += strlen(s) + 1 + 1;
 8003d50: 6ef8         	ldr	r0, [r7, #0x6c]
 8003d52: f7fc fd7d    	bl	0x8000850 <strlen>      @ imm = #-0x3506
 8003d56: 4602         	mov	r2, r0
 8003d58: 68bb         	ldr	r3, [r7, #0x8]
 8003d5a: 4413         	add	r3, r2
 8003d5c: 3302         	adds	r3, #0x2
 8003d5e: 60bb         	str	r3, [r7, #0x8]
; 				s_idx++;
 8003d60: f8d7 3080    	ldr.w	r3, [r7, #0x80]
 8003d64: 3301         	adds	r3, #0x1
 8003d66: f8c7 3080    	str.w	r3, [r7, #0x80]
; 			buf += sizeof(char *);
 8003d6a: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 8003d6e: 3304         	adds	r3, #0x4
 8003d70: f8c7 308c    	str.w	r3, [r7, #0x8c]
; 			is_str_arg = false;
 8003d74: 2300         	movs	r3, #0x0
 8003d76: f887 3063    	strb.w	r3, [r7, #0x63]
 8003d7a: e055         	b	0x8003e28 <cbvprintf_package+0x5d8> @ imm = #0xaa
; 		} else if (size == sizeof(int)) {
 8003d7c: f8d7 3088    	ldr.w	r3, [r7, #0x88]
 8003d80: 2b04         	cmp	r3, #0x4
 8003d82: d113         	bne	0x8003dac <cbvprintf_package+0x55c> @ imm = #0x26
; 			int v = va_arg(ap, int);
 8003d84: f8d7 3098    	ldr.w	r3, [r7, #0x98]
 8003d88: 1d1a         	adds	r2, r3, #0x4
 8003d8a: f8c7 2098    	str.w	r2, [r7, #0x98]
 8003d8e: 681b         	ldr	r3, [r3]
 8003d90: 647b         	str	r3, [r7, #0x44]
; 			if (buf0 != NULL) {
 8003d92: 6dfb         	ldr	r3, [r7, #0x5c]
 8003d94: 2b00         	cmp	r3, #0x0
 8003d96: d003         	beq	0x8003da0 <cbvprintf_package+0x550> @ imm = #0x6
; 				*(int *)buf = v;
 8003d98: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 8003d9c: 6c7a         	ldr	r2, [r7, #0x44]
 8003d9e: 601a         	str	r2, [r3]
; 			buf += sizeof(int);
 8003da0: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 8003da4: 3304         	adds	r3, #0x4
 8003da6: f8c7 308c    	str.w	r3, [r7, #0x8c]
 8003daa: e03d         	b	0x8003e28 <cbvprintf_package+0x5d8> @ imm = #0x7a
; 		} else if (size == sizeof(long)) {
 8003dac: f8d7 3088    	ldr.w	r3, [r7, #0x88]
 8003db0: 2b04         	cmp	r3, #0x4
 8003db2: d113         	bne	0x8003ddc <cbvprintf_package+0x58c> @ imm = #0x26
; 			long v = va_arg(ap, long);
 8003db4: f8d7 3098    	ldr.w	r3, [r7, #0x98]
 8003db8: 1d1a         	adds	r2, r3, #0x4
 8003dba: f8c7 2098    	str.w	r2, [r7, #0x98]
 8003dbe: 681b         	ldr	r3, [r3]
 8003dc0: 64bb         	str	r3, [r7, #0x48]
; 			if (buf0 != NULL) {
 8003dc2: 6dfb         	ldr	r3, [r7, #0x5c]
 8003dc4: 2b00         	cmp	r3, #0x0
 8003dc6: d003         	beq	0x8003dd0 <cbvprintf_package+0x580> @ imm = #0x6
; 				*(long *)buf = v;
 8003dc8: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 8003dcc: 6cba         	ldr	r2, [r7, #0x48]
 8003dce: 601a         	str	r2, [r3]
; 			buf += sizeof(long);
 8003dd0: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 8003dd4: 3304         	adds	r3, #0x4
 8003dd6: f8c7 308c    	str.w	r3, [r7, #0x8c]
 8003dda: e025         	b	0x8003e28 <cbvprintf_package+0x5d8> @ imm = #0x4a
; 		} else if (size == sizeof(long long)) {
 8003ddc: f8d7 3088    	ldr.w	r3, [r7, #0x88]
 8003de0: 2b08         	cmp	r3, #0x8
 8003de2: d11b         	bne	0x8003e1c <cbvprintf_package+0x5cc> @ imm = #0x36
; 			long long v = va_arg(ap, long long);
 8003de4: f8d7 3098    	ldr.w	r3, [r7, #0x98]
 8003de8: 3307         	adds	r3, #0x7
 8003dea: f023 0307    	bic	r3, r3, #0x7
 8003dee: f103 0208    	add.w	r2, r3, #0x8
 8003df2: f8c7 2098    	str.w	r2, [r7, #0x98]
 8003df6: e9d3 2300    	ldrd	r2, r3, [r3]
 8003dfa: e9c7 2304    	strd	r2, r3, [r7, #16]
; 			if (buf0 != NULL) {
 8003dfe: 6dfb         	ldr	r3, [r7, #0x5c]
 8003e00: 2b00         	cmp	r3, #0x0
 8003e02: d005         	beq	0x8003e10 <cbvprintf_package+0x5c0> @ imm = #0xa
; 					*(long long *)buf = v;
 8003e04: f8d7 108c    	ldr.w	r1, [r7, #0x8c]
 8003e08: e9d7 2304    	ldrd	r2, r3, [r7, #16]
 8003e0c: e9c1 2300    	strd	r2, r3, [r1]
; 			buf += sizeof(long long);
 8003e10: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 8003e14: 3308         	adds	r3, #0x8
 8003e16: f8c7 308c    	str.w	r3, [r7, #0x8c]
 8003e1a: e005         	b	0x8003e28 <cbvprintf_package+0x5d8> @ imm = #0xa
; 			return -EINVAL;
 8003e1c: f06f 0315    	mvn	r3, #0x15
 8003e20: e0ee         	b	0x8004000 <cbvprintf_package+0x7b0> @ imm = #0x1dc
; 				continue;
 8003e22: bf00         	nop
 8003e24: e000         	b	0x8003e28 <cbvprintf_package+0x5d8> @ imm = #0x0
; 				continue;
 8003e26: bf00         	nop
; 			if (*++fmt == '\0') {
 8003e28: 683b         	ldr	r3, [r7]
 8003e2a: 3301         	adds	r3, #0x1
 8003e2c: 603b         	str	r3, [r7]
 8003e2e: 683b         	ldr	r3, [r7]
 8003e30: 781b         	ldrb	r3, [r3]
 8003e32: 2b00         	cmp	r3, #0x0
 8003e34: f47f ad71    	bne.w	0x800391a <cbvprintf_package+0xca> @ imm = #-0x51e
; 				break;
 8003e38: bf00         	nop
; 	if ((BUF_OFFSET / sizeof(int)) > 255) {
 8003e3a: 6dfb         	ldr	r3, [r7, #0x5c]
 8003e3c: f8d7 208c    	ldr.w	r2, [r7, #0x8c]
 8003e40: 1ad3         	subs	r3, r2, r3
 8003e42: f5b3 6f80    	cmp.w	r3, #0x400
 8003e46: d302         	blo	0x8003e4e <cbvprintf_package+0x5fe> @ imm = #0x4
; 		return -EINVAL;
 8003e48: f06f 0315    	mvn	r3, #0x15
 8003e4c: e0d8         	b	0x8004000 <cbvprintf_package+0x7b0> @ imm = #0x1b0
; 	if (buf0 == NULL) {
 8003e4e: 6dfb         	ldr	r3, [r7, #0x5c]
 8003e50: 2b00         	cmp	r3, #0x0
 8003e52: d107         	bne	0x8003e64 <cbvprintf_package+0x614> @ imm = #0xe
; 		return BUF_OFFSET + len - CBPRINTF_PACKAGE_ALIGNMENT;
 8003e54: 6dfb         	ldr	r3, [r7, #0x5c]
 8003e56: f8d7 208c    	ldr.w	r2, [r7, #0x8c]
 8003e5a: 1ad2         	subs	r2, r2, r3
 8003e5c: 68bb         	ldr	r3, [r7, #0x8]
 8003e5e: 4413         	add	r3, r2
 8003e60: 3b08         	subs	r3, #0x8
 8003e62: e0cd         	b	0x8004000 <cbvprintf_package+0x7b0> @ imm = #0x19a
; 	*(char **)buf0 = NULL;
 8003e64: 6dfb         	ldr	r3, [r7, #0x5c]
 8003e66: 2200         	movs	r2, #0x0
 8003e68: 601a         	str	r2, [r3]
; 	pkg_hdr->desc.len = BUF_OFFSET / sizeof(int);
 8003e6a: 6dfb         	ldr	r3, [r7, #0x5c]
 8003e6c: f8d7 208c    	ldr.w	r2, [r7, #0x8c]
 8003e70: 1ad3         	subs	r3, r2, r3
 8003e72: 089b         	lsrs	r3, r3, #0x2
 8003e74: b2da         	uxtb	r2, r3
 8003e76: 6d7b         	ldr	r3, [r7, #0x54]
 8003e78: 701a         	strb	r2, [r3]
; 	if (rws_pos_en) {
 8003e7a: f897 305b    	ldrb.w	r3, [r7, #0x5b]
 8003e7e: 2b00         	cmp	r3, #0x0
 8003e80: d007         	beq	0x8003e92 <cbvprintf_package+0x642> @ imm = #0xe
; 		pkg_hdr->desc.str_cnt = 0;
 8003e82: 6d7b         	ldr	r3, [r7, #0x54]
 8003e84: 2200         	movs	r2, #0x0
 8003e86: 705a         	strb	r2, [r3, #0x1]
; 		pkg_hdr->desc.rw_str_cnt = s_rw_cnt;
 8003e88: 6ffb         	ldr	r3, [r7, #0x7c]
 8003e8a: b2da         	uxtb	r2, r3
 8003e8c: 6d7b         	ldr	r3, [r7, #0x54]
 8003e8e: 70da         	strb	r2, [r3, #0x3]
 8003e90: e006         	b	0x8003ea0 <cbvprintf_package+0x650> @ imm = #0xc
; 		pkg_hdr->desc.str_cnt = s_rw_cnt;
 8003e92: 6ffb         	ldr	r3, [r7, #0x7c]
 8003e94: b2da         	uxtb	r2, r3
 8003e96: 6d7b         	ldr	r3, [r7, #0x54]
 8003e98: 705a         	strb	r2, [r3, #0x1]
; 		pkg_hdr->desc.rw_str_cnt = 0;
 8003e9a: 6d7b         	ldr	r3, [r7, #0x54]
 8003e9c: 2200         	movs	r2, #0x0
 8003e9e: 70da         	strb	r2, [r3, #0x3]
; 	pkg_hdr->desc.ro_str_cnt = s_ro_cnt;
 8003ea0: 6fbb         	ldr	r3, [r7, #0x78]
 8003ea2: b2da         	uxtb	r2, r3
 8003ea4: 6d7b         	ldr	r3, [r7, #0x54]
 8003ea6: 709a         	strb	r2, [r3, #0x2]
; 	if (s_ro_cnt != 0U) {
 8003ea8: 6fbb         	ldr	r3, [r7, #0x78]
 8003eaa: 2b00         	cmp	r3, #0x0
 8003eac: d032         	beq	0x8003f14 <cbvprintf_package+0x6c4> @ imm = #0x64
; 		for (i = 0; i < s_idx; i++) {
 8003eae: 2300         	movs	r3, #0x0
 8003eb0: 673b         	str	r3, [r7, #0x70]
 8003eb2: e02a         	b	0x8003f0a <cbvprintf_package+0x6ba> @ imm = #0x54
; 			if (!(str_ptr_pos[i] & STR_POS_RO_FLAG)) {
 8003eb4: f107 0230    	add.w	r2, r7, #0x30
 8003eb8: 6f3b         	ldr	r3, [r7, #0x70]
 8003eba: 4413         	add	r3, r2
 8003ebc: 781b         	ldrb	r3, [r3]
 8003ebe: b25b         	sxtb	r3, r3
 8003ec0: 2b00         	cmp	r3, #0x0
 8003ec2: da1e         	bge	0x8003f02 <cbvprintf_package+0x6b2> @ imm = #0x3c
; 			uint8_t pos = str_ptr_pos[i] & STR_POS_MASK;
 8003ec4: f107 0230    	add.w	r2, r7, #0x30
 8003ec8: 6f3b         	ldr	r3, [r7, #0x70]
 8003eca: 4413         	add	r3, r2
 8003ecc: 781b         	ldrb	r3, [r3]
 8003ece: f003 037f    	and	r3, r3, #0x7f
 8003ed2: f887 3043    	strb.w	r3, [r7, #0x43]
; 			if ((BUF_OFFSET + 1) > len) {
 8003ed6: 6dfb         	ldr	r3, [r7, #0x5c]
 8003ed8: f8d7 208c    	ldr.w	r2, [r7, #0x8c]
 8003edc: 1ad3         	subs	r3, r2, r3
 8003ede: 3301         	adds	r3, #0x1
 8003ee0: 68ba         	ldr	r2, [r7, #0x8]
 8003ee2: 429a         	cmp	r2, r3
 8003ee4: d202         	bhs	0x8003eec <cbvprintf_package+0x69c> @ imm = #0x4
; 				return -ENOSPC;
 8003ee6: f06f 031b    	mvn	r3, #0x1b
 8003eea: e089         	b	0x8004000 <cbvprintf_package+0x7b0> @ imm = #0x112
; 			*(uint8_t *)buf = pos;
 8003eec: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 8003ef0: f897 2043    	ldrb.w	r2, [r7, #0x43]
 8003ef4: 701a         	strb	r2, [r3]
; 			++buf;
 8003ef6: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 8003efa: 3301         	adds	r3, #0x1
 8003efc: f8c7 308c    	str.w	r3, [r7, #0x8c]
 8003f00: e000         	b	0x8003f04 <cbvprintf_package+0x6b4> @ imm = #0x0
; 				continue;
 8003f02: bf00         	nop
; 		for (i = 0; i < s_idx; i++) {
 8003f04: 6f3b         	ldr	r3, [r7, #0x70]
 8003f06: 3301         	adds	r3, #0x1
 8003f08: 673b         	str	r3, [r7, #0x70]
 8003f0a: 6f3a         	ldr	r2, [r7, #0x70]
 8003f0c: f8d7 3080    	ldr.w	r3, [r7, #0x80]
 8003f10: 429a         	cmp	r2, r3
 8003f12: d3cf         	blo	0x8003eb4 <cbvprintf_package+0x664> @ imm = #-0x62
; 	for (i = 0; i < s_idx; i++) {
 8003f14: 2300         	movs	r3, #0x0
 8003f16: 673b         	str	r3, [r7, #0x70]
 8003f18: e069         	b	0x8003fee <cbvprintf_package+0x79e> @ imm = #0xd2
; 		if (s_ro_cnt && str_ptr_pos[i] & STR_POS_RO_FLAG) {
 8003f1a: 6fbb         	ldr	r3, [r7, #0x78]
 8003f1c: 2b00         	cmp	r3, #0x0
 8003f1e: d007         	beq	0x8003f30 <cbvprintf_package+0x6e0> @ imm = #0xe
 8003f20: f107 0230    	add.w	r2, r7, #0x30
 8003f24: 6f3b         	ldr	r3, [r7, #0x70]
 8003f26: 4413         	add	r3, r2
 8003f28: 781b         	ldrb	r3, [r3]
 8003f2a: b25b         	sxtb	r3, r3
 8003f2c: 2b00         	cmp	r3, #0x0
 8003f2e: db5a         	blt	0x8003fe6 <cbvprintf_package+0x796> @ imm = #0xb4
; 		if (rws_pos_en) {
 8003f30: f897 305b    	ldrb.w	r3, [r7, #0x5b]
 8003f34: 2b00         	cmp	r3, #0x0
 8003f36: d010         	beq	0x8003f5a <cbvprintf_package+0x70a> @ imm = #0x20
; 			size = 0;
 8003f38: 2300         	movs	r3, #0x0
 8003f3a: f8c7 3088    	str.w	r3, [r7, #0x88]
; 			*(uint8_t *)buf = str_ptr_arg[i];
 8003f3e: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 8003f42: f107 0120    	add.w	r1, r7, #0x20
 8003f46: 6f3a         	ldr	r2, [r7, #0x70]
 8003f48: 440a         	add	r2, r1
 8003f4a: 7812         	ldrb	r2, [r2]
 8003f4c: 701a         	strb	r2, [r3]
; 			++buf;
 8003f4e: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 8003f52: 3301         	adds	r3, #0x1
 8003f54: f8c7 308c    	str.w	r3, [r7, #0x8c]
 8003f58: e01a         	b	0x8003f90 <cbvprintf_package+0x740> @ imm = #0x34
; 			s = *(char **)(buf0 + str_ptr_pos[i] * sizeof(int));
 8003f5a: f107 0230    	add.w	r2, r7, #0x30
 8003f5e: 6f3b         	ldr	r3, [r7, #0x70]
 8003f60: 4413         	add	r3, r2
 8003f62: 781b         	ldrb	r3, [r3]
 8003f64: 009b         	lsls	r3, r3, #0x2
 8003f66: 6dfa         	ldr	r2, [r7, #0x5c]
 8003f68: 4413         	add	r3, r2
 8003f6a: 681b         	ldr	r3, [r3]
 8003f6c: 66fb         	str	r3, [r7, #0x6c]
; 			*(char **)(buf0 + str_ptr_pos[i] * sizeof(int)) = NULL;
 8003f6e: f107 0230    	add.w	r2, r7, #0x30
 8003f72: 6f3b         	ldr	r3, [r7, #0x70]
 8003f74: 4413         	add	r3, r2
 8003f76: 781b         	ldrb	r3, [r3]
 8003f78: 009b         	lsls	r3, r3, #0x2
 8003f7a: 6dfa         	ldr	r2, [r7, #0x5c]
 8003f7c: 4413         	add	r3, r2
 8003f7e: 2200         	movs	r2, #0x0
 8003f80: 601a         	str	r2, [r3]
; 			size = strlen(s) + 1;
 8003f82: 6ef8         	ldr	r0, [r7, #0x6c]
 8003f84: f7fc fc64    	bl	0x8000850 <strlen>      @ imm = #-0x3738
 8003f88: 4603         	mov	r3, r0
 8003f8a: 3301         	adds	r3, #0x1
 8003f8c: f8c7 3088    	str.w	r3, [r7, #0x88]
; 		if ((BUF_OFFSET + 1 + size) > len) {
 8003f90: 6dfb         	ldr	r3, [r7, #0x5c]
 8003f92: f8d7 208c    	ldr.w	r2, [r7, #0x8c]
 8003f96: 1ad2         	subs	r2, r2, r3
 8003f98: f8d7 3088    	ldr.w	r3, [r7, #0x88]
 8003f9c: 4413         	add	r3, r2
 8003f9e: 3301         	adds	r3, #0x1
 8003fa0: 68ba         	ldr	r2, [r7, #0x8]
 8003fa2: 429a         	cmp	r2, r3
 8003fa4: d202         	bhs	0x8003fac <cbvprintf_package+0x75c> @ imm = #0x4
; 			return -ENOSPC;
 8003fa6: f06f 031b    	mvn	r3, #0x1b
 8003faa: e029         	b	0x8004000 <cbvprintf_package+0x7b0> @ imm = #0x52
; 		*(uint8_t *)buf = str_ptr_pos[i];
 8003fac: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 8003fb0: f107 0130    	add.w	r1, r7, #0x30
 8003fb4: 6f3a         	ldr	r2, [r7, #0x70]
 8003fb6: 440a         	add	r2, r1
 8003fb8: 7812         	ldrb	r2, [r2]
 8003fba: 701a         	strb	r2, [r3]
; 		++buf;
 8003fbc: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 8003fc0: 3301         	adds	r3, #0x1
 8003fc2: f8c7 308c    	str.w	r3, [r7, #0x8c]
; 		memcpy((void *)buf, (uint8_t *)s, size);
 8003fc6: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 8003fca: f8d7 2088    	ldr.w	r2, [r7, #0x88]
 8003fce: 6ef9         	ldr	r1, [r7, #0x6c]
 8003fd0: 4618         	mov	r0, r3
 8003fd2: f019 fbfd    	bl	0x801d7d0 <memcpy>      @ imm = #0x197fa
; 		buf += size;
 8003fd6: f8d7 208c    	ldr.w	r2, [r7, #0x8c]
 8003fda: f8d7 3088    	ldr.w	r3, [r7, #0x88]
 8003fde: 4413         	add	r3, r2
 8003fe0: f8c7 308c    	str.w	r3, [r7, #0x8c]
 8003fe4: e000         	b	0x8003fe8 <cbvprintf_package+0x798> @ imm = #0x0
; 			continue;
 8003fe6: bf00         	nop
; 	for (i = 0; i < s_idx; i++) {
 8003fe8: 6f3b         	ldr	r3, [r7, #0x70]
 8003fea: 3301         	adds	r3, #0x1
 8003fec: 673b         	str	r3, [r7, #0x70]
 8003fee: 6f3a         	ldr	r2, [r7, #0x70]
 8003ff0: f8d7 3080    	ldr.w	r3, [r7, #0x80]
 8003ff4: 429a         	cmp	r2, r3
 8003ff6: d390         	blo	0x8003f1a <cbvprintf_package+0x6ca> @ imm = #-0xe0
; 	return BUF_OFFSET;
 8003ff8: 6dfb         	ldr	r3, [r7, #0x5c]
 8003ffa: f8d7 208c    	ldr.w	r2, [r7, #0x8c]
 8003ffe: 1ad3         	subs	r3, r2, r3
; }
 8004000: 4618         	mov	r0, r3
 8004002: 3790         	adds	r7, #0x90
 8004004: 46bd         	mov	sp, r7
 8004006: bd80         	pop	{r7, pc}

08004008 <__printk_hook_install>:
; {
 8004008: b480         	push	{r7}
 800400a: b083         	sub	sp, #0xc
 800400c: af00         	add	r7, sp, #0x0
 800400e: 6078         	str	r0, [r7, #0x4]
; 	_char_out = fn;
 8004010: 4a03         	ldr	r2, [pc, #0xc]          @ 0x8004020 <__printk_hook_install+0x18>
 8004012: 687b         	ldr	r3, [r7, #0x4]
 8004014: 6013         	str	r3, [r2]
; }
 8004016: bf00         	nop
 8004018: 370c         	adds	r7, #0xc
 800401a: 46bd         	mov	sp, r7
 800401c: bc80         	pop	{r7}
 800401e: 4770         	bx	lr

08004020 <$d>:
 8004020: ac 04 00 20  	.word	0x200004ac

08004024 <k_current_get>:
; {
 8004024: b580         	push	{r7, lr}
 8004026: af00         	add	r7, sp, #0x0
; 	return z_tls_current;
 8004028: f019 fe0c    	bl	0x801dc44 <__aeabi_read_tp> @ imm = #0x19c18
 800402c: 4603         	mov	r3, r0
 800402e: 4a02         	ldr	r2, [pc, #0x8]          @ 0x8004038 <k_current_get+0x14>
 8004030: 589b         	ldr	r3, [r3, r2]
; }
 8004032: 4618         	mov	r0, r3
 8004034: bd80         	pop	{r7, pc}
 8004036: bf00         	nop

08004038 <$d>:
 8004038: 08 00 00 00  	.word	0x00000008

0800403c <z_thread_entry>:
; {
 800403c: b580         	push	{r7, lr}
 800403e: b084         	sub	sp, #0x10
 8004040: af00         	add	r7, sp, #0x0
 8004042: 60f8         	str	r0, [r7, #0xc]
 8004044: 60b9         	str	r1, [r7, #0x8]
 8004046: 607a         	str	r2, [r7, #0x4]
 8004048: 603b         	str	r3, [r7]
; 	z_tls_current = k_sched_current_thread_query();
 800404a: f010 fdf9    	bl	0x8014c40 <k_sched_current_thread_query> @ imm = #0x10bf2
 800404e: 4602         	mov	r2, r0
 8004050: f019 fdf8    	bl	0x801dc44 <__aeabi_read_tp> @ imm = #0x19bf0
 8004054: 4603         	mov	r3, r0
 8004056: 4906         	ldr	r1, [pc, #0x18]         @ 0x8004070 <z_thread_entry+0x34>
 8004058: 505a         	str	r2, [r3, r1]
; 	entry(p1, p2, p3);
 800405a: 68fb         	ldr	r3, [r7, #0xc]
 800405c: 683a         	ldr	r2, [r7]
 800405e: 6879         	ldr	r1, [r7, #0x4]
 8004060: 68b8         	ldr	r0, [r7, #0x8]
 8004062: 4798         	blx	r3
; 	k_thread_abort(k_current_get());
 8004064: f7ff ffde    	bl	0x8004024 <k_current_get> @ imm = #-0x44
 8004068: 4603         	mov	r3, r0
 800406a: 4618         	mov	r0, r3
 800406c: f010 fdef    	bl	0x8014c4e <k_thread_abort> @ imm = #0x10bde

08004070 <$d>:
 8004070: 08 00 00 00  	.word	0x00000008

08004074 <LL_DBGMCU_DisableDBGStopMode>:
; {
 8004074: b480         	push	{r7}
 8004076: af00         	add	r7, sp, #0x0
;   CLEAR_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STOP);
 8004078: 4b04         	ldr	r3, [pc, #0x10]         @ 0x800408c <LL_DBGMCU_DisableDBGStopMode+0x18>
 800407a: 685b         	ldr	r3, [r3, #0x4]
 800407c: 4a03         	ldr	r2, [pc, #0xc]          @ 0x800408c <LL_DBGMCU_DisableDBGStopMode+0x18>
 800407e: f023 0302    	bic	r3, r3, #0x2
 8004082: 6053         	str	r3, [r2, #0x4]
; }
 8004084: bf00         	nop
 8004086: 46bd         	mov	sp, r7
 8004088: bc80         	pop	{r7}
 800408a: 4770         	bx	lr

0800408c <$d>:
 800408c: 00 20 04 e0  	.word	0xe0042000

08004090 <LL_FLASH_EnablePrefetch>:
; {
 8004090: b480         	push	{r7}
 8004092: af00         	add	r7, sp, #0x0
;   SET_BIT(FLASH->ACR, FLASH_ACR_PRFTEN);
 8004094: 4b04         	ldr	r3, [pc, #0x10]         @ 0x80040a8 <LL_FLASH_EnablePrefetch+0x18>
 8004096: 681b         	ldr	r3, [r3]
 8004098: 4a03         	ldr	r2, [pc, #0xc]          @ 0x80040a8 <LL_FLASH_EnablePrefetch+0x18>
 800409a: f443 7380    	orr	r3, r3, #0x100
 800409e: 6013         	str	r3, [r2]
; }
 80040a0: bf00         	nop
 80040a2: 46bd         	mov	sp, r7
 80040a4: bc80         	pop	{r7}
 80040a6: 4770         	bx	lr

080040a8 <$d>:
 80040a8: 00 3c 02 40  	.word	0x40023c00

080040ac <LL_FLASH_EnableInstCache>:
; {
 80040ac: b480         	push	{r7}
 80040ae: af00         	add	r7, sp, #0x0
;   SET_BIT(FLASH->ACR, FLASH_ACR_ICEN);
 80040b0: 4b04         	ldr	r3, [pc, #0x10]         @ 0x80040c4 <LL_FLASH_EnableInstCache+0x18>
 80040b2: 681b         	ldr	r3, [r3]
 80040b4: 4a03         	ldr	r2, [pc, #0xc]          @ 0x80040c4 <LL_FLASH_EnableInstCache+0x18>
 80040b6: f443 7300    	orr	r3, r3, #0x200
 80040ba: 6013         	str	r3, [r2]
; }
 80040bc: bf00         	nop
 80040be: 46bd         	mov	sp, r7
 80040c0: bc80         	pop	{r7}
 80040c2: 4770         	bx	lr

080040c4 <$d>:
 80040c4: 00 3c 02 40  	.word	0x40023c00

080040c8 <LL_FLASH_EnableDataCache>:
; {
 80040c8: b480         	push	{r7}
 80040ca: af00         	add	r7, sp, #0x0
;   SET_BIT(FLASH->ACR, FLASH_ACR_DCEN);
 80040cc: 4b04         	ldr	r3, [pc, #0x10]         @ 0x80040e0 <LL_FLASH_EnableDataCache+0x18>
 80040ce: 681b         	ldr	r3, [r3]
 80040d0: 4a03         	ldr	r2, [pc, #0xc]          @ 0x80040e0 <LL_FLASH_EnableDataCache+0x18>
 80040d2: f443 6380    	orr	r3, r3, #0x400
 80040d6: 6013         	str	r3, [r2]
; }
 80040d8: bf00         	nop
 80040da: 46bd         	mov	sp, r7
 80040dc: bc80         	pop	{r7}
 80040de: 4770         	bx	lr

080040e0 <$d>:
 80040e0: 00 3c 02 40  	.word	0x40023c00

080040e4 <soc_early_init_hook>:
; {
 80040e4: b580         	push	{r7, lr}
 80040e6: af00         	add	r7, sp, #0x0
; 	LL_FLASH_EnablePrefetch();
 80040e8: f7ff ffd2    	bl	0x8004090 <LL_FLASH_EnablePrefetch> @ imm = #-0x5c
; 	LL_FLASH_EnableInstCache();
 80040ec: f7ff ffde    	bl	0x80040ac <LL_FLASH_EnableInstCache> @ imm = #-0x44
; 	LL_FLASH_EnableDataCache();
 80040f0: f7ff ffea    	bl	0x80040c8 <LL_FLASH_EnableDataCache> @ imm = #-0x2c
; 	SystemCoreClock = 16000000;
 80040f4: 4b02         	ldr	r3, [pc, #0x8]          @ 0x8004100 <soc_early_init_hook+0x1c>
 80040f6: 4a03         	ldr	r2, [pc, #0xc]          @ 0x8004104 <soc_early_init_hook+0x20>
 80040f8: 601a         	str	r2, [r3]
; }
 80040fa: bf00         	nop
 80040fc: bd80         	pop	{r7, pc}
 80040fe: bf00         	nop

08004100 <$d>:
 8004100: 90 05 00 20  	.word	0x20000590
 8004104: 00 24 f4 00  	.word	0x00f42400

08004108 <log_backend_get>:
; {
 8004108: b480         	push	{r7}
 800410a: b085         	sub	sp, #0x14
 800410c: af00         	add	r7, sp, #0x0
 800410e: 6078         	str	r0, [r7, #0x4]
; 	STRUCT_SECTION_GET(log_backend, idx, &backend);
 8004110: 687b         	ldr	r3, [r7, #0x4]
 8004112: 011b         	lsls	r3, r3, #0x4
 8004114: 4a04         	ldr	r2, [pc, #0x10]         @ 0x8004128 <log_backend_get+0x20>
 8004116: 4413         	add	r3, r2
 8004118: 60fb         	str	r3, [r7, #0xc]
; 	return backend;
 800411a: 68fb         	ldr	r3, [r7, #0xc]
; }
 800411c: 4618         	mov	r0, r3
 800411e: 3714         	adds	r7, #0x14
 8004120: 46bd         	mov	sp, r7
 8004122: bc80         	pop	{r7}
 8004124: 4770         	bx	lr
 8004126: bf00         	nop

08004128 <$d>:
 8004128: ac e2 01 08  	.word	0x0801e2ac

0800412c <log_format_func_t_get>:
; {
 800412c: b480         	push	{r7}
 800412e: b083         	sub	sp, #0xc
 8004130: af00         	add	r7, sp, #0x0
 8004132: 6078         	str	r0, [r7, #0x4]
; 	return format_table[log_type];
 8004134: 4a04         	ldr	r2, [pc, #0x10]         @ 0x8004148 <log_format_func_t_get+0x1c>
 8004136: 687b         	ldr	r3, [r7, #0x4]
 8004138: f852 3023    	ldr.w	r3, [r2, r3, lsl #2]
; }
 800413c: 4618         	mov	r0, r3
 800413e: 370c         	adds	r7, #0xc
 8004140: 46bd         	mov	sp, r7
 8004142: bc80         	pop	{r7}
 8004144: 4770         	bx	lr
 8004146: bf00         	nop

08004148 <$d>:
 8004148: e4 fe 01 08  	.word	0x0801fee4

0800414c <log_core_init>:
; {
 800414c: b580         	push	{r7, lr}
 800414e: af00         	add	r7, sp, #0x0
; 	panic_mode = false;
 8004150: 4b07         	ldr	r3, [pc, #0x1c]         @ 0x8004170 <log_core_init+0x24>
 8004152: 2200         	movs	r2, #0x0
 8004154: 701a         	strb	r2, [r3]
; 	dropped_cnt = 0;
 8004156: 4b07         	ldr	r3, [pc, #0x1c]         @ 0x8004174 <log_core_init+0x28>
 8004158: 2200         	movs	r2, #0x0
 800415a: 601a         	str	r2, [r3]
; 	buffered_cnt = 0;
 800415c: 4b06         	ldr	r3, [pc, #0x18]         @ 0x8004178 <log_core_init+0x2c>
 800415e: 2200         	movs	r2, #0x0
 8004160: 601a         	str	r2, [r3]
; 		log_set_timestamp_func(default_lf_get_timestamp, 1000U);
 8004162: f44f 717a    	mov.w	r1, #0x3e8
 8004166: 4805         	ldr	r0, [pc, #0x14]         @ 0x800417c <log_core_init+0x30>
 8004168: f000 f86a    	bl	0x8004240 <log_set_timestamp_func> @ imm = #0xd4
; }
 800416c: bd80         	pop	{r7, pc}
 800416e: bf00         	nop

08004170 <$d>:
 8004170: 88 1f 00 20  	.word	0x20001f88
 8004174: e8 1b 00 20  	.word	0x20001be8
 8004178: e4 1b 00 20  	.word	0x20001be4
 800417c: d3 4e 01 08  	.word	0x08014ed3

08004180 <z_log_init>:
; {
 8004180: b580         	push	{r7, lr}
 8004182: b086         	sub	sp, #0x18
 8004184: af00         	add	r7, sp, #0x0
 8004186: 4603         	mov	r3, r0
 8004188: 460a         	mov	r2, r1
 800418a: 71fb         	strb	r3, [r7, #0x7]
 800418c: 4613         	mov	r3, r2
 800418e: 71bb         	strb	r3, [r7, #0x6]
; 	uint32_t mask = 0;
 8004190: 2300         	movs	r3, #0x0
 8004192: 617b         	str	r3, [r7, #0x14]
; 	if (atomic_inc(&initialized) != 0) {
 8004194: 4827         	ldr	r0, [pc, #0x9c]         @ 0x8004234 <z_log_init+0xb4>
 8004196: f010 fda4    	bl	0x8014ce2 <atomic_inc>  @ imm = #0x10b48
 800419a: 4603         	mov	r3, r0
 800419c: 2b00         	cmp	r3, #0x0
 800419e: d001         	beq	0x80041a4 <z_log_init+0x24> @ imm = #0x2
; 		return 0;
 80041a0: 2300         	movs	r3, #0x0
 80041a2: e042         	b	0x800422a <z_log_init+0xaa> @ imm = #0x84
; 	int backend_index = 0;
 80041a4: 2300         	movs	r3, #0x0
 80041a6: 613b         	str	r3, [r7, #0x10]
; 	STRUCT_SECTION_FOREACH(log_backend, backend) {
 80041a8: 4b23         	ldr	r3, [pc, #0x8c]         @ 0x8004238 <z_log_init+0xb8>
 80041aa: 60fb         	str	r3, [r7, #0xc]
 80041ac: e022         	b	0x80041f4 <z_log_init+0x74> @ imm = #0x44
; 		if (backend->autostart) {
 80041ae: 68fb         	ldr	r3, [r7, #0xc]
 80041b0: 7b1b         	ldrb	r3, [r3, #0xc]
 80041b2: 2b00         	cmp	r3, #0x0
 80041b4: d018         	beq	0x80041e8 <z_log_init+0x68> @ imm = #0x30
; 			log_backend_init(backend);
 80041b6: 68f8         	ldr	r0, [r7, #0xc]
 80041b8: f010 fe1f    	bl	0x8014dfa <log_backend_init> @ imm = #0x10c3e
; 			if (log_backend_is_ready(backend) == 0) {
 80041bc: 68f8         	ldr	r0, [r7, #0xc]
 80041be: f010 fe2e    	bl	0x8014e1e <log_backend_is_ready> @ imm = #0x10c5c
 80041c2: 4603         	mov	r3, r0
 80041c4: 2b00         	cmp	r3, #0x0
 80041c6: d108         	bne	0x80041da <z_log_init+0x5a> @ imm = #0x10
; 						   backend->cb->ctx,
 80041c8: 68fb         	ldr	r3, [r7, #0xc]
 80041ca: 685b         	ldr	r3, [r3, #0x4]
; 				log_backend_enable(backend,
 80041cc: 681b         	ldr	r3, [r3]
 80041ce: 2204         	movs	r2, #0x4
 80041d0: 4619         	mov	r1, r3
 80041d2: 68f8         	ldr	r0, [r7, #0xc]
 80041d4: f010 ff7f    	bl	0x80150d6 <log_backend_enable> @ imm = #0x10efe
 80041d8: e006         	b	0x80041e8 <z_log_init+0x68> @ imm = #0xc
; 				mask |= BIT(backend_index);
 80041da: 2201         	movs	r2, #0x1
 80041dc: 693b         	ldr	r3, [r7, #0x10]
 80041de: fa02 f303    	lsl.w	r3, r2, r3
 80041e2: 697a         	ldr	r2, [r7, #0x14]
 80041e4: 4313         	orrs	r3, r2
 80041e6: 617b         	str	r3, [r7, #0x14]
; 		++backend_index;
 80041e8: 693b         	ldr	r3, [r7, #0x10]
 80041ea: 3301         	adds	r3, #0x1
 80041ec: 613b         	str	r3, [r7, #0x10]
; 	STRUCT_SECTION_FOREACH(log_backend, backend) {
 80041ee: 68fb         	ldr	r3, [r7, #0xc]
 80041f0: 3310         	adds	r3, #0x10
 80041f2: 60fb         	str	r3, [r7, #0xc]
 80041f4: 68fb         	ldr	r3, [r7, #0xc]
 80041f6: 4a11         	ldr	r2, [pc, #0x44]         @ 0x800423c <z_log_init+0xbc>
 80041f8: 4293         	cmp	r3, r2
 80041fa: bf34         	ite	lo
 80041fc: 2301         	movlo	r3, #0x1
 80041fe: 2300         	movhs	r3, #0x0
 8004200: b2db         	uxtb	r3, r3
 8004202: 2b00         	cmp	r3, #0x0
 8004204: d1d3         	bne	0x80041ae <z_log_init+0x2e> @ imm = #-0x5a
; 	if (blocking) {
 8004206: 79fb         	ldrb	r3, [r7, #0x7]
 8004208: 2b00         	cmp	r3, #0x0
 800420a: d00d         	beq	0x8004228 <z_log_init+0xa8> @ imm = #0x1a
; 		while (mask) {
 800420c: e009         	b	0x8004222 <z_log_init+0xa2> @ imm = #0x12
; 			mask = activate_foreach_backend(mask);
 800420e: 6978         	ldr	r0, [r7, #0x14]
 8004210: f010 fe66    	bl	0x8014ee0 <activate_foreach_backend> @ imm = #0x10ccc
 8004214: 6178         	str	r0, [r7, #0x14]
; 			if (IS_ENABLED(CONFIG_MULTITHREADING) && can_sleep) {
 8004216: 79bb         	ldrb	r3, [r7, #0x6]
 8004218: 2b00         	cmp	r3, #0x0
 800421a: d002         	beq	0x8004222 <z_log_init+0xa2> @ imm = #0x4
; 				k_msleep(10);
 800421c: 200a         	movs	r0, #0xa
 800421e: f010 fd8d    	bl	0x8014d3c <k_msleep>    @ imm = #0x10b1a
; 		while (mask) {
 8004222: 697b         	ldr	r3, [r7, #0x14]
 8004224: 2b00         	cmp	r3, #0x0
 8004226: d1f2         	bne	0x800420e <z_log_init+0x8e> @ imm = #-0x1c
; 	return mask;
 8004228: 697b         	ldr	r3, [r7, #0x14]
; }
 800422a: 4618         	mov	r0, r3
 800422c: 3718         	adds	r7, #0x18
 800422e: 46bd         	mov	sp, r7
 8004230: bd80         	pop	{r7, pc}
 8004232: bf00         	nop

08004234 <$d>:
 8004234: e0 1b 00 20  	.word	0x20001be0
 8004238: ac e2 01 08  	.word	0x0801e2ac
 800423c: bc e2 01 08  	.word	0x0801e2bc

08004240 <log_set_timestamp_func>:
; {
 8004240: b580         	push	{r7, lr}
 8004242: b082         	sub	sp, #0x8
 8004244: af00         	add	r7, sp, #0x0
 8004246: 6078         	str	r0, [r7, #0x4]
 8004248: 6039         	str	r1, [r7]
; 	if (timestamp_getter == NULL) {
 800424a: 687b         	ldr	r3, [r7, #0x4]
 800424c: 2b00         	cmp	r3, #0x0
 800424e: d102         	bne	0x8004256 <log_set_timestamp_func+0x16> @ imm = #0x4
; 		return -EINVAL;
 8004250: f06f 0315    	mvn	r3, #0x15
 8004254: e009         	b	0x800426a <log_set_timestamp_func+0x2a> @ imm = #0x12
; 	timestamp_func = timestamp_getter;
 8004256: 4a07         	ldr	r2, [pc, #0x1c]         @ 0x8004274 <log_set_timestamp_func+0x34>
 8004258: 687b         	ldr	r3, [r7, #0x4]
 800425a: 6013         	str	r3, [r2]
; 	timestamp_freq = freq;
 800425c: 4a06         	ldr	r2, [pc, #0x18]         @ 0x8004278 <log_set_timestamp_func+0x38>
 800425e: 683b         	ldr	r3, [r7]
 8004260: 6013         	str	r3, [r2]
; 		log_output_timestamp_freq_set(freq);
 8004262: 6838         	ldr	r0, [r7]
 8004264: f000 fcea    	bl	0x8004c3c <log_output_timestamp_freq_set> @ imm = #0x9d4
; 	return 0;
 8004268: 2300         	movs	r3, #0x0
; }
 800426a: 4618         	mov	r0, r3
 800426c: 3708         	adds	r7, #0x8
 800426e: 46bd         	mov	sp, r7
 8004270: bd80         	pop	{r7, pc}
 8004272: bf00         	nop

08004274 <$d>:
 8004274: b0 04 00 20  	.word	0x200004b0
 8004278: ec 1b 00 20  	.word	0x20001bec

0800427c <z_impl_log_panic>:
; {
 800427c: b580         	push	{r7, lr}
 800427e: b082         	sub	sp, #0x8
 8004280: af00         	add	r7, sp, #0x0
; 	if (panic_mode) {
 8004282: 4b14         	ldr	r3, [pc, #0x50]         @ 0x80042d4 <z_impl_log_panic+0x58>
 8004284: 781b         	ldrb	r3, [r3]
 8004286: 2b00         	cmp	r3, #0x0
 8004288: d120         	bne	0x80042cc <z_impl_log_panic+0x50> @ imm = #0x40
; 	(void)z_log_init(true, false);
 800428a: 2100         	movs	r1, #0x0
 800428c: 2001         	movs	r0, #0x1
 800428e: f7ff ff77    	bl	0x8004180 <z_log_init>  @ imm = #-0x112
; 	STRUCT_SECTION_FOREACH(log_backend, backend) {
 8004292: 4b11         	ldr	r3, [pc, #0x44]         @ 0x80042d8 <z_impl_log_panic+0x5c>
 8004294: 607b         	str	r3, [r7, #0x4]
 8004296: e00b         	b	0x80042b0 <z_impl_log_panic+0x34> @ imm = #0x16
; 		if (log_backend_is_active(backend)) {
 8004298: 6878         	ldr	r0, [r7, #0x4]
 800429a: f010 fdf1    	bl	0x8014e80 <log_backend_is_active> @ imm = #0x10be2
 800429e: 4603         	mov	r3, r0
 80042a0: 2b00         	cmp	r3, #0x0
 80042a2: d002         	beq	0x80042aa <z_impl_log_panic+0x2e> @ imm = #0x4
; 			log_backend_panic(backend);
 80042a4: 6878         	ldr	r0, [r7, #0x4]
 80042a6: f010 fdde    	bl	0x8014e66 <log_backend_panic> @ imm = #0x10bbc
; 	STRUCT_SECTION_FOREACH(log_backend, backend) {
 80042aa: 687b         	ldr	r3, [r7, #0x4]
 80042ac: 3310         	adds	r3, #0x10
 80042ae: 607b         	str	r3, [r7, #0x4]
 80042b0: 687b         	ldr	r3, [r7, #0x4]
 80042b2: 4a0a         	ldr	r2, [pc, #0x28]         @ 0x80042dc <z_impl_log_panic+0x60>
 80042b4: 4293         	cmp	r3, r2
 80042b6: bf34         	ite	lo
 80042b8: 2301         	movlo	r3, #0x1
 80042ba: 2300         	movhs	r3, #0x0
 80042bc: b2db         	uxtb	r3, r3
 80042be: 2b00         	cmp	r3, #0x0
 80042c0: d1ea         	bne	0x8004298 <z_impl_log_panic+0x1c> @ imm = #-0x2c
; out:
 80042c2: bf00         	nop
; 	panic_mode = true;
 80042c4: 4b03         	ldr	r3, [pc, #0xc]          @ 0x80042d4 <z_impl_log_panic+0x58>
 80042c6: 2201         	movs	r2, #0x1
 80042c8: 701a         	strb	r2, [r3]
 80042ca: e000         	b	0x80042ce <z_impl_log_panic+0x52> @ imm = #0x0
; 		return;
 80042cc: bf00         	nop
; }
 80042ce: 3708         	adds	r7, #0x8
 80042d0: 46bd         	mov	sp, r7
 80042d2: bd80         	pop	{r7, pc}

080042d4 <$d>:
 80042d4: 88 1f 00 20  	.word	0x20001f88
 80042d8: ac e2 01 08  	.word	0x0801e2ac
 80042dc: bc e2 01 08  	.word	0x0801e2bc

080042e0 <msg_process>:
; {
 80042e0: b580         	push	{r7, lr}
 80042e2: b084         	sub	sp, #0x10
 80042e4: af00         	add	r7, sp, #0x0
 80042e6: 6078         	str	r0, [r7, #0x4]
; 	STRUCT_SECTION_FOREACH(log_backend, backend) {
 80042e8: 4b12         	ldr	r3, [pc, #0x48]         @ 0x8004334 <msg_process+0x54>
 80042ea: 60fb         	str	r3, [r7, #0xc]
 80042ec: e013         	b	0x8004316 <msg_process+0x36> @ imm = #0x26
; 		if (log_backend_is_active(backend) &&
 80042ee: 68f8         	ldr	r0, [r7, #0xc]
 80042f0: f010 fdc6    	bl	0x8014e80 <log_backend_is_active> @ imm = #0x10b8c
 80042f4: 4603         	mov	r3, r0
 80042f6: 2b00         	cmp	r3, #0x0
 80042f8: d00a         	beq	0x8004310 <msg_process+0x30> @ imm = #0x14
; 		    msg_filter_check(backend, msg)) {
 80042fa: 6879         	ldr	r1, [r7, #0x4]
 80042fc: 68f8         	ldr	r0, [r7, #0xc]
 80042fe: f010 fe2a    	bl	0x8014f56 <msg_filter_check> @ imm = #0x10c54
 8004302: 4603         	mov	r3, r0
; 		if (log_backend_is_active(backend) &&
 8004304: 2b00         	cmp	r3, #0x0
 8004306: d003         	beq	0x8004310 <msg_process+0x30> @ imm = #0x6
; 			log_backend_msg_process(backend, msg);
 8004308: 6879         	ldr	r1, [r7, #0x4]
 800430a: 68f8         	ldr	r0, [r7, #0xc]
 800430c: f010 fd9c    	bl	0x8014e48 <log_backend_msg_process> @ imm = #0x10b38
; 	STRUCT_SECTION_FOREACH(log_backend, backend) {
 8004310: 68fb         	ldr	r3, [r7, #0xc]
 8004312: 3310         	adds	r3, #0x10
 8004314: 60fb         	str	r3, [r7, #0xc]
 8004316: 68fb         	ldr	r3, [r7, #0xc]
 8004318: 4a07         	ldr	r2, [pc, #0x1c]         @ 0x8004338 <msg_process+0x58>
 800431a: 4293         	cmp	r3, r2
 800431c: bf34         	ite	lo
 800431e: 2301         	movlo	r3, #0x1
 8004320: 2300         	movhs	r3, #0x0
 8004322: b2db         	uxtb	r3, r3
 8004324: 2b00         	cmp	r3, #0x0
 8004326: d1e2         	bne	0x80042ee <msg_process+0xe> @ imm = #-0x3c
; }
 8004328: bf00         	nop
 800432a: bf00         	nop
 800432c: 3710         	adds	r7, #0x10
 800432e: 46bd         	mov	sp, r7
 8004330: bd80         	pop	{r7, pc}
 8004332: bf00         	nop

08004334 <$d>:
 8004334: ac e2 01 08  	.word	0x0801e2ac
 8004338: bc e2 01 08  	.word	0x0801e2bc

0800433c <z_log_notify_backend_enabled>:
; {
 800433c: b480         	push	{r7}
 800433e: af00         	add	r7, sp, #0x0
; 	backend_attached = true;
 8004340: 4b03         	ldr	r3, [pc, #0xc]          @ 0x8004350 <z_log_notify_backend_enabled+0x14>
 8004342: 2201         	movs	r2, #0x1
 8004344: 701a         	strb	r2, [r3]
; }
 8004346: bf00         	nop
 8004348: 46bd         	mov	sp, r7
 800434a: bc80         	pop	{r7}
 800434c: 4770         	bx	lr
 800434e: bf00         	nop

08004350 <$d>:
 8004350: 89 1f 00 20  	.word	0x20001f89

08004354 <z_log_dropped>:
; {
 8004354: b580         	push	{r7, lr}
 8004356: b082         	sub	sp, #0x8
 8004358: af00         	add	r7, sp, #0x0
 800435a: 4603         	mov	r3, r0
 800435c: 71fb         	strb	r3, [r7, #0x7]
; 	atomic_inc(&dropped_cnt);
 800435e: 4806         	ldr	r0, [pc, #0x18]         @ 0x8004378 <z_log_dropped+0x24>
 8004360: f010 fcbf    	bl	0x8014ce2 <atomic_inc>  @ imm = #0x1097e
; 	if (buffered) {
 8004364: 79fb         	ldrb	r3, [r7, #0x7]
 8004366: 2b00         	cmp	r3, #0x0
 8004368: d002         	beq	0x8004370 <z_log_dropped+0x1c> @ imm = #0x4
; 		atomic_dec(&buffered_cnt);
 800436a: 4804         	ldr	r0, [pc, #0x10]         @ 0x800437c <z_log_dropped+0x28>
 800436c: f010 fcc6    	bl	0x8014cfc <atomic_dec>  @ imm = #0x1098c
; }
 8004370: bf00         	nop
 8004372: 3708         	adds	r7, #0x8
 8004374: 46bd         	mov	sp, r7
 8004376: bd80         	pop	{r7, pc}

08004378 <$d>:
 8004378: e8 1b 00 20  	.word	0x20001be8
 800437c: e4 1b 00 20  	.word	0x20001be4

08004380 <z_log_msg_commit>:
; {
 8004380: b580         	push	{r7, lr}
 8004382: b082         	sub	sp, #0x8
 8004384: af00         	add	r7, sp, #0x0
 8004386: 6078         	str	r0, [r7, #0x4]
; 	msg->hdr.timestamp = timestamp_func();
 8004388: 4b06         	ldr	r3, [pc, #0x18]         @ 0x80043a4 <z_log_msg_commit+0x24>
 800438a: 681b         	ldr	r3, [r3]
 800438c: 4798         	blx	r3
 800438e: 4602         	mov	r2, r0
 8004390: 687b         	ldr	r3, [r7, #0x4]
 8004392: 609a         	str	r2, [r3, #0x8]
; 	msg_commit(&log_buffer, msg);
 8004394: 6879         	ldr	r1, [r7, #0x4]
 8004396: 4804         	ldr	r0, [pc, #0x10]         @ 0x80043a8 <z_log_msg_commit+0x28>
 8004398: f010 fdf2    	bl	0x8014f80 <msg_commit>  @ imm = #0x10be4
; }
 800439c: bf00         	nop
 800439e: 3708         	adds	r7, #0x8
 80043a0: 46bd         	mov	sp, r7
 80043a2: bd80         	pop	{r7, pc}

080043a4 <$d>:
 80043a4: b0 04 00 20  	.word	0x200004b0
 80043a8: ec 05 00 20  	.word	0x200005ec

080043ac <log_const_source_id>:
; {
 80043ac: b480         	push	{r7}
 80043ae: b083         	sub	sp, #0xc
 80043b0: af00         	add	r7, sp, #0x0
 80043b2: 6078         	str	r0, [r7, #0x4]
; 	return ((const uint8_t *)data - (uint8_t *)TYPE_SECTION_START(log_const))/
 80043b4: 687b         	ldr	r3, [r7, #0x4]
 80043b6: 4a04         	ldr	r2, [pc, #0x10]         @ 0x80043c8 <log_const_source_id+0x1c>
 80043b8: 1a9b         	subs	r3, r3, r2
 80043ba: 08db         	lsrs	r3, r3, #0x3
; }
 80043bc: 4618         	mov	r0, r3
 80043be: 370c         	adds	r7, #0xc
 80043c0: 46bd         	mov	sp, r7
 80043c2: bc80         	pop	{r7}
 80043c4: 4770         	bx	lr
 80043c6: bf00         	nop

080043c8 <$d>:
 80043c8: 3c e2 01 08  	.word	0x0801e23c

080043cc <z_log_sources_count>:
; {
 80043cc: b580         	push	{r7, lr}
 80043ce: af00         	add	r7, sp, #0x0
; 	return log_const_source_id(TYPE_SECTION_END(log_const));
 80043d0: 4802         	ldr	r0, [pc, #0x8]          @ 0x80043dc <z_log_sources_count+0x10>
 80043d2: f7ff ffeb    	bl	0x80043ac <log_const_source_id> @ imm = #-0x2a
 80043d6: 4603         	mov	r3, r0
; }
 80043d8: 4618         	mov	r0, r3
 80043da: bd80         	pop	{r7, pc}

080043dc <$d>:
 80043dc: ac e2 01 08  	.word	0x0801e2ac

080043e0 <log_backend_get>:
; {
 80043e0: b480         	push	{r7}
 80043e2: b085         	sub	sp, #0x14
 80043e4: af00         	add	r7, sp, #0x0
 80043e6: 6078         	str	r0, [r7, #0x4]
; 	STRUCT_SECTION_GET(log_backend, idx, &backend);
 80043e8: 687b         	ldr	r3, [r7, #0x4]
 80043ea: 011b         	lsls	r3, r3, #0x4
 80043ec: 4a04         	ldr	r2, [pc, #0x10]         @ 0x8004400 <log_backend_get+0x20>
 80043ee: 4413         	add	r3, r2
 80043f0: 60fb         	str	r3, [r7, #0xc]
; 	return backend;
 80043f2: 68fb         	ldr	r3, [r7, #0xc]
; }
 80043f4: 4618         	mov	r0, r3
 80043f6: 3714         	adds	r7, #0x14
 80043f8: 46bd         	mov	sp, r7
 80043fa: bc80         	pop	{r7}
 80043fc: 4770         	bx	lr
 80043fe: bf00         	nop

08004400 <$d>:
 8004400: ac e2 01 08  	.word	0x0801e2ac

08004404 <get_link_domain>:
; {
 8004404: b480         	push	{r7}
 8004406: b085         	sub	sp, #0x14
 8004408: af00         	add	r7, sp, #0x0
 800440a: 4603         	mov	r3, r0
 800440c: 6039         	str	r1, [r7]
 800440e: 71fb         	strb	r3, [r7, #0x7]
; 	STRUCT_SECTION_FOREACH(log_link, link) {
 8004410: 4b18         	ldr	r3, [pc, #0x60]         @ 0x8004474 <get_link_domain+0x70>
 8004412: 60fb         	str	r3, [r7, #0xc]
 8004414: e01b         	b	0x800444e <get_link_domain+0x4a> @ imm = #0x36
; 		domain_max = link->ctrl_blk->domain_offset +
 8004416: 68fb         	ldr	r3, [r7, #0xc]
 8004418: 689b         	ldr	r3, [r3, #0x8]
 800441a: 689b         	ldr	r3, [r3, #0x8]
 800441c: b2da         	uxtb	r2, r3
; 				link->ctrl_blk->domain_cnt;
 800441e: 68fb         	ldr	r3, [r7, #0xc]
 8004420: 689b         	ldr	r3, [r3, #0x8]
 8004422: 681b         	ldr	r3, [r3]
; 		domain_max = link->ctrl_blk->domain_offset +
 8004424: b2db         	uxtb	r3, r3
 8004426: 4413         	add	r3, r2
 8004428: 72fb         	strb	r3, [r7, #0xb]
; 		if (domain_id < domain_max) {
 800442a: 79fa         	ldrb	r2, [r7, #0x7]
 800442c: 7afb         	ldrb	r3, [r7, #0xb]
 800442e: 429a         	cmp	r2, r3
 8004430: d20a         	bhs	0x8004448 <get_link_domain+0x44> @ imm = #0x14
; 			*rel_domain_id = domain_id - link->ctrl_blk->domain_offset;
 8004432: 68fb         	ldr	r3, [r7, #0xc]
 8004434: 689b         	ldr	r3, [r3, #0x8]
 8004436: 689b         	ldr	r3, [r3, #0x8]
 8004438: b2db         	uxtb	r3, r3
 800443a: 79fa         	ldrb	r2, [r7, #0x7]
 800443c: 1ad3         	subs	r3, r2, r3
 800443e: b2da         	uxtb	r2, r3
 8004440: 683b         	ldr	r3, [r7]
 8004442: 701a         	strb	r2, [r3]
; 			return link;
 8004444: 68fb         	ldr	r3, [r7, #0xc]
 8004446: e00f         	b	0x8004468 <get_link_domain+0x64> @ imm = #0x1e
; 	STRUCT_SECTION_FOREACH(log_link, link) {
 8004448: 68fb         	ldr	r3, [r7, #0xc]
 800444a: 3318         	adds	r3, #0x18
 800444c: 60fb         	str	r3, [r7, #0xc]
 800444e: 68fb         	ldr	r3, [r7, #0xc]
 8004450: 4a09         	ldr	r2, [pc, #0x24]         @ 0x8004478 <get_link_domain+0x74>
 8004452: 4293         	cmp	r3, r2
 8004454: bf34         	ite	lo
 8004456: 2301         	movlo	r3, #0x1
 8004458: 2300         	movhs	r3, #0x0
 800445a: b2db         	uxtb	r3, r3
 800445c: 2b00         	cmp	r3, #0x0
 800445e: d1da         	bne	0x8004416 <get_link_domain+0x12> @ imm = #-0x4c
; 	*rel_domain_id = 0;
 8004460: 683b         	ldr	r3, [r7]
 8004462: 2200         	movs	r2, #0x0
 8004464: 701a         	strb	r2, [r3]
; 	return NULL;
 8004466: 2300         	movs	r3, #0x0
; }
 8004468: 4618         	mov	r0, r3
 800446a: 3714         	adds	r7, #0x14
 800446c: 46bd         	mov	sp, r7
 800446e: bc80         	pop	{r7}
 8004470: 4770         	bx	lr
 8004472: bf00         	nop

08004474 <$d>:
 8004474: bc e2 01 08  	.word	0x0801e2bc
 8004478: bc e2 01 08  	.word	0x0801e2bc

0800447c <link_source_name_get>:
; {
 800447c: b580         	push	{r7, lr}
 800447e: b08a         	sub	sp, #0x28
 8004480: af02         	add	r7, sp, #0x8
 8004482: 4603         	mov	r3, r0
 8004484: 6039         	str	r1, [r7]
 8004486: 71fb         	strb	r3, [r7, #0x7]
; 	size_t cache_size = sname_cache.item_size;
 8004488: 4b1c         	ldr	r3, [pc, #0x70]         @ 0x80044fc <link_source_name_get+0x80>
 800448a: 69db         	ldr	r3, [r3, #0x1c]
 800448c: 613b         	str	r3, [r7, #0x10]
; 	union log_source_ids id = {
 800448e: 79fb         	ldrb	r3, [r7, #0x7]
 8004490: 733b         	strb	r3, [r7, #0xc]
 8004492: 683b         	ldr	r3, [r7]
 8004494: b29b         	uxth	r3, r3
 8004496: 81fb         	strh	r3, [r7, #0xe]
; 	if (!log_cache_get(&sname_cache, id.raw, &cached)) {
 8004498: 68fb         	ldr	r3, [r7, #0xc]
 800449a: f107 0214    	add.w	r2, r7, #0x14
 800449e: 4619         	mov	r1, r3
 80044a0: 4816         	ldr	r0, [pc, #0x58]         @ 0x80044fc <link_source_name_get+0x80>
 80044a2: f010 ff4f    	bl	0x8015344 <log_cache_get> @ imm = #0x10e9e
 80044a6: 4603         	mov	r3, r0
 80044a8: f083 0301    	eor	r3, r3, #0x1
 80044ac: b2db         	uxtb	r3, r3
 80044ae: 2b00         	cmp	r3, #0x0
 80044b0: d01f         	beq	0x80044f2 <link_source_name_get+0x76> @ imm = #0x3e
; 		const struct log_link *link = get_link_domain(domain_id, &rel_domain_id);
 80044b2: f107 020b    	add.w	r2, r7, #0xb
 80044b6: 79fb         	ldrb	r3, [r7, #0x7]
 80044b8: 4611         	mov	r1, r2
 80044ba: 4618         	mov	r0, r3
 80044bc: f7ff ffa2    	bl	0x8004404 <get_link_domain> @ imm = #-0xbc
 80044c0: 61f8         	str	r0, [r7, #0x1c]
; 		err = log_link_get_source_name(link, rel_domain_id, source_id,
 80044c2: 7afb         	ldrb	r3, [r7, #0xb]
 80044c4: 4618         	mov	r0, r3
 80044c6: 683b         	ldr	r3, [r7]
 80044c8: b29a         	uxth	r2, r3
 80044ca: 6979         	ldr	r1, [r7, #0x14]
 80044cc: f107 0310    	add.w	r3, r7, #0x10
 80044d0: 9300         	str	r3, [sp]
 80044d2: 460b         	mov	r3, r1
 80044d4: 4601         	mov	r1, r0
 80044d6: 69f8         	ldr	r0, [r7, #0x1c]
 80044d8: f010 fdab    	bl	0x8015032 <log_link_get_source_name> @ imm = #0x10b56
 80044dc: 61b8         	str	r0, [r7, #0x18]
; 		if (err < 0) {
 80044de: 69bb         	ldr	r3, [r7, #0x18]
 80044e0: 2b00         	cmp	r3, #0x0
 80044e2: da01         	bge	0x80044e8 <link_source_name_get+0x6c> @ imm = #0x2
; 			return NULL;
 80044e4: 2300         	movs	r3, #0x0
 80044e6: e005         	b	0x80044f4 <link_source_name_get+0x78> @ imm = #0xa
; 		log_cache_put(&sname_cache, cached);
 80044e8: 697b         	ldr	r3, [r7, #0x14]
 80044ea: 4619         	mov	r1, r3
 80044ec: 4803         	ldr	r0, [pc, #0xc]          @ 0x80044fc <link_source_name_get+0x80>
 80044ee: f010 ffac    	bl	0x801544a <log_cache_put> @ imm = #0x10f58
; 	return (const char *)cached;
 80044f2: 697b         	ldr	r3, [r7, #0x14]
; }
 80044f4: 4618         	mov	r0, r3
 80044f6: 3720         	adds	r7, #0x20
 80044f8: 46bd         	mov	sp, r7
 80044fa: bd80         	pop	{r7, pc}

080044fc <$d>:
 80044fc: f0 1b 00 20  	.word	0x20001bf0

08004500 <log_source_name_get>:
; {
 8004500: b580         	push	{r7, lr}
 8004502: b082         	sub	sp, #0x8
 8004504: af00         	add	r7, sp, #0x0
 8004506: 6078         	str	r0, [r7, #0x4]
 8004508: 6039         	str	r1, [r7]
; 	if (z_log_is_local_domain(domain_id)) {
 800450a: 687b         	ldr	r3, [r7, #0x4]
 800450c: b2db         	uxtb	r3, r3
 800450e: 4618         	mov	r0, r3
 8004510: f010 fd53    	bl	0x8014fba <z_log_is_local_domain> @ imm = #0x10aa6
 8004514: 4603         	mov	r3, r0
 8004516: 2b00         	cmp	r3, #0x0
 8004518: d00d         	beq	0x8004536 <log_source_name_get+0x36> @ imm = #0x1a
; 		if (source_id < log_src_cnt_get(domain_id)) {
 800451a: 6878         	ldr	r0, [r7, #0x4]
 800451c: f010 fdb7    	bl	0x801508e <log_src_cnt_get> @ imm = #0x10b6e
 8004520: 4602         	mov	r2, r0
 8004522: 683b         	ldr	r3, [r7]
 8004524: 4293         	cmp	r3, r2
 8004526: d204         	bhs	0x8004532 <log_source_name_get+0x32> @ imm = #0x8
; 			return TYPE_SECTION_START(log_const)[source_id].name;
 8004528: 4a08         	ldr	r2, [pc, #0x20]         @ 0x800454c <log_source_name_get+0x4c>
 800452a: 683b         	ldr	r3, [r7]
 800452c: f852 3033    	ldr.w	r3, [r2, r3, lsl #3]
 8004530: e008         	b	0x8004544 <log_source_name_get+0x44> @ imm = #0x10
; 			return NULL;
 8004532: 2300         	movs	r3, #0x0
 8004534: e006         	b	0x8004544 <log_source_name_get+0x44> @ imm = #0xc
; 	return link_source_name_get(domain_id, source_id);
 8004536: 687b         	ldr	r3, [r7, #0x4]
 8004538: b2db         	uxtb	r3, r3
 800453a: 6839         	ldr	r1, [r7]
 800453c: 4618         	mov	r0, r3
 800453e: f7ff ff9d    	bl	0x800447c <link_source_name_get> @ imm = #-0xc6
 8004542: 4603         	mov	r3, r0
; }
 8004544: 4618         	mov	r0, r3
 8004546: 3708         	adds	r7, #0x8
 8004548: 46bd         	mov	sp, r7
 800454a: bd80         	pop	{r7, pc}

0800454c <$d>:
 800454c: 3c e2 01 08  	.word	0x0801e23c

08004550 <log_const_source_id>:
; {
 8004550: b480         	push	{r7}
 8004552: b083         	sub	sp, #0xc
 8004554: af00         	add	r7, sp, #0x0
 8004556: 6078         	str	r0, [r7, #0x4]
; 	return ((const uint8_t *)data - (uint8_t *)TYPE_SECTION_START(log_const))/
 8004558: 687b         	ldr	r3, [r7, #0x4]
 800455a: 4a04         	ldr	r2, [pc, #0x10]         @ 0x800456c <log_const_source_id+0x1c>
 800455c: 1a9b         	subs	r3, r3, r2
 800455e: 08db         	lsrs	r3, r3, #0x3
; }
 8004560: 4618         	mov	r0, r3
 8004562: 370c         	adds	r7, #0xc
 8004564: 46bd         	mov	sp, r7
 8004566: bc80         	pop	{r7}
 8004568: 4770         	bx	lr
 800456a: bf00         	nop

0800456c <$d>:
 800456c: 3c e2 01 08  	.word	0x0801e23c

08004570 <z_log_msg_runtime_vcreate>:
; {
 8004570: b580         	push	{r7, lr}
 8004572: b090         	sub	sp, #0x40
 8004574: af04         	add	r7, sp, #0x10
 8004576: 60b9         	str	r1, [r7, #0x8]
 8004578: 607b         	str	r3, [r7, #0x4]
 800457a: 4603         	mov	r3, r0
 800457c: 73fb         	strb	r3, [r7, #0xf]
 800457e: 4613         	mov	r3, r2
 8004580: 73bb         	strb	r3, [r7, #0xe]
; 	if (fmt) {
 8004582: 6c3b         	ldr	r3, [r7, #0x40]
 8004584: 2b00         	cmp	r3, #0x0
 8004586: d00b         	beq	0x80045a0 <z_log_msg_runtime_vcreate+0x30> @ imm = #0x16
; 		va_copy(ap2, ap);
 8004588: 6c7b         	ldr	r3, [r7, #0x44]
 800458a: 613b         	str	r3, [r7, #0x10]
; 		plen = cbvprintf_package(NULL, Z_LOG_MSG_ALIGN_OFFSET,
 800458c: 693b         	ldr	r3, [r7, #0x10]
 800458e: 9300         	str	r3, [sp]
 8004590: 6c3b         	ldr	r3, [r7, #0x40]
 8004592: 6bfa         	ldr	r2, [r7, #0x3c]
 8004594: 2110         	movs	r1, #0x10
 8004596: 2000         	movs	r0, #0x0
 8004598: f7ff f95a    	bl	0x8003850 <cbvprintf_package> @ imm = #-0xd4c
 800459c: 62f8         	str	r0, [r7, #0x2c]
 800459e: e001         	b	0x80045a4 <z_log_msg_runtime_vcreate+0x34> @ imm = #0x2
; 		plen = 0;
 80045a0: 2300         	movs	r3, #0x0
 80045a2: 62fb         	str	r3, [r7, #0x2c]
; 	if (plen > Z_LOG_MSG_MAX_PACKAGE) {
 80045a4: 6afb         	ldr	r3, [r7, #0x2c]
 80045a6: f5b3 6f00    	cmp.w	r3, #0x800
 80045aa: d31d         	blo	0x80045e8 <z_log_msg_runtime_vcreate+0x78> @ imm = #0x3a
; 		LOG_WRN("Message dropped because it exceeds size limitation (%u)",
 80045ac: 2303         	movs	r3, #0x3
 80045ae: 2b01         	cmp	r3, #0x1
 80045b0: d973         	bls	0x800469a <z_log_msg_runtime_vcreate+0x12a> @ imm = #0xe6
 80045b2: 2301         	movs	r3, #0x1
 80045b4: 77fb         	strb	r3, [r7, #0x1f]
 80045b6: 7ffb         	ldrb	r3, [r7, #0x1f]
 80045b8: f083 0301    	eor	r3, r3, #0x1
 80045bc: b2db         	uxtb	r3, r3
 80045be: 2b00         	cmp	r3, #0x0
 80045c0: d16b         	bne	0x800469a <z_log_msg_runtime_vcreate+0x12a> @ imm = #0xd6
 80045c2: 4b37         	ldr	r3, [pc, #0xdc]         @ 0x80046a0 <z_log_msg_runtime_vcreate+0x130>
 80045c4: 6819         	ldr	r1, [r3]
 80045c6: f240 73ff    	movw	r3, #0x7ff
 80045ca: 9303         	str	r3, [sp, #0xc]
 80045cc: 4b35         	ldr	r3, [pc, #0xd4]         @ 0x80046a4 <z_log_msg_runtime_vcreate+0x134>
 80045ce: 9302         	str	r3, [sp, #0x8]
 80045d0: 2300         	movs	r3, #0x0
 80045d2: 9301         	str	r3, [sp, #0x4]
 80045d4: 2300         	movs	r3, #0x0
 80045d6: 9300         	str	r3, [sp]
 80045d8: 2300         	movs	r3, #0x0
 80045da: 2202         	movs	r2, #0x2
 80045dc: 2000         	movs	r0, #0x0
 80045de: f010 ff46    	bl	0x801546e <z_log_msg_runtime_create> @ imm = #0x10e8c
 80045e2: 2300         	movs	r3, #0x0
 80045e4: 61bb         	str	r3, [r7, #0x18]
; 		return;
 80045e6: e058         	b	0x800469a <z_log_msg_runtime_vcreate+0x12a> @ imm = #0xb0
; 	size_t msg_wlen = Z_LOG_MSG_ALIGNED_WLEN(plen, dlen);
 80045e8: 6afa         	ldr	r2, [r7, #0x2c]
 80045ea: 6bbb         	ldr	r3, [r7, #0x38]
 80045ec: 4413         	add	r3, r2
 80045ee: 3317         	adds	r3, #0x17
 80045f0: f023 0307    	bic	r3, r3, #0x7
 80045f4: 3303         	adds	r3, #0x3
 80045f6: 089b         	lsrs	r3, r3, #0x2
 80045f8: 62bb         	str	r3, [r7, #0x28]
; 	struct log_msg_desc desc =
 80045fa: 7d3b         	ldrb	r3, [r7, #0x14]
 80045fc: f36f 0300    	bfc	r3, #0, #1
 8004600: 753b         	strb	r3, [r7, #0x14]
 8004602: 7d3b         	ldrb	r3, [r7, #0x14]
 8004604: f36f 0341    	bfc	r3, #1, #1
 8004608: 753b         	strb	r3, [r7, #0x14]
 800460a: 7d3b         	ldrb	r3, [r7, #0x14]
 800460c: f36f 0382    	bfc	r3, #2, #1
 8004610: 753b         	strb	r3, [r7, #0x14]
 8004612: 7bfb         	ldrb	r3, [r7, #0xf]
 8004614: f003 0307    	and	r3, r3, #0x7
 8004618: b2da         	uxtb	r2, r3
 800461a: 7d3b         	ldrb	r3, [r7, #0x14]
 800461c: f362 03c5    	bfi	r3, r2, #3, #3
 8004620: 753b         	strb	r3, [r7, #0x14]
 8004622: 7bbb         	ldrb	r3, [r7, #0xe]
 8004624: f003 0307    	and	r3, r3, #0x7
 8004628: b2da         	uxtb	r2, r3
 800462a: 8abb         	ldrh	r3, [r7, #0x14]
 800462c: f362 1388    	bfi	r3, r2, #6, #3
 8004630: 82bb         	strh	r3, [r7, #0x14]
 8004632: 6afb         	ldr	r3, [r7, #0x2c]
 8004634: f3c3 030a    	ubfx	r3, r3, #0x0, #0xb
 8004638: b29a         	uxth	r2, r3
 800463a: 697b         	ldr	r3, [r7, #0x14]
 800463c: f362 2353    	bfi	r3, r2, #9, #11
 8004640: 617b         	str	r3, [r7, #0x14]
 8004642: 6bbb         	ldr	r3, [r7, #0x38]
 8004644: f3c3 030b    	ubfx	r3, r3, #0x0, #0xc
 8004648: b29a         	uxth	r2, r3
 800464a: 8afb         	ldrh	r3, [r7, #0x16]
 800464c: f362 130f    	bfi	r3, r2, #4, #12
 8004650: 82fb         	strh	r3, [r7, #0x16]
; 		msg = alloca(msg_wlen * sizeof(int));
 8004652: 6abb         	ldr	r3, [r7, #0x28]
 8004654: 009b         	lsls	r3, r3, #0x2
 8004656: 3307         	adds	r3, #0x7
 8004658: 08db         	lsrs	r3, r3, #0x3
 800465a: 00db         	lsls	r3, r3, #0x3
 800465c: ebad 0d03    	sub.w	sp, sp, r3
 8004660: ab04         	add	r3, sp, #0x10
 8004662: 3307         	adds	r3, #0x7
 8004664: 08db         	lsrs	r3, r3, #0x3
 8004666: 00db         	lsls	r3, r3, #0x3
 8004668: 627b         	str	r3, [r7, #0x24]
; 		pkg = msg->data;
 800466a: 6a7b         	ldr	r3, [r7, #0x24]
 800466c: 3310         	adds	r3, #0x10
 800466e: 623b         	str	r3, [r7, #0x20]
; 	if (pkg && fmt) {
 8004670: 6a3b         	ldr	r3, [r7, #0x20]
 8004672: 2b00         	cmp	r3, #0x0
 8004674: d00b         	beq	0x800468e <z_log_msg_runtime_vcreate+0x11e> @ imm = #0x16
 8004676: 6c3b         	ldr	r3, [r7, #0x40]
 8004678: 2b00         	cmp	r3, #0x0
 800467a: d008         	beq	0x800468e <z_log_msg_runtime_vcreate+0x11e> @ imm = #0x10
; 		plen = cbvprintf_package(pkg, (size_t)plen, package_flags, fmt, ap);
 800467c: 6af9         	ldr	r1, [r7, #0x2c]
 800467e: 6c7b         	ldr	r3, [r7, #0x44]
 8004680: 9300         	str	r3, [sp]
 8004682: 6c3b         	ldr	r3, [r7, #0x40]
 8004684: 6bfa         	ldr	r2, [r7, #0x3c]
 8004686: 6a38         	ldr	r0, [r7, #0x20]
 8004688: f7ff f8e2    	bl	0x8003850 <cbvprintf_package> @ imm = #-0xe3c
 800468c: 62f8         	str	r0, [r7, #0x2c]
; 		z_log_msg_finalize(msg, source, desc, data);
 800468e: 687b         	ldr	r3, [r7, #0x4]
 8004690: 697a         	ldr	r2, [r7, #0x14]
 8004692: 68b9         	ldr	r1, [r7, #0x8]
 8004694: 6a78         	ldr	r0, [r7, #0x24]
 8004696: f010 ff38    	bl	0x801550a <z_log_msg_finalize> @ imm = #0x10e70
; }
 800469a: 3730         	adds	r7, #0x30
 800469c: 46bd         	mov	sp, r7
 800469e: bd80         	pop	{r7, pc}

080046a0 <$d>:
 80046a0: b4 04 00 20  	.word	0x200004b4
 80046a4: f4 e4 01 08  	.word	0x0801e4f4

080046a8 <cbpprintf>:
; {
 80046a8: b580         	push	{r7, lr}
 80046aa: b084         	sub	sp, #0x10
 80046ac: af00         	add	r7, sp, #0x0
 80046ae: 60f8         	str	r0, [r7, #0xc]
 80046b0: 60b9         	str	r1, [r7, #0x8]
 80046b2: 607a         	str	r2, [r7, #0x4]
; 	return cbpprintf_external(out, cbvprintf, ctx, packaged);
 80046b4: 687b         	ldr	r3, [r7, #0x4]
 80046b6: 68ba         	ldr	r2, [r7, #0x8]
 80046b8: 4904         	ldr	r1, [pc, #0x10]         @ 0x80046cc <cbpprintf+0x24>
 80046ba: 68f8         	ldr	r0, [r7, #0xc]
 80046bc: f010 fa3e    	bl	0x8014b3c <cbpprintf_external> @ imm = #0x1047c
 80046c0: 4603         	mov	r3, r0
; }
 80046c2: 4618         	mov	r0, r3
 80046c4: 3710         	adds	r7, #0x10
 80046c6: 46bd         	mov	sp, r7
 80046c8: bd80         	pop	{r7, pc}
 80046ca: bf00         	nop

080046cc <$d>:
 80046cc: 71 60 00 08  	.word	0x08006071

080046d0 <__ctype_lookup>:
; static __inline char __ctype_lookup(int c) { return (__CTYPE_PTR + 1)[c]; }
 80046d0: b480         	push	{r7}
 80046d2: b083         	sub	sp, #0xc
 80046d4: af00         	add	r7, sp, #0x0
 80046d6: 6078         	str	r0, [r7, #0x4]
 80046d8: 687b         	ldr	r3, [r7, #0x4]
 80046da: 3301         	adds	r3, #0x1
 80046dc: 4a03         	ldr	r2, [pc, #0xc]          @ 0x80046ec <__ctype_lookup+0x1c>
 80046de: 4413         	add	r3, r2
 80046e0: 781b         	ldrb	r3, [r3]
 80046e2: 4618         	mov	r0, r3
 80046e4: 370c         	adds	r7, #0xc
 80046e6: 46bd         	mov	sp, r7
 80046e8: bc80         	pop	{r7}
 80046ea: 4770         	bx	lr

080046ec <$d>:
 80046ec: 00 0c 02 08  	.word	0x08020c00

080046f0 <print_formatted>:
; {
 80046f0: b40e         	push	{r1, r2, r3}
 80046f2: b580         	push	{r7, lr}
 80046f4: b085         	sub	sp, #0x14
 80046f6: af00         	add	r7, sp, #0x0
 80046f8: 6078         	str	r0, [r7, #0x4]
; 	int length = 0;
 80046fa: 2300         	movs	r3, #0x0
 80046fc: 60fb         	str	r3, [r7, #0xc]
; 	va_start(args, fmt);
 80046fe: f107 0320    	add.w	r3, r7, #0x20
 8004702: 60bb         	str	r3, [r7, #0x8]
; 	length = cbvprintf(out_func, (void *)output, fmt, args);
 8004704: 68bb         	ldr	r3, [r7, #0x8]
 8004706: 69fa         	ldr	r2, [r7, #0x1c]
 8004708: 6879         	ldr	r1, [r7, #0x4]
 800470a: 4806         	ldr	r0, [pc, #0x18]         @ 0x8004724 <print_formatted+0x34>
 800470c: f001 fcb0    	bl	0x8006070 <cbvprintf>   @ imm = #0x1960
 8004710: 60f8         	str	r0, [r7, #0xc]
; 	return length;
 8004712: 68fb         	ldr	r3, [r7, #0xc]
; }
 8004714: 4618         	mov	r0, r3
 8004716: 3714         	adds	r7, #0x14
 8004718: 46bd         	mov	sp, r7
 800471a: e8bd 4080    	pop.w	{r7, lr}
 800471e: b003         	add	sp, #0xc
 8004720: 4770         	bx	lr
 8004722: bf00         	nop

08004724 <$d>:
 8004724: e7 56 01 08  	.word	0x080156e7

08004728 <timestamp_print>:
; {
 8004728: b580         	push	{r7, lr}
 800472a: b09a         	sub	sp, #0x68
 800472c: af04         	add	r7, sp, #0x10
 800472e: 60f8         	str	r0, [r7, #0xc]
 8004730: 60b9         	str	r1, [r7, #0x8]
 8004732: 607a         	str	r2, [r7, #0x4]
; 		IS_ENABLED(CONFIG_LOG_OUTPUT_FORMAT_LINUX_TIMESTAMP) |
 8004734: 68bb         	ldr	r3, [r7, #0x8]
 8004736: f003 0344    	and	r3, r3, #0x44
; 	bool format =
 800473a: 2b00         	cmp	r3, #0x0
 800473c: bf14         	ite	ne
 800473e: 2301         	movne	r3, #0x1
 8004740: 2300         	moveq	r3, #0x0
 8004742: f887 3037    	strb.w	r3, [r7, #0x37]
; 	if (!format) {
 8004746: f897 3037    	ldrb.w	r3, [r7, #0x37]
 800474a: f083 0301    	eor	r3, r3, #0x1
 800474e: b2db         	uxtb	r3, r3
 8004750: 2b00         	cmp	r3, #0x0
 8004752: d006         	beq	0x8004762 <timestamp_print+0x3a> @ imm = #0xc
; 		length = print_formatted(output, "[%08lu] ", timestamp);
 8004754: 687a         	ldr	r2, [r7, #0x4]
 8004756: 4938         	ldr	r1, [pc, #0xe0]         @ 0x8004838 <timestamp_print+0x110>
 8004758: 68f8         	ldr	r0, [r7, #0xc]
 800475a: f7ff ffc9    	bl	0x80046f0 <print_formatted> @ imm = #-0x6e
 800475e: 63b8         	str	r0, [r7, #0x38]
 8004760: e065         	b	0x800482e <timestamp_print+0x106> @ imm = #0xca
; 	} else if (freq != 0U) {
 8004762: 4b36         	ldr	r3, [pc, #0xd8]         @ 0x800483c <timestamp_print+0x114>
 8004764: 681b         	ldr	r3, [r3]
 8004766: 2b00         	cmp	r3, #0x0
 8004768: d05f         	beq	0x800482a <timestamp_print+0x102> @ imm = #0xbe
; 		timestamp /= timestamp_div;
 800476a: 4b35         	ldr	r3, [pc, #0xd4]         @ 0x8004840 <timestamp_print+0x118>
 800476c: 681b         	ldr	r3, [r3]
 800476e: 687a         	ldr	r2, [r7, #0x4]
 8004770: fbb2 f3f3    	udiv	r3, r2, r3
 8004774: 607b         	str	r3, [r7, #0x4]
; 		total_seconds = timestamp / freq;
 8004776: 4b31         	ldr	r3, [pc, #0xc4]         @ 0x800483c <timestamp_print+0x114>
 8004778: 681b         	ldr	r3, [r3]
 800477a: 687a         	ldr	r2, [r7, #0x4]
 800477c: fbb2 f3f3    	udiv	r3, r2, r3
 8004780: 63fb         	str	r3, [r7, #0x3c]
; 		seconds = total_seconds;
 8004782: 6bfb         	ldr	r3, [r7, #0x3c]
 8004784: 653b         	str	r3, [r7, #0x50]
; 		hours = seconds / 3600U;
 8004786: 6d3b         	ldr	r3, [r7, #0x50]
 8004788: 4a2e         	ldr	r2, [pc, #0xb8]         @ 0x8004844 <timestamp_print+0x11c>
 800478a: fba2 2303    	umull	r2, r3, r2, r3
 800478e: 0adb         	lsrs	r3, r3, #0xb
 8004790: 643b         	str	r3, [r7, #0x40]
; 		seconds -= hours * 3600U;
 8004792: 6c3b         	ldr	r3, [r7, #0x40]
 8004794: f44f 6261    	mov.w	r2, #0xe10
 8004798: fb02 f303    	mul	r3, r2, r3
 800479c: 6d3a         	ldr	r2, [r7, #0x50]
 800479e: 1ad3         	subs	r3, r2, r3
 80047a0: 653b         	str	r3, [r7, #0x50]
; 		mins = seconds / 60U;
 80047a2: 6d3b         	ldr	r3, [r7, #0x50]
 80047a4: 4a28         	ldr	r2, [pc, #0xa0]         @ 0x8004848 <timestamp_print+0x120>
 80047a6: fba2 2303    	umull	r2, r3, r2, r3
 80047aa: 095b         	lsrs	r3, r3, #0x5
 80047ac: 657b         	str	r3, [r7, #0x54]
; 		seconds -= mins * 60U;
 80047ae: 6d7a         	ldr	r2, [r7, #0x54]
 80047b0: 4613         	mov	r3, r2
 80047b2: 011b         	lsls	r3, r3, #0x4
 80047b4: 1a9b         	subs	r3, r3, r2
 80047b6: 009b         	lsls	r3, r3, #0x2
 80047b8: 461a         	mov	r2, r3
 80047ba: 6d3b         	ldr	r3, [r7, #0x50]
 80047bc: 1a9b         	subs	r3, r3, r2
 80047be: 653b         	str	r3, [r7, #0x50]
; 		remainder = timestamp % freq;
 80047c0: 4b1e         	ldr	r3, [pc, #0x78]         @ 0x800483c <timestamp_print+0x114>
 80047c2: 681a         	ldr	r2, [r3]
 80047c4: 687b         	ldr	r3, [r7, #0x4]
 80047c6: fbb3 f1f2    	udiv	r1, r3, r2
 80047ca: fb01 f202    	mul	r2, r1, r2
 80047ce: 1a9b         	subs	r3, r3, r2
 80047d0: 64fb         	str	r3, [r7, #0x4c]
; 		ms = (remainder * 1000U) / freq;
 80047d2: 6cfb         	ldr	r3, [r7, #0x4c]
 80047d4: f44f 727a    	mov.w	r2, #0x3e8
 80047d8: fb03 f202    	mul	r2, r3, r2
 80047dc: 4b17         	ldr	r3, [pc, #0x5c]         @ 0x800483c <timestamp_print+0x114>
 80047de: 681b         	ldr	r3, [r3]
 80047e0: fbb2 f3f3    	udiv	r3, r2, r3
 80047e4: 64bb         	str	r3, [r7, #0x48]
; 		us = (1000 * (remainder * 1000U - (ms * freq))) / freq;
 80047e6: 6cfb         	ldr	r3, [r7, #0x4c]
 80047e8: f44f 727a    	mov.w	r2, #0x3e8
 80047ec: fb03 f202    	mul	r2, r3, r2
 80047f0: 4b12         	ldr	r3, [pc, #0x48]         @ 0x800483c <timestamp_print+0x114>
 80047f2: 681b         	ldr	r3, [r3]
 80047f4: 6cb9         	ldr	r1, [r7, #0x48]
 80047f6: fb01 f303    	mul	r3, r1, r3
 80047fa: 1ad3         	subs	r3, r2, r3
 80047fc: f44f 727a    	mov.w	r2, #0x3e8
 8004800: fb03 f202    	mul	r2, r3, r2
 8004804: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x800483c <timestamp_print+0x114>
 8004806: 681b         	ldr	r3, [r3]
 8004808: fbb2 f3f3    	udiv	r3, r2, r3
 800480c: 647b         	str	r3, [r7, #0x44]
; 				length = print_formatted(output,
 800480e: 6c7b         	ldr	r3, [r7, #0x44]
 8004810: 9302         	str	r3, [sp, #0x8]
 8004812: 6cbb         	ldr	r3, [r7, #0x48]
 8004814: 9301         	str	r3, [sp, #0x4]
 8004816: 6d3b         	ldr	r3, [r7, #0x50]
 8004818: 9300         	str	r3, [sp]
 800481a: 6d7b         	ldr	r3, [r7, #0x54]
 800481c: 6c3a         	ldr	r2, [r7, #0x40]
 800481e: 490b         	ldr	r1, [pc, #0x2c]         @ 0x800484c <timestamp_print+0x124>
 8004820: 68f8         	ldr	r0, [r7, #0xc]
 8004822: f7ff ff65    	bl	0x80046f0 <print_formatted> @ imm = #-0x136
 8004826: 63b8         	str	r0, [r7, #0x38]
 8004828: e001         	b	0x800482e <timestamp_print+0x106> @ imm = #0x2
; 		length = 0;
 800482a: 2300         	movs	r3, #0x0
 800482c: 63bb         	str	r3, [r7, #0x38]
; 	return length;
 800482e: 6bbb         	ldr	r3, [r7, #0x38]
; }
 8004830: 4618         	mov	r0, r3
 8004832: 3758         	adds	r7, #0x58
 8004834: 46bd         	mov	sp, r7
 8004836: bd80         	pop	{r7, pc}

08004838 <$d>:
 8004838: 4c e5 01 08  	.word	0x0801e54c
 800483c: 10 1c 00 20  	.word	0x20001c10
 8004840: 14 1c 00 20  	.word	0x20001c14
 8004844: c5 b3 a2 91  	.word	0x91a2b3c5
 8004848: 89 88 88 88  	.word	0x88888889
 800484c: 58 e5 01 08  	.word	0x0801e558

08004850 <color_print>:
; {
 8004850: b580         	push	{r7, lr}
 8004852: b086         	sub	sp, #0x18
 8004854: af00         	add	r7, sp, #0x0
 8004856: 60f8         	str	r0, [r7, #0xc]
 8004858: 607b         	str	r3, [r7, #0x4]
 800485a: 460b         	mov	r3, r1
 800485c: 72fb         	strb	r3, [r7, #0xb]
 800485e: 4613         	mov	r3, r2
 8004860: 72bb         	strb	r3, [r7, #0xa]
; 	if (color) {
 8004862: 7afb         	ldrb	r3, [r7, #0xb]
 8004864: 2b00         	cmp	r3, #0x0
 8004866: d014         	beq	0x8004892 <color_print+0x42> @ imm = #0x28
; 				colors[level] : LOG_COLOR_CODE_DEFAULT;
 8004868: 7abb         	ldrb	r3, [r7, #0xa]
 800486a: 2b00         	cmp	r3, #0x0
 800486c: d00a         	beq	0x8004884 <color_print+0x34> @ imm = #0x14
; 		const char *log_color = start && (colors[level] != NULL) ?
 800486e: 4a0b         	ldr	r2, [pc, #0x2c]         @ 0x800489c <color_print+0x4c>
 8004870: 687b         	ldr	r3, [r7, #0x4]
 8004872: f852 3023    	ldr.w	r3, [r2, r3, lsl #2]
 8004876: 2b00         	cmp	r3, #0x0
 8004878: d004         	beq	0x8004884 <color_print+0x34> @ imm = #0x8
; 				colors[level] : LOG_COLOR_CODE_DEFAULT;
 800487a: 4a08         	ldr	r2, [pc, #0x20]         @ 0x800489c <color_print+0x4c>
 800487c: 687b         	ldr	r3, [r7, #0x4]
 800487e: f852 3023    	ldr.w	r3, [r2, r3, lsl #2]
 8004882: e000         	b	0x8004886 <color_print+0x36> @ imm = #0x0
 8004884: 4b06         	ldr	r3, [pc, #0x18]         @ 0x80048a0 <color_print+0x50>
; 		const char *log_color = start && (colors[level] != NULL) ?
 8004886: 617b         	str	r3, [r7, #0x14]
; 		print_formatted(output, "%s", log_color);
 8004888: 697a         	ldr	r2, [r7, #0x14]
 800488a: 4906         	ldr	r1, [pc, #0x18]         @ 0x80048a4 <color_print+0x54>
 800488c: 68f8         	ldr	r0, [r7, #0xc]
 800488e: f7ff ff2f    	bl	0x80046f0 <print_formatted> @ imm = #-0x1a2
; }
 8004892: bf00         	nop
 8004894: 3718         	adds	r7, #0x18
 8004896: 46bd         	mov	sp, r7
 8004898: bd80         	pop	{r7, pc}
 800489a: bf00         	nop

0800489c <$d>:
 800489c: 08 ff 01 08  	.word	0x0801ff08
 80048a0: 74 e5 01 08  	.word	0x0801e574
 80048a4: 7c e5 01 08  	.word	0x0801e57c

080048a8 <ids_print>:
; {
 80048a8: b580         	push	{r7, lr}
 80048aa: b084         	sub	sp, #0x10
 80048ac: af00         	add	r7, sp, #0x0
 80048ae: 6078         	str	r0, [r7, #0x4]
 80048b0: 4608         	mov	r0, r1
 80048b2: 4611         	mov	r1, r2
 80048b4: 461a         	mov	r2, r3
 80048b6: 4603         	mov	r3, r0
 80048b8: 70fb         	strb	r3, [r7, #0x3]
 80048ba: 460b         	mov	r3, r1
 80048bc: 70bb         	strb	r3, [r7, #0x2]
 80048be: 4613         	mov	r3, r2
 80048c0: 707b         	strb	r3, [r7, #0x1]
; 	int total = 0;
 80048c2: 2300         	movs	r3, #0x0
 80048c4: 60fb         	str	r3, [r7, #0xc]
; 	if (level_on) {
 80048c6: 78fb         	ldrb	r3, [r7, #0x3]
 80048c8: 2b00         	cmp	r3, #0x0
 80048ca: d00c         	beq	0x80048e6 <ids_print+0x3e> @ imm = #0x18
; 		total += print_formatted(output, "<%s> ", severity[level]);
 80048cc: 4a19         	ldr	r2, [pc, #0x64]         @ 0x8004934 <ids_print+0x8c>
 80048ce: 6a7b         	ldr	r3, [r7, #0x24]
 80048d0: f852 3023    	ldr.w	r3, [r2, r3, lsl #2]
 80048d4: 461a         	mov	r2, r3
 80048d6: 4918         	ldr	r1, [pc, #0x60]         @ 0x8004938 <ids_print+0x90>
 80048d8: 6878         	ldr	r0, [r7, #0x4]
 80048da: f7ff ff09    	bl	0x80046f0 <print_formatted> @ imm = #-0x1ee
 80048de: 4602         	mov	r2, r0
 80048e0: 68fb         	ldr	r3, [r7, #0xc]
 80048e2: 4413         	add	r3, r2
 80048e4: 60fb         	str	r3, [r7, #0xc]
; 	if (domain) {
 80048e6: 69bb         	ldr	r3, [r7, #0x18]
 80048e8: 2b00         	cmp	r3, #0x0
 80048ea: d008         	beq	0x80048fe <ids_print+0x56> @ imm = #0x10
; 		total += print_formatted(output, "%s/", domain);
 80048ec: 69ba         	ldr	r2, [r7, #0x18]
 80048ee: 4913         	ldr	r1, [pc, #0x4c]         @ 0x800493c <ids_print+0x94>
 80048f0: 6878         	ldr	r0, [r7, #0x4]
 80048f2: f7ff fefd    	bl	0x80046f0 <print_formatted> @ imm = #-0x206
 80048f6: 4602         	mov	r2, r0
 80048f8: 68fb         	ldr	r3, [r7, #0xc]
 80048fa: 4413         	add	r3, r2
 80048fc: 60fb         	str	r3, [r7, #0xc]
; 	if (source) {
 80048fe: 69fb         	ldr	r3, [r7, #0x1c]
 8004900: 2b00         	cmp	r3, #0x0
 8004902: d011         	beq	0x8004928 <ids_print+0x80> @ imm = #0x22
; 		total += print_formatted(output,
 8004904: 78bb         	ldrb	r3, [r7, #0x2]
 8004906: 2b00         	cmp	r3, #0x0
 8004908: d004         	beq	0x8004914 <ids_print+0x6c> @ imm = #0x8
; 				(func_on &&
 800490a: 6a7b         	ldr	r3, [r7, #0x24]
 800490c: 2b04         	cmp	r3, #0x4
 800490e: d101         	bne	0x8004914 <ids_print+0x6c> @ imm = #0x2
; 		total += print_formatted(output,
 8004910: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x8004940 <ids_print+0x98>
 8004912: e000         	b	0x8004916 <ids_print+0x6e> @ imm = #0x0
 8004914: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x8004944 <ids_print+0x9c>
 8004916: 69fa         	ldr	r2, [r7, #0x1c]
 8004918: 4619         	mov	r1, r3
 800491a: 6878         	ldr	r0, [r7, #0x4]
 800491c: f7ff fee8    	bl	0x80046f0 <print_formatted> @ imm = #-0x230
 8004920: 4602         	mov	r2, r0
 8004922: 68fb         	ldr	r3, [r7, #0xc]
 8004924: 4413         	add	r3, r2
 8004926: 60fb         	str	r3, [r7, #0xc]
; 	return total;
 8004928: 68fb         	ldr	r3, [r7, #0xc]
; }
 800492a: 4618         	mov	r0, r3
 800492c: 3710         	adds	r7, #0x10
 800492e: 46bd         	mov	sp, r7
 8004930: bd80         	pop	{r7, pc}
 8004932: bf00         	nop

08004934 <$d>:
 8004934: f4 fe 01 08  	.word	0x0801fef4
 8004938: 80 e5 01 08  	.word	0x0801e580
 800493c: 88 e5 01 08  	.word	0x0801e588
 8004940: 8c e5 01 08  	.word	0x0801e58c
 8004944: 90 e5 01 08  	.word	0x0801e590

08004948 <newline_print>:
; {
 8004948: b580         	push	{r7, lr}
 800494a: b082         	sub	sp, #0x8
 800494c: af00         	add	r7, sp, #0x0
 800494e: 6078         	str	r0, [r7, #0x4]
 8004950: 6039         	str	r1, [r7]
; 	if ((flags & LOG_OUTPUT_FLAG_CRLF_NONE) != 0U) {
 8004952: 683b         	ldr	r3, [r7]
 8004954: f003 0310    	and	r3, r3, #0x10
 8004958: 2b00         	cmp	r3, #0x0
 800495a: d10e         	bne	0x800497a <newline_print+0x32> @ imm = #0x1c
; 	if ((flags & LOG_OUTPUT_FLAG_CRLF_LFONLY) != 0U) {
 800495c: 683b         	ldr	r3, [r7]
 800495e: f003 0320    	and	r3, r3, #0x20
 8004962: 2b00         	cmp	r3, #0x0
 8004964: d004         	beq	0x8004970 <newline_print+0x28> @ imm = #0x8
; 		print_formatted(ctx, "\n");
 8004966: 4907         	ldr	r1, [pc, #0x1c]         @ 0x8004984 <newline_print+0x3c>
 8004968: 6878         	ldr	r0, [r7, #0x4]
 800496a: f7ff fec1    	bl	0x80046f0 <print_formatted> @ imm = #-0x27e
 800496e: e005         	b	0x800497c <newline_print+0x34> @ imm = #0xa
; 		print_formatted(ctx, "\r\n");
 8004970: 4905         	ldr	r1, [pc, #0x14]         @ 0x8004988 <newline_print+0x40>
 8004972: 6878         	ldr	r0, [r7, #0x4]
 8004974: f7ff febc    	bl	0x80046f0 <print_formatted> @ imm = #-0x288
 8004978: e000         	b	0x800497c <newline_print+0x34> @ imm = #0x0
; 		return;
 800497a: bf00         	nop
; }
 800497c: 3708         	adds	r7, #0x8
 800497e: 46bd         	mov	sp, r7
 8004980: bd80         	pop	{r7, pc}
 8004982: bf00         	nop

08004984 <$d>:
 8004984: 98 e5 01 08  	.word	0x0801e598
 8004988: 9c e5 01 08  	.word	0x0801e59c

0800498c <hexdump_line_print>:
; {
 800498c: b580         	push	{r7, lr}
 800498e: b088         	sub	sp, #0x20
 8004990: af00         	add	r7, sp, #0x0
 8004992: 60f8         	str	r0, [r7, #0xc]
 8004994: 60b9         	str	r1, [r7, #0x8]
 8004996: 607a         	str	r2, [r7, #0x4]
 8004998: 603b         	str	r3, [r7]
; 	newline_print(output, flags);
 800499a: 6ab9         	ldr	r1, [r7, #0x28]
 800499c: 68f8         	ldr	r0, [r7, #0xc]
 800499e: f7ff ffd3    	bl	0x8004948 <newline_print> @ imm = #-0x5a
; 	for (int i = 0; i < prefix_offset; i++) {
 80049a2: 2300         	movs	r3, #0x0
 80049a4: 61fb         	str	r3, [r7, #0x1c]
 80049a6: e006         	b	0x80049b6 <hexdump_line_print+0x2a> @ imm = #0xc
; 		print_formatted(output, " ");
 80049a8: 4937         	ldr	r1, [pc, #0xdc]         @ 0x8004a88 <hexdump_line_print+0xfc>
 80049aa: 68f8         	ldr	r0, [r7, #0xc]
 80049ac: f7ff fea0    	bl	0x80046f0 <print_formatted> @ imm = #-0x2c0
; 	for (int i = 0; i < prefix_offset; i++) {
 80049b0: 69fb         	ldr	r3, [r7, #0x1c]
 80049b2: 3301         	adds	r3, #0x1
 80049b4: 61fb         	str	r3, [r7, #0x1c]
 80049b6: 69fa         	ldr	r2, [r7, #0x1c]
 80049b8: 683b         	ldr	r3, [r7]
 80049ba: 429a         	cmp	r2, r3
 80049bc: dbf4         	blt	0x80049a8 <hexdump_line_print+0x1c> @ imm = #-0x18
; 	for (int i = 0; i < HEXDUMP_BYTES_IN_LINE; i++) {
 80049be: 2300         	movs	r3, #0x0
 80049c0: 61bb         	str	r3, [r7, #0x18]
 80049c2: e020         	b	0x8004a06 <hexdump_line_print+0x7a> @ imm = #0x40
; 		if (i > 0 && !(i % 8)) {
 80049c4: 69bb         	ldr	r3, [r7, #0x18]
 80049c6: 2b00         	cmp	r3, #0x0
 80049c8: dd08         	ble	0x80049dc <hexdump_line_print+0x50> @ imm = #0x10
 80049ca: 69bb         	ldr	r3, [r7, #0x18]
 80049cc: f003 0307    	and	r3, r3, #0x7
 80049d0: 2b00         	cmp	r3, #0x0
 80049d2: d103         	bne	0x80049dc <hexdump_line_print+0x50> @ imm = #0x6
; 			print_formatted(output, " ");
 80049d4: 492c         	ldr	r1, [pc, #0xb0]         @ 0x8004a88 <hexdump_line_print+0xfc>
 80049d6: 68f8         	ldr	r0, [r7, #0xc]
 80049d8: f7ff fe8a    	bl	0x80046f0 <print_formatted> @ imm = #-0x2ec
; 		if (i < length) {
 80049dc: 69bb         	ldr	r3, [r7, #0x18]
 80049de: 687a         	ldr	r2, [r7, #0x4]
 80049e0: 429a         	cmp	r2, r3
 80049e2: d909         	bls	0x80049f8 <hexdump_line_print+0x6c> @ imm = #0x12
; 			print_formatted(output, "%02x ", data[i]);
 80049e4: 69bb         	ldr	r3, [r7, #0x18]
 80049e6: 68ba         	ldr	r2, [r7, #0x8]
 80049e8: 4413         	add	r3, r2
 80049ea: 781b         	ldrb	r3, [r3]
 80049ec: 461a         	mov	r2, r3
 80049ee: 4927         	ldr	r1, [pc, #0x9c]         @ 0x8004a8c <hexdump_line_print+0x100>
 80049f0: 68f8         	ldr	r0, [r7, #0xc]
 80049f2: f7ff fe7d    	bl	0x80046f0 <print_formatted> @ imm = #-0x306
 80049f6: e003         	b	0x8004a00 <hexdump_line_print+0x74> @ imm = #0x6
; 			print_formatted(output, "   ");
 80049f8: 4925         	ldr	r1, [pc, #0x94]         @ 0x8004a90 <hexdump_line_print+0x104>
 80049fa: 68f8         	ldr	r0, [r7, #0xc]
 80049fc: f7ff fe78    	bl	0x80046f0 <print_formatted> @ imm = #-0x310
; 	for (int i = 0; i < HEXDUMP_BYTES_IN_LINE; i++) {
 8004a00: 69bb         	ldr	r3, [r7, #0x18]
 8004a02: 3301         	adds	r3, #0x1
 8004a04: 61bb         	str	r3, [r7, #0x18]
 8004a06: 69bb         	ldr	r3, [r7, #0x18]
 8004a08: 2b0f         	cmp	r3, #0xf
 8004a0a: dddb         	ble	0x80049c4 <hexdump_line_print+0x38> @ imm = #-0x4a
; 	print_formatted(output, "|");
 8004a0c: 4921         	ldr	r1, [pc, #0x84]         @ 0x8004a94 <hexdump_line_print+0x108>
 8004a0e: 68f8         	ldr	r0, [r7, #0xc]
 8004a10: f7ff fe6e    	bl	0x80046f0 <print_formatted> @ imm = #-0x324
; 	for (int i = 0; i < HEXDUMP_BYTES_IN_LINE; i++) {
 8004a14: 2300         	movs	r3, #0x0
 8004a16: 617b         	str	r3, [r7, #0x14]
 8004a18: e02d         	b	0x8004a76 <hexdump_line_print+0xea> @ imm = #0x5a
; 		if (i > 0 && !(i % 8)) {
 8004a1a: 697b         	ldr	r3, [r7, #0x14]
 8004a1c: 2b00         	cmp	r3, #0x0
 8004a1e: dd08         	ble	0x8004a32 <hexdump_line_print+0xa6> @ imm = #0x10
 8004a20: 697b         	ldr	r3, [r7, #0x14]
 8004a22: f003 0307    	and	r3, r3, #0x7
 8004a26: 2b00         	cmp	r3, #0x0
 8004a28: d103         	bne	0x8004a32 <hexdump_line_print+0xa6> @ imm = #0x6
; 			print_formatted(output, " ");
 8004a2a: 4917         	ldr	r1, [pc, #0x5c]         @ 0x8004a88 <hexdump_line_print+0xfc>
 8004a2c: 68f8         	ldr	r0, [r7, #0xc]
 8004a2e: f7ff fe5f    	bl	0x80046f0 <print_formatted> @ imm = #-0x342
; 		if (i < length) {
 8004a32: 697b         	ldr	r3, [r7, #0x14]
 8004a34: 687a         	ldr	r2, [r7, #0x4]
 8004a36: 429a         	cmp	r2, r3
 8004a38: d916         	bls	0x8004a68 <hexdump_line_print+0xdc> @ imm = #0x2c
; 			unsigned char c = (unsigned char)data[i];
 8004a3a: 697b         	ldr	r3, [r7, #0x14]
 8004a3c: 68ba         	ldr	r2, [r7, #0x8]
 8004a3e: 4413         	add	r3, r2
 8004a40: 781b         	ldrb	r3, [r3]
 8004a42: 74fb         	strb	r3, [r7, #0x13]
; 			      isprint((int)c) != 0 ? c : '.');
 8004a44: 7cfb         	ldrb	r3, [r7, #0x13]
 8004a46: 4618         	mov	r0, r3
 8004a48: f7ff fe42    	bl	0x80046d0 <__ctype_lookup> @ imm = #-0x37c
 8004a4c: 4603         	mov	r3, r0
 8004a4e: f003 0397    	and	r3, r3, #0x97
; 			print_formatted(output, "%c",
 8004a52: 2b00         	cmp	r3, #0x0
 8004a54: d001         	beq	0x8004a5a <hexdump_line_print+0xce> @ imm = #0x2
 8004a56: 7cfb         	ldrb	r3, [r7, #0x13]
 8004a58: e000         	b	0x8004a5c <hexdump_line_print+0xd0> @ imm = #0x0
 8004a5a: 232e         	movs	r3, #0x2e
 8004a5c: 461a         	mov	r2, r3
 8004a5e: 490e         	ldr	r1, [pc, #0x38]         @ 0x8004a98 <hexdump_line_print+0x10c>
 8004a60: 68f8         	ldr	r0, [r7, #0xc]
 8004a62: f7ff fe45    	bl	0x80046f0 <print_formatted> @ imm = #-0x376
 8004a66: e003         	b	0x8004a70 <hexdump_line_print+0xe4> @ imm = #0x6
; 			print_formatted(output, " ");
 8004a68: 4907         	ldr	r1, [pc, #0x1c]         @ 0x8004a88 <hexdump_line_print+0xfc>
 8004a6a: 68f8         	ldr	r0, [r7, #0xc]
 8004a6c: f7ff fe40    	bl	0x80046f0 <print_formatted> @ imm = #-0x380
; 	for (int i = 0; i < HEXDUMP_BYTES_IN_LINE; i++) {
 8004a70: 697b         	ldr	r3, [r7, #0x14]
 8004a72: 3301         	adds	r3, #0x1
 8004a74: 617b         	str	r3, [r7, #0x14]
 8004a76: 697b         	ldr	r3, [r7, #0x14]
 8004a78: 2b0f         	cmp	r3, #0xf
 8004a7a: ddce         	ble	0x8004a1a <hexdump_line_print+0x8e> @ imm = #-0x64
; }
 8004a7c: bf00         	nop
 8004a7e: bf00         	nop
 8004a80: 3720         	adds	r7, #0x20
 8004a82: 46bd         	mov	sp, r7
 8004a84: bd80         	pop	{r7, pc}
 8004a86: bf00         	nop

08004a88 <$d>:
 8004a88: a0 e5 01 08  	.word	0x0801e5a0
 8004a8c: a4 e5 01 08  	.word	0x0801e5a4
 8004a90: ac e5 01 08  	.word	0x0801e5ac
 8004a94: b0 e5 01 08  	.word	0x0801e5b0
 8004a98: b4 e5 01 08  	.word	0x0801e5b4

08004a9c <prefix_print>:
; {
 8004a9c: b590         	push	{r4, r7, lr}
 8004a9e: b08d         	sub	sp, #0x34
 8004aa0: af04         	add	r7, sp, #0x10
 8004aa2: 60f8         	str	r0, [r7, #0xc]
 8004aa4: 60b9         	str	r1, [r7, #0x8]
 8004aa6: 603b         	str	r3, [r7]
 8004aa8: 4613         	mov	r3, r2
 8004aaa: 71fb         	strb	r3, [r7, #0x7]
; 	uint32_t length = 0U;
 8004aac: 2300         	movs	r3, #0x0
 8004aae: 61fb         	str	r3, [r7, #0x1c]
; 	bool stamp = flags & LOG_OUTPUT_FLAG_TIMESTAMP;
 8004ab0: 68bb         	ldr	r3, [r7, #0x8]
 8004ab2: f003 0302    	and	r3, r3, #0x2
 8004ab6: 2b00         	cmp	r3, #0x0
 8004ab8: bf14         	ite	ne
 8004aba: 2301         	movne	r3, #0x1
 8004abc: 2300         	moveq	r3, #0x0
 8004abe: 76fb         	strb	r3, [r7, #0x1b]
; 	bool colors_on = flags & LOG_OUTPUT_FLAG_COLORS;
 8004ac0: 68bb         	ldr	r3, [r7, #0x8]
 8004ac2: f003 0301    	and	r3, r3, #0x1
 8004ac6: 2b00         	cmp	r3, #0x0
 8004ac8: bf14         	ite	ne
 8004aca: 2301         	movne	r3, #0x1
 8004acc: 2300         	moveq	r3, #0x0
 8004ace: 76bb         	strb	r3, [r7, #0x1a]
; 	bool level_on = flags & LOG_OUTPUT_FLAG_LEVEL;
 8004ad0: 68bb         	ldr	r3, [r7, #0x8]
 8004ad2: f003 0308    	and	r3, r3, #0x8
 8004ad6: 2b00         	cmp	r3, #0x0
 8004ad8: bf14         	ite	ne
 8004ada: 2301         	movne	r3, #0x1
 8004adc: 2300         	moveq	r3, #0x0
 8004ade: 767b         	strb	r3, [r7, #0x19]
; 	bool thread_on = IS_ENABLED(CONFIG_LOG_THREAD_ID_PREFIX) &&
 8004ae0: 2300         	movs	r3, #0x0
 8004ae2: 74fb         	strb	r3, [r7, #0x13]
; 	bool source_off = flags & LOG_OUTPUT_FLAG_SKIP_SOURCE;
 8004ae4: 68bb         	ldr	r3, [r7, #0x8]
 8004ae6: f403 7380    	and	r3, r3, #0x100
 8004aea: 2b00         	cmp	r3, #0x0
 8004aec: bf14         	ite	ne
 8004aee: 2301         	movne	r3, #0x1
 8004af0: 2300         	moveq	r3, #0x0
 8004af2: 763b         	strb	r3, [r7, #0x18]
; 	const char *tag = IS_ENABLED(CONFIG_LOG) ? z_log_get_tag() : NULL;
 8004af4: f010 fa51    	bl	0x8014f9a <z_log_get_tag> @ imm = #0x104a2
 8004af8: 6178         	str	r0, [r7, #0x14]
; 	if (tag) {
 8004afa: 697b         	ldr	r3, [r7, #0x14]
 8004afc: 2b00         	cmp	r3, #0x0
 8004afe: d009         	beq	0x8004b14 <prefix_print+0x78> @ imm = #0x12
; 		length += print_formatted(output, "%s ", tag);
 8004b00: 697a         	ldr	r2, [r7, #0x14]
 8004b02: 491e         	ldr	r1, [pc, #0x78]         @ 0x8004b7c <prefix_print+0xe0>
 8004b04: 68f8         	ldr	r0, [r7, #0xc]
 8004b06: f7ff fdf3    	bl	0x80046f0 <print_formatted> @ imm = #-0x41a
 8004b0a: 4603         	mov	r3, r0
 8004b0c: 461a         	mov	r2, r3
 8004b0e: 69fb         	ldr	r3, [r7, #0x1c]
 8004b10: 4413         	add	r3, r2
 8004b12: 61fb         	str	r3, [r7, #0x1c]
; 	if (stamp) {
 8004b14: 7efb         	ldrb	r3, [r7, #0x1b]
 8004b16: 2b00         	cmp	r3, #0x0
 8004b18: d009         	beq	0x8004b2e <prefix_print+0x92> @ imm = #0x12
; 		length += timestamp_print(output, flags, timestamp);
 8004b1a: 683a         	ldr	r2, [r7]
 8004b1c: 68b9         	ldr	r1, [r7, #0x8]
 8004b1e: 68f8         	ldr	r0, [r7, #0xc]
 8004b20: f7ff fe02    	bl	0x8004728 <timestamp_print> @ imm = #-0x3fc
 8004b24: 4603         	mov	r3, r0
 8004b26: 461a         	mov	r2, r3
 8004b28: 69fb         	ldr	r3, [r7, #0x1c]
 8004b2a: 4413         	add	r3, r2
 8004b2c: 61fb         	str	r3, [r7, #0x1c]
; 		color_prefix(output, colors_on, level);
 8004b2e: f897 203c    	ldrb.w	r2, [r7, #0x3c]
 8004b32: 7ebb         	ldrb	r3, [r7, #0x1a]
 8004b34: 4619         	mov	r1, r3
 8004b36: 68f8         	ldr	r0, [r7, #0xc]
 8004b38: f010 fe02    	bl	0x8015740 <color_prefix> @ imm = #0x10c04
; 	length += ids_print(output, level_on, func_on, thread_on, domain,
 8004b3c: 7cfc         	ldrb	r4, [r7, #0x13]
 8004b3e: 7e3b         	ldrb	r3, [r7, #0x18]
 8004b40: 2b00         	cmp	r3, #0x0
 8004b42: d001         	beq	0x8004b48 <prefix_print+0xac> @ imm = #0x2
 8004b44: 2300         	movs	r3, #0x0
 8004b46: e000         	b	0x8004b4a <prefix_print+0xae> @ imm = #0x0
 8004b48: 6b7b         	ldr	r3, [r7, #0x34]
 8004b4a: f897 203c    	ldrb.w	r2, [r7, #0x3c]
 8004b4e: 79f8         	ldrb	r0, [r7, #0x7]
 8004b50: 7e79         	ldrb	r1, [r7, #0x19]
 8004b52: 9203         	str	r2, [sp, #0xc]
 8004b54: 6bba         	ldr	r2, [r7, #0x38]
 8004b56: 9202         	str	r2, [sp, #0x8]
 8004b58: 9301         	str	r3, [sp, #0x4]
 8004b5a: 6b3b         	ldr	r3, [r7, #0x30]
 8004b5c: 9300         	str	r3, [sp]
 8004b5e: 4623         	mov	r3, r4
 8004b60: 4602         	mov	r2, r0
 8004b62: 68f8         	ldr	r0, [r7, #0xc]
 8004b64: f7ff fea0    	bl	0x80048a8 <ids_print>   @ imm = #-0x2c0
 8004b68: 4603         	mov	r3, r0
 8004b6a: 461a         	mov	r2, r3
 8004b6c: 69fb         	ldr	r3, [r7, #0x1c]
 8004b6e: 4413         	add	r3, r2
 8004b70: 61fb         	str	r3, [r7, #0x1c]
; 	return length;
 8004b72: 69fb         	ldr	r3, [r7, #0x1c]
; }
 8004b74: 4618         	mov	r0, r3
 8004b76: 3724         	adds	r7, #0x24
 8004b78: 46bd         	mov	sp, r7
 8004b7a: bd90         	pop	{r4, r7, pc}

08004b7c <$d>:
 8004b7c: c0 e5 01 08  	.word	0x0801e5c0

08004b80 <log_output_process>:
; {
 8004b80: b580         	push	{r7, lr}
 8004b82: b08c         	sub	sp, #0x30
 8004b84: af04         	add	r7, sp, #0x10
 8004b86: 60f8         	str	r0, [r7, #0xc]
 8004b88: 60b9         	str	r1, [r7, #0x8]
 8004b8a: 607a         	str	r2, [r7, #0x4]
 8004b8c: 603b         	str	r3, [r7]
; 	bool raw_string = (level == LOG_LEVEL_INTERNAL_RAW_STRING);
 8004b8e: f897 302c    	ldrb.w	r3, [r7, #0x2c]
 8004b92: 2b00         	cmp	r3, #0x0
 8004b94: bf0c         	ite	eq
 8004b96: 2301         	moveq	r3, #0x1
 8004b98: 2300         	movne	r3, #0x0
 8004b9a: 75fb         	strb	r3, [r7, #0x17]
; 	if (!raw_string) {
 8004b9c: 7dfb         	ldrb	r3, [r7, #0x17]
 8004b9e: f083 0301    	eor	r3, r3, #0x1
 8004ba2: b2db         	uxtb	r3, r3
 8004ba4: 2b00         	cmp	r3, #0x0
 8004ba6: d012         	beq	0x8004bce <log_output_process+0x4e> @ imm = #0x24
; 		prefix_offset = prefix_print(output, flags, 0, timestamp,
 8004ba8: f897 302c    	ldrb.w	r3, [r7, #0x2c]
 8004bac: 9303         	str	r3, [sp, #0xc]
 8004bae: 6abb         	ldr	r3, [r7, #0x28]
 8004bb0: 9302         	str	r3, [sp, #0x8]
 8004bb2: 683b         	ldr	r3, [r7]
 8004bb4: 9301         	str	r3, [sp, #0x4]
 8004bb6: 687b         	ldr	r3, [r7, #0x4]
 8004bb8: 9300         	str	r3, [sp]
 8004bba: 68bb         	ldr	r3, [r7, #0x8]
 8004bbc: 2200         	movs	r2, #0x0
 8004bbe: 6bf9         	ldr	r1, [r7, #0x3c]
 8004bc0: 68f8         	ldr	r0, [r7, #0xc]
 8004bc2: f7ff ff6b    	bl	0x8004a9c <prefix_print> @ imm = #-0x12a
 8004bc6: 61f8         	str	r0, [r7, #0x1c]
; 		cb = out_func;
 8004bc8: 4b1a         	ldr	r3, [pc, #0x68]         @ 0x8004c34 <log_output_process+0xb4>
 8004bca: 61bb         	str	r3, [r7, #0x18]
 8004bcc: e008         	b	0x8004be0 <log_output_process+0x60> @ imm = #0x10
; 		prefix_offset = 0;
 8004bce: 2300         	movs	r3, #0x0
 8004bd0: 61fb         	str	r3, [r7, #0x1c]
; 		cb = ((uintptr_t)source == 1) ? out_func : cr_out_func;
 8004bd2: 683b         	ldr	r3, [r7]
 8004bd4: 2b01         	cmp	r3, #0x1
 8004bd6: d101         	bne	0x8004bdc <log_output_process+0x5c> @ imm = #0x2
 8004bd8: 4b16         	ldr	r3, [pc, #0x58]         @ 0x8004c34 <log_output_process+0xb4>
 8004bda: e000         	b	0x8004bde <log_output_process+0x5e> @ imm = #0x0
 8004bdc: 4b16         	ldr	r3, [pc, #0x58]         @ 0x8004c38 <log_output_process+0xb8>
 8004bde: 61bb         	str	r3, [r7, #0x18]
; 	if (package) {
 8004be0: 6b3b         	ldr	r3, [r7, #0x30]
 8004be2: 2b00         	cmp	r3, #0x0
 8004be4: d005         	beq	0x8004bf2 <log_output_process+0x72> @ imm = #0xa
; 		int err = cbpprintf(cb, (void *)output, (void *)package);
 8004be6: 6b3a         	ldr	r2, [r7, #0x30]
 8004be8: 68f9         	ldr	r1, [r7, #0xc]
 8004bea: 69b8         	ldr	r0, [r7, #0x18]
 8004bec: f7ff fd5c    	bl	0x80046a8 <cbpprintf>   @ imm = #-0x548
 8004bf0: 6138         	str	r0, [r7, #0x10]
; 	if (data_len) {
 8004bf2: 6bbb         	ldr	r3, [r7, #0x38]
 8004bf4: 2b00         	cmp	r3, #0x0
 8004bf6: d008         	beq	0x8004c0a <log_output_process+0x8a> @ imm = #0x10
; 		log_msg_hexdump(output, (uint8_t *)data, data_len, prefix_offset, flags);
 8004bf8: 69fa         	ldr	r2, [r7, #0x1c]
 8004bfa: 6bfb         	ldr	r3, [r7, #0x3c]
 8004bfc: 9300         	str	r3, [sp]
 8004bfe: 4613         	mov	r3, r2
 8004c00: 6bba         	ldr	r2, [r7, #0x38]
 8004c02: 6b79         	ldr	r1, [r7, #0x34]
 8004c04: 68f8         	ldr	r0, [r7, #0xc]
 8004c06: f010 fdbd    	bl	0x8015784 <log_msg_hexdump> @ imm = #0x10b7a
; 	if (!raw_string) {
 8004c0a: 7dfb         	ldrb	r3, [r7, #0x17]
 8004c0c: f083 0301    	eor	r3, r3, #0x1
 8004c10: b2db         	uxtb	r3, r3
 8004c12: 2b00         	cmp	r3, #0x0
 8004c14: d006         	beq	0x8004c24 <log_output_process+0xa4> @ imm = #0xc
; 		postfix_print(output, flags, level);
 8004c16: f897 302c    	ldrb.w	r3, [r7, #0x2c]
 8004c1a: 461a         	mov	r2, r3
 8004c1c: 6bf9         	ldr	r1, [r7, #0x3c]
 8004c1e: 68f8         	ldr	r0, [r7, #0xc]
 8004c20: f010 fdd4    	bl	0x80157cc <postfix_print> @ imm = #0x10ba8
; 	log_output_flush(output);
 8004c24: 68f8         	ldr	r0, [r7, #0xc]
 8004c26: f010 fd45    	bl	0x80156b4 <log_output_flush> @ imm = #0x10a8a
; }
 8004c2a: bf00         	nop
 8004c2c: 3720         	adds	r7, #0x20
 8004c2e: 46bd         	mov	sp, r7
 8004c30: bd80         	pop	{r7, pc}
 8004c32: bf00         	nop

08004c34 <$d>:
 8004c34: e7 56 01 08  	.word	0x080156e7
 8004c38: 17 57 01 08  	.word	0x08015717

08004c3c <log_output_timestamp_freq_set>:
; {
 8004c3c: b480         	push	{r7}
 8004c3e: b083         	sub	sp, #0xc
 8004c40: af00         	add	r7, sp, #0x0
 8004c42: 6078         	str	r0, [r7, #0x4]
; 	timestamp_div = 1U;
 8004c44: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x8004c74 <log_output_timestamp_freq_set+0x38>
 8004c46: 2201         	movs	r2, #0x1
 8004c48: 601a         	str	r2, [r3]
; 	while (frequency > 1000000) {
 8004c4a: e007         	b	0x8004c5c <log_output_timestamp_freq_set+0x20> @ imm = #0xe
; 		frequency /= 2U;
 8004c4c: 687b         	ldr	r3, [r7, #0x4]
 8004c4e: 085b         	lsrs	r3, r3, #0x1
 8004c50: 607b         	str	r3, [r7, #0x4]
; 		timestamp_div *= 2U;
 8004c52: 4b08         	ldr	r3, [pc, #0x20]         @ 0x8004c74 <log_output_timestamp_freq_set+0x38>
 8004c54: 681b         	ldr	r3, [r3]
 8004c56: 005b         	lsls	r3, r3, #0x1
 8004c58: 4a06         	ldr	r2, [pc, #0x18]         @ 0x8004c74 <log_output_timestamp_freq_set+0x38>
 8004c5a: 6013         	str	r3, [r2]
; 	while (frequency > 1000000) {
 8004c5c: 687b         	ldr	r3, [r7, #0x4]
 8004c5e: 4a06         	ldr	r2, [pc, #0x18]         @ 0x8004c78 <log_output_timestamp_freq_set+0x3c>
 8004c60: 4293         	cmp	r3, r2
 8004c62: d8f3         	bhi	0x8004c4c <log_output_timestamp_freq_set+0x10> @ imm = #-0x1a
; 	freq = frequency;
 8004c64: 4a05         	ldr	r2, [pc, #0x14]         @ 0x8004c7c <log_output_timestamp_freq_set+0x40>
 8004c66: 687b         	ldr	r3, [r7, #0x4]
 8004c68: 6013         	str	r3, [r2]
; }
 8004c6a: bf00         	nop
 8004c6c: 370c         	adds	r7, #0xc
 8004c6e: 46bd         	mov	sp, r7
 8004c70: bc80         	pop	{r7}
 8004c72: 4770         	bx	lr

08004c74 <$d>:
 8004c74: 14 1c 00 20  	.word	0x20001c14
 8004c78: 40 42 0f 00  	.word	0x000f4240
 8004c7c: 10 1c 00 20  	.word	0x20001c10

08004c80 <char_out>:
; {
 8004c80: b580         	push	{r7, lr}
 8004c82: b088         	sub	sp, #0x20
 8004c84: af00         	add	r7, sp, #0x0
 8004c86: 60f8         	str	r0, [r7, #0xc]
 8004c88: 60b9         	str	r1, [r7, #0x8]
 8004c8a: 607a         	str	r2, [r7, #0x4]
; 	const struct lbu_cb_ctx *cb_ctx = ctx;
 8004c8c: 687b         	ldr	r3, [r7, #0x4]
 8004c8e: 61bb         	str	r3, [r7, #0x18]
; 	struct lbu_data *lb_data = cb_ctx->data;
 8004c90: 69bb         	ldr	r3, [r7, #0x18]
 8004c92: 685b         	ldr	r3, [r3, #0x4]
 8004c94: 617b         	str	r3, [r7, #0x14]
; 	const struct device *uart_dev = LBU_UART_DEV(cb_ctx);
 8004c96: 4b15         	ldr	r3, [pc, #0x54]         @ 0x8004cec <char_out+0x6c>
 8004c98: 613b         	str	r3, [r7, #0x10]
; 	if (pm_device_runtime_get(uart_dev) < 0) {
 8004c9a: 6938         	ldr	r0, [r7, #0x10]
 8004c9c: f010 fe8e    	bl	0x80159bc <pm_device_runtime_get> @ imm = #0x10d1c
 8004ca0: 4603         	mov	r3, r0
 8004ca2: 2b00         	cmp	r3, #0x0
 8004ca4: da01         	bge	0x8004caa <char_out+0x2a> @ imm = #0x2
; 		return length;
 8004ca6: 68b9         	ldr	r1, [r7, #0x8]
 8004ca8: e01a         	b	0x8004ce0 <char_out+0x60> @ imm = #0x34
; 		for (size_t i = 0; i < length; i++) {
 8004caa: 2300         	movs	r3, #0x0
 8004cac: 61fb         	str	r3, [r7, #0x1c]
 8004cae: e00a         	b	0x8004cc6 <char_out+0x46> @ imm = #0x14
; 			uart_poll_out(uart_dev, data[i]);
 8004cb0: 68fa         	ldr	r2, [r7, #0xc]
 8004cb2: 69fb         	ldr	r3, [r7, #0x1c]
 8004cb4: 4413         	add	r3, r2
 8004cb6: 781b         	ldrb	r3, [r3]
 8004cb8: 4619         	mov	r1, r3
 8004cba: 6938         	ldr	r0, [r7, #0x10]
 8004cbc: f010 fe6f    	bl	0x801599e <uart_poll_out> @ imm = #0x10cde
; 		for (size_t i = 0; i < length; i++) {
 8004cc0: 69fb         	ldr	r3, [r7, #0x1c]
 8004cc2: 3301         	adds	r3, #0x1
 8004cc4: 61fb         	str	r3, [r7, #0x1c]
 8004cc6: 69fa         	ldr	r2, [r7, #0x1c]
 8004cc8: 68bb         	ldr	r3, [r7, #0x8]
 8004cca: 429a         	cmp	r2, r3
 8004ccc: d3f0         	blo	0x8004cb0 <char_out+0x30> @ imm = #-0x20
; 		goto cleanup;
 8004cce: bf00         	nop
; 	(void)pm_device_runtime_put_async(uart_dev, K_MSEC(1));
 8004cd0: f04f 020a    	mov.w	r2, #0xa
 8004cd4: f04f 0300    	mov.w	r3, #0x0
 8004cd8: 6938         	ldr	r0, [r7, #0x10]
 8004cda: f010 fe79    	bl	0x80159d0 <pm_device_runtime_put_async> @ imm = #0x10cf2
; 	return length;
 8004cde: 68b9         	ldr	r1, [r7, #0x8]
; }
 8004ce0: 460b         	mov	r3, r1
 8004ce2: 4618         	mov	r0, r3
 8004ce4: 3720         	adds	r7, #0x20
 8004ce6: 46bd         	mov	sp, r7
 8004ce8: bd80         	pop	{r7, pc}
 8004cea: bf00         	nop

08004cec <$d>:
 8004cec: 40 de 01 08  	.word	0x0801de40

08004cf0 <log_backend_uart_init>:
; {
 8004cf0: b580         	push	{r7, lr}
 8004cf2: b086         	sub	sp, #0x18
 8004cf4: af00         	add	r7, sp, #0x0
 8004cf6: 6078         	str	r0, [r7, #0x4]
; 	const struct lbu_cb_ctx *ctx = backend->cb->ctx;
 8004cf8: 687b         	ldr	r3, [r7, #0x4]
 8004cfa: 685b         	ldr	r3, [r3, #0x4]
 8004cfc: 681b         	ldr	r3, [r3]
 8004cfe: 613b         	str	r3, [r7, #0x10]
; 	const struct device *uart_dev = LBU_UART_DEV(ctx);
 8004d00: 4b06         	ldr	r3, [pc, #0x18]         @ 0x8004d1c <log_backend_uart_init+0x2c>
 8004d02: 60fb         	str	r3, [r7, #0xc]
; 	struct lbu_data *data = ctx->data;
 8004d04: 693b         	ldr	r3, [r7, #0x10]
 8004d06: 685b         	ldr	r3, [r3, #0x4]
 8004d08: 617b         	str	r3, [r7, #0x14]
; 	log_output_ctx_set(ctx->output, (void *)ctx);
 8004d0a: 693b         	ldr	r3, [r7, #0x10]
 8004d0c: 681b         	ldr	r3, [r3]
 8004d0e: 6939         	ldr	r1, [r7, #0x10]
 8004d10: 4618         	mov	r0, r3
 8004d12: f010 fe05    	bl	0x8015920 <log_output_ctx_set> @ imm = #0x10c0a
; }
 8004d16: 3718         	adds	r7, #0x18
 8004d18: 46bd         	mov	sp, r7
 8004d1a: bd80         	pop	{r7, pc}

08004d1c <$d>:
 8004d1c: 40 de 01 08  	.word	0x0801de40

08004d20 <panic>:
; {
 8004d20: b580         	push	{r7, lr}
 8004d22: b086         	sub	sp, #0x18
 8004d24: af00         	add	r7, sp, #0x0
 8004d26: 6078         	str	r0, [r7, #0x4]
; 	const struct lbu_cb_ctx *ctx = backend->cb->ctx;
 8004d28: 687b         	ldr	r3, [r7, #0x4]
 8004d2a: 685b         	ldr	r3, [r3, #0x4]
 8004d2c: 681b         	ldr	r3, [r3]
 8004d2e: 617b         	str	r3, [r7, #0x14]
; 	struct lbu_data *data = ctx->data;
 8004d30: 697b         	ldr	r3, [r7, #0x14]
 8004d32: 685b         	ldr	r3, [r3, #0x4]
 8004d34: 613b         	str	r3, [r7, #0x10]
; 	const struct device *uart_dev = LBU_UART_DEV(ctx);
 8004d36: 4b07         	ldr	r3, [pc, #0x1c]         @ 0x8004d54 <panic+0x34>
 8004d38: 60fb         	str	r3, [r7, #0xc]
; 	data->in_panic = true;
 8004d3a: 693b         	ldr	r3, [r7, #0x10]
 8004d3c: 2201         	movs	r2, #0x1
 8004d3e: 751a         	strb	r2, [r3, #0x14]
; 	log_backend_std_panic(ctx->output);
 8004d40: 697b         	ldr	r3, [r7, #0x14]
 8004d42: 681b         	ldr	r3, [r3]
 8004d44: 4618         	mov	r0, r3
 8004d46: f010 fe0c    	bl	0x8015962 <log_backend_std_panic> @ imm = #0x10c18
; }
 8004d4a: bf00         	nop
 8004d4c: 3718         	adds	r7, #0x18
 8004d4e: 46bd         	mov	sp, r7
 8004d50: bd80         	pop	{r7, pc}
 8004d52: bf00         	nop

08004d54 <$d>:
 8004d54: 40 de 01 08  	.word	0x0801de40

08004d58 <esf_dump>:
; {
 8004d58: b580         	push	{r7, lr}
 8004d5a: b090         	sub	sp, #0x40
 8004d5c: af06         	add	r7, sp, #0x18
 8004d5e: 6078         	str	r0, [r7, #0x4]
; 	LOG_ERR("r0/a1:  0x%08x  r1/a2:  0x%08x  r2/a3:  0x%08x",
 8004d60: 2303         	movs	r3, #0x3
 8004d62: 2b00         	cmp	r3, #0x0
 8004d64: d020         	beq	0x8004da8 <esf_dump+0x50> @ imm = #0x40
 8004d66: 2301         	movs	r3, #0x1
 8004d68: 73bb         	strb	r3, [r7, #0xe]
 8004d6a: 7bbb         	ldrb	r3, [r7, #0xe]
 8004d6c: f083 0301    	eor	r3, r3, #0x1
 8004d70: b2db         	uxtb	r3, r3
 8004d72: 2b00         	cmp	r3, #0x0
 8004d74: d118         	bne	0x8004da8 <esf_dump+0x50> @ imm = #0x30
 8004d76: 4b3e         	ldr	r3, [pc, #0xf8]         @ 0x8004e70 <esf_dump+0x118>
 8004d78: 6818         	ldr	r0, [r3]
 8004d7a: 687b         	ldr	r3, [r7, #0x4]
 8004d7c: 681b         	ldr	r3, [r3]
 8004d7e: 687a         	ldr	r2, [r7, #0x4]
 8004d80: 6852         	ldr	r2, [r2, #0x4]
 8004d82: 6879         	ldr	r1, [r7, #0x4]
 8004d84: 6889         	ldr	r1, [r1, #0x8]
 8004d86: 9105         	str	r1, [sp, #0x14]
 8004d88: 9204         	str	r2, [sp, #0x10]
 8004d8a: 9303         	str	r3, [sp, #0xc]
 8004d8c: 4b39         	ldr	r3, [pc, #0xe4]         @ 0x8004e74 <esf_dump+0x11c>
 8004d8e: 9302         	str	r3, [sp, #0x8]
 8004d90: 2300         	movs	r3, #0x0
 8004d92: 9301         	str	r3, [sp, #0x4]
 8004d94: 2300         	movs	r3, #0x0
 8004d96: 9300         	str	r3, [sp]
 8004d98: 2300         	movs	r3, #0x0
 8004d9a: 2201         	movs	r2, #0x1
 8004d9c: 4601         	mov	r1, r0
 8004d9e: 2000         	movs	r0, #0x0
 8004da0: f010 fe56    	bl	0x8015a50 <z_log_msg_runtime_create> @ imm = #0x10cac
 8004da4: 2300         	movs	r3, #0x0
 8004da6: 613b         	str	r3, [r7, #0x10]
; 	LOG_ERR("r3/a4:  0x%08x r12/ip:  0x%08x r14/lr:  0x%08x",
 8004da8: 2303         	movs	r3, #0x3
 8004daa: 2b00         	cmp	r3, #0x0
 8004dac: d020         	beq	0x8004df0 <esf_dump+0x98> @ imm = #0x40
 8004dae: 2301         	movs	r3, #0x1
 8004db0: 73fb         	strb	r3, [r7, #0xf]
 8004db2: 7bfb         	ldrb	r3, [r7, #0xf]
 8004db4: f083 0301    	eor	r3, r3, #0x1
 8004db8: b2db         	uxtb	r3, r3
 8004dba: 2b00         	cmp	r3, #0x0
 8004dbc: d118         	bne	0x8004df0 <esf_dump+0x98> @ imm = #0x30
 8004dbe: 4b2c         	ldr	r3, [pc, #0xb0]         @ 0x8004e70 <esf_dump+0x118>
 8004dc0: 6818         	ldr	r0, [r3]
 8004dc2: 687b         	ldr	r3, [r7, #0x4]
 8004dc4: 68db         	ldr	r3, [r3, #0xc]
 8004dc6: 687a         	ldr	r2, [r7, #0x4]
 8004dc8: 6912         	ldr	r2, [r2, #0x10]
 8004dca: 6879         	ldr	r1, [r7, #0x4]
 8004dcc: 6949         	ldr	r1, [r1, #0x14]
 8004dce: 9105         	str	r1, [sp, #0x14]
 8004dd0: 9204         	str	r2, [sp, #0x10]
 8004dd2: 9303         	str	r3, [sp, #0xc]
 8004dd4: 4b28         	ldr	r3, [pc, #0xa0]         @ 0x8004e78 <esf_dump+0x120>
 8004dd6: 9302         	str	r3, [sp, #0x8]
 8004dd8: 2300         	movs	r3, #0x0
 8004dda: 9301         	str	r3, [sp, #0x4]
 8004ddc: 2300         	movs	r3, #0x0
 8004dde: 9300         	str	r3, [sp]
 8004de0: 2300         	movs	r3, #0x0
 8004de2: 2201         	movs	r2, #0x1
 8004de4: 4601         	mov	r1, r0
 8004de6: 2000         	movs	r0, #0x0
 8004de8: f010 fe32    	bl	0x8015a50 <z_log_msg_runtime_create> @ imm = #0x10c64
 8004dec: 2300         	movs	r3, #0x0
 8004dee: 623b         	str	r3, [r7, #0x20]
; 	LOG_ERR(" xpsr:  0x%08x", esf->basic.xpsr);
 8004df0: 2303         	movs	r3, #0x3
 8004df2: 2b00         	cmp	r3, #0x0
 8004df4: d019         	beq	0x8004e2a <esf_dump+0xd2> @ imm = #0x32
 8004df6: 2301         	movs	r3, #0x1
 8004df8: 77fb         	strb	r3, [r7, #0x1f]
 8004dfa: 7ffb         	ldrb	r3, [r7, #0x1f]
 8004dfc: f083 0301    	eor	r3, r3, #0x1
 8004e00: b2db         	uxtb	r3, r3
 8004e02: 2b00         	cmp	r3, #0x0
 8004e04: d111         	bne	0x8004e2a <esf_dump+0xd2> @ imm = #0x22
 8004e06: 4b1a         	ldr	r3, [pc, #0x68]         @ 0x8004e70 <esf_dump+0x118>
 8004e08: 6819         	ldr	r1, [r3]
 8004e0a: 687b         	ldr	r3, [r7, #0x4]
 8004e0c: 69db         	ldr	r3, [r3, #0x1c]
 8004e0e: 9303         	str	r3, [sp, #0xc]
 8004e10: 4b1a         	ldr	r3, [pc, #0x68]         @ 0x8004e7c <esf_dump+0x124>
 8004e12: 9302         	str	r3, [sp, #0x8]
 8004e14: 2300         	movs	r3, #0x0
 8004e16: 9301         	str	r3, [sp, #0x4]
 8004e18: 2300         	movs	r3, #0x0
 8004e1a: 9300         	str	r3, [sp]
 8004e1c: 2300         	movs	r3, #0x0
 8004e1e: 2201         	movs	r2, #0x1
 8004e20: 2000         	movs	r0, #0x0
 8004e22: f010 fe15    	bl	0x8015a50 <z_log_msg_runtime_create> @ imm = #0x10c2a
 8004e26: 2300         	movs	r3, #0x0
 8004e28: 61bb         	str	r3, [r7, #0x18]
; 	LOG_ERR("Faulting instruction address (r15/pc): 0x%08x",
 8004e2a: 2303         	movs	r3, #0x3
 8004e2c: 2b00         	cmp	r3, #0x0
 8004e2e: d01a         	beq	0x8004e66 <esf_dump+0x10e> @ imm = #0x34
 8004e30: 2301         	movs	r3, #0x1
 8004e32: 75fb         	strb	r3, [r7, #0x17]
 8004e34: 7dfb         	ldrb	r3, [r7, #0x17]
 8004e36: f083 0301    	eor	r3, r3, #0x1
 8004e3a: b2db         	uxtb	r3, r3
 8004e3c: 2b00         	cmp	r3, #0x0
 8004e3e: d112         	bne	0x8004e66 <esf_dump+0x10e> @ imm = #0x24
 8004e40: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x8004e70 <esf_dump+0x118>
 8004e42: 6819         	ldr	r1, [r3]
 8004e44: 687b         	ldr	r3, [r7, #0x4]
 8004e46: 699b         	ldr	r3, [r3, #0x18]
 8004e48: 9303         	str	r3, [sp, #0xc]
 8004e4a: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x8004e80 <esf_dump+0x128>
 8004e4c: 9302         	str	r3, [sp, #0x8]
 8004e4e: 2300         	movs	r3, #0x0
 8004e50: 9301         	str	r3, [sp, #0x4]
 8004e52: 2300         	movs	r3, #0x0
 8004e54: 9300         	str	r3, [sp]
 8004e56: 2300         	movs	r3, #0x0
 8004e58: 2201         	movs	r2, #0x1
 8004e5a: 2000         	movs	r0, #0x0
 8004e5c: f010 fdf8    	bl	0x8015a50 <z_log_msg_runtime_create> @ imm = #0x10bf0
 8004e60: 2300         	movs	r3, #0x0
 8004e62: 627b         	str	r3, [r7, #0x24]
; }
 8004e64: bf00         	nop
 8004e66: bf00         	nop
 8004e68: 3728         	adds	r7, #0x28
 8004e6a: 46bd         	mov	sp, r7
 8004e6c: bd80         	pop	{r7, pc}
 8004e6e: bf00         	nop

08004e70 <$d>:
 8004e70: c0 04 00 20  	.word	0x200004c0
 8004e74: fc e5 01 08  	.word	0x0801e5fc
 8004e78: 2c e6 01 08  	.word	0x0801e62c
 8004e7c: 5c e6 01 08  	.word	0x0801e65c
 8004e80: 6c e6 01 08  	.word	0x0801e66c

08004e84 <z_arm_fatal_error>:
; {
 8004e84: b580         	push	{r7, lr}
 8004e86: b08a         	sub	sp, #0x28
 8004e88: af04         	add	r7, sp, #0x10
 8004e8a: 6078         	str	r0, [r7, #0x4]
 8004e8c: 6039         	str	r1, [r7]
; 	if (esf != NULL) {
 8004e8e: 683b         	ldr	r3, [r7]
 8004e90: 2b00         	cmp	r3, #0x0
 8004e92: d002         	beq	0x8004e9a <z_arm_fatal_error+0x16> @ imm = #0x4
; 		esf_dump(esf);
 8004e94: 6838         	ldr	r0, [r7]
 8004e96: f7ff ff5f    	bl	0x8004d58 <esf_dump>    @ imm = #-0x142
; 	if (reason == K_ERR_SPURIOUS_IRQ) {
 8004e9a: 687b         	ldr	r3, [r7, #0x4]
 8004e9c: 2b01         	cmp	r3, #0x1
 8004e9e: d121         	bne	0x8004ee4 <z_arm_fatal_error+0x60> @ imm = #0x42
;   __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 8004ea0: f3ef 8305    	mrs	r3, ipsr
 8004ea4: 60bb         	str	r3, [r7, #0x8]
;   return(result);
 8004ea6: 68bb         	ldr	r3, [r7, #0x8]
; 		uint32_t irqn = __get_IPSR() - 16;
 8004ea8: 3b10         	subs	r3, #0x10
 8004eaa: 617b         	str	r3, [r7, #0x14]
; 		LOG_ERR("Unhandled IRQn: %d", irqn);
 8004eac: 2303         	movs	r3, #0x3
 8004eae: 2b00         	cmp	r3, #0x0
 8004eb0: d018         	beq	0x8004ee4 <z_arm_fatal_error+0x60> @ imm = #0x30
 8004eb2: 2301         	movs	r3, #0x1
 8004eb4: 74fb         	strb	r3, [r7, #0x13]
 8004eb6: 7cfb         	ldrb	r3, [r7, #0x13]
 8004eb8: f083 0301    	eor	r3, r3, #0x1
 8004ebc: b2db         	uxtb	r3, r3
 8004ebe: 2b00         	cmp	r3, #0x0
 8004ec0: d110         	bne	0x8004ee4 <z_arm_fatal_error+0x60> @ imm = #0x20
 8004ec2: 4b0c         	ldr	r3, [pc, #0x30]         @ 0x8004ef4 <z_arm_fatal_error+0x70>
 8004ec4: 6819         	ldr	r1, [r3]
 8004ec6: 697b         	ldr	r3, [r7, #0x14]
 8004ec8: 9303         	str	r3, [sp, #0xc]
 8004eca: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x8004ef8 <z_arm_fatal_error+0x74>
 8004ecc: 9302         	str	r3, [sp, #0x8]
 8004ece: 2300         	movs	r3, #0x0
 8004ed0: 9301         	str	r3, [sp, #0x4]
 8004ed2: 2300         	movs	r3, #0x0
 8004ed4: 9300         	str	r3, [sp]
 8004ed6: 2300         	movs	r3, #0x0
 8004ed8: 2201         	movs	r2, #0x1
 8004eda: 2000         	movs	r0, #0x0
 8004edc: f010 fdb8    	bl	0x8015a50 <z_log_msg_runtime_create> @ imm = #0x10b70
 8004ee0: 2300         	movs	r3, #0x0
 8004ee2: 60fb         	str	r3, [r7, #0xc]
; 	z_fatal_error(reason, esf);
 8004ee4: 6839         	ldr	r1, [r7]
 8004ee6: 6878         	ldr	r0, [r7, #0x4]
 8004ee8: f008 fbc6    	bl	0x800d678 <z_fatal_error> @ imm = #0x878c
; }
 8004eec: bf00         	nop
 8004eee: 3718         	adds	r7, #0x18
 8004ef0: 46bd         	mov	sp, r7
 8004ef2: bd80         	pop	{r7, pc}

08004ef4 <$d>:
 8004ef4: c0 04 00 20  	.word	0x200004c0
 8004ef8: 9c e6 01 08  	.word	0x0801e69c

08004efc <z_arm_nmi>:
; {
 8004efc: b580         	push	{r7, lr}
 8004efe: af00         	add	r7, sp, #0x0
; 	handler();
 8004f00: 4b03         	ldr	r3, [pc, #0xc]          @ 0x8004f10 <z_arm_nmi+0x14>
 8004f02: 681b         	ldr	r3, [r3]
 8004f04: 4798         	blx	r3
; 	z_arm_int_exit();
 8004f06: f000 f835    	bl	0x8004f74 <z_arm_int_exit> @ imm = #0x6a
; }
 8004f0a: bf00         	nop
 8004f0c: bd80         	pop	{r7, pc}
 8004f0e: bf00         	nop

08004f10 <$d>:
 8004f10: c4 04 00 20  	.word	0x200004c4

08004f14 <z_SysNmiOnReset>:
;     wfi
 8004f14: bf30         	wfi
;     b z_SysNmiOnReset
 8004f16: f7ff bffd    	b.w	0x8004f14 <z_SysNmiOnReset> @ imm = #-0x6
 8004f1a: bf00         	nop

08004f1c <z_tls_data_size>:
; {
 8004f1c: b480         	push	{r7}
 8004f1e: af00         	add	r7, sp, #0x0
; 	return (size_t)(uintptr_t)__tdata_size +
 8004f20: 4a03         	ldr	r2, [pc, #0xc]          @ 0x8004f30 <z_tls_data_size+0x14>
; 	       (size_t)(uintptr_t)__tbss_size;
 8004f22: 4b04         	ldr	r3, [pc, #0x10]         @ 0x8004f34 <z_tls_data_size+0x18>
; 	return (size_t)(uintptr_t)__tdata_size +
 8004f24: 4413         	add	r3, r2
; }
 8004f26: 4618         	mov	r0, r3
 8004f28: 46bd         	mov	sp, r7
 8004f2a: bc80         	pop	{r7}
 8004f2c: 4770         	bx	lr
 8004f2e: bf00         	nop

08004f30 <$d>:
 8004f30: 00 00 00 00  	.word	0x00000000
 8004f34: 08 00 00 00  	.word	0x00000008

08004f38 <z_tls_copy>:
; {
 8004f38: b580         	push	{r7, lr}
 8004f3a: b082         	sub	sp, #0x8
 8004f3c: af00         	add	r7, sp, #0x0
 8004f3e: 6078         	str	r0, [r7, #0x4]
; 	memcpy(dest, __tdata_start, (size_t)(uintptr_t)__tdata_size);
 8004f40: 4b09         	ldr	r3, [pc, #0x24]         @ 0x8004f68 <z_tls_copy+0x30>
 8004f42: 461a         	mov	r2, r3
 8004f44: 4909         	ldr	r1, [pc, #0x24]         @ 0x8004f6c <z_tls_copy+0x34>
 8004f46: 6878         	ldr	r0, [r7, #0x4]
 8004f48: f018 fc42    	bl	0x801d7d0 <memcpy>      @ imm = #0x18884
; 	dest += (size_t)(uintptr_t)__tdata_size;
 8004f4c: 4a06         	ldr	r2, [pc, #0x18]         @ 0x8004f68 <z_tls_copy+0x30>
 8004f4e: 687b         	ldr	r3, [r7, #0x4]
 8004f50: 4413         	add	r3, r2
 8004f52: 607b         	str	r3, [r7, #0x4]
; 	memset(dest, 0, (size_t)(uintptr_t)__tbss_size);
 8004f54: 4b06         	ldr	r3, [pc, #0x18]         @ 0x8004f70 <z_tls_copy+0x38>
 8004f56: 461a         	mov	r2, r3
 8004f58: 2100         	movs	r1, #0x0
 8004f5a: 6878         	ldr	r0, [r7, #0x4]
 8004f5c: f018 fc46    	bl	0x801d7ec <memset>      @ imm = #0x1888c
; }
 8004f60: bf00         	nop
 8004f62: 3708         	adds	r7, #0x8
 8004f64: 46bd         	mov	sp, r7
 8004f66: bd80         	pop	{r7, pc}

08004f68 <$d>:
 8004f68: 00 00 00 00  	.word	0x00000000
 8004f6c: bc e2 01 08  	.word	0x0801e2bc
 8004f70: 08 00 00 00  	.word	0x00000008

08004f74 <z_arm_int_exit>:
; {
 8004f74: b480         	push	{r7}
 8004f76: af00         	add	r7, sp, #0x0
; 	if (_kernel.cpus->current->base.prio >= 0) {
 8004f78: 4b0a         	ldr	r3, [pc, #0x28]         @ 0x8004fa4 <z_arm_int_exit+0x30>
 8004f7a: 689b         	ldr	r3, [r3, #0x8]
 8004f7c: f993 300e    	ldrsb.w	r3, [r3, #0xe]
 8004f80: 2b00         	cmp	r3, #0x0
 8004f82: db0b         	blt	0x8004f9c <z_arm_int_exit+0x28> @ imm = #0x16
; 		if (_kernel.ready_q.cache != _kernel.cpus->current) {
 8004f84: 4b07         	ldr	r3, [pc, #0x1c]         @ 0x8004fa4 <z_arm_int_exit+0x30>
 8004f86: 69da         	ldr	r2, [r3, #0x1c]
 8004f88: 4b06         	ldr	r3, [pc, #0x18]         @ 0x8004fa4 <z_arm_int_exit+0x30>
 8004f8a: 689b         	ldr	r3, [r3, #0x8]
 8004f8c: 429a         	cmp	r2, r3
 8004f8e: d005         	beq	0x8004f9c <z_arm_int_exit+0x28> @ imm = #0xa
; 			SCB->ICSR |= SCB_ICSR_PENDSVSET_Msk;
 8004f90: 4b05         	ldr	r3, [pc, #0x14]         @ 0x8004fa8 <z_arm_int_exit+0x34>
 8004f92: 685b         	ldr	r3, [r3, #0x4]
 8004f94: 4a04         	ldr	r2, [pc, #0x10]         @ 0x8004fa8 <z_arm_int_exit+0x34>
 8004f96: f043 5380    	orr	r3, r3, #0x10000000
 8004f9a: 6053         	str	r3, [r2, #0x4]
; }
 8004f9c: bf00         	nop
 8004f9e: 46bd         	mov	sp, r7
 8004fa0: bc80         	pop	{r7}
 8004fa2: 4770         	bx	lr

08004fa4 <$d>:
 8004fa4: f0 16 00 20  	.word	0x200016f0
 8004fa8: 00 ed 00 e0  	.word	0xe000ed00

08004fac <mem_manage_fault>:
; {
 8004fac: b580         	push	{r7, lr}
 8004fae: b09a         	sub	sp, #0x68
 8004fb0: af04         	add	r7, sp, #0x10
 8004fb2: 60f8         	str	r0, [r7, #0xc]
 8004fb4: 60b9         	str	r1, [r7, #0x8]
 8004fb6: 607a         	str	r2, [r7, #0x4]
; 	uint32_t reason = K_ERR_ARM_MEM_GENERIC;
 8004fb8: 2310         	movs	r3, #0x10
 8004fba: 657b         	str	r3, [r7, #0x54]
; 	uint32_t mmfar = -EINVAL;
 8004fbc: f06f 0315    	mvn	r3, #0x15
 8004fc0: 653b         	str	r3, [r7, #0x50]
; 	PR_FAULT_INFO("***** MPU FAULT *****");
 8004fc2: 2303         	movs	r3, #0x3
 8004fc4: 2b00         	cmp	r3, #0x0
 8004fc6: d018         	beq	0x8004ffa <mem_manage_fault+0x4e> @ imm = #0x30
 8004fc8: 2301         	movs	r3, #0x1
 8004fca: f887 304f    	strb.w	r3, [r7, #0x4f]
 8004fce: f897 304f    	ldrb.w	r3, [r7, #0x4f]
 8004fd2: f083 0301    	eor	r3, r3, #0x1
 8004fd6: b2db         	uxtb	r3, r3
 8004fd8: 2b00         	cmp	r3, #0x0
 8004fda: d10e         	bne	0x8004ffa <mem_manage_fault+0x4e> @ imm = #0x1c
 8004fdc: 4b8c         	ldr	r3, [pc, #0x230]        @ 0x8005210 <mem_manage_fault+0x264>
 8004fde: 6819         	ldr	r1, [r3]
 8004fe0: 4b8c         	ldr	r3, [pc, #0x230]        @ 0x8005214 <mem_manage_fault+0x268>
 8004fe2: 9302         	str	r3, [sp, #0x8]
 8004fe4: 2300         	movs	r3, #0x0
 8004fe6: 9301         	str	r3, [sp, #0x4]
 8004fe8: 2300         	movs	r3, #0x0
 8004fea: 9300         	str	r3, [sp]
 8004fec: 2300         	movs	r3, #0x0
 8004fee: 2201         	movs	r2, #0x1
 8004ff0: 2000         	movs	r0, #0x0
 8004ff2: f010 fd7f    	bl	0x8015af4 <z_log_msg_runtime_create> @ imm = #0x10afe
 8004ff6: 2300         	movs	r3, #0x0
 8004ff8: 64bb         	str	r3, [r7, #0x48]
; 	if ((SCB->CFSR & SCB_CFSR_MSTKERR_Msk) != 0) {
 8004ffa: 4b87         	ldr	r3, [pc, #0x21c]        @ 0x8005218 <mem_manage_fault+0x26c>
 8004ffc: 6a9b         	ldr	r3, [r3, #0x28]
 8004ffe: f003 0310    	and	r3, r3, #0x10
 8005002: 2b00         	cmp	r3, #0x0
 8005004: d01d         	beq	0x8005042 <mem_manage_fault+0x96> @ imm = #0x3a
; 		reason = K_ERR_ARM_MEM_STACKING;
 8005006: 2311         	movs	r3, #0x11
 8005008: 657b         	str	r3, [r7, #0x54]
; 		PR_FAULT_INFO("  Stacking error (context area might be"
 800500a: 2303         	movs	r3, #0x3
 800500c: 2b00         	cmp	r3, #0x0
 800500e: d018         	beq	0x8005042 <mem_manage_fault+0x96> @ imm = #0x30
 8005010: 2301         	movs	r3, #0x1
 8005012: f887 3047    	strb.w	r3, [r7, #0x47]
 8005016: f897 3047    	ldrb.w	r3, [r7, #0x47]
 800501a: f083 0301    	eor	r3, r3, #0x1
 800501e: b2db         	uxtb	r3, r3
 8005020: 2b00         	cmp	r3, #0x0
 8005022: d10e         	bne	0x8005042 <mem_manage_fault+0x96> @ imm = #0x1c
 8005024: 4b7a         	ldr	r3, [pc, #0x1e8]        @ 0x8005210 <mem_manage_fault+0x264>
 8005026: 6819         	ldr	r1, [r3]
 8005028: 4b7c         	ldr	r3, [pc, #0x1f0]        @ 0x800521c <mem_manage_fault+0x270>
 800502a: 9302         	str	r3, [sp, #0x8]
 800502c: 2300         	movs	r3, #0x0
 800502e: 9301         	str	r3, [sp, #0x4]
 8005030: 2300         	movs	r3, #0x0
 8005032: 9300         	str	r3, [sp]
 8005034: 2300         	movs	r3, #0x0
 8005036: 2201         	movs	r2, #0x1
 8005038: 2000         	movs	r0, #0x0
 800503a: f010 fd5b    	bl	0x8015af4 <z_log_msg_runtime_create> @ imm = #0x10ab6
 800503e: 2300         	movs	r3, #0x0
 8005040: 643b         	str	r3, [r7, #0x40]
; 	if ((SCB->CFSR & SCB_CFSR_MUNSTKERR_Msk) != 0) {
 8005042: 4b75         	ldr	r3, [pc, #0x1d4]        @ 0x8005218 <mem_manage_fault+0x26c>
 8005044: 6a9b         	ldr	r3, [r3, #0x28]
 8005046: f003 0308    	and	r3, r3, #0x8
 800504a: 2b00         	cmp	r3, #0x0
 800504c: d01d         	beq	0x800508a <mem_manage_fault+0xde> @ imm = #0x3a
; 		reason = K_ERR_ARM_MEM_UNSTACKING;
 800504e: 2312         	movs	r3, #0x12
 8005050: 657b         	str	r3, [r7, #0x54]
; 		PR_FAULT_INFO("  Unstacking error");
 8005052: 2303         	movs	r3, #0x3
 8005054: 2b00         	cmp	r3, #0x0
 8005056: d018         	beq	0x800508a <mem_manage_fault+0xde> @ imm = #0x30
 8005058: 2301         	movs	r3, #0x1
 800505a: f887 303f    	strb.w	r3, [r7, #0x3f]
 800505e: f897 303f    	ldrb.w	r3, [r7, #0x3f]
 8005062: f083 0301    	eor	r3, r3, #0x1
 8005066: b2db         	uxtb	r3, r3
 8005068: 2b00         	cmp	r3, #0x0
 800506a: d10e         	bne	0x800508a <mem_manage_fault+0xde> @ imm = #0x1c
 800506c: 4b68         	ldr	r3, [pc, #0x1a0]        @ 0x8005210 <mem_manage_fault+0x264>
 800506e: 6819         	ldr	r1, [r3]
 8005070: 4b6b         	ldr	r3, [pc, #0x1ac]        @ 0x8005220 <mem_manage_fault+0x274>
 8005072: 9302         	str	r3, [sp, #0x8]
 8005074: 2300         	movs	r3, #0x0
 8005076: 9301         	str	r3, [sp, #0x4]
 8005078: 2300         	movs	r3, #0x0
 800507a: 9300         	str	r3, [sp]
 800507c: 2300         	movs	r3, #0x0
 800507e: 2201         	movs	r2, #0x1
 8005080: 2000         	movs	r0, #0x0
 8005082: f010 fd37    	bl	0x8015af4 <z_log_msg_runtime_create> @ imm = #0x10a6e
 8005086: 2300         	movs	r3, #0x0
 8005088: 63bb         	str	r3, [r7, #0x38]
; 	if ((SCB->CFSR & SCB_CFSR_DACCVIOL_Msk) != 0) {
 800508a: 4b63         	ldr	r3, [pc, #0x18c]        @ 0x8005218 <mem_manage_fault+0x26c>
 800508c: 6a9b         	ldr	r3, [r3, #0x28]
 800508e: f003 0302    	and	r3, r3, #0x2
 8005092: 2b00         	cmp	r3, #0x0
 8005094: d04f         	beq	0x8005136 <mem_manage_fault+0x18a> @ imm = #0x9e
; 		reason = K_ERR_ARM_MEM_DATA_ACCESS;
 8005096: 2313         	movs	r3, #0x13
 8005098: 657b         	str	r3, [r7, #0x54]
; 		PR_FAULT_INFO("  Data Access Violation");
 800509a: 2303         	movs	r3, #0x3
 800509c: 2b00         	cmp	r3, #0x0
 800509e: d018         	beq	0x80050d2 <mem_manage_fault+0x126> @ imm = #0x30
 80050a0: 2301         	movs	r3, #0x1
 80050a2: f887 3037    	strb.w	r3, [r7, #0x37]
 80050a6: f897 3037    	ldrb.w	r3, [r7, #0x37]
 80050aa: f083 0301    	eor	r3, r3, #0x1
 80050ae: b2db         	uxtb	r3, r3
 80050b0: 2b00         	cmp	r3, #0x0
 80050b2: d10e         	bne	0x80050d2 <mem_manage_fault+0x126> @ imm = #0x1c
 80050b4: 4b56         	ldr	r3, [pc, #0x158]        @ 0x8005210 <mem_manage_fault+0x264>
 80050b6: 6819         	ldr	r1, [r3]
 80050b8: 4b5a         	ldr	r3, [pc, #0x168]        @ 0x8005224 <mem_manage_fault+0x278>
 80050ba: 9302         	str	r3, [sp, #0x8]
 80050bc: 2300         	movs	r3, #0x0
 80050be: 9301         	str	r3, [sp, #0x4]
 80050c0: 2300         	movs	r3, #0x0
 80050c2: 9300         	str	r3, [sp]
 80050c4: 2300         	movs	r3, #0x0
 80050c6: 2201         	movs	r2, #0x1
 80050c8: 2000         	movs	r0, #0x0
 80050ca: f010 fd13    	bl	0x8015af4 <z_log_msg_runtime_create> @ imm = #0x10a26
 80050ce: 2300         	movs	r3, #0x0
 80050d0: 633b         	str	r3, [r7, #0x30]
; 		uint32_t temp = SCB->MMFAR;
 80050d2: 4b51         	ldr	r3, [pc, #0x144]        @ 0x8005218 <mem_manage_fault+0x26c>
 80050d4: 6b5b         	ldr	r3, [r3, #0x34]
 80050d6: 62fb         	str	r3, [r7, #0x2c]
; 		if ((SCB->CFSR & SCB_CFSR_MMARVALID_Msk) != 0) {
 80050d8: 4b4f         	ldr	r3, [pc, #0x13c]        @ 0x8005218 <mem_manage_fault+0x26c>
 80050da: 6a9b         	ldr	r3, [r3, #0x28]
 80050dc: f003 0380    	and	r3, r3, #0x80
 80050e0: 2b00         	cmp	r3, #0x0
 80050e2: d028         	beq	0x8005136 <mem_manage_fault+0x18a> @ imm = #0x50
; 			mmfar = temp;
 80050e4: 6afb         	ldr	r3, [r7, #0x2c]
 80050e6: 653b         	str	r3, [r7, #0x50]
; 			PR_EXC("  MMFAR Address: 0x%x", mmfar);
 80050e8: 2303         	movs	r3, #0x3
 80050ea: 2b00         	cmp	r3, #0x0
 80050ec: d01a         	beq	0x8005124 <mem_manage_fault+0x178> @ imm = #0x34
 80050ee: 2301         	movs	r3, #0x1
 80050f0: f887 302b    	strb.w	r3, [r7, #0x2b]
 80050f4: f897 302b    	ldrb.w	r3, [r7, #0x2b]
 80050f8: f083 0301    	eor	r3, r3, #0x1
 80050fc: b2db         	uxtb	r3, r3
 80050fe: 2b00         	cmp	r3, #0x0
 8005100: d110         	bne	0x8005124 <mem_manage_fault+0x178> @ imm = #0x20
 8005102: 4b43         	ldr	r3, [pc, #0x10c]        @ 0x8005210 <mem_manage_fault+0x264>
 8005104: 6819         	ldr	r1, [r3]
 8005106: 6d3b         	ldr	r3, [r7, #0x50]
 8005108: 9303         	str	r3, [sp, #0xc]
 800510a: 4b47         	ldr	r3, [pc, #0x11c]        @ 0x8005228 <mem_manage_fault+0x27c>
 800510c: 9302         	str	r3, [sp, #0x8]
 800510e: 2300         	movs	r3, #0x0
 8005110: 9301         	str	r3, [sp, #0x4]
 8005112: 2300         	movs	r3, #0x0
 8005114: 9300         	str	r3, [sp]
 8005116: 2300         	movs	r3, #0x0
 8005118: 2201         	movs	r2, #0x1
 800511a: 2000         	movs	r0, #0x0
 800511c: f010 fcea    	bl	0x8015af4 <z_log_msg_runtime_create> @ imm = #0x109d4
 8005120: 2300         	movs	r3, #0x0
 8005122: 627b         	str	r3, [r7, #0x24]
; 			if (from_hard_fault != 0) {
 8005124: 68bb         	ldr	r3, [r7, #0x8]
 8005126: 2b00         	cmp	r3, #0x0
 8005128: d005         	beq	0x8005136 <mem_manage_fault+0x18a> @ imm = #0xa
; 				SCB->CFSR &= ~SCB_CFSR_MMARVALID_Msk;
 800512a: 4b3b         	ldr	r3, [pc, #0xec]         @ 0x8005218 <mem_manage_fault+0x26c>
 800512c: 6a9b         	ldr	r3, [r3, #0x28]
 800512e: 4a3a         	ldr	r2, [pc, #0xe8]         @ 0x8005218 <mem_manage_fault+0x26c>
 8005130: f023 0380    	bic	r3, r3, #0x80
 8005134: 6293         	str	r3, [r2, #0x28]
; 	if ((SCB->CFSR & SCB_CFSR_IACCVIOL_Msk) != 0) {
 8005136: 4b38         	ldr	r3, [pc, #0xe0]         @ 0x8005218 <mem_manage_fault+0x26c>
 8005138: 6a9b         	ldr	r3, [r3, #0x28]
 800513a: f003 0301    	and	r3, r3, #0x1
 800513e: 2b00         	cmp	r3, #0x0
 8005140: d01d         	beq	0x800517e <mem_manage_fault+0x1d2> @ imm = #0x3a
; 		reason = K_ERR_ARM_MEM_INSTRUCTION_ACCESS;
 8005142: 2314         	movs	r3, #0x14
 8005144: 657b         	str	r3, [r7, #0x54]
; 		PR_FAULT_INFO("  Instruction Access Violation");
 8005146: 2303         	movs	r3, #0x3
 8005148: 2b00         	cmp	r3, #0x0
 800514a: d018         	beq	0x800517e <mem_manage_fault+0x1d2> @ imm = #0x30
 800514c: 2301         	movs	r3, #0x1
 800514e: f887 3023    	strb.w	r3, [r7, #0x23]
 8005152: f897 3023    	ldrb.w	r3, [r7, #0x23]
 8005156: f083 0301    	eor	r3, r3, #0x1
 800515a: b2db         	uxtb	r3, r3
 800515c: 2b00         	cmp	r3, #0x0
 800515e: d10e         	bne	0x800517e <mem_manage_fault+0x1d2> @ imm = #0x1c
 8005160: 4b2b         	ldr	r3, [pc, #0xac]         @ 0x8005210 <mem_manage_fault+0x264>
 8005162: 6819         	ldr	r1, [r3]
 8005164: 4b31         	ldr	r3, [pc, #0xc4]         @ 0x800522c <mem_manage_fault+0x280>
 8005166: 9302         	str	r3, [sp, #0x8]
 8005168: 2300         	movs	r3, #0x0
 800516a: 9301         	str	r3, [sp, #0x4]
 800516c: 2300         	movs	r3, #0x0
 800516e: 9300         	str	r3, [sp]
 8005170: 2300         	movs	r3, #0x0
 8005172: 2201         	movs	r2, #0x1
 8005174: 2000         	movs	r0, #0x0
 8005176: f010 fcbd    	bl	0x8015af4 <z_log_msg_runtime_create> @ imm = #0x1097a
 800517a: 2300         	movs	r3, #0x0
 800517c: 61fb         	str	r3, [r7, #0x1c]
; 	if ((SCB->CFSR & SCB_CFSR_MLSPERR_Msk) != 0) {
 800517e: 4b26         	ldr	r3, [pc, #0x98]         @ 0x8005218 <mem_manage_fault+0x26c>
 8005180: 6a9b         	ldr	r3, [r3, #0x28]
 8005182: f003 0320    	and	r3, r3, #0x20
 8005186: 2b00         	cmp	r3, #0x0
 8005188: d01b         	beq	0x80051c2 <mem_manage_fault+0x216> @ imm = #0x36
; 		reason = K_ERR_ARM_MEM_FP_LAZY_STATE_PRESERVATION;
 800518a: 2315         	movs	r3, #0x15
 800518c: 657b         	str	r3, [r7, #0x54]
; 		PR_FAULT_INFO(
 800518e: 2303         	movs	r3, #0x3
 8005190: 2b00         	cmp	r3, #0x0
 8005192: d016         	beq	0x80051c2 <mem_manage_fault+0x216> @ imm = #0x2c
 8005194: 2301         	movs	r3, #0x1
 8005196: 76fb         	strb	r3, [r7, #0x1b]
 8005198: 7efb         	ldrb	r3, [r7, #0x1b]
 800519a: f083 0301    	eor	r3, r3, #0x1
 800519e: b2db         	uxtb	r3, r3
 80051a0: 2b00         	cmp	r3, #0x0
 80051a2: d10e         	bne	0x80051c2 <mem_manage_fault+0x216> @ imm = #0x1c
 80051a4: 4b1a         	ldr	r3, [pc, #0x68]         @ 0x8005210 <mem_manage_fault+0x264>
 80051a6: 6819         	ldr	r1, [r3]
 80051a8: 4b21         	ldr	r3, [pc, #0x84]         @ 0x8005230 <mem_manage_fault+0x284>
 80051aa: 9302         	str	r3, [sp, #0x8]
 80051ac: 2300         	movs	r3, #0x0
 80051ae: 9301         	str	r3, [sp, #0x4]
 80051b0: 2300         	movs	r3, #0x0
 80051b2: 9300         	str	r3, [sp]
 80051b4: 2300         	movs	r3, #0x0
 80051b6: 2201         	movs	r2, #0x1
 80051b8: 2000         	movs	r0, #0x0
 80051ba: f010 fc9b    	bl	0x8015af4 <z_log_msg_runtime_create> @ imm = #0x10936
 80051be: 2300         	movs	r3, #0x0
 80051c0: 617b         	str	r3, [r7, #0x14]
; 	if ((SCB->CFSR & SCB_CFSR_MSTKERR_Msk) ||
 80051c2: 4b15         	ldr	r3, [pc, #0x54]         @ 0x8005218 <mem_manage_fault+0x26c>
 80051c4: 6a9b         	ldr	r3, [r3, #0x28]
 80051c6: f003 0310    	and	r3, r3, #0x10
 80051ca: 2b00         	cmp	r3, #0x0
 80051cc: d101         	bne	0x80051d2 <mem_manage_fault+0x226> @ imm = #0x2
; 		(SCB->CFSR & SCB_CFSR_DACCVIOL_Msk)) {
 80051ce: 4b12         	ldr	r3, [pc, #0x48]         @ 0x8005218 <mem_manage_fault+0x26c>
 80051d0: 6a9b         	ldr	r3, [r3, #0x28]
; 	if ((SCB->CFSR & SCB_CFSR_MLSPERR_Msk) != 0) {
 80051d2: 4b11         	ldr	r3, [pc, #0x44]         @ 0x8005218 <mem_manage_fault+0x26c>
 80051d4: 6a9b         	ldr	r3, [r3, #0x28]
 80051d6: f003 0320    	and	r3, r3, #0x20
 80051da: 2b00         	cmp	r3, #0x0
 80051dc: d005         	beq	0x80051ea <mem_manage_fault+0x23e> @ imm = #0xa
; 		SCB->SHCSR &= ~SCB_SHCSR_MEMFAULTPENDED_Msk;
 80051de: 4b0e         	ldr	r3, [pc, #0x38]         @ 0x8005218 <mem_manage_fault+0x26c>
 80051e0: 6a5b         	ldr	r3, [r3, #0x24]
 80051e2: 4a0d         	ldr	r2, [pc, #0x34]         @ 0x8005218 <mem_manage_fault+0x26c>
 80051e4: f423 5300    	bic	r3, r3, #0x2000
 80051e8: 6253         	str	r3, [r2, #0x24]
; 	SCB->CFSR |= SCB_CFSR_MEMFAULTSR_Msk;
 80051ea: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x8005218 <mem_manage_fault+0x26c>
 80051ec: 6a9b         	ldr	r3, [r3, #0x28]
 80051ee: 4a0a         	ldr	r2, [pc, #0x28]         @ 0x8005218 <mem_manage_fault+0x26c>
 80051f0: f043 03ff    	orr	r3, r3, #0xff
 80051f4: 6293         	str	r3, [r2, #0x28]
; 	*recoverable = memory_fault_recoverable(esf, true);
 80051f6: 2101         	movs	r1, #0x1
 80051f8: 68f8         	ldr	r0, [r7, #0xc]
 80051fa: f010 fca3    	bl	0x8015b44 <memory_fault_recoverable> @ imm = #0x10946
 80051fe: 4603         	mov	r3, r0
 8005200: 461a         	mov	r2, r3
 8005202: 687b         	ldr	r3, [r7, #0x4]
 8005204: 701a         	strb	r2, [r3]
; 	return reason;
 8005206: 6d7b         	ldr	r3, [r7, #0x54]
; }
 8005208: 4618         	mov	r0, r3
 800520a: 3758         	adds	r7, #0x58
 800520c: 46bd         	mov	sp, r7
 800520e: bd80         	pop	{r7, pc}

08005210 <$d>:
 8005210: c8 04 00 20  	.word	0x200004c8
 8005214: b0 e6 01 08  	.word	0x0801e6b0
 8005218: 00 ed 00 e0  	.word	0xe000ed00
 800521c: c8 e6 01 08  	.word	0x0801e6c8
 8005220: fc e6 01 08  	.word	0x0801e6fc
 8005224: 10 e7 01 08  	.word	0x0801e710
 8005228: 28 e7 01 08  	.word	0x0801e728
 800522c: 40 e7 01 08  	.word	0x0801e740
 8005230: 60 e7 01 08  	.word	0x0801e760

08005234 <bus_fault>:
; {
 8005234: b580         	push	{r7, lr}
 8005236: b09a         	sub	sp, #0x68
 8005238: af04         	add	r7, sp, #0x10
 800523a: 60f8         	str	r0, [r7, #0xc]
 800523c: 60b9         	str	r1, [r7, #0x8]
 800523e: 607a         	str	r2, [r7, #0x4]
; 	uint32_t reason = K_ERR_ARM_BUS_GENERIC;
 8005240: 2316         	movs	r3, #0x16
 8005242: 657b         	str	r3, [r7, #0x54]
; 	PR_FAULT_INFO("***** BUS FAULT *****");
 8005244: 2303         	movs	r3, #0x3
 8005246: 2b00         	cmp	r3, #0x0
 8005248: d018         	beq	0x800527c <bus_fault+0x48> @ imm = #0x30
 800524a: 2301         	movs	r3, #0x1
 800524c: f887 3053    	strb.w	r3, [r7, #0x53]
 8005250: f897 3053    	ldrb.w	r3, [r7, #0x53]
 8005254: f083 0301    	eor	r3, r3, #0x1
 8005258: b2db         	uxtb	r3, r3
 800525a: 2b00         	cmp	r3, #0x0
 800525c: d10e         	bne	0x800527c <bus_fault+0x48> @ imm = #0x1c
 800525e: 4b93         	ldr	r3, [pc, #0x24c]        @ 0x80054ac <bus_fault+0x278>
 8005260: 6819         	ldr	r1, [r3]
 8005262: 4b93         	ldr	r3, [pc, #0x24c]        @ 0x80054b0 <bus_fault+0x27c>
 8005264: 9302         	str	r3, [sp, #0x8]
 8005266: 2300         	movs	r3, #0x0
 8005268: 9301         	str	r3, [sp, #0x4]
 800526a: 2300         	movs	r3, #0x0
 800526c: 9300         	str	r3, [sp]
 800526e: 2300         	movs	r3, #0x0
 8005270: 2201         	movs	r2, #0x1
 8005272: 2000         	movs	r0, #0x0
 8005274: f010 fc3e    	bl	0x8015af4 <z_log_msg_runtime_create> @ imm = #0x1087c
 8005278: 2300         	movs	r3, #0x0
 800527a: 64fb         	str	r3, [r7, #0x4c]
; 	if (SCB->CFSR & SCB_CFSR_STKERR_Msk) {
 800527c: 4b8d         	ldr	r3, [pc, #0x234]        @ 0x80054b4 <bus_fault+0x280>
 800527e: 6a9b         	ldr	r3, [r3, #0x28]
 8005280: f403 5380    	and	r3, r3, #0x1000
 8005284: 2b00         	cmp	r3, #0x0
 8005286: d01d         	beq	0x80052c4 <bus_fault+0x90> @ imm = #0x3a
; 		reason = K_ERR_ARM_BUS_STACKING;
 8005288: 2317         	movs	r3, #0x17
 800528a: 657b         	str	r3, [r7, #0x54]
; 		PR_FAULT_INFO("  Stacking error");
 800528c: 2303         	movs	r3, #0x3
 800528e: 2b00         	cmp	r3, #0x0
 8005290: d018         	beq	0x80052c4 <bus_fault+0x90> @ imm = #0x30
 8005292: 2301         	movs	r3, #0x1
 8005294: f887 304b    	strb.w	r3, [r7, #0x4b]
 8005298: f897 304b    	ldrb.w	r3, [r7, #0x4b]
 800529c: f083 0301    	eor	r3, r3, #0x1
 80052a0: b2db         	uxtb	r3, r3
 80052a2: 2b00         	cmp	r3, #0x0
 80052a4: d10e         	bne	0x80052c4 <bus_fault+0x90> @ imm = #0x1c
 80052a6: 4b81         	ldr	r3, [pc, #0x204]        @ 0x80054ac <bus_fault+0x278>
 80052a8: 6819         	ldr	r1, [r3]
 80052aa: 4b83         	ldr	r3, [pc, #0x20c]        @ 0x80054b8 <bus_fault+0x284>
 80052ac: 9302         	str	r3, [sp, #0x8]
 80052ae: 2300         	movs	r3, #0x0
 80052b0: 9301         	str	r3, [sp, #0x4]
 80052b2: 2300         	movs	r3, #0x0
 80052b4: 9300         	str	r3, [sp]
 80052b6: 2300         	movs	r3, #0x0
 80052b8: 2201         	movs	r2, #0x1
 80052ba: 2000         	movs	r0, #0x0
 80052bc: f010 fc1a    	bl	0x8015af4 <z_log_msg_runtime_create> @ imm = #0x10834
 80052c0: 2300         	movs	r3, #0x0
 80052c2: 647b         	str	r3, [r7, #0x44]
; 	if (SCB->CFSR & SCB_CFSR_UNSTKERR_Msk) {
 80052c4: 4b7b         	ldr	r3, [pc, #0x1ec]        @ 0x80054b4 <bus_fault+0x280>
 80052c6: 6a9b         	ldr	r3, [r3, #0x28]
 80052c8: f403 6300    	and	r3, r3, #0x800
 80052cc: 2b00         	cmp	r3, #0x0
 80052ce: d01d         	beq	0x800530c <bus_fault+0xd8> @ imm = #0x3a
; 		reason = K_ERR_ARM_BUS_UNSTACKING;
 80052d0: 2318         	movs	r3, #0x18
 80052d2: 657b         	str	r3, [r7, #0x54]
; 		PR_FAULT_INFO("  Unstacking error");
 80052d4: 2303         	movs	r3, #0x3
 80052d6: 2b00         	cmp	r3, #0x0
 80052d8: d018         	beq	0x800530c <bus_fault+0xd8> @ imm = #0x30
 80052da: 2301         	movs	r3, #0x1
 80052dc: f887 3043    	strb.w	r3, [r7, #0x43]
 80052e0: f897 3043    	ldrb.w	r3, [r7, #0x43]
 80052e4: f083 0301    	eor	r3, r3, #0x1
 80052e8: b2db         	uxtb	r3, r3
 80052ea: 2b00         	cmp	r3, #0x0
 80052ec: d10e         	bne	0x800530c <bus_fault+0xd8> @ imm = #0x1c
 80052ee: 4b6f         	ldr	r3, [pc, #0x1bc]        @ 0x80054ac <bus_fault+0x278>
 80052f0: 6819         	ldr	r1, [r3]
 80052f2: 4b72         	ldr	r3, [pc, #0x1c8]        @ 0x80054bc <bus_fault+0x288>
 80052f4: 9302         	str	r3, [sp, #0x8]
 80052f6: 2300         	movs	r3, #0x0
 80052f8: 9301         	str	r3, [sp, #0x4]
 80052fa: 2300         	movs	r3, #0x0
 80052fc: 9300         	str	r3, [sp]
 80052fe: 2300         	movs	r3, #0x0
 8005300: 2201         	movs	r2, #0x1
 8005302: 2000         	movs	r0, #0x0
 8005304: f010 fbf6    	bl	0x8015af4 <z_log_msg_runtime_create> @ imm = #0x107ec
 8005308: 2300         	movs	r3, #0x0
 800530a: 63fb         	str	r3, [r7, #0x3c]
; 	if (SCB->CFSR & SCB_CFSR_PRECISERR_Msk) {
 800530c: 4b69         	ldr	r3, [pc, #0x1a4]        @ 0x80054b4 <bus_fault+0x280>
 800530e: 6a9b         	ldr	r3, [r3, #0x28]
 8005310: f403 7300    	and	r3, r3, #0x200
 8005314: 2b00         	cmp	r3, #0x0
 8005316: d04d         	beq	0x80053b4 <bus_fault+0x180> @ imm = #0x9a
; 		reason = K_ERR_ARM_BUS_PRECISE_DATA_BUS;
 8005318: 2319         	movs	r3, #0x19
 800531a: 657b         	str	r3, [r7, #0x54]
; 		PR_FAULT_INFO("  Precise data bus error");
 800531c: 2303         	movs	r3, #0x3
 800531e: 2b00         	cmp	r3, #0x0
 8005320: d018         	beq	0x8005354 <bus_fault+0x120> @ imm = #0x30
 8005322: 2301         	movs	r3, #0x1
 8005324: f887 303b    	strb.w	r3, [r7, #0x3b]
 8005328: f897 303b    	ldrb.w	r3, [r7, #0x3b]
 800532c: f083 0301    	eor	r3, r3, #0x1
 8005330: b2db         	uxtb	r3, r3
 8005332: 2b00         	cmp	r3, #0x0
 8005334: d10e         	bne	0x8005354 <bus_fault+0x120> @ imm = #0x1c
 8005336: 4b5d         	ldr	r3, [pc, #0x174]        @ 0x80054ac <bus_fault+0x278>
 8005338: 6819         	ldr	r1, [r3]
 800533a: 4b61         	ldr	r3, [pc, #0x184]        @ 0x80054c0 <bus_fault+0x28c>
 800533c: 9302         	str	r3, [sp, #0x8]
 800533e: 2300         	movs	r3, #0x0
 8005340: 9301         	str	r3, [sp, #0x4]
 8005342: 2300         	movs	r3, #0x0
 8005344: 9300         	str	r3, [sp]
 8005346: 2300         	movs	r3, #0x0
 8005348: 2201         	movs	r2, #0x1
 800534a: 2000         	movs	r0, #0x0
 800534c: f010 fbd2    	bl	0x8015af4 <z_log_msg_runtime_create> @ imm = #0x107a4
 8005350: 2300         	movs	r3, #0x0
 8005352: 637b         	str	r3, [r7, #0x34]
; 		STORE_xFAR(bfar, SCB->BFAR);
 8005354: 4b57         	ldr	r3, [pc, #0x15c]        @ 0x80054b4 <bus_fault+0x280>
 8005356: 6b9b         	ldr	r3, [r3, #0x38]
 8005358: 633b         	str	r3, [r7, #0x30]
; 		if ((SCB->CFSR & SCB_CFSR_BFARVALID_Msk) != 0) {
 800535a: 4b56         	ldr	r3, [pc, #0x158]        @ 0x80054b4 <bus_fault+0x280>
 800535c: 6a9b         	ldr	r3, [r3, #0x28]
 800535e: f403 4300    	and	r3, r3, #0x8000
 8005362: 2b00         	cmp	r3, #0x0
 8005364: d026         	beq	0x80053b4 <bus_fault+0x180> @ imm = #0x4c
; 			PR_EXC("  BFAR Address: 0x%x", bfar);
 8005366: 2303         	movs	r3, #0x3
 8005368: 2b00         	cmp	r3, #0x0
 800536a: d01a         	beq	0x80053a2 <bus_fault+0x16e> @ imm = #0x34
 800536c: 2301         	movs	r3, #0x1
 800536e: f887 302f    	strb.w	r3, [r7, #0x2f]
 8005372: f897 302f    	ldrb.w	r3, [r7, #0x2f]
 8005376: f083 0301    	eor	r3, r3, #0x1
 800537a: b2db         	uxtb	r3, r3
 800537c: 2b00         	cmp	r3, #0x0
 800537e: d110         	bne	0x80053a2 <bus_fault+0x16e> @ imm = #0x20
 8005380: 4b4a         	ldr	r3, [pc, #0x128]        @ 0x80054ac <bus_fault+0x278>
 8005382: 6819         	ldr	r1, [r3]
 8005384: 6b3b         	ldr	r3, [r7, #0x30]
 8005386: 9303         	str	r3, [sp, #0xc]
 8005388: 4b4e         	ldr	r3, [pc, #0x138]        @ 0x80054c4 <bus_fault+0x290>
 800538a: 9302         	str	r3, [sp, #0x8]
 800538c: 2300         	movs	r3, #0x0
 800538e: 9301         	str	r3, [sp, #0x4]
 8005390: 2300         	movs	r3, #0x0
 8005392: 9300         	str	r3, [sp]
 8005394: 2300         	movs	r3, #0x0
 8005396: 2201         	movs	r2, #0x1
 8005398: 2000         	movs	r0, #0x0
 800539a: f010 fbab    	bl	0x8015af4 <z_log_msg_runtime_create> @ imm = #0x10756
 800539e: 2300         	movs	r3, #0x0
 80053a0: 62bb         	str	r3, [r7, #0x28]
; 			if (from_hard_fault != 0) {
 80053a2: 68bb         	ldr	r3, [r7, #0x8]
 80053a4: 2b00         	cmp	r3, #0x0
 80053a6: d005         	beq	0x80053b4 <bus_fault+0x180> @ imm = #0xa
; 				SCB->CFSR &= ~SCB_CFSR_BFARVALID_Msk;
 80053a8: 4b42         	ldr	r3, [pc, #0x108]        @ 0x80054b4 <bus_fault+0x280>
 80053aa: 6a9b         	ldr	r3, [r3, #0x28]
 80053ac: 4a41         	ldr	r2, [pc, #0x104]        @ 0x80054b4 <bus_fault+0x280>
 80053ae: f423 4300    	bic	r3, r3, #0x8000
 80053b2: 6293         	str	r3, [r2, #0x28]
; 	if (SCB->CFSR & SCB_CFSR_IMPRECISERR_Msk) {
 80053b4: 4b3f         	ldr	r3, [pc, #0xfc]         @ 0x80054b4 <bus_fault+0x280>
 80053b6: 6a9b         	ldr	r3, [r3, #0x28]
 80053b8: f403 6380    	and	r3, r3, #0x400
 80053bc: 2b00         	cmp	r3, #0x0
 80053be: d01d         	beq	0x80053fc <bus_fault+0x1c8> @ imm = #0x3a
; 		reason = K_ERR_ARM_BUS_IMPRECISE_DATA_BUS;
 80053c0: 231a         	movs	r3, #0x1a
 80053c2: 657b         	str	r3, [r7, #0x54]
; 		PR_FAULT_INFO("  Imprecise data bus error");
 80053c4: 2303         	movs	r3, #0x3
 80053c6: 2b00         	cmp	r3, #0x0
 80053c8: d018         	beq	0x80053fc <bus_fault+0x1c8> @ imm = #0x30
 80053ca: 2301         	movs	r3, #0x1
 80053cc: f887 3027    	strb.w	r3, [r7, #0x27]
 80053d0: f897 3027    	ldrb.w	r3, [r7, #0x27]
 80053d4: f083 0301    	eor	r3, r3, #0x1
 80053d8: b2db         	uxtb	r3, r3
 80053da: 2b00         	cmp	r3, #0x0
 80053dc: d10e         	bne	0x80053fc <bus_fault+0x1c8> @ imm = #0x1c
 80053de: 4b33         	ldr	r3, [pc, #0xcc]         @ 0x80054ac <bus_fault+0x278>
 80053e0: 6819         	ldr	r1, [r3]
 80053e2: 4b39         	ldr	r3, [pc, #0xe4]         @ 0x80054c8 <bus_fault+0x294>
 80053e4: 9302         	str	r3, [sp, #0x8]
 80053e6: 2300         	movs	r3, #0x0
 80053e8: 9301         	str	r3, [sp, #0x4]
 80053ea: 2300         	movs	r3, #0x0
 80053ec: 9300         	str	r3, [sp]
 80053ee: 2300         	movs	r3, #0x0
 80053f0: 2201         	movs	r2, #0x1
 80053f2: 2000         	movs	r0, #0x0
 80053f4: f010 fb7e    	bl	0x8015af4 <z_log_msg_runtime_create> @ imm = #0x106fc
 80053f8: 2300         	movs	r3, #0x0
 80053fa: 623b         	str	r3, [r7, #0x20]
; 	if ((SCB->CFSR & SCB_CFSR_IBUSERR_Msk) != 0) {
 80053fc: 4b2d         	ldr	r3, [pc, #0xb4]         @ 0x80054b4 <bus_fault+0x280>
 80053fe: 6a9b         	ldr	r3, [r3, #0x28]
 8005400: f403 7380    	and	r3, r3, #0x100
 8005404: 2b00         	cmp	r3, #0x0
 8005406: d01c         	beq	0x8005442 <bus_fault+0x20e> @ imm = #0x38
; 		reason = K_ERR_ARM_BUS_INSTRUCTION_BUS;
 8005408: 231b         	movs	r3, #0x1b
 800540a: 657b         	str	r3, [r7, #0x54]
; 		PR_FAULT_INFO("  Instruction bus error");
 800540c: 2303         	movs	r3, #0x3
 800540e: 2b00         	cmp	r3, #0x0
 8005410: d039         	beq	0x8005486 <bus_fault+0x252> @ imm = #0x72
 8005412: 2301         	movs	r3, #0x1
 8005414: 75fb         	strb	r3, [r7, #0x17]
 8005416: 7dfb         	ldrb	r3, [r7, #0x17]
 8005418: f083 0301    	eor	r3, r3, #0x1
 800541c: b2db         	uxtb	r3, r3
 800541e: 2b00         	cmp	r3, #0x0
 8005420: d131         	bne	0x8005486 <bus_fault+0x252> @ imm = #0x62
 8005422: 4b22         	ldr	r3, [pc, #0x88]         @ 0x80054ac <bus_fault+0x278>
 8005424: 6819         	ldr	r1, [r3]
 8005426: 4b29         	ldr	r3, [pc, #0xa4]         @ 0x80054cc <bus_fault+0x298>
 8005428: 9302         	str	r3, [sp, #0x8]
 800542a: 2300         	movs	r3, #0x0
 800542c: 9301         	str	r3, [sp, #0x4]
 800542e: 2300         	movs	r3, #0x0
 8005430: 9300         	str	r3, [sp]
 8005432: 2300         	movs	r3, #0x0
 8005434: 2201         	movs	r2, #0x1
 8005436: 2000         	movs	r0, #0x0
 8005438: f010 fb5c    	bl	0x8015af4 <z_log_msg_runtime_create> @ imm = #0x106b8
 800543c: 2300         	movs	r3, #0x0
 800543e: 613b         	str	r3, [r7, #0x10]
 8005440: e021         	b	0x8005486 <bus_fault+0x252> @ imm = #0x42
; 	} else if (SCB->CFSR & SCB_CFSR_LSPERR_Msk) {
 8005442: 4b1c         	ldr	r3, [pc, #0x70]         @ 0x80054b4 <bus_fault+0x280>
 8005444: 6a9b         	ldr	r3, [r3, #0x28]
 8005446: f403 5300    	and	r3, r3, #0x2000
 800544a: 2b00         	cmp	r3, #0x0
 800544c: d01b         	beq	0x8005486 <bus_fault+0x252> @ imm = #0x36
; 		reason = K_ERR_ARM_BUS_FP_LAZY_STATE_PRESERVATION;
 800544e: 231c         	movs	r3, #0x1c
 8005450: 657b         	str	r3, [r7, #0x54]
; 		PR_FAULT_INFO("  Floating-point lazy state preservation error");
 8005452: 2303         	movs	r3, #0x3
 8005454: 2b00         	cmp	r3, #0x0
 8005456: d016         	beq	0x8005486 <bus_fault+0x252> @ imm = #0x2c
 8005458: 2301         	movs	r3, #0x1
 800545a: 77fb         	strb	r3, [r7, #0x1f]
 800545c: 7ffb         	ldrb	r3, [r7, #0x1f]
 800545e: f083 0301    	eor	r3, r3, #0x1
 8005462: b2db         	uxtb	r3, r3
 8005464: 2b00         	cmp	r3, #0x0
 8005466: d10e         	bne	0x8005486 <bus_fault+0x252> @ imm = #0x1c
 8005468: 4b10         	ldr	r3, [pc, #0x40]         @ 0x80054ac <bus_fault+0x278>
 800546a: 6819         	ldr	r1, [r3]
 800546c: 4b18         	ldr	r3, [pc, #0x60]         @ 0x80054d0 <bus_fault+0x29c>
 800546e: 9302         	str	r3, [sp, #0x8]
 8005470: 2300         	movs	r3, #0x0
 8005472: 9301         	str	r3, [sp, #0x4]
 8005474: 2300         	movs	r3, #0x0
 8005476: 9300         	str	r3, [sp]
 8005478: 2300         	movs	r3, #0x0
 800547a: 2201         	movs	r2, #0x1
 800547c: 2000         	movs	r0, #0x0
 800547e: f010 fb39    	bl	0x8015af4 <z_log_msg_runtime_create> @ imm = #0x10672
 8005482: 2300         	movs	r3, #0x0
 8005484: 61bb         	str	r3, [r7, #0x18]
; 	SCB->CFSR |= SCB_CFSR_BUSFAULTSR_Msk;
 8005486: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x80054b4 <bus_fault+0x280>
 8005488: 6a9b         	ldr	r3, [r3, #0x28]
 800548a: 4a0a         	ldr	r2, [pc, #0x28]         @ 0x80054b4 <bus_fault+0x280>
 800548c: f443 437f    	orr	r3, r3, #0xff00
 8005490: 6293         	str	r3, [r2, #0x28]
; 	*recoverable = memory_fault_recoverable(esf, true);
 8005492: 2101         	movs	r1, #0x1
 8005494: 68f8         	ldr	r0, [r7, #0xc]
 8005496: f010 fb55    	bl	0x8015b44 <memory_fault_recoverable> @ imm = #0x106aa
 800549a: 4603         	mov	r3, r0
 800549c: 461a         	mov	r2, r3
 800549e: 687b         	ldr	r3, [r7, #0x4]
 80054a0: 701a         	strb	r2, [r3]
; 	return reason;
 80054a2: 6d7b         	ldr	r3, [r7, #0x54]
; }
 80054a4: 4618         	mov	r0, r3
 80054a6: 3758         	adds	r7, #0x58
 80054a8: 46bd         	mov	sp, r7
 80054aa: bd80         	pop	{r7, pc}

080054ac <$d>:
 80054ac: c8 04 00 20  	.word	0x200004c8
 80054b0: 90 e7 01 08  	.word	0x0801e790
 80054b4: 00 ed 00 e0  	.word	0xe000ed00
 80054b8: a8 e7 01 08  	.word	0x0801e7a8
 80054bc: fc e6 01 08  	.word	0x0801e6fc
 80054c0: bc e7 01 08  	.word	0x0801e7bc
 80054c4: d8 e7 01 08  	.word	0x0801e7d8
 80054c8: f0 e7 01 08  	.word	0x0801e7f0
 80054cc: 0c e8 01 08  	.word	0x0801e80c
 80054d0: 60 e7 01 08  	.word	0x0801e760

080054d4 <usage_fault>:
; {
 80054d4: b580         	push	{r7, lr}
 80054d6: b096         	sub	sp, #0x58
 80054d8: af04         	add	r7, sp, #0x10
 80054da: 6078         	str	r0, [r7, #0x4]
; 	uint32_t reason = K_ERR_ARM_USAGE_GENERIC;
 80054dc: 231d         	movs	r3, #0x1d
 80054de: 647b         	str	r3, [r7, #0x44]
; 	PR_FAULT_INFO("***** USAGE FAULT *****");
 80054e0: 2303         	movs	r3, #0x3
 80054e2: 2b00         	cmp	r3, #0x0
 80054e4: d018         	beq	0x8005518 <usage_fault+0x44> @ imm = #0x30
 80054e6: 2301         	movs	r3, #0x1
 80054e8: f887 3043    	strb.w	r3, [r7, #0x43]
 80054ec: f897 3043    	ldrb.w	r3, [r7, #0x43]
 80054f0: f083 0301    	eor	r3, r3, #0x1
 80054f4: b2db         	uxtb	r3, r3
 80054f6: 2b00         	cmp	r3, #0x0
 80054f8: d10e         	bne	0x8005518 <usage_fault+0x44> @ imm = #0x1c
 80054fa: 4b78         	ldr	r3, [pc, #0x1e0]        @ 0x80056dc <usage_fault+0x208>
 80054fc: 6819         	ldr	r1, [r3]
 80054fe: 4b78         	ldr	r3, [pc, #0x1e0]        @ 0x80056e0 <usage_fault+0x20c>
 8005500: 9302         	str	r3, [sp, #0x8]
 8005502: 2300         	movs	r3, #0x0
 8005504: 9301         	str	r3, [sp, #0x4]
 8005506: 2300         	movs	r3, #0x0
 8005508: 9300         	str	r3, [sp]
 800550a: 2300         	movs	r3, #0x0
 800550c: 2201         	movs	r2, #0x1
 800550e: 2000         	movs	r0, #0x0
 8005510: f010 faf0    	bl	0x8015af4 <z_log_msg_runtime_create> @ imm = #0x105e0
 8005514: 2300         	movs	r3, #0x0
 8005516: 63fb         	str	r3, [r7, #0x3c]
; 	if ((SCB->CFSR & SCB_CFSR_DIVBYZERO_Msk) != 0) {
 8005518: 4b72         	ldr	r3, [pc, #0x1c8]        @ 0x80056e4 <usage_fault+0x210>
 800551a: 6a9b         	ldr	r3, [r3, #0x28]
 800551c: f003 7300    	and	r3, r3, #0x2000000
 8005520: 2b00         	cmp	r3, #0x0
 8005522: d01d         	beq	0x8005560 <usage_fault+0x8c> @ imm = #0x3a
; 		reason = K_ERR_ARM_USAGE_DIV_0;
 8005524: 231e         	movs	r3, #0x1e
 8005526: 647b         	str	r3, [r7, #0x44]
; 		PR_FAULT_INFO("  Division by zero");
 8005528: 2303         	movs	r3, #0x3
 800552a: 2b00         	cmp	r3, #0x0
 800552c: d018         	beq	0x8005560 <usage_fault+0x8c> @ imm = #0x30
 800552e: 2301         	movs	r3, #0x1
 8005530: f887 303b    	strb.w	r3, [r7, #0x3b]
 8005534: f897 303b    	ldrb.w	r3, [r7, #0x3b]
 8005538: f083 0301    	eor	r3, r3, #0x1
 800553c: b2db         	uxtb	r3, r3
 800553e: 2b00         	cmp	r3, #0x0
 8005540: d10e         	bne	0x8005560 <usage_fault+0x8c> @ imm = #0x1c
 8005542: 4b66         	ldr	r3, [pc, #0x198]        @ 0x80056dc <usage_fault+0x208>
 8005544: 6819         	ldr	r1, [r3]
 8005546: 4b68         	ldr	r3, [pc, #0x1a0]        @ 0x80056e8 <usage_fault+0x214>
 8005548: 9302         	str	r3, [sp, #0x8]
 800554a: 2300         	movs	r3, #0x0
 800554c: 9301         	str	r3, [sp, #0x4]
 800554e: 2300         	movs	r3, #0x0
 8005550: 9300         	str	r3, [sp]
 8005552: 2300         	movs	r3, #0x0
 8005554: 2201         	movs	r2, #0x1
 8005556: 2000         	movs	r0, #0x0
 8005558: f010 facc    	bl	0x8015af4 <z_log_msg_runtime_create> @ imm = #0x10598
 800555c: 2300         	movs	r3, #0x0
 800555e: 637b         	str	r3, [r7, #0x34]
; 	if ((SCB->CFSR & SCB_CFSR_UNALIGNED_Msk) != 0) {
 8005560: 4b60         	ldr	r3, [pc, #0x180]        @ 0x80056e4 <usage_fault+0x210>
 8005562: 6a9b         	ldr	r3, [r3, #0x28]
 8005564: f003 7380    	and	r3, r3, #0x1000000
 8005568: 2b00         	cmp	r3, #0x0
 800556a: d01d         	beq	0x80055a8 <usage_fault+0xd4> @ imm = #0x3a
; 		reason = K_ERR_ARM_USAGE_UNALIGNED_ACCESS;
 800556c: 231f         	movs	r3, #0x1f
 800556e: 647b         	str	r3, [r7, #0x44]
; 		PR_FAULT_INFO("  Unaligned memory access");
 8005570: 2303         	movs	r3, #0x3
 8005572: 2b00         	cmp	r3, #0x0
 8005574: d018         	beq	0x80055a8 <usage_fault+0xd4> @ imm = #0x30
 8005576: 2301         	movs	r3, #0x1
 8005578: f887 3033    	strb.w	r3, [r7, #0x33]
 800557c: f897 3033    	ldrb.w	r3, [r7, #0x33]
 8005580: f083 0301    	eor	r3, r3, #0x1
 8005584: b2db         	uxtb	r3, r3
 8005586: 2b00         	cmp	r3, #0x0
 8005588: d10e         	bne	0x80055a8 <usage_fault+0xd4> @ imm = #0x1c
 800558a: 4b54         	ldr	r3, [pc, #0x150]        @ 0x80056dc <usage_fault+0x208>
 800558c: 6819         	ldr	r1, [r3]
 800558e: 4b57         	ldr	r3, [pc, #0x15c]        @ 0x80056ec <usage_fault+0x218>
 8005590: 9302         	str	r3, [sp, #0x8]
 8005592: 2300         	movs	r3, #0x0
 8005594: 9301         	str	r3, [sp, #0x4]
 8005596: 2300         	movs	r3, #0x0
 8005598: 9300         	str	r3, [sp]
 800559a: 2300         	movs	r3, #0x0
 800559c: 2201         	movs	r2, #0x1
 800559e: 2000         	movs	r0, #0x0
 80055a0: f010 faa8    	bl	0x8015af4 <z_log_msg_runtime_create> @ imm = #0x10550
 80055a4: 2300         	movs	r3, #0x0
 80055a6: 62fb         	str	r3, [r7, #0x2c]
; 	if ((SCB->CFSR & SCB_CFSR_NOCP_Msk) != 0) {
 80055a8: 4b4e         	ldr	r3, [pc, #0x138]        @ 0x80056e4 <usage_fault+0x210>
 80055aa: 6a9b         	ldr	r3, [r3, #0x28]
 80055ac: f403 2300    	and	r3, r3, #0x80000
 80055b0: 2b00         	cmp	r3, #0x0
 80055b2: d01d         	beq	0x80055f0 <usage_fault+0x11c> @ imm = #0x3a
; 		reason = K_ERR_ARM_USAGE_NO_COPROCESSOR;
 80055b4: 2321         	movs	r3, #0x21
 80055b6: 647b         	str	r3, [r7, #0x44]
; 		PR_FAULT_INFO("  No coprocessor instructions");
 80055b8: 2303         	movs	r3, #0x3
 80055ba: 2b00         	cmp	r3, #0x0
 80055bc: d018         	beq	0x80055f0 <usage_fault+0x11c> @ imm = #0x30
 80055be: 2301         	movs	r3, #0x1
 80055c0: f887 302b    	strb.w	r3, [r7, #0x2b]
 80055c4: f897 302b    	ldrb.w	r3, [r7, #0x2b]
 80055c8: f083 0301    	eor	r3, r3, #0x1
 80055cc: b2db         	uxtb	r3, r3
 80055ce: 2b00         	cmp	r3, #0x0
 80055d0: d10e         	bne	0x80055f0 <usage_fault+0x11c> @ imm = #0x1c
 80055d2: 4b42         	ldr	r3, [pc, #0x108]        @ 0x80056dc <usage_fault+0x208>
 80055d4: 6819         	ldr	r1, [r3]
 80055d6: 4b46         	ldr	r3, [pc, #0x118]        @ 0x80056f0 <usage_fault+0x21c>
 80055d8: 9302         	str	r3, [sp, #0x8]
 80055da: 2300         	movs	r3, #0x0
 80055dc: 9301         	str	r3, [sp, #0x4]
 80055de: 2300         	movs	r3, #0x0
 80055e0: 9300         	str	r3, [sp]
 80055e2: 2300         	movs	r3, #0x0
 80055e4: 2201         	movs	r2, #0x1
 80055e6: 2000         	movs	r0, #0x0
 80055e8: f010 fa84    	bl	0x8015af4 <z_log_msg_runtime_create> @ imm = #0x10508
 80055ec: 2300         	movs	r3, #0x0
 80055ee: 627b         	str	r3, [r7, #0x24]
; 	if ((SCB->CFSR & SCB_CFSR_INVPC_Msk) != 0) {
 80055f0: 4b3c         	ldr	r3, [pc, #0xf0]         @ 0x80056e4 <usage_fault+0x210>
 80055f2: 6a9b         	ldr	r3, [r3, #0x28]
 80055f4: f403 2380    	and	r3, r3, #0x40000
 80055f8: 2b00         	cmp	r3, #0x0
 80055fa: d01d         	beq	0x8005638 <usage_fault+0x164> @ imm = #0x3a
; 		reason = K_ERR_ARM_USAGE_ILLEGAL_EXC_RETURN;
 80055fc: 2322         	movs	r3, #0x22
 80055fe: 647b         	str	r3, [r7, #0x44]
; 		PR_FAULT_INFO("  Illegal load of EXC_RETURN into PC");
 8005600: 2303         	movs	r3, #0x3
 8005602: 2b00         	cmp	r3, #0x0
 8005604: d018         	beq	0x8005638 <usage_fault+0x164> @ imm = #0x30
 8005606: 2301         	movs	r3, #0x1
 8005608: f887 3023    	strb.w	r3, [r7, #0x23]
 800560c: f897 3023    	ldrb.w	r3, [r7, #0x23]
 8005610: f083 0301    	eor	r3, r3, #0x1
 8005614: b2db         	uxtb	r3, r3
 8005616: 2b00         	cmp	r3, #0x0
 8005618: d10e         	bne	0x8005638 <usage_fault+0x164> @ imm = #0x1c
 800561a: 4b30         	ldr	r3, [pc, #0xc0]         @ 0x80056dc <usage_fault+0x208>
 800561c: 6819         	ldr	r1, [r3]
 800561e: 4b35         	ldr	r3, [pc, #0xd4]         @ 0x80056f4 <usage_fault+0x220>
 8005620: 9302         	str	r3, [sp, #0x8]
 8005622: 2300         	movs	r3, #0x0
 8005624: 9301         	str	r3, [sp, #0x4]
 8005626: 2300         	movs	r3, #0x0
 8005628: 9300         	str	r3, [sp]
 800562a: 2300         	movs	r3, #0x0
 800562c: 2201         	movs	r2, #0x1
 800562e: 2000         	movs	r0, #0x0
 8005630: f010 fa60    	bl	0x8015af4 <z_log_msg_runtime_create> @ imm = #0x104c0
 8005634: 2300         	movs	r3, #0x0
 8005636: 61fb         	str	r3, [r7, #0x1c]
; 	if ((SCB->CFSR & SCB_CFSR_INVSTATE_Msk) != 0) {
 8005638: 4b2a         	ldr	r3, [pc, #0xa8]         @ 0x80056e4 <usage_fault+0x210>
 800563a: 6a9b         	ldr	r3, [r3, #0x28]
 800563c: f403 3300    	and	r3, r3, #0x20000
 8005640: 2b00         	cmp	r3, #0x0
 8005642: d01b         	beq	0x800567c <usage_fault+0x1a8> @ imm = #0x36
; 		reason = K_ERR_ARM_USAGE_ILLEGAL_EPSR;
 8005644: 2323         	movs	r3, #0x23
 8005646: 647b         	str	r3, [r7, #0x44]
; 		PR_FAULT_INFO("  Illegal use of the EPSR");
 8005648: 2303         	movs	r3, #0x3
 800564a: 2b00         	cmp	r3, #0x0
 800564c: d016         	beq	0x800567c <usage_fault+0x1a8> @ imm = #0x2c
 800564e: 2301         	movs	r3, #0x1
 8005650: 76fb         	strb	r3, [r7, #0x1b]
 8005652: 7efb         	ldrb	r3, [r7, #0x1b]
 8005654: f083 0301    	eor	r3, r3, #0x1
 8005658: b2db         	uxtb	r3, r3
 800565a: 2b00         	cmp	r3, #0x0
 800565c: d10e         	bne	0x800567c <usage_fault+0x1a8> @ imm = #0x1c
 800565e: 4b1f         	ldr	r3, [pc, #0x7c]         @ 0x80056dc <usage_fault+0x208>
 8005660: 6819         	ldr	r1, [r3]
 8005662: 4b25         	ldr	r3, [pc, #0x94]         @ 0x80056f8 <usage_fault+0x224>
 8005664: 9302         	str	r3, [sp, #0x8]
 8005666: 2300         	movs	r3, #0x0
 8005668: 9301         	str	r3, [sp, #0x4]
 800566a: 2300         	movs	r3, #0x0
 800566c: 9300         	str	r3, [sp]
 800566e: 2300         	movs	r3, #0x0
 8005670: 2201         	movs	r2, #0x1
 8005672: 2000         	movs	r0, #0x0
 8005674: f010 fa3e    	bl	0x8015af4 <z_log_msg_runtime_create> @ imm = #0x1047c
 8005678: 2300         	movs	r3, #0x0
 800567a: 617b         	str	r3, [r7, #0x14]
; 	if ((SCB->CFSR & SCB_CFSR_UNDEFINSTR_Msk) != 0) {
 800567c: 4b19         	ldr	r3, [pc, #0x64]         @ 0x80056e4 <usage_fault+0x210>
 800567e: 6a9b         	ldr	r3, [r3, #0x28]
 8005680: f403 3380    	and	r3, r3, #0x10000
 8005684: 2b00         	cmp	r3, #0x0
 8005686: d01b         	beq	0x80056c0 <usage_fault+0x1ec> @ imm = #0x36
; 		reason = K_ERR_ARM_USAGE_UNDEFINED_INSTRUCTION;
 8005688: 2324         	movs	r3, #0x24
 800568a: 647b         	str	r3, [r7, #0x44]
; 		PR_FAULT_INFO("  Attempt to execute undefined instruction");
 800568c: 2303         	movs	r3, #0x3
 800568e: 2b00         	cmp	r3, #0x0
 8005690: d016         	beq	0x80056c0 <usage_fault+0x1ec> @ imm = #0x2c
 8005692: 2301         	movs	r3, #0x1
 8005694: 74fb         	strb	r3, [r7, #0x13]
 8005696: 7cfb         	ldrb	r3, [r7, #0x13]
 8005698: f083 0301    	eor	r3, r3, #0x1
 800569c: b2db         	uxtb	r3, r3
 800569e: 2b00         	cmp	r3, #0x0
 80056a0: d10e         	bne	0x80056c0 <usage_fault+0x1ec> @ imm = #0x1c
 80056a2: 4b0e         	ldr	r3, [pc, #0x38]         @ 0x80056dc <usage_fault+0x208>
 80056a4: 6819         	ldr	r1, [r3]
 80056a6: 4b15         	ldr	r3, [pc, #0x54]         @ 0x80056fc <usage_fault+0x228>
 80056a8: 9302         	str	r3, [sp, #0x8]
 80056aa: 2300         	movs	r3, #0x0
 80056ac: 9301         	str	r3, [sp, #0x4]
 80056ae: 2300         	movs	r3, #0x0
 80056b0: 9300         	str	r3, [sp]
 80056b2: 2300         	movs	r3, #0x0
 80056b4: 2201         	movs	r2, #0x1
 80056b6: 2000         	movs	r0, #0x0
 80056b8: f010 fa1c    	bl	0x8015af4 <z_log_msg_runtime_create> @ imm = #0x10438
 80056bc: 2300         	movs	r3, #0x0
 80056be: 60fb         	str	r3, [r7, #0xc]
; 	SCB->CFSR |= SCB_CFSR_USGFAULTSR_Msk;
 80056c0: 4b08         	ldr	r3, [pc, #0x20]         @ 0x80056e4 <usage_fault+0x210>
 80056c2: 6a9b         	ldr	r3, [r3, #0x28]
 80056c4: 4a07         	ldr	r2, [pc, #0x1c]         @ 0x80056e4 <usage_fault+0x210>
 80056c6: ea6f 4303    	mvn.w	r3, r3, lsl #16
 80056ca: ea6f 4313    	mvn.w	r3, r3, lsr #16
 80056ce: 6293         	str	r3, [r2, #0x28]
; 	return reason;
 80056d0: 6c7b         	ldr	r3, [r7, #0x44]
; }
 80056d2: 4618         	mov	r0, r3
 80056d4: 3748         	adds	r7, #0x48
 80056d6: 46bd         	mov	sp, r7
 80056d8: bd80         	pop	{r7, pc}
 80056da: bf00         	nop

080056dc <$d>:
 80056dc: c8 04 00 20  	.word	0x200004c8
 80056e0: 24 e8 01 08  	.word	0x0801e824
 80056e4: 00 ed 00 e0  	.word	0xe000ed00
 80056e8: 3c e8 01 08  	.word	0x0801e83c
 80056ec: 50 e8 01 08  	.word	0x0801e850
 80056f0: 6c e8 01 08  	.word	0x0801e86c
 80056f4: 8c e8 01 08  	.word	0x0801e88c
 80056f8: b4 e8 01 08  	.word	0x0801e8b4
 80056fc: d0 e8 01 08  	.word	0x0801e8d0

08005700 <debug_monitor>:
; {
 8005700: b580         	push	{r7, lr}
 8005702: b088         	sub	sp, #0x20
 8005704: af04         	add	r7, sp, #0x10
 8005706: 6078         	str	r0, [r7, #0x4]
 8005708: 6039         	str	r1, [r7]
; 	*recoverable = false;
 800570a: 683b         	ldr	r3, [r7]
 800570c: 2200         	movs	r2, #0x0
 800570e: 701a         	strb	r2, [r3]
; 	PR_FAULT_INFO(
 8005710: 2303         	movs	r3, #0x3
 8005712: 2b00         	cmp	r3, #0x0
 8005714: d017         	beq	0x8005746 <debug_monitor+0x46> @ imm = #0x2e
 8005716: 2301         	movs	r3, #0x1
 8005718: 73fb         	strb	r3, [r7, #0xf]
 800571a: 7bfb         	ldrb	r3, [r7, #0xf]
 800571c: f083 0301    	eor	r3, r3, #0x1
 8005720: b2db         	uxtb	r3, r3
 8005722: 2b00         	cmp	r3, #0x0
 8005724: d10f         	bne	0x8005746 <debug_monitor+0x46> @ imm = #0x1e
 8005726: 4b0a         	ldr	r3, [pc, #0x28]         @ 0x8005750 <debug_monitor+0x50>
 8005728: 6819         	ldr	r1, [r3]
 800572a: 4b0a         	ldr	r3, [pc, #0x28]         @ 0x8005754 <debug_monitor+0x54>
 800572c: 9302         	str	r3, [sp, #0x8]
 800572e: 2300         	movs	r3, #0x0
 8005730: 9301         	str	r3, [sp, #0x4]
 8005732: 2300         	movs	r3, #0x0
 8005734: 9300         	str	r3, [sp]
 8005736: 2300         	movs	r3, #0x0
 8005738: 2201         	movs	r2, #0x1
 800573a: 2000         	movs	r0, #0x0
 800573c: f010 f9da    	bl	0x8015af4 <z_log_msg_runtime_create> @ imm = #0x103b4
 8005740: 2300         	movs	r3, #0x0
 8005742: 60bb         	str	r3, [r7, #0x8]
; }
 8005744: bf00         	nop
 8005746: bf00         	nop
 8005748: 3710         	adds	r7, #0x10
 800574a: 46bd         	mov	sp, r7
 800574c: bd80         	pop	{r7, pc}
 800574e: bf00         	nop

08005750 <$d>:
 8005750: c8 04 00 20  	.word	0x200004c8
 8005754: fc e8 01 08  	.word	0x0801e8fc

08005758 <z_arm_is_synchronous_svc>:
; {
 8005758: b480         	push	{r7}
 800575a: b085         	sub	sp, #0x14
 800575c: af00         	add	r7, sp, #0x0
 800575e: 6078         	str	r0, [r7, #0x4]
; 	uint16_t *ret_addr = (uint16_t *)esf->basic.pc;
 8005760: 687b         	ldr	r3, [r7, #0x4]
 8005762: 699b         	ldr	r3, [r3, #0x18]
 8005764: 60fb         	str	r3, [r7, #0xc]
; 	SCB->CCR |= SCB_CCR_BFHFNMIGN_Msk;
 8005766: 4b1b         	ldr	r3, [pc, #0x6c]         @ 0x80057d4 <z_arm_is_synchronous_svc+0x7c>
 8005768: 695b         	ldr	r3, [r3, #0x14]
 800576a: 4a1a         	ldr	r2, [pc, #0x68]         @ 0x80057d4 <z_arm_is_synchronous_svc+0x7c>
 800576c: f443 7380    	orr	r3, r3, #0x100
 8005770: 6153         	str	r3, [r2, #0x14]
;   __ASM volatile ("dsb 0xF":::"memory");
 8005772: f3bf 8f4f    	dsb	sy
; }
 8005776: bf00         	nop
; }
 8005778: bf00         	nop
; }
 800577a: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800577c: f3bf 8f6f    	isb	sy
; }
 8005780: bf00         	nop
; }
 8005782: bf00         	nop
; }
 8005784: bf00         	nop
; 	uint16_t fault_insn = *(ret_addr - 1);
 8005786: 68fb         	ldr	r3, [r7, #0xc]
 8005788: f833 3c02    	ldrh	r3, [r3, #-2]
 800578c: 817b         	strh	r3, [r7, #0xa]
; 	SCB->CCR &= ~SCB_CCR_BFHFNMIGN_Msk;
 800578e: 4b11         	ldr	r3, [pc, #0x44]         @ 0x80057d4 <z_arm_is_synchronous_svc+0x7c>
 8005790: 695b         	ldr	r3, [r3, #0x14]
 8005792: 4a10         	ldr	r2, [pc, #0x40]         @ 0x80057d4 <z_arm_is_synchronous_svc+0x7c>
 8005794: f423 7380    	bic	r3, r3, #0x100
 8005798: 6153         	str	r3, [r2, #0x14]
;   __ASM volatile ("dsb 0xF":::"memory");
 800579a: f3bf 8f4f    	dsb	sy
; }
 800579e: bf00         	nop
; }
 80057a0: bf00         	nop
; }
 80057a2: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 80057a4: f3bf 8f6f    	isb	sy
; }
 80057a8: bf00         	nop
; }
 80057aa: bf00         	nop
; }
 80057ac: bf00         	nop
; 	if (((fault_insn & 0xff00) == _SVC_OPCODE) &&
 80057ae: 897b         	ldrh	r3, [r7, #0xa]
 80057b0: f403 437f    	and	r3, r3, #0xff00
 80057b4: f5b3 4f5f    	cmp.w	r3, #0xdf00
 80057b8: d105         	bne	0x80057c6 <z_arm_is_synchronous_svc+0x6e> @ imm = #0xa
; 		((fault_insn & 0x00ff) == _SVC_CALL_RUNTIME_EXCEPT)) {
 80057ba: 897b         	ldrh	r3, [r7, #0xa]
 80057bc: b2db         	uxtb	r3, r3
; 	if (((fault_insn & 0xff00) == _SVC_OPCODE) &&
 80057be: 2b02         	cmp	r3, #0x2
 80057c0: d101         	bne	0x80057c6 <z_arm_is_synchronous_svc+0x6e> @ imm = #0x2
; 		return true;
 80057c2: 2301         	movs	r3, #0x1
 80057c4: e000         	b	0x80057c8 <z_arm_is_synchronous_svc+0x70> @ imm = #0x0
; 	return false;
 80057c6: 2300         	movs	r3, #0x0
; }
 80057c8: 4618         	mov	r0, r3
 80057ca: 3714         	adds	r7, #0x14
 80057cc: 46bd         	mov	sp, r7
 80057ce: bc80         	pop	{r7}
 80057d0: 4770         	bx	lr
 80057d2: bf00         	nop

080057d4 <$d>:
 80057d4: 00 ed 00 e0  	.word	0xe000ed00

080057d8 <hard_fault>:
; {
 80057d8: b580         	push	{r7, lr}
 80057da: b092         	sub	sp, #0x48
 80057dc: af04         	add	r7, sp, #0x10
 80057de: 6078         	str	r0, [r7, #0x4]
 80057e0: 6039         	str	r1, [r7]
; 	uint32_t reason = K_ERR_CPU_EXCEPTION;
 80057e2: 2300         	movs	r3, #0x0
 80057e4: 62fb         	str	r3, [r7, #0x2c]
; 	PR_FAULT_INFO("***** HARD FAULT *****");
 80057e6: 2303         	movs	r3, #0x3
 80057e8: 2b00         	cmp	r3, #0x0
 80057ea: d018         	beq	0x800581e <hard_fault+0x46> @ imm = #0x30
 80057ec: 2301         	movs	r3, #0x1
 80057ee: f887 3033    	strb.w	r3, [r7, #0x33]
 80057f2: f897 3033    	ldrb.w	r3, [r7, #0x33]
 80057f6: f083 0301    	eor	r3, r3, #0x1
 80057fa: b2db         	uxtb	r3, r3
 80057fc: 2b00         	cmp	r3, #0x0
 80057fe: d10e         	bne	0x800581e <hard_fault+0x46> @ imm = #0x1c
 8005800: 4b63         	ldr	r3, [pc, #0x18c]        @ 0x8005990 <hard_fault+0x1b8>
 8005802: 6819         	ldr	r1, [r3]
 8005804: 4b63         	ldr	r3, [pc, #0x18c]        @ 0x8005994 <hard_fault+0x1bc>
 8005806: 9302         	str	r3, [sp, #0x8]
 8005808: 2300         	movs	r3, #0x0
 800580a: 9301         	str	r3, [sp, #0x4]
 800580c: 2300         	movs	r3, #0x0
 800580e: 9300         	str	r3, [sp]
 8005810: 2300         	movs	r3, #0x0
 8005812: 2201         	movs	r2, #0x1
 8005814: 2000         	movs	r0, #0x0
 8005816: f010 f96d    	bl	0x8015af4 <z_log_msg_runtime_create> @ imm = #0x102da
 800581a: 2300         	movs	r3, #0x0
 800581c: 637b         	str	r3, [r7, #0x34]
; 	*recoverable = false;
 800581e: 683b         	ldr	r3, [r7]
 8005820: 2200         	movs	r2, #0x0
 8005822: 701a         	strb	r2, [r3]
; 	if ((SCB->HFSR & SCB_HFSR_VECTTBL_Msk) != 0) {
 8005824: 4b5c         	ldr	r3, [pc, #0x170]        @ 0x8005998 <hard_fault+0x1c0>
 8005826: 6adb         	ldr	r3, [r3, #0x2c]
 8005828: f003 0302    	and	r3, r3, #0x2
 800582c: 2b00         	cmp	r3, #0x0
 800582e: d01c         	beq	0x800586a <hard_fault+0x92> @ imm = #0x38
; 		PR_EXC("  Bus fault on vector table read");
 8005830: 2303         	movs	r3, #0x3
 8005832: 2b00         	cmp	r3, #0x0
 8005834: f000 80a7    	beq.w	0x8005986 <hard_fault+0x1ae> @ imm = #0x14e
 8005838: 2301         	movs	r3, #0x1
 800583a: 74fb         	strb	r3, [r7, #0x13]
 800583c: 7cfb         	ldrb	r3, [r7, #0x13]
 800583e: f083 0301    	eor	r3, r3, #0x1
 8005842: b2db         	uxtb	r3, r3
 8005844: 2b00         	cmp	r3, #0x0
 8005846: f040 809e    	bne.w	0x8005986 <hard_fault+0x1ae> @ imm = #0x13c
 800584a: 4b51         	ldr	r3, [pc, #0x144]        @ 0x8005990 <hard_fault+0x1b8>
 800584c: 6819         	ldr	r1, [r3]
 800584e: 4b53         	ldr	r3, [pc, #0x14c]        @ 0x800599c <hard_fault+0x1c4>
 8005850: 9302         	str	r3, [sp, #0x8]
 8005852: 2300         	movs	r3, #0x0
 8005854: 9301         	str	r3, [sp, #0x4]
 8005856: 2300         	movs	r3, #0x0
 8005858: 9300         	str	r3, [sp]
 800585a: 2300         	movs	r3, #0x0
 800585c: 2201         	movs	r2, #0x1
 800585e: 2000         	movs	r0, #0x0
 8005860: f010 f948    	bl	0x8015af4 <z_log_msg_runtime_create> @ imm = #0x10290
 8005864: 2300         	movs	r3, #0x0
 8005866: 60fb         	str	r3, [r7, #0xc]
 8005868: e08d         	b	0x8005986 <hard_fault+0x1ae> @ imm = #0x11a
; 	} else if ((SCB->HFSR & SCB_HFSR_DEBUGEVT_Msk) != 0) {
 800586a: 4b4b         	ldr	r3, [pc, #0x12c]        @ 0x8005998 <hard_fault+0x1c0>
 800586c: 6adb         	ldr	r3, [r3, #0x2c]
 800586e: 2b00         	cmp	r3, #0x0
 8005870: da1b         	bge	0x80058aa <hard_fault+0xd2> @ imm = #0x36
; 		PR_EXC("  Debug event");
 8005872: 2303         	movs	r3, #0x3
 8005874: 2b00         	cmp	r3, #0x0
 8005876: f000 8086    	beq.w	0x8005986 <hard_fault+0x1ae> @ imm = #0x10c
 800587a: 2301         	movs	r3, #0x1
 800587c: 76fb         	strb	r3, [r7, #0x1b]
 800587e: 7efb         	ldrb	r3, [r7, #0x1b]
 8005880: f083 0301    	eor	r3, r3, #0x1
 8005884: b2db         	uxtb	r3, r3
 8005886: 2b00         	cmp	r3, #0x0
 8005888: d17d         	bne	0x8005986 <hard_fault+0x1ae> @ imm = #0xfa
 800588a: 4b41         	ldr	r3, [pc, #0x104]        @ 0x8005990 <hard_fault+0x1b8>
 800588c: 6819         	ldr	r1, [r3]
 800588e: 4b44         	ldr	r3, [pc, #0x110]        @ 0x80059a0 <hard_fault+0x1c8>
 8005890: 9302         	str	r3, [sp, #0x8]
 8005892: 2300         	movs	r3, #0x0
 8005894: 9301         	str	r3, [sp, #0x4]
 8005896: 2300         	movs	r3, #0x0
 8005898: 9300         	str	r3, [sp]
 800589a: 2300         	movs	r3, #0x0
 800589c: 2201         	movs	r2, #0x1
 800589e: 2000         	movs	r0, #0x0
 80058a0: f010 f928    	bl	0x8015af4 <z_log_msg_runtime_create> @ imm = #0x10250
 80058a4: 2300         	movs	r3, #0x0
 80058a6: 617b         	str	r3, [r7, #0x14]
 80058a8: e06d         	b	0x8005986 <hard_fault+0x1ae> @ imm = #0xda
; 	} else if ((SCB->HFSR & SCB_HFSR_FORCED_Msk) != 0) {
 80058aa: 4b3b         	ldr	r3, [pc, #0xec]         @ 0x8005998 <hard_fault+0x1c0>
 80058ac: 6adb         	ldr	r3, [r3, #0x2c]
 80058ae: f003 4380    	and	r3, r3, #0x40000000
 80058b2: 2b00         	cmp	r3, #0x0
 80058b4: d067         	beq	0x8005986 <hard_fault+0x1ae> @ imm = #0xce
; 		PR_EXC("  Fault escalation (see below)");
 80058b6: 2303         	movs	r3, #0x3
 80058b8: 2b00         	cmp	r3, #0x0
 80058ba: d018         	beq	0x80058ee <hard_fault+0x116> @ imm = #0x30
 80058bc: 2301         	movs	r3, #0x1
 80058be: f887 302b    	strb.w	r3, [r7, #0x2b]
 80058c2: f897 302b    	ldrb.w	r3, [r7, #0x2b]
 80058c6: f083 0301    	eor	r3, r3, #0x1
 80058ca: b2db         	uxtb	r3, r3
 80058cc: 2b00         	cmp	r3, #0x0
 80058ce: d10e         	bne	0x80058ee <hard_fault+0x116> @ imm = #0x1c
 80058d0: 4b2f         	ldr	r3, [pc, #0xbc]         @ 0x8005990 <hard_fault+0x1b8>
 80058d2: 6819         	ldr	r1, [r3]
 80058d4: 4b33         	ldr	r3, [pc, #0xcc]         @ 0x80059a4 <hard_fault+0x1cc>
 80058d6: 9302         	str	r3, [sp, #0x8]
 80058d8: 2300         	movs	r3, #0x0
 80058da: 9301         	str	r3, [sp, #0x4]
 80058dc: 2300         	movs	r3, #0x0
 80058de: 9300         	str	r3, [sp]
 80058e0: 2300         	movs	r3, #0x0
 80058e2: 2201         	movs	r2, #0x1
 80058e4: 2000         	movs	r0, #0x0
 80058e6: f010 f905    	bl	0x8015af4 <z_log_msg_runtime_create> @ imm = #0x1020a
 80058ea: 2300         	movs	r3, #0x0
 80058ec: 627b         	str	r3, [r7, #0x24]
; 		if (z_arm_is_synchronous_svc(esf)) {
 80058ee: 6878         	ldr	r0, [r7, #0x4]
 80058f0: f7ff ff32    	bl	0x8005758 <z_arm_is_synchronous_svc> @ imm = #-0x19c
 80058f4: 4603         	mov	r3, r0
 80058f6: 2b00         	cmp	r3, #0x0
 80058f8: d022         	beq	0x8005940 <hard_fault+0x168> @ imm = #0x44
; 			PR_EXC("ARCH_EXCEPT with reason %x\n", esf->basic.r0);
 80058fa: 2303         	movs	r3, #0x3
 80058fc: 2b00         	cmp	r3, #0x0
 80058fe: d01b         	beq	0x8005938 <hard_fault+0x160> @ imm = #0x36
 8005900: 2301         	movs	r3, #0x1
 8005902: f887 3023    	strb.w	r3, [r7, #0x23]
 8005906: f897 3023    	ldrb.w	r3, [r7, #0x23]
 800590a: f083 0301    	eor	r3, r3, #0x1
 800590e: b2db         	uxtb	r3, r3
 8005910: 2b00         	cmp	r3, #0x0
 8005912: d111         	bne	0x8005938 <hard_fault+0x160> @ imm = #0x22
 8005914: 4b1e         	ldr	r3, [pc, #0x78]         @ 0x8005990 <hard_fault+0x1b8>
 8005916: 6819         	ldr	r1, [r3]
 8005918: 687b         	ldr	r3, [r7, #0x4]
 800591a: 681b         	ldr	r3, [r3]
 800591c: 9303         	str	r3, [sp, #0xc]
 800591e: 4b22         	ldr	r3, [pc, #0x88]         @ 0x80059a8 <hard_fault+0x1d0>
 8005920: 9302         	str	r3, [sp, #0x8]
 8005922: 2300         	movs	r3, #0x0
 8005924: 9301         	str	r3, [sp, #0x4]
 8005926: 2300         	movs	r3, #0x0
 8005928: 9300         	str	r3, [sp]
 800592a: 2300         	movs	r3, #0x0
 800592c: 2201         	movs	r2, #0x1
 800592e: 2000         	movs	r0, #0x0
 8005930: f010 f8e0    	bl	0x8015af4 <z_log_msg_runtime_create> @ imm = #0x101c0
 8005934: 2300         	movs	r3, #0x0
 8005936: 61fb         	str	r3, [r7, #0x1c]
; 			reason = esf->basic.r0;
 8005938: 687b         	ldr	r3, [r7, #0x4]
 800593a: 681b         	ldr	r3, [r3]
 800593c: 62fb         	str	r3, [r7, #0x2c]
 800593e: e022         	b	0x8005986 <hard_fault+0x1ae> @ imm = #0x44
; 		} else if ((SCB->CFSR & SCB_CFSR_MEMFAULTSR_Msk) != 0) {
 8005940: 4b15         	ldr	r3, [pc, #0x54]         @ 0x8005998 <hard_fault+0x1c0>
 8005942: 6a9b         	ldr	r3, [r3, #0x28]
 8005944: b2db         	uxtb	r3, r3
 8005946: 2b00         	cmp	r3, #0x0
 8005948: d006         	beq	0x8005958 <hard_fault+0x180> @ imm = #0xc
; 			reason = mem_manage_fault(esf, 1, recoverable);
 800594a: 683a         	ldr	r2, [r7]
 800594c: 2101         	movs	r1, #0x1
 800594e: 6878         	ldr	r0, [r7, #0x4]
 8005950: f7ff fb2c    	bl	0x8004fac <mem_manage_fault> @ imm = #-0x9a8
 8005954: 62f8         	str	r0, [r7, #0x2c]
 8005956: e016         	b	0x8005986 <hard_fault+0x1ae> @ imm = #0x2c
; 		} else if ((SCB->CFSR & SCB_CFSR_BUSFAULTSR_Msk) != 0) {
 8005958: 4b0f         	ldr	r3, [pc, #0x3c]         @ 0x8005998 <hard_fault+0x1c0>
 800595a: 6a9b         	ldr	r3, [r3, #0x28]
 800595c: f403 437f    	and	r3, r3, #0xff00
 8005960: 2b00         	cmp	r3, #0x0
 8005962: d007         	beq	0x8005974 <hard_fault+0x19c> @ imm = #0xe
; 			reason = bus_fault(esf, 1, recoverable);
 8005964: 683a         	ldr	r2, [r7]
 8005966: 2101         	movs	r1, #0x1
 8005968: 6878         	ldr	r0, [r7, #0x4]
 800596a: f7ff fc63    	bl	0x8005234 <bus_fault>   @ imm = #-0x73a
 800596e: 4603         	mov	r3, r0
 8005970: 62fb         	str	r3, [r7, #0x2c]
 8005972: e008         	b	0x8005986 <hard_fault+0x1ae> @ imm = #0x10
; 		} else if ((SCB->CFSR & SCB_CFSR_USGFAULTSR_Msk) != 0) {
 8005974: 4b08         	ldr	r3, [pc, #0x20]         @ 0x8005998 <hard_fault+0x1c0>
 8005976: 6a9b         	ldr	r3, [r3, #0x28]
 8005978: f5b3 3f80    	cmp.w	r3, #0x10000
 800597c: d303         	blo	0x8005986 <hard_fault+0x1ae> @ imm = #0x6
; 			reason = usage_fault(esf);
 800597e: 6878         	ldr	r0, [r7, #0x4]
 8005980: f7ff fda8    	bl	0x80054d4 <usage_fault> @ imm = #-0x4b0
 8005984: 62f8         	str	r0, [r7, #0x2c]
; 	return reason;
 8005986: 6afb         	ldr	r3, [r7, #0x2c]
; }
 8005988: 4618         	mov	r0, r3
 800598a: 3738         	adds	r7, #0x38
 800598c: 46bd         	mov	sp, r7
 800598e: bd80         	pop	{r7, pc}

08005990 <$d>:
 8005990: c8 04 00 20  	.word	0x200004c8
 8005994: 20 e9 01 08  	.word	0x0801e920
 8005998: 00 ed 00 e0  	.word	0xe000ed00
 800599c: 38 e9 01 08  	.word	0x0801e938
 80059a0: 5c e9 01 08  	.word	0x0801e95c
 80059a4: 6c e9 01 08  	.word	0x0801e96c
 80059a8: 8c e9 01 08  	.word	0x0801e98c

080059ac <reserved_exception>:
; {
 80059ac: b580         	push	{r7, lr}
 80059ae: b08a         	sub	sp, #0x28
 80059b0: af06         	add	r7, sp, #0x18
 80059b2: 6078         	str	r0, [r7, #0x4]
 80059b4: 6039         	str	r1, [r7]
; 	PR_FAULT_INFO("***** %s %d) *****",
 80059b6: 2303         	movs	r3, #0x3
 80059b8: 2b00         	cmp	r3, #0x0
 80059ba: d021         	beq	0x8005a00 <reserved_exception+0x54> @ imm = #0x42
 80059bc: 2301         	movs	r3, #0x1
 80059be: 73fb         	strb	r3, [r7, #0xf]
 80059c0: 7bfb         	ldrb	r3, [r7, #0xf]
 80059c2: f083 0301    	eor	r3, r3, #0x1
 80059c6: b2db         	uxtb	r3, r3
 80059c8: 2b00         	cmp	r3, #0x0
 80059ca: d119         	bne	0x8005a00 <reserved_exception+0x54> @ imm = #0x32
 80059cc: 4b0e         	ldr	r3, [pc, #0x38]         @ 0x8005a08 <reserved_exception+0x5c>
 80059ce: 6819         	ldr	r1, [r3]
 80059d0: 683b         	ldr	r3, [r7]
 80059d2: 2b0f         	cmp	r3, #0xf
 80059d4: dc01         	bgt	0x80059da <reserved_exception+0x2e> @ imm = #0x2
 80059d6: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x8005a0c <reserved_exception+0x60>
 80059d8: e000         	b	0x80059dc <reserved_exception+0x30> @ imm = #0x0
 80059da: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x8005a10 <reserved_exception+0x64>
 80059dc: 683a         	ldr	r2, [r7]
 80059de: 3a10         	subs	r2, #0x10
 80059e0: 9204         	str	r2, [sp, #0x10]
 80059e2: 9303         	str	r3, [sp, #0xc]
 80059e4: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x8005a14 <reserved_exception+0x68>
 80059e6: 9302         	str	r3, [sp, #0x8]
 80059e8: 2300         	movs	r3, #0x0
 80059ea: 9301         	str	r3, [sp, #0x4]
 80059ec: 2300         	movs	r3, #0x0
 80059ee: 9300         	str	r3, [sp]
 80059f0: 2300         	movs	r3, #0x0
 80059f2: 2201         	movs	r2, #0x1
 80059f4: 2000         	movs	r0, #0x0
 80059f6: f010 f87d    	bl	0x8015af4 <z_log_msg_runtime_create> @ imm = #0x100fa
 80059fa: 2300         	movs	r3, #0x0
 80059fc: 60bb         	str	r3, [r7, #0x8]
; }
 80059fe: bf00         	nop
 8005a00: bf00         	nop
 8005a02: 3710         	adds	r7, #0x10
 8005a04: 46bd         	mov	sp, r7
 8005a06: bd80         	pop	{r7, pc}

08005a08 <$d>:
 8005a08: c8 04 00 20  	.word	0x200004c8
 8005a0c: a8 e9 01 08  	.word	0x0801e9a8
 8005a10: c0 e9 01 08  	.word	0x0801e9c0
 8005a14: dc e9 01 08  	.word	0x0801e9dc

08005a18 <fault_handle>:
; {
 8005a18: b580         	push	{r7, lr}
 8005a1a: b086         	sub	sp, #0x18
 8005a1c: af00         	add	r7, sp, #0x0
 8005a1e: 60f8         	str	r0, [r7, #0xc]
 8005a20: 60b9         	str	r1, [r7, #0x8]
 8005a22: 607a         	str	r2, [r7, #0x4]
; 	uint32_t reason = K_ERR_CPU_EXCEPTION;
 8005a24: 2300         	movs	r3, #0x0
 8005a26: 617b         	str	r3, [r7, #0x14]
; 	*recoverable = false;
 8005a28: 687b         	ldr	r3, [r7, #0x4]
 8005a2a: 2200         	movs	r2, #0x0
 8005a2c: 701a         	strb	r2, [r3]
; 	switch (fault) {
 8005a2e: 68bb         	ldr	r3, [r7, #0x8]
 8005a30: 3b03         	subs	r3, #0x3
 8005a32: 2b09         	cmp	r3, #0x9
 8005a34: d835         	bhi	0x8005aa2 <fault_handle+0x8a> @ imm = #0x6a
 8005a36: a201         	adr	r2, #4 <fault_handle+0x23>
 8005a38: f852 f023    	ldr.w	pc, [r2, r3, lsl #2]

08005a3c <$d>:
 8005a3c: 65 5a 00 08  	.word	0x08005a65
 8005a40: 71 5a 00 08  	.word	0x08005a71
 8005a44: 7f 5a 00 08  	.word	0x08005a7f
 8005a48: 8f 5a 00 08  	.word	0x08005a8f
 8005a4c: a3 5a 00 08  	.word	0x08005aa3
 8005a50: a3 5a 00 08  	.word	0x08005aa3
 8005a54: a3 5a 00 08  	.word	0x08005aa3
 8005a58: a3 5a 00 08  	.word	0x08005aa3
 8005a5c: a3 5a 00 08  	.word	0x08005aa3
 8005a60: 99 5a 00 08  	.word	0x08005a99

08005a64 <$t>:
; 		reason = hard_fault(esf, recoverable);
 8005a64: 6879         	ldr	r1, [r7, #0x4]
 8005a66: 68f8         	ldr	r0, [r7, #0xc]
 8005a68: f7ff feb6    	bl	0x80057d8 <hard_fault>  @ imm = #-0x294
 8005a6c: 6178         	str	r0, [r7, #0x14]
; 		break;
 8005a6e: e01d         	b	0x8005aac <fault_handle+0x94> @ imm = #0x3a
; 		reason = mem_manage_fault(esf, 0, recoverable);
 8005a70: 687a         	ldr	r2, [r7, #0x4]
 8005a72: 2100         	movs	r1, #0x0
 8005a74: 68f8         	ldr	r0, [r7, #0xc]
 8005a76: f7ff fa99    	bl	0x8004fac <mem_manage_fault> @ imm = #-0xace
 8005a7a: 6178         	str	r0, [r7, #0x14]
; 		break;
 8005a7c: e016         	b	0x8005aac <fault_handle+0x94> @ imm = #0x2c
; 		reason = bus_fault(esf, 0, recoverable);
 8005a7e: 687a         	ldr	r2, [r7, #0x4]
 8005a80: 2100         	movs	r1, #0x0
 8005a82: 68f8         	ldr	r0, [r7, #0xc]
 8005a84: f7ff fbd6    	bl	0x8005234 <bus_fault>   @ imm = #-0x854
 8005a88: 4603         	mov	r3, r0
 8005a8a: 617b         	str	r3, [r7, #0x14]
; 		break;
 8005a8c: e00e         	b	0x8005aac <fault_handle+0x94> @ imm = #0x1c
; 		reason = usage_fault(esf);
 8005a8e: 68f8         	ldr	r0, [r7, #0xc]
 8005a90: f7ff fd20    	bl	0x80054d4 <usage_fault> @ imm = #-0x5c0
 8005a94: 6178         	str	r0, [r7, #0x14]
; 		break;
 8005a96: e009         	b	0x8005aac <fault_handle+0x94> @ imm = #0x12
; 		debug_monitor(esf, recoverable);
 8005a98: 6879         	ldr	r1, [r7, #0x4]
 8005a9a: 68f8         	ldr	r0, [r7, #0xc]
 8005a9c: f7ff fe30    	bl	0x8005700 <debug_monitor> @ imm = #-0x3a0
; 		break;
 8005aa0: e004         	b	0x8005aac <fault_handle+0x94> @ imm = #0x8
; 		reserved_exception(esf, fault);
 8005aa2: 68b9         	ldr	r1, [r7, #0x8]
 8005aa4: 68f8         	ldr	r0, [r7, #0xc]
 8005aa6: f7ff ff81    	bl	0x80059ac <reserved_exception> @ imm = #-0xfe
; 		break;
 8005aaa: bf00         	nop
; 	if ((*recoverable) == false) {
 8005aac: 687b         	ldr	r3, [r7, #0x4]
 8005aae: 781b         	ldrb	r3, [r3]
 8005ab0: f083 0301    	eor	r3, r3, #0x1
 8005ab4: b2db         	uxtb	r3, r3
 8005ab6: 2b00         	cmp	r3, #0x0
 8005ab8: d003         	beq	0x8005ac2 <fault_handle+0xaa> @ imm = #0x6
; 		fault_show(esf, fault);
 8005aba: 68b9         	ldr	r1, [r7, #0x8]
 8005abc: 68f8         	ldr	r0, [r7, #0xc]
 8005abe: f010 f837    	bl	0x8015b30 <fault_show>  @ imm = #0x1006e
; 	return reason;
 8005ac2: 697b         	ldr	r3, [r7, #0x14]
; }
 8005ac4: 4618         	mov	r0, r3
 8005ac6: 3718         	adds	r7, #0x18
 8005ac8: 46bd         	mov	sp, r7
 8005aca: bd80         	pop	{r7, pc}

08005acc <get_esf>:
; {
 8005acc: b580         	push	{r7, lr}
 8005ace: b08c         	sub	sp, #0x30
 8005ad0: af04         	add	r7, sp, #0x10
 8005ad2: 60f8         	str	r0, [r7, #0xc]
 8005ad4: 60b9         	str	r1, [r7, #0x8]
 8005ad6: 607a         	str	r2, [r7, #0x4]
 8005ad8: 603b         	str	r3, [r7]
; 	bool alternative_state_exc = false;
 8005ada: 2300         	movs	r3, #0x0
 8005adc: 76fb         	strb	r3, [r7, #0x1b]
; 	struct arch_esf *ptr_esf = NULL;
 8005ade: 2300         	movs	r3, #0x0
 8005ae0: 61fb         	str	r3, [r7, #0x1c]
; 	*nested_exc = false;
 8005ae2: 683b         	ldr	r3, [r7]
 8005ae4: 2200         	movs	r2, #0x0
 8005ae6: 701a         	strb	r2, [r3]
; 	if ((exc_return & EXC_RETURN_INDICATOR_PREFIX) !=
 8005ae8: 687b         	ldr	r3, [r7, #0x4]
 8005aea: f003 437f    	and	r3, r3, #0xff000000
 8005aee: f1b3 4f7f    	cmp.w	r3, #0xff000000
 8005af2: d001         	beq	0x8005af8 <get_esf+0x2c> @ imm = #0x2
; 		return NULL;
 8005af4: 2300         	movs	r3, #0x0
 8005af6: e039         	b	0x8005b6c <get_esf+0xa0> @ imm = #0x72
; 	if ((exc_return & EXC_RETURN_MODE_THREAD) &&
 8005af8: 687b         	ldr	r3, [r7, #0x4]
 8005afa: f003 0308    	and	r3, r3, #0x8
 8005afe: 2b00         	cmp	r3, #0x0
 8005b00: d020         	beq	0x8005b44 <get_esf+0x78> @ imm = #0x40
; 		(!(exc_return & EXC_RETURN_SPSEL_PROCESS))) {
 8005b02: 687b         	ldr	r3, [r7, #0x4]
 8005b04: f003 0304    	and	r3, r3, #0x4
; 	if ((exc_return & EXC_RETURN_MODE_THREAD) &&
 8005b08: 2b00         	cmp	r3, #0x0
 8005b0a: d11b         	bne	0x8005b44 <get_esf+0x78> @ imm = #0x36
; 		PR_EXC("SPSEL in thread mode does not indicate PSP");
 8005b0c: 2303         	movs	r3, #0x3
 8005b0e: 2b00         	cmp	r3, #0x0
 8005b10: d016         	beq	0x8005b40 <get_esf+0x74> @ imm = #0x2c
 8005b12: 2301         	movs	r3, #0x1
 8005b14: 76bb         	strb	r3, [r7, #0x1a]
 8005b16: 7ebb         	ldrb	r3, [r7, #0x1a]
 8005b18: f083 0301    	eor	r3, r3, #0x1
 8005b1c: b2db         	uxtb	r3, r3
 8005b1e: 2b00         	cmp	r3, #0x0
 8005b20: d10e         	bne	0x8005b40 <get_esf+0x74> @ imm = #0x1c
 8005b22: 4b14         	ldr	r3, [pc, #0x50]         @ 0x8005b74 <get_esf+0xa8>
 8005b24: 6819         	ldr	r1, [r3]
 8005b26: 4b14         	ldr	r3, [pc, #0x50]         @ 0x8005b78 <get_esf+0xac>
 8005b28: 9302         	str	r3, [sp, #0x8]
 8005b2a: 2300         	movs	r3, #0x0
 8005b2c: 9301         	str	r3, [sp, #0x4]
 8005b2e: 2300         	movs	r3, #0x0
 8005b30: 9300         	str	r3, [sp]
 8005b32: 2300         	movs	r3, #0x0
 8005b34: 2201         	movs	r2, #0x1
 8005b36: 2000         	movs	r0, #0x0
 8005b38: f00f ffdc    	bl	0x8015af4 <z_log_msg_runtime_create> @ imm = #0xffb8
 8005b3c: 2300         	movs	r3, #0x0
 8005b3e: 617b         	str	r3, [r7, #0x14]
; 		return NULL;
 8005b40: 2300         	movs	r3, #0x0
 8005b42: e013         	b	0x8005b6c <get_esf+0xa0> @ imm = #0x26
; 	if (!alternative_state_exc) {
 8005b44: 7efb         	ldrb	r3, [r7, #0x1b]
 8005b46: f083 0301    	eor	r3, r3, #0x1
 8005b4a: b2db         	uxtb	r3, r3
 8005b4c: 2b00         	cmp	r3, #0x0
 8005b4e: d00c         	beq	0x8005b6a <get_esf+0x9e> @ imm = #0x18
; 		if (exc_return & EXC_RETURN_MODE_THREAD) {
 8005b50: 687b         	ldr	r3, [r7, #0x4]
 8005b52: f003 0308    	and	r3, r3, #0x8
 8005b56: 2b00         	cmp	r3, #0x0
 8005b58: d002         	beq	0x8005b60 <get_esf+0x94> @ imm = #0x4
; 			ptr_esf =  (struct arch_esf *)psp;
 8005b5a: 68bb         	ldr	r3, [r7, #0x8]
 8005b5c: 61fb         	str	r3, [r7, #0x1c]
 8005b5e: e004         	b	0x8005b6a <get_esf+0x9e> @ imm = #0x8
; 			ptr_esf = (struct arch_esf *)msp;
 8005b60: 68fb         	ldr	r3, [r7, #0xc]
 8005b62: 61fb         	str	r3, [r7, #0x1c]
; 			*nested_exc = true;
 8005b64: 683b         	ldr	r3, [r7]
 8005b66: 2201         	movs	r2, #0x1
 8005b68: 701a         	strb	r2, [r3]
; 	return ptr_esf;
 8005b6a: 69fb         	ldr	r3, [r7, #0x1c]
; }
 8005b6c: 4618         	mov	r0, r3
 8005b6e: 3720         	adds	r7, #0x20
 8005b70: 46bd         	mov	sp, r7
 8005b72: bd80         	pop	{r7, pc}

08005b74 <$d>:
 8005b74: c8 04 00 20  	.word	0x200004c8
 8005b78: f0 e9 01 08  	.word	0x0801e9f0

08005b7c <z_arm_fault>:
; {
 8005b7c: b580         	push	{r7, lr}
 8005b7e: b094         	sub	sp, #0x50
 8005b80: af00         	add	r7, sp, #0x0
 8005b82: 60f8         	str	r0, [r7, #0xc]
 8005b84: 60b9         	str	r1, [r7, #0x8]
 8005b86: 607a         	str	r2, [r7, #0x4]
 8005b88: 603b         	str	r3, [r7]
; 	uint32_t reason = K_ERR_CPU_EXCEPTION;
 8005b8a: 2300         	movs	r3, #0x0
 8005b8c: 64fb         	str	r3, [r7, #0x4c]
; 	int fault = SCB->ICSR & SCB_ICSR_VECTACTIVE_Msk;
 8005b8e: 4b29         	ldr	r3, [pc, #0xa4]         @ 0x8005c34 <z_arm_fault+0xb8>
 8005b90: 685b         	ldr	r3, [r3, #0x4]
 8005b92: f3c3 0308    	ubfx	r3, r3, #0x0, #0x9
 8005b96: 64bb         	str	r3, [r7, #0x48]
 8005b98: 2300         	movs	r3, #0x0
 8005b9a: 63bb         	str	r3, [r7, #0x38]
 8005b9c: 6bbb         	ldr	r3, [r7, #0x38]
 8005b9e: 637b         	str	r3, [r7, #0x34]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8005ba0: 6b7b         	ldr	r3, [r7, #0x34]
 8005ba2: f383 8811    	msr	basepri, r3
; }
 8005ba6: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8005ba8: f3bf 8f6f    	isb	sy
; }
 8005bac: bf00         	nop
; }
 8005bae: bf00         	nop
; 	 esf = get_esf(msp, psp, exc_return, &nested_exc);
 8005bb0: f107 0332    	add.w	r3, r7, #0x32
 8005bb4: 687a         	ldr	r2, [r7, #0x4]
 8005bb6: 68b9         	ldr	r1, [r7, #0x8]
 8005bb8: 68f8         	ldr	r0, [r7, #0xc]
 8005bba: f7ff ff87    	bl	0x8005acc <get_esf>     @ imm = #-0xf2
 8005bbe: 6478         	str	r0, [r7, #0x44]
 8005bc0: 6c7b         	ldr	r3, [r7, #0x44]
 8005bc2: 643b         	str	r3, [r7, #0x40]
 8005bc4: 687b         	ldr	r3, [r7, #0x4]
 8005bc6: 63fb         	str	r3, [r7, #0x3c]
; }
 8005bc8: bf00         	nop
; 	reason = fault_handle(esf, fault, &recoverable);
 8005bca: f107 0333    	add.w	r3, r7, #0x33
 8005bce: 461a         	mov	r2, r3
 8005bd0: 6cb9         	ldr	r1, [r7, #0x48]
 8005bd2: 6c78         	ldr	r0, [r7, #0x44]
 8005bd4: f7ff ff20    	bl	0x8005a18 <fault_handle> @ imm = #-0x1c0
 8005bd8: 64f8         	str	r0, [r7, #0x4c]
; 	if (recoverable) {
 8005bda: f897 3033    	ldrb.w	r3, [r7, #0x33]
 8005bde: 2b00         	cmp	r3, #0x0
 8005be0: d123         	bne	0x8005c2a <z_arm_fault+0xae> @ imm = #0x46
; 	memcpy(&esf_copy, esf, sizeof(struct arch_esf));
 8005be2: f107 0310    	add.w	r3, r7, #0x10
 8005be6: 2220         	movs	r2, #0x20
 8005be8: 6c79         	ldr	r1, [r7, #0x44]
 8005bea: 4618         	mov	r0, r3
 8005bec: f017 fdf0    	bl	0x801d7d0 <memcpy>      @ imm = #0x17be0
; 	if (nested_exc) {
 8005bf0: f897 3032    	ldrb.w	r3, [r7, #0x32]
 8005bf4: 2b00         	cmp	r3, #0x0
 8005bf6: d00b         	beq	0x8005c10 <z_arm_fault+0x94> @ imm = #0x16
; 		if ((esf_copy.basic.xpsr & IPSR_ISR_Msk) == 0) {
 8005bf8: 6afb         	ldr	r3, [r7, #0x2c]
 8005bfa: f3c3 0308    	ubfx	r3, r3, #0x0, #0x9
 8005bfe: 2b00         	cmp	r3, #0x0
 8005c00: d10c         	bne	0x8005c1c <z_arm_fault+0xa0> @ imm = #0x18
; 			esf_copy.basic.xpsr |= IPSR_ISR_Msk;
 8005c02: 6afb         	ldr	r3, [r7, #0x2c]
 8005c04: ea6f 2353    	mvn.w	r3, r3, lsr #9
 8005c08: ea6f 2343    	mvn.w	r3, r3, lsl #9
 8005c0c: 62fb         	str	r3, [r7, #0x2c]
 8005c0e: e005         	b	0x8005c1c <z_arm_fault+0xa0> @ imm = #0xa
; 		esf_copy.basic.xpsr &= ~(IPSR_ISR_Msk);
 8005c10: 6afb         	ldr	r3, [r7, #0x2c]
 8005c12: f423 73ff    	bic	r3, r3, #0x1fe
 8005c16: f023 0301    	bic	r3, r3, #0x1
 8005c1a: 62fb         	str	r3, [r7, #0x2c]
; 	z_arm_fatal_error(reason, &esf_copy);
 8005c1c: f107 0310    	add.w	r3, r7, #0x10
 8005c20: 4619         	mov	r1, r3
 8005c22: 6cf8         	ldr	r0, [r7, #0x4c]
 8005c24: f7ff f92e    	bl	0x8004e84 <z_arm_fatal_error> @ imm = #-0xda4
 8005c28: e000         	b	0x8005c2c <z_arm_fault+0xb0> @ imm = #0x0
; 		return;
 8005c2a: bf00         	nop
; }
 8005c2c: 3750         	adds	r7, #0x50
 8005c2e: 46bd         	mov	sp, r7
 8005c30: bd80         	pop	{r7, pc}
 8005c32: bf00         	nop

08005c34 <$d>:
 8005c34: 00 ed 00 e0  	.word	0xe000ed00

08005c38 <z_arm_fault_init>:
; {
 8005c38: b480         	push	{r7}
 8005c3a: af00         	add	r7, sp, #0x0
; 	SCB->CCR |= SCB_CCR_DIV_0_TRP_Msk;
 8005c3c: 4b07         	ldr	r3, [pc, #0x1c]         @ 0x8005c5c <z_arm_fault_init+0x24>
 8005c3e: 695b         	ldr	r3, [r3, #0x14]
 8005c40: 4a06         	ldr	r2, [pc, #0x18]         @ 0x8005c5c <z_arm_fault_init+0x24>
 8005c42: f043 0310    	orr	r3, r3, #0x10
 8005c46: 6153         	str	r3, [r2, #0x14]
; 	SCB->CCR &= ~SCB_CCR_UNALIGN_TRP_Msk;
 8005c48: 4b04         	ldr	r3, [pc, #0x10]         @ 0x8005c5c <z_arm_fault_init+0x24>
 8005c4a: 695b         	ldr	r3, [r3, #0x14]
 8005c4c: 4a03         	ldr	r2, [pc, #0xc]          @ 0x8005c5c <z_arm_fault_init+0x24>
 8005c4e: f023 0308    	bic	r3, r3, #0x8
 8005c52: 6153         	str	r3, [r2, #0x14]
; }
 8005c54: bf00         	nop
 8005c56: 46bd         	mov	sp, r7
 8005c58: bc80         	pop	{r7}
 8005c5a: 4770         	bx	lr

08005c5c <$d>:
 8005c5c: 00 ed 00 e0  	.word	0xe000ed00

08005c60 <z_arm_usage_fault>:
; 	mrs r0, MSP
 8005c60: f3ef 8008    	mrs	r0, msp
; 	mrs r1, PSP
 8005c64: f3ef 8109    	mrs	r1, psp
; 	push {r0, lr}
 8005c68: b501         	push	{r0, lr}
; 	mov r2, lr /* EXC_RETURN */
 8005c6a: 4672         	mov	r2, lr
; 	bl z_arm_fault
 8005c6c: f7ff ff86    	bl	0x8005b7c <z_arm_fault> @ imm = #-0xf4
; 	pop {r0, pc}
 8005c70: bd01         	pop	{r0, pc}
 8005c72: bf00         	nop

08005c74 <z_arm_reset>:
;     movs.n r0, #_EXC_IRQ_DEFAULT_PRIO
 8005c74: 2010         	movs	r0, #0x10
;     msr BASEPRI, r0
 8005c76: f380 8811    	msr	basepri, r0
;     ldr r0, =z_interrupt_stacks
 8005c7a: 480b         	ldr	r0, [pc, #0x2c]         @ 0x8005ca8 <z_arm_reset+0x34>
;     ldr r1, =0xaa
 8005c7c: f04f 01aa    	mov.w	r1, #0xaa
;     ldr r2, =CONFIG_ISR_STACK_SIZE + MPU_GUARD_ALIGN_AND_SIZE
 8005c80: f44f 6200    	mov.w	r2, #0x800
;     bl z_early_memset
 8005c84: f016 f857    	bl	0x801bd36 <z_early_memset> @ imm = #0x160ae
;     ldr r0, =z_interrupt_stacks
 8005c88: 4807         	ldr	r0, [pc, #0x1c]         @ 0x8005ca8 <z_arm_reset+0x34>
;     ldr r1, =CONFIG_ISR_STACK_SIZE + MPU_GUARD_ALIGN_AND_SIZE
 8005c8a: f44f 6100    	mov.w	r1, #0x800
;     adds r0, r0, r1
 8005c8e: 1840         	adds	r0, r0, r1
;     msr PSP, r0
 8005c90: f380 8809    	msr	psp, r0
;     mrs r0, CONTROL
 8005c94: f3ef 8014    	mrs	r0, control
;     movs r1, #2
 8005c98: 2102         	movs	r1, #0x2
;     orrs r0, r1 /* CONTROL_SPSEL_Msk */
 8005c9a: 4308         	orrs	r0, r1
;     msr CONTROL, r0
 8005c9c: f380 8814    	msr	control, r0
;     isb
 8005ca0: f3bf 8f6f    	isb	sy
;     bl z_prep_c
 8005ca4: f00f ff86    	bl	0x8015bb4 <z_prep_c>    @ imm = #0xff0c

08005ca8 <$d>:
 8005ca8: d0 37 00 20  	.word	0x200037d0

08005cac <z_impl_k_thread_abort>:
; {
 8005cac: b580         	push	{r7, lr}
 8005cae: b084         	sub	sp, #0x10
 8005cb0: af00         	add	r7, sp, #0x0
 8005cb2: 6078         	str	r0, [r7, #0x4]
; 	struct k_thread *ret = _kernel.cpus[0].current;
 8005cb4: 4b12         	ldr	r3, [pc, #0x48]         @ 0x8005d00 <z_impl_k_thread_abort+0x54>
 8005cb6: 689b         	ldr	r3, [r3, #0x8]
 8005cb8: 60fb         	str	r3, [r7, #0xc]
; 	return ret;
 8005cba: 68fb         	ldr	r3, [r7, #0xc]
; 	if (arch_current_thread() == thread) {
 8005cbc: 687a         	ldr	r2, [r7, #0x4]
 8005cbe: 429a         	cmp	r2, r3
 8005cc0: d116         	bne	0x8005cf0 <z_impl_k_thread_abort+0x44> @ imm = #0x2c
;   __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 8005cc2: f3ef 8305    	mrs	r3, ipsr
 8005cc6: 60bb         	str	r3, [r7, #0x8]
;   return(result);
 8005cc8: 68bb         	ldr	r3, [r7, #0x8]
; 	return (__get_IPSR()) ? (true) : (false);
 8005cca: 2b00         	cmp	r3, #0x0
 8005ccc: bf14         	ite	ne
 8005cce: 2301         	movne	r3, #0x1
 8005cd0: 2300         	moveq	r3, #0x0
 8005cd2: b2db         	uxtb	r3, r3
; 		if (arch_is_in_isr()) {
 8005cd4: 2b00         	cmp	r3, #0x0
 8005cd6: d00b         	beq	0x8005cf0 <z_impl_k_thread_abort+0x44> @ imm = #0x16
; 			SCB->ICSR |= SCB_ICSR_PENDSVSET_Msk;
 8005cd8: 4b0a         	ldr	r3, [pc, #0x28]         @ 0x8005d04 <z_impl_k_thread_abort+0x58>
 8005cda: 685b         	ldr	r3, [r3, #0x4]
 8005cdc: 4a09         	ldr	r2, [pc, #0x24]         @ 0x8005d04 <z_impl_k_thread_abort+0x58>
 8005cde: f043 5380    	orr	r3, r3, #0x10000000
 8005ce2: 6053         	str	r3, [r2, #0x4]
; 			SCB->SHCSR &= ~SCB_SHCSR_SVCALLPENDED_Msk;
 8005ce4: 4b07         	ldr	r3, [pc, #0x1c]         @ 0x8005d04 <z_impl_k_thread_abort+0x58>
 8005ce6: 6a5b         	ldr	r3, [r3, #0x24]
 8005ce8: 4a06         	ldr	r2, [pc, #0x18]         @ 0x8005d04 <z_impl_k_thread_abort+0x58>
 8005cea: f423 4300    	bic	r3, r3, #0x8000
 8005cee: 6253         	str	r3, [r2, #0x24]
; 	z_thread_abort(thread);
 8005cf0: 6878         	ldr	r0, [r7, #0x4]
 8005cf2: f00a fcb7    	bl	0x8010664 <z_thread_abort> @ imm = #0xa96e
; }
 8005cf6: bf00         	nop
 8005cf8: 3710         	adds	r7, #0x10
 8005cfa: 46bd         	mov	sp, r7
 8005cfc: bd80         	pop	{r7, pc}
 8005cfe: bf00         	nop

08005d00 <$d>:
 8005d00: f0 16 00 20  	.word	0x200016f0
 8005d04: 00 ed 00 e0  	.word	0xe000ed00

08005d08 <arch_swap>:
; {
 8005d08: b480         	push	{r7}
 8005d0a: b089         	sub	sp, #0x24
 8005d0c: af00         	add	r7, sp, #0x0
 8005d0e: 6078         	str	r0, [r7, #0x4]
; 	struct k_thread *ret = _kernel.cpus[0].current;
 8005d10: 4b15         	ldr	r3, [pc, #0x54]         @ 0x8005d68 <arch_swap+0x60>
 8005d12: 689b         	ldr	r3, [r3, #0x8]
 8005d14: 60fb         	str	r3, [r7, #0xc]
; 	return ret;
 8005d16: 68fb         	ldr	r3, [r7, #0xc]
; 	arch_current_thread()->arch.basepri = key;
 8005d18: 687a         	ldr	r2, [r7, #0x4]
 8005d1a: f8c3 20c8    	str.w	r2, [r3, #0xc8]
; 	struct k_thread *ret = _kernel.cpus[0].current;
 8005d1e: 4b12         	ldr	r3, [pc, #0x48]         @ 0x8005d68 <arch_swap+0x60>
 8005d20: 689b         	ldr	r3, [r3, #0x8]
 8005d22: 613b         	str	r3, [r7, #0x10]
; 	return ret;
 8005d24: 693b         	ldr	r3, [r7, #0x10]
; 	arch_current_thread()->arch.swap_return_value = -EAGAIN;
 8005d26: f06f 020a    	mvn	r2, #0xa
 8005d2a: f8c3 20cc    	str.w	r2, [r3, #0xcc]
; 	SCB->ICSR |= SCB_ICSR_PENDSVSET_Msk;
 8005d2e: 4b0f         	ldr	r3, [pc, #0x3c]         @ 0x8005d6c <arch_swap+0x64>
 8005d30: 685b         	ldr	r3, [r3, #0x4]
 8005d32: 4a0e         	ldr	r2, [pc, #0x38]         @ 0x8005d6c <arch_swap+0x64>
 8005d34: f043 5380    	orr	r3, r3, #0x10000000
 8005d38: 6053         	str	r3, [r2, #0x4]
 8005d3a: 2300         	movs	r3, #0x0
 8005d3c: 61bb         	str	r3, [r7, #0x18]
 8005d3e: 69bb         	ldr	r3, [r7, #0x18]
 8005d40: 617b         	str	r3, [r7, #0x14]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8005d42: 697b         	ldr	r3, [r7, #0x14]
 8005d44: f383 8811    	msr	basepri, r3
; }
 8005d48: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8005d4a: f3bf 8f6f    	isb	sy
; }
 8005d4e: bf00         	nop
; }
 8005d50: bf00         	nop
; 	struct k_thread *ret = _kernel.cpus[0].current;
 8005d52: 4b05         	ldr	r3, [pc, #0x14]         @ 0x8005d68 <arch_swap+0x60>
 8005d54: 689b         	ldr	r3, [r3, #0x8]
 8005d56: 61fb         	str	r3, [r7, #0x1c]
; 	return ret;
 8005d58: 69fb         	ldr	r3, [r7, #0x1c]
; 	return arch_current_thread()->arch.swap_return_value;
 8005d5a: f8d3 30cc    	ldr.w	r3, [r3, #0xcc]
; }
 8005d5e: 4618         	mov	r0, r3
 8005d60: 3724         	adds	r7, #0x24
 8005d62: 46bd         	mov	sp, r7
 8005d64: bc80         	pop	{r7}
 8005d66: 4770         	bx	lr

08005d68 <$d>:
 8005d68: f0 16 00 20  	.word	0x200016f0
 8005d6c: 00 ed 00 e0  	.word	0xe000ed00

08005d70 <z_arm_pendsv>:
;     push {r0, lr}
 8005d70: b501         	push	{r0, lr}
;     bl z_thread_mark_switched_out
 8005d72: f016 ff2e    	bl	0x801cbd2 <z_thread_mark_switched_out> @ imm = #0x16e5c
;     pop {r0, lr}
 8005d76: e8bd 4001    	pop.w	{r0, lr}
;     ldr r1, =_kernel
 8005d7a: 4916         	ldr	r1, [pc, #0x58]         @ 0x8005dd4 <z_arm_pendsv+0x64>
;     ldr r2, [r1, #_kernel_offset_to_current]
 8005d7c: 688a         	ldr	r2, [r1, #0x8]
;     ldr r0, =_thread_offset_to_callee_saved
 8005d7e: f04f 0040    	mov.w	r0, #0x40
;     add r0, r2
 8005d82: 4410         	add	r0, r2
;     mrs ip, PSP
 8005d84: f3ef 8c09    	mrs	r12, psp
;     stmia r0, {r4-r11, ip}
 8005d88: e880 1ff0    	stm.w	r0, {r4, r5, r6, r7, r8, r9, r10, r11, r12}
;     movs.n r0, #_EXC_IRQ_DEFAULT_PRIO
 8005d8c: 2010         	movs	r0, #0x10
;     msr BASEPRI_MAX, r0
 8005d8e: f380 8812    	msr	basepri_max, r0
;     isb /* Make the effect of disabling interrupts be realized immediately */
 8005d92: f3bf 8f6f    	isb	sy
;     ldr r7, =_SCS_ICSR
 8005d96: 4f10         	ldr	r7, [pc, #0x40]         @ 0x8005dd8 <z_arm_pendsv+0x68>
;     ldr r6, =_SCS_ICSR_UNPENDSV
 8005d98: f04f 6600    	mov.w	r6, #0x8000000
;     ldr r2, [r1, #_kernel_offset_to_ready_q_cache]
 8005d9c: 69ca         	ldr	r2, [r1, #0x1c]
;     str r2, [r1, #_kernel_offset_to_current]
 8005d9e: 608a         	str	r2, [r1, #0x8]
;     str r6, [r7, #0]
 8005da0: 603e         	str	r6, [r7]
;     ldr r4, =_thread_offset_to_tls
 8005da2: f04f 04c4    	mov.w	r4, #0xc4
;     adds r4, r2, r4
 8005da6: 1914         	adds	r4, r2, r4
;     ldr r0, [r4]
 8005da8: 6820         	ldr	r0, [r4]
;     ldr r4, =z_arm_tls_ptr
 8005daa: 4c0c         	ldr	r4, [pc, #0x30]         @ 0x8005ddc <z_arm_pendsv+0x6c>
;     str r0, [r4]
 8005dac: 6020         	str	r0, [r4]
;     ldr r0, [r2, #_thread_offset_to_basepri]
 8005dae: f8d2 00c8    	ldr.w	r0, [r2, #0xc8]
;     movs r3, #0
 8005db2: 2300         	movs	r3, #0x0
;     str r3, [r2, #_thread_offset_to_basepri]
 8005db4: f8c2 30c8    	str.w	r3, [r2, #0xc8]
;     msr BASEPRI, r0
 8005db8: f380 8811    	msr	basepri, r0
;     add r0, r2, #_thread_offset_to_callee_saved
 8005dbc: f102 0040    	add.w	r0, r2, #0x40
;     ldmia r0, {r4-r11, ip}
 8005dc0: e890 1ff0    	ldm.w	r0, {r4, r5, r6, r7, r8, r9, r10, r11, r12}
;     msr PSP, ip
 8005dc4: f38c 8809    	msr	psp, r12
;     push {r0, lr}
 8005dc8: b501         	push	{r0, lr}
;     bl z_thread_mark_switched_in
 8005dca: f009 f8a9    	bl	0x800ef20 <z_thread_mark_switched_in> @ imm = #0x9152
;     pop {r0, lr}
 8005dce: e8bd 4001    	pop.w	{r0, lr}
;     bx lr
 8005dd2: 4770         	bx	lr

08005dd4 <$d>:
 8005dd4: f0 16 00 20  	.word	0x200016f0
 8005dd8: 04 ed 00 e0  	.word	0xe000ed04
 8005ddc: 40 1c 00 20  	.word	0x20001c40

08005de0 <z_arm_svc>:
;     tst lr, #_EXC_RETURN_SPSEL_Msk /* did we come from thread mode ? */
 8005de0: f01e 0f04    	tst.w	lr, #0x4
;     ite eq  /* if zero (equal), came from handler mode */
 8005de4: bf0c         	ite	eq
;         mrseq r0, MSP   /* handler mode, stack frame is on MSP */
 8005de6: f3ef 8008    	mrseq	r0, msp
;         mrsne r0, PSP   /* thread mode, stack frame is on PSP */
 8005dea: f3ef 8009    	mrsne	r0, psp
;     ldr r1, [r0, #24]   /* grab address of PC from stack frame */
 8005dee: 6981         	ldr	r1, [r0, #0x18]
;     ldrb r1, [r1, #-2]
 8005df0: f811 1c02    	ldrb	r1, [r1, #-2]
;     cmp r1, #2
 8005df4: 2902         	cmp	r1, #0x2
;     beq _oops
 8005df6: d0ff         	beq	0x8005df8 <_oops>       @ imm = #-0x2

08005df8 <_oops>:
;     push {r0, lr}
 8005df8: b501         	push	{r0, lr}
;     mov r2, lr /* EXC_RETURN */
 8005dfa: 4672         	mov	r2, lr
;     bl z_do_kernel_oops
 8005dfc: f00f fe46    	bl	0x8015a8c <z_do_kernel_oops> @ imm = #0xfc8c
;     pop {r0, pc}
 8005e00: bd01         	pop	{r0, pc}
 8005e02: bf00         	nop

08005e04 <__NVIC_EnableIRQ>:
; {
 8005e04: b480         	push	{r7}
 8005e06: b083         	sub	sp, #0xc
 8005e08: af00         	add	r7, sp, #0x0
 8005e0a: 4603         	mov	r3, r0
 8005e0c: 71fb         	strb	r3, [r7, #0x7]
;   if ((int32_t)(IRQn) >= 0)
 8005e0e: f997 3007    	ldrsb.w	r3, [r7, #0x7]
 8005e12: 2b00         	cmp	r3, #0x0
 8005e14: db0b         	blt	0x8005e2e <__NVIC_EnableIRQ+0x2a> @ imm = #0x16
;     NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 8005e16: 79fb         	ldrb	r3, [r7, #0x7]
 8005e18: f003 021f    	and	r2, r3, #0x1f
 8005e1c: 4906         	ldr	r1, [pc, #0x18]         @ 0x8005e38 <__NVIC_EnableIRQ+0x34>
 8005e1e: f997 3007    	ldrsb.w	r3, [r7, #0x7]
 8005e22: 095b         	lsrs	r3, r3, #0x5
 8005e24: 2001         	movs	r0, #0x1
 8005e26: fa00 f202    	lsl.w	r2, r0, r2
 8005e2a: f841 2023    	str.w	r2, [r1, r3, lsl #2]
; }
 8005e2e: bf00         	nop
 8005e30: 370c         	adds	r7, #0xc
 8005e32: 46bd         	mov	sp, r7
 8005e34: bc80         	pop	{r7}
 8005e36: 4770         	bx	lr

08005e38 <$d>:
 8005e38: 00 e1 00 e0  	.word	0xe000e100

08005e3c <__NVIC_SetPriority>:
; {
 8005e3c: b480         	push	{r7}
 8005e3e: b083         	sub	sp, #0xc
 8005e40: af00         	add	r7, sp, #0x0
 8005e42: 4603         	mov	r3, r0
 8005e44: 6039         	str	r1, [r7]
 8005e46: 71fb         	strb	r3, [r7, #0x7]
;   if ((int32_t)(IRQn) >= 0)
 8005e48: f997 3007    	ldrsb.w	r3, [r7, #0x7]
 8005e4c: 2b00         	cmp	r3, #0x0
 8005e4e: db0a         	blt	0x8005e66 <__NVIC_SetPriority+0x2a> @ imm = #0x14
;     NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8005e50: 683b         	ldr	r3, [r7]
 8005e52: b2da         	uxtb	r2, r3
 8005e54: 490c         	ldr	r1, [pc, #0x30]         @ 0x8005e88 <__NVIC_SetPriority+0x4c>
 8005e56: f997 3007    	ldrsb.w	r3, [r7, #0x7]
 8005e5a: 0112         	lsls	r2, r2, #0x4
 8005e5c: b2d2         	uxtb	r2, r2
 8005e5e: 440b         	add	r3, r1
 8005e60: f883 2300    	strb.w	r2, [r3, #0x300]
; }
 8005e64: e00a         	b	0x8005e7c <__NVIC_SetPriority+0x40> @ imm = #0x14
;     SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8005e66: 683b         	ldr	r3, [r7]
 8005e68: b2da         	uxtb	r2, r3
 8005e6a: 4908         	ldr	r1, [pc, #0x20]         @ 0x8005e8c <__NVIC_SetPriority+0x50>
 8005e6c: 79fb         	ldrb	r3, [r7, #0x7]
 8005e6e: f003 030f    	and	r3, r3, #0xf
 8005e72: 3b04         	subs	r3, #0x4
 8005e74: 0112         	lsls	r2, r2, #0x4
 8005e76: b2d2         	uxtb	r2, r2
 8005e78: 440b         	add	r3, r1
 8005e7a: 761a         	strb	r2, [r3, #0x18]
; }
 8005e7c: bf00         	nop
 8005e7e: 370c         	adds	r7, #0xc
 8005e80: 46bd         	mov	sp, r7
 8005e82: bc80         	pop	{r7}
 8005e84: 4770         	bx	lr
 8005e86: bf00         	nop

08005e88 <$d>:
 8005e88: 00 e1 00 e0  	.word	0xe000e100
 8005e8c: 00 ed 00 e0  	.word	0xe000ed00

08005e90 <relocate_vector_table>:
; {
 8005e90: b480         	push	{r7}
 8005e92: af00         	add	r7, sp, #0x0
; 	SCB->VTOR = VECTOR_ADDRESS & SCB_VTOR_TBLOFF_Msk;
 8005e94: 4b09         	ldr	r3, [pc, #0x24]         @ 0x8005ebc <relocate_vector_table+0x2c>
 8005e96: 4a0a         	ldr	r2, [pc, #0x28]         @ 0x8005ec0 <relocate_vector_table+0x30>
 8005e98: f023 037f    	bic	r3, r3, #0x7f
 8005e9c: 6093         	str	r3, [r2, #0x8]
;   __ASM volatile ("dsb 0xF":::"memory");
 8005e9e: f3bf 8f4f    	dsb	sy
; }
 8005ea2: bf00         	nop
; }
 8005ea4: bf00         	nop
; }
 8005ea6: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8005ea8: f3bf 8f6f    	isb	sy
; }
 8005eac: bf00         	nop
; }
 8005eae: bf00         	nop
; }
 8005eb0: bf00         	nop
; }
 8005eb2: bf00         	nop
 8005eb4: 46bd         	mov	sp, r7
 8005eb6: bc80         	pop	{r7}
 8005eb8: 4770         	bx	lr
 8005eba: bf00         	nop

08005ebc <$d>:
 8005ebc: 00 00 00 08  	.word	0x08000000
 8005ec0: 00 ed 00 e0  	.word	0xe000ed00

08005ec4 <z_arm_floating_point_init>:
; {
 8005ec4: b480         	push	{r7}
 8005ec6: b083         	sub	sp, #0xc
 8005ec8: af00         	add	r7, sp, #0x0
; 	SCB->CPACR &= (~(CPACR_CP10_Msk | CPACR_CP11_Msk));
 8005eca: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x8005f00 <z_arm_floating_point_init+0x3c>
 8005ecc: f8d3 3088    	ldr.w	r3, [r3, #0x88]
 8005ed0: 4a0b         	ldr	r2, [pc, #0x2c]         @ 0x8005f00 <z_arm_floating_point_init+0x3c>
 8005ed2: f423 0370    	bic	r3, r3, #0xf00000
 8005ed6: f8c2 3088    	str.w	r3, [r2, #0x88]
;   __ASM volatile ("MRS %0, control" : "=r" (result) );
 8005eda: f3ef 8314    	mrs	r3, control
 8005ede: 603b         	str	r3, [r7]
;   return(result);
 8005ee0: 683b         	ldr	r3, [r7]
; 	__set_CONTROL(__get_CONTROL() & (~(CONTROL_FPCA_Msk)));
 8005ee2: f023 0304    	bic	r3, r3, #0x4
 8005ee6: 607b         	str	r3, [r7, #0x4]
;   __ASM volatile ("MSR control, %0" : : "r" (control) : "memory");
 8005ee8: 687b         	ldr	r3, [r7, #0x4]
 8005eea: f383 8814    	msr	control, r3
;   __ASM volatile ("isb 0xF":::"memory");
 8005eee: f3bf 8f6f    	isb	sy
; }
 8005ef2: bf00         	nop
; }
 8005ef4: bf00         	nop
; }
 8005ef6: bf00         	nop
 8005ef8: 370c         	adds	r7, #0xc
 8005efa: 46bd         	mov	sp, r7
 8005efc: bc80         	pop	{r7}
 8005efe: 4770         	bx	lr

08005f00 <$d>:
 8005f00: 00 ed 00 e0  	.word	0xe000ed00

08005f04 <arch_new_thread>:
; {
 8005f04: b480         	push	{r7}
 8005f06: b087         	sub	sp, #0x1c
 8005f08: af00         	add	r7, sp, #0x0
 8005f0a: 60f8         	str	r0, [r7, #0xc]
 8005f0c: 60b9         	str	r1, [r7, #0x8]
 8005f0e: 607a         	str	r2, [r7, #0x4]
 8005f10: 603b         	str	r3, [r7]
; 	iframe = Z_STACK_PTR_TO_FRAME(struct __basic_sf, stack_ptr);
 8005f12: 687b         	ldr	r3, [r7, #0x4]
 8005f14: 3b20         	subs	r3, #0x20
 8005f16: 617b         	str	r3, [r7, #0x14]
; 	iframe->pc = (uint32_t)z_thread_entry;
 8005f18: 4a12         	ldr	r2, [pc, #0x48]         @ 0x8005f64 <arch_new_thread+0x60>
 8005f1a: 697b         	ldr	r3, [r7, #0x14]
 8005f1c: 619a         	str	r2, [r3, #0x18]
; 	iframe->pc &= 0xfffffffe;
 8005f1e: 697b         	ldr	r3, [r7, #0x14]
 8005f20: 699b         	ldr	r3, [r3, #0x18]
 8005f22: f023 0201    	bic	r2, r3, #0x1
 8005f26: 697b         	ldr	r3, [r7, #0x14]
 8005f28: 619a         	str	r2, [r3, #0x18]
; 	iframe->a1 = (uint32_t)entry;
 8005f2a: 683a         	ldr	r2, [r7]
 8005f2c: 697b         	ldr	r3, [r7, #0x14]
 8005f2e: 601a         	str	r2, [r3]
; 	iframe->a2 = (uint32_t)p1;
 8005f30: 6a3a         	ldr	r2, [r7, #0x20]
 8005f32: 697b         	ldr	r3, [r7, #0x14]
 8005f34: 605a         	str	r2, [r3, #0x4]
; 	iframe->a3 = (uint32_t)p2;
 8005f36: 6a7a         	ldr	r2, [r7, #0x24]
 8005f38: 697b         	ldr	r3, [r7, #0x14]
 8005f3a: 609a         	str	r2, [r3, #0x8]
; 	iframe->a4 = (uint32_t)p3;
 8005f3c: 6aba         	ldr	r2, [r7, #0x28]
 8005f3e: 697b         	ldr	r3, [r7, #0x14]
 8005f40: 60da         	str	r2, [r3, #0xc]
; 	iframe->xpsr =
 8005f42: 697b         	ldr	r3, [r7, #0x14]
 8005f44: f04f 7280    	mov.w	r2, #0x1000000
 8005f48: 61da         	str	r2, [r3, #0x1c]
; 	thread->callee_saved.psp = (uint32_t)iframe;
 8005f4a: 697a         	ldr	r2, [r7, #0x14]
 8005f4c: 68fb         	ldr	r3, [r7, #0xc]
 8005f4e: 661a         	str	r2, [r3, #0x60]
; 	thread->arch.basepri = 0;
 8005f50: 68fb         	ldr	r3, [r7, #0xc]
 8005f52: 2200         	movs	r2, #0x0
 8005f54: f8c3 20c8    	str.w	r2, [r3, #0xc8]
; }
 8005f58: bf00         	nop
 8005f5a: 371c         	adds	r7, #0x1c
 8005f5c: 46bd         	mov	sp, r7
 8005f5e: bc80         	pop	{r7}
 8005f60: 4770         	bx	lr
 8005f62: bf00         	nop

08005f64 <$d>:
 8005f64: 3d 40 00 08  	.word	0x0800403d

08005f68 <arch_switch_to_main_thread>:
; {
 8005f68: b5f0         	push	{r4, r5, r6, r7, lr}
 8005f6a: b087         	sub	sp, #0x1c
 8005f6c: af00         	add	r7, sp, #0x0
 8005f6e: 60f8         	str	r0, [r7, #0xc]
 8005f70: 60b9         	str	r1, [r7, #0x8]
 8005f72: 607a         	str	r2, [r7, #0x4]
; 	z_arm_prepare_switch_to_main();
 8005f74: f00f fe2c    	bl	0x8015bd0 <z_arm_prepare_switch_to_main> @ imm = #0xfc58
 8005f78: 68fb         	ldr	r3, [r7, #0xc]
 8005f7a: 617b         	str	r3, [r7, #0x14]
; 	_current_cpu->current = thread;
 8005f7c: 4a0e         	ldr	r2, [pc, #0x38]         @ 0x8005fb8 <arch_switch_to_main_thread+0x50>
 8005f7e: 697b         	ldr	r3, [r7, #0x14]
 8005f80: 6093         	str	r3, [r2, #0x8]
; }
 8005f82: bf00         	nop
; 	z_arm_tls_ptr = main_thread->tls;
 8005f84: 68fb         	ldr	r3, [r7, #0xc]
 8005f86: f8d3 30c4    	ldr.w	r3, [r3, #0xc4]
 8005f8a: 4a0c         	ldr	r2, [pc, #0x30]         @ 0x8005fbc <arch_switch_to_main_thread+0x54>
 8005f8c: 6013         	str	r3, [r2]
; 	z_thread_mark_switched_in();
 8005f8e: f008 ffc7    	bl	0x800ef20 <z_thread_mark_switched_in> @ imm = #0x8f8e
; 	__asm__ volatile (
 8005f92: 687d         	ldr	r5, [r7, #0x4]
 8005f94: 68be         	ldr	r6, [r7, #0x8]
 8005f96: 462c         	mov	r4, r5
 8005f98: f386 8809    	msr	psp, r6
 8005f9c: f04f 0000    	mov.w	r0, #0x0
 8005fa0: 4b07         	ldr	r3, [pc, #0x1c]         @ 0x8005fc0 <arch_switch_to_main_thread+0x58>
 8005fa2: 4798         	blx	r3
 8005fa4: 4620         	mov	r0, r4
 8005fa6: f04f 0100    	mov.w	r1, #0x0
 8005faa: f04f 0200    	mov.w	r2, #0x0
 8005fae: f04f 0300    	mov.w	r3, #0x0
 8005fb2: 4c04         	ldr	r4, [pc, #0x10]         @ 0x8005fc4 <arch_switch_to_main_thread+0x5c>
 8005fb4: 4720         	bx	r4
 8005fb6: bf00         	nop

08005fb8 <$d>:
 8005fb8: f0 16 00 20  	.word	0x200016f0
 8005fbc: 40 1c 00 20  	.word	0x20001c40

08005fc0 <$d>:
 8005fc0: dd 5b 01 08  	.word	0x08015bdd
 8005fc4: 3d 40 00 08  	.word	0x0800403d

08005fc8 <z_arm_cpu_idle_init>:
; {
 8005fc8: b480         	push	{r7}
 8005fca: af00         	add	r7, sp, #0x0
; 	SCB->SCR = SCB_SCR_SEVONPEND_Msk;
 8005fcc: 4b03         	ldr	r3, [pc, #0xc]          @ 0x8005fdc <z_arm_cpu_idle_init+0x14>
 8005fce: 2210         	movs	r2, #0x10
 8005fd0: 611a         	str	r2, [r3, #0x10]
; }
 8005fd2: bf00         	nop
 8005fd4: 46bd         	mov	sp, r7
 8005fd6: bc80         	pop	{r7}
 8005fd8: 4770         	bx	lr
 8005fda: bf00         	nop

08005fdc <$d>:
 8005fdc: 00 ed 00 e0  	.word	0xe000ed00

08005fe0 <__NVIC_SetPriority>:
; {
 8005fe0: b480         	push	{r7}
 8005fe2: b083         	sub	sp, #0xc
 8005fe4: af00         	add	r7, sp, #0x0
 8005fe6: 4603         	mov	r3, r0
 8005fe8: 6039         	str	r1, [r7]
 8005fea: 71fb         	strb	r3, [r7, #0x7]
;   if ((int32_t)(IRQn) >= 0)
 8005fec: f997 3007    	ldrsb.w	r3, [r7, #0x7]
 8005ff0: 2b00         	cmp	r3, #0x0
 8005ff2: db0a         	blt	0x800600a <__NVIC_SetPriority+0x2a> @ imm = #0x14
;     NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8005ff4: 683b         	ldr	r3, [r7]
 8005ff6: b2da         	uxtb	r2, r3
 8005ff8: 490c         	ldr	r1, [pc, #0x30]         @ 0x800602c <__NVIC_SetPriority+0x4c>
 8005ffa: f997 3007    	ldrsb.w	r3, [r7, #0x7]
 8005ffe: 0112         	lsls	r2, r2, #0x4
 8006000: b2d2         	uxtb	r2, r2
 8006002: 440b         	add	r3, r1
 8006004: f883 2300    	strb.w	r2, [r3, #0x300]
; }
 8006008: e00a         	b	0x8006020 <__NVIC_SetPriority+0x40> @ imm = #0x14
;     SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800600a: 683b         	ldr	r3, [r7]
 800600c: b2da         	uxtb	r2, r3
 800600e: 4908         	ldr	r1, [pc, #0x20]         @ 0x8006030 <__NVIC_SetPriority+0x50>
 8006010: 79fb         	ldrb	r3, [r7, #0x7]
 8006012: f003 030f    	and	r3, r3, #0xf
 8006016: 3b04         	subs	r3, #0x4
 8006018: 0112         	lsls	r2, r2, #0x4
 800601a: b2d2         	uxtb	r2, r2
 800601c: 440b         	add	r3, r1
 800601e: 761a         	strb	r2, [r3, #0x18]
; }
 8006020: bf00         	nop
 8006022: 370c         	adds	r7, #0xc
 8006024: 46bd         	mov	sp, r7
 8006026: bc80         	pop	{r7}
 8006028: 4770         	bx	lr
 800602a: bf00         	nop

0800602c <$d>:
 800602c: 00 e1 00 e0  	.word	0xe000e100
 8006030: 00 ed 00 e0  	.word	0xe000ed00

08006034 <_isr_wrapper>:
; {
 8006034: b580         	push	{r7, lr}
 8006036: b084         	sub	sp, #0x10
 8006038: af00         	add	r7, sp, #0x0
;   __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 800603a: f3ef 8305    	mrs	r3, ipsr
 800603e: 607b         	str	r3, [r7, #0x4]
;   return(result);
 8006040: 687b         	ldr	r3, [r7, #0x4]
; 	int32_t irq_number = __get_IPSR();
 8006042: 60fb         	str	r3, [r7, #0xc]
; 	irq_number -= 16;
 8006044: 68fb         	ldr	r3, [r7, #0xc]
 8006046: 3b10         	subs	r3, #0x10
 8006048: 60fb         	str	r3, [r7, #0xc]
; 	struct _isr_table_entry *entry = &_sw_isr_table[irq_number];
 800604a: 68fb         	ldr	r3, [r7, #0xc]
 800604c: 00db         	lsls	r3, r3, #0x3
 800604e: 4a07         	ldr	r2, [pc, #0x1c]         @ 0x800606c <_isr_wrapper+0x38>
 8006050: 4413         	add	r3, r2
 8006052: 60bb         	str	r3, [r7, #0x8]
; 	(entry->isr)(entry->arg);
 8006054: 68bb         	ldr	r3, [r7, #0x8]
 8006056: 685b         	ldr	r3, [r3, #0x4]
 8006058: 68ba         	ldr	r2, [r7, #0x8]
 800605a: 6812         	ldr	r2, [r2]
 800605c: 4610         	mov	r0, r2
 800605e: 4798         	blx	r3
; 	z_arm_exc_exit();
 8006060: f7fe ff88    	bl	0x8004f74 <z_arm_int_exit> @ imm = #-0x10f0
; }
 8006064: bf00         	nop
 8006066: 3710         	adds	r7, #0x10
 8006068: 46bd         	mov	sp, r7
 800606a: bd80         	pop	{r7, pc}

0800606c <$d>:
 800606c: b8 de 01 08  	.word	0x0801deb8

08006070 <cbvprintf>:
; {
 8006070: b580         	push	{r7, lr}
 8006072: b08a         	sub	sp, #0x28
 8006074: af00         	add	r7, sp, #0x0
 8006076: 60f8         	str	r0, [r7, #0xc]
 8006078: 60b9         	str	r1, [r7, #0x8]
 800607a: 607a         	str	r2, [r7, #0x4]
 800607c: 603b         	str	r3, [r7]
; 	struct cb_bits	s = {
 800607e: f107 0310    	add.w	r3, r7, #0x10
 8006082: 2200         	movs	r2, #0x0
 8006084: 601a         	str	r2, [r3]
 8006086: 605a         	str	r2, [r3, #0x4]
 8006088: 609a         	str	r2, [r3, #0x8]
 800608a: 60da         	str	r2, [r3, #0xc]
 800608c: 611a         	str	r2, [r3, #0x10]
 800608e: 615a         	str	r2, [r3, #0x14]
 8006090: 2302         	movs	r3, #0x2
 8006092: 74bb         	strb	r3, [r7, #0x12]
 8006094: 4b08         	ldr	r3, [pc, #0x20]         @ 0x80060b8 <cbvprintf+0x48>
 8006096: 617b         	str	r3, [r7, #0x14]
 8006098: 68fb         	ldr	r3, [r7, #0xc]
 800609a: 623b         	str	r3, [r7, #0x20]
 800609c: 68bb         	ldr	r3, [r7, #0x8]
 800609e: 627b         	str	r3, [r7, #0x24]
; 	return vfprintf(&s.f, fp, ap);
 80060a0: f107 0310    	add.w	r3, r7, #0x10
 80060a4: 683a         	ldr	r2, [r7]
 80060a6: 6879         	ldr	r1, [r7, #0x4]
 80060a8: 4618         	mov	r0, r3
 80060aa: f00b f97d    	bl	0x80113a8 <vfprintf>    @ imm = #0xb2fa
 80060ae: 4603         	mov	r3, r0
; }
 80060b0: 4618         	mov	r0, r3
 80060b2: 3728         	adds	r7, #0x28
 80060b4: 46bd         	mov	sp, r7
 80060b6: bd80         	pop	{r7, pc}

080060b8 <$d>:
 80060b8: 75 5c 01 08  	.word	0x08015c75

080060bc <z_impl_zephyr_fputc>:
; {
 80060bc: b580         	push	{r7, lr}
 80060be: b082         	sub	sp, #0x8
 80060c0: af00         	add	r7, sp, #0x0
 80060c2: 6078         	str	r0, [r7, #0x4]
 80060c4: 6039         	str	r1, [r7]
; 	(*_stdout_hook)(a);
 80060c6: 4b04         	ldr	r3, [pc, #0x10]         @ 0x80060d8 <z_impl_zephyr_fputc+0x1c>
 80060c8: 681b         	ldr	r3, [r3]
 80060ca: 6878         	ldr	r0, [r7, #0x4]
 80060cc: 4798         	blx	r3
; 	return 0;
 80060ce: 2300         	movs	r3, #0x0
; }
 80060d0: 4618         	mov	r0, r3
 80060d2: 3708         	adds	r7, #0x8
 80060d4: 46bd         	mov	sp, r7
 80060d6: bd80         	pop	{r7, pc}

080060d8 <$d>:
 80060d8: 44 1c 00 20  	.word	0x20001c44

080060dc <__stdout_hook_install>:
; {
 80060dc: b480         	push	{r7}
 80060de: b083         	sub	sp, #0xc
 80060e0: af00         	add	r7, sp, #0x0
 80060e2: 6078         	str	r0, [r7, #0x4]
; 	_stdout_hook = hook;
 80060e4: 4a07         	ldr	r2, [pc, #0x1c]         @ 0x8006104 <__stdout_hook_install+0x28>
 80060e6: 687b         	ldr	r3, [r7, #0x4]
 80060e8: 6013         	str	r3, [r2]
; 	__stdout.flags |= _FDEV_SETUP_WRITE;
 80060ea: 4b07         	ldr	r3, [pc, #0x1c]         @ 0x8006108 <__stdout_hook_install+0x2c>
 80060ec: 789b         	ldrb	r3, [r3, #0x2]
 80060ee: f043 0302    	orr	r3, r3, #0x2
 80060f2: b2da         	uxtb	r2, r3
 80060f4: 4b04         	ldr	r3, [pc, #0x10]         @ 0x8006108 <__stdout_hook_install+0x2c>
 80060f6: 709a         	strb	r2, [r3, #0x2]
; }
 80060f8: bf00         	nop
 80060fa: 370c         	adds	r7, #0xc
 80060fc: 46bd         	mov	sp, r7
 80060fe: bc80         	pop	{r7}
 8006100: 4770         	bx	lr
 8006102: bf00         	nop

08006104 <$d>:
 8006104: 44 1c 00 20  	.word	0x20001c44
 8006108: cc 04 00 20  	.word	0x200004cc

0800610c <malloc_lock>:
; malloc_lock(void) {
 800610c: b580         	push	{r7, lr}
 800610e: b082         	sub	sp, #0x8
 8006110: af00         	add	r7, sp, #0x0
; 	lock_ret = sys_mutex_lock(&z_malloc_heap_mutex, K_FOREVER);
 8006112: f04f 32ff    	mov.w	r2, #0xffffffff
 8006116: f04f 33ff    	mov.w	r3, #0xffffffff
 800611a: 4804         	ldr	r0, [pc, #0x10]         @ 0x800612c <malloc_lock+0x20>
 800611c: f00f fdf8    	bl	0x8015d10 <sys_mutex_lock> @ imm = #0xfbf0
 8006120: 6078         	str	r0, [r7, #0x4]
; }
 8006122: bf00         	nop
 8006124: 3708         	adds	r7, #0x8
 8006126: 46bd         	mov	sp, r7
 8006128: bd80         	pop	{r7, pc}
 800612a: bf00         	nop

0800612c <$d>:
 800612c: dc 04 00 20  	.word	0x200004dc

08006130 <malloc_unlock>:
; {
 8006130: b580         	push	{r7, lr}
 8006132: af00         	add	r7, sp, #0x0
; 	(void) sys_mutex_unlock(&z_malloc_heap_mutex);
 8006134: 4802         	ldr	r0, [pc, #0x8]          @ 0x8006140 <malloc_unlock+0x10>
 8006136: f00f fdfc    	bl	0x8015d32 <sys_mutex_unlock> @ imm = #0xfbf8
; }
 800613a: bf00         	nop
 800613c: bd80         	pop	{r7, pc}
 800613e: bf00         	nop

08006140 <$d>:
 8006140: dc 04 00 20  	.word	0x200004dc

08006144 <malloc>:
; {
 8006144: b580         	push	{r7, lr}
 8006146: b084         	sub	sp, #0x10
 8006148: af00         	add	r7, sp, #0x0
 800614a: 6078         	str	r0, [r7, #0x4]
; 	malloc_lock();
 800614c: f7ff ffde    	bl	0x800610c <malloc_lock> @ imm = #-0x44
; 	void *ret = sys_heap_aligned_alloc(&z_malloc_heap,
 8006150: 687a         	ldr	r2, [r7, #0x4]
 8006152: 2108         	movs	r1, #0x8
 8006154: 480b         	ldr	r0, [pc, #0x2c]         @ 0x8006184 <malloc+0x40>
 8006156: f00e fbac    	bl	0x80148b2 <sys_heap_aligned_alloc> @ imm = #0xe758
 800615a: 60f8         	str	r0, [r7, #0xc]
; 	if (ret == NULL && size != 0) {
 800615c: 68fb         	ldr	r3, [r7, #0xc]
 800615e: 2b00         	cmp	r3, #0x0
 8006160: d108         	bne	0x8006174 <malloc+0x30> @ imm = #0x10
 8006162: 687b         	ldr	r3, [r7, #0x4]
 8006164: 2b00         	cmp	r3, #0x0
 8006166: d005         	beq	0x8006174 <malloc+0x30> @ imm = #0xa
; 		errno = ENOMEM;
 8006168: f017 fd6c    	bl	0x801dc44 <__aeabi_read_tp> @ imm = #0x17ad8
 800616c: 4603         	mov	r3, r0
 800616e: 4a06         	ldr	r2, [pc, #0x18]         @ 0x8006188 <malloc+0x44>
 8006170: 210c         	movs	r1, #0xc
 8006172: 5099         	str	r1, [r3, r2]
; 	malloc_unlock();
 8006174: f7ff ffdc    	bl	0x8006130 <malloc_unlock> @ imm = #-0x48
; 	return ret;
 8006178: 68fb         	ldr	r3, [r7, #0xc]
; }
 800617a: 4618         	mov	r0, r3
 800617c: 3710         	adds	r7, #0x10
 800617e: 46bd         	mov	sp, r7
 8006180: bd80         	pop	{r7, pc}
 8006182: bf00         	nop

08006184 <$d>:
 8006184: 48 1c 00 20  	.word	0x20001c48
 8006188: 0c 00 00 00  	.word	0x0000000c

0800618c <malloc_prepare>:
; {
 800618c: b580         	push	{r7, lr}
 800618e: b082         	sub	sp, #0x8
 8006190: af00         	add	r7, sp, #0x0
; 	void *heap_base = NULL;
 8006192: 2300         	movs	r3, #0x0
 8006194: 607b         	str	r3, [r7, #0x4]
; 	heap_base = UINT_TO_POINTER(HEAP_BASE);
 8006196: 4b0c         	ldr	r3, [pc, #0x30]         @ 0x80061c8 <malloc_prepare+0x3c>
 8006198: 3307         	adds	r3, #0x7
 800619a: f023 0307    	bic	r3, r3, #0x7
 800619e: 607b         	str	r3, [r7, #0x4]
; 	heap_size = HEAP_SIZE;
 80061a0: 4b09         	ldr	r3, [pc, #0x24]         @ 0x80061c8 <malloc_prepare+0x3c>
 80061a2: 3307         	adds	r3, #0x7
 80061a4: f023 0307    	bic	r3, r3, #0x7
 80061a8: f1c3 5300    	rsb.w	r3, r3, #0x20000000
 80061ac: f503 3300    	add.w	r3, r3, #0x20000
 80061b0: 603b         	str	r3, [r7]
; 	sys_heap_init(&z_malloc_heap, heap_base, heap_size);
 80061b2: 683a         	ldr	r2, [r7]
 80061b4: 6879         	ldr	r1, [r7, #0x4]
 80061b6: 4805         	ldr	r0, [pc, #0x14]         @ 0x80061cc <malloc_prepare+0x40>
 80061b8: f00e fc24    	bl	0x8014a04 <sys_heap_init> @ imm = #0xe848
; 	return 0;
 80061bc: 2300         	movs	r3, #0x0
; }
 80061be: 4618         	mov	r0, r3
 80061c0: 3708         	adds	r7, #0x8
 80061c2: 46bd         	mov	sp, r7
 80061c4: bd80         	pop	{r7, pc}
 80061c6: bf00         	nop

080061c8 <$d>:
 80061c8: d0 43 00 20  	.word	0x200043d0
 80061cc: 48 1c 00 20  	.word	0x20001c48

080061d0 <LL_EXTI_EnableIT_0_31>:
; {
 80061d0: b480         	push	{r7}
 80061d2: b083         	sub	sp, #0xc
 80061d4: af00         	add	r7, sp, #0x0
 80061d6: 6078         	str	r0, [r7, #0x4]
;   SET_BIT(EXTI->IMR, ExtiLine);
 80061d8: 4b05         	ldr	r3, [pc, #0x14]         @ 0x80061f0 <LL_EXTI_EnableIT_0_31+0x20>
 80061da: 681a         	ldr	r2, [r3]
 80061dc: 4904         	ldr	r1, [pc, #0x10]         @ 0x80061f0 <LL_EXTI_EnableIT_0_31+0x20>
 80061de: 687b         	ldr	r3, [r7, #0x4]
 80061e0: 4313         	orrs	r3, r2
 80061e2: 600b         	str	r3, [r1]
; }
 80061e4: bf00         	nop
 80061e6: 370c         	adds	r7, #0xc
 80061e8: 46bd         	mov	sp, r7
 80061ea: bc80         	pop	{r7}
 80061ec: 4770         	bx	lr
 80061ee: bf00         	nop

080061f0 <$d>:
 80061f0: 00 3c 01 40  	.word	0x40013c00

080061f4 <LL_EXTI_DisableIT_0_31>:
; {
 80061f4: b480         	push	{r7}
 80061f6: b083         	sub	sp, #0xc
 80061f8: af00         	add	r7, sp, #0x0
 80061fa: 6078         	str	r0, [r7, #0x4]
;   CLEAR_BIT(EXTI->IMR, ExtiLine);
 80061fc: 4b05         	ldr	r3, [pc, #0x14]         @ 0x8006214 <LL_EXTI_DisableIT_0_31+0x20>
 80061fe: 681a         	ldr	r2, [r3]
 8006200: 687b         	ldr	r3, [r7, #0x4]
 8006202: 43db         	mvns	r3, r3
 8006204: 4903         	ldr	r1, [pc, #0xc]          @ 0x8006214 <LL_EXTI_DisableIT_0_31+0x20>
 8006206: 4013         	ands	r3, r2
 8006208: 600b         	str	r3, [r1]
; }
 800620a: bf00         	nop
 800620c: 370c         	adds	r7, #0xc
 800620e: 46bd         	mov	sp, r7
 8006210: bc80         	pop	{r7}
 8006212: 4770         	bx	lr

08006214 <$d>:
 8006214: 00 3c 01 40  	.word	0x40013c00

08006218 <LL_EXTI_EnableRisingTrig_0_31>:
; {
 8006218: b480         	push	{r7}
 800621a: b083         	sub	sp, #0xc
 800621c: af00         	add	r7, sp, #0x0
 800621e: 6078         	str	r0, [r7, #0x4]
;   SET_BIT(EXTI->RTSR, ExtiLine);
 8006220: 4b05         	ldr	r3, [pc, #0x14]         @ 0x8006238 <LL_EXTI_EnableRisingTrig_0_31+0x20>
 8006222: 689a         	ldr	r2, [r3, #0x8]
 8006224: 4904         	ldr	r1, [pc, #0x10]         @ 0x8006238 <LL_EXTI_EnableRisingTrig_0_31+0x20>
 8006226: 687b         	ldr	r3, [r7, #0x4]
 8006228: 4313         	orrs	r3, r2
 800622a: 608b         	str	r3, [r1, #0x8]
; }
 800622c: bf00         	nop
 800622e: 370c         	adds	r7, #0xc
 8006230: 46bd         	mov	sp, r7
 8006232: bc80         	pop	{r7}
 8006234: 4770         	bx	lr
 8006236: bf00         	nop

08006238 <$d>:
 8006238: 00 3c 01 40  	.word	0x40013c00

0800623c <LL_EXTI_DisableRisingTrig_0_31>:
; {
 800623c: b480         	push	{r7}
 800623e: b083         	sub	sp, #0xc
 8006240: af00         	add	r7, sp, #0x0
 8006242: 6078         	str	r0, [r7, #0x4]
;   CLEAR_BIT(EXTI->RTSR, ExtiLine);
 8006244: 4b05         	ldr	r3, [pc, #0x14]         @ 0x800625c <LL_EXTI_DisableRisingTrig_0_31+0x20>
 8006246: 689a         	ldr	r2, [r3, #0x8]
 8006248: 687b         	ldr	r3, [r7, #0x4]
 800624a: 43db         	mvns	r3, r3
 800624c: 4903         	ldr	r1, [pc, #0xc]          @ 0x800625c <LL_EXTI_DisableRisingTrig_0_31+0x20>
 800624e: 4013         	ands	r3, r2
 8006250: 608b         	str	r3, [r1, #0x8]
; }
 8006252: bf00         	nop
 8006254: 370c         	adds	r7, #0xc
 8006256: 46bd         	mov	sp, r7
 8006258: bc80         	pop	{r7}
 800625a: 4770         	bx	lr

0800625c <$d>:
 800625c: 00 3c 01 40  	.word	0x40013c00

08006260 <LL_EXTI_EnableFallingTrig_0_31>:
; {
 8006260: b480         	push	{r7}
 8006262: b083         	sub	sp, #0xc
 8006264: af00         	add	r7, sp, #0x0
 8006266: 6078         	str	r0, [r7, #0x4]
;   SET_BIT(EXTI->FTSR, ExtiLine);
 8006268: 4b05         	ldr	r3, [pc, #0x14]         @ 0x8006280 <LL_EXTI_EnableFallingTrig_0_31+0x20>
 800626a: 68da         	ldr	r2, [r3, #0xc]
 800626c: 4904         	ldr	r1, [pc, #0x10]         @ 0x8006280 <LL_EXTI_EnableFallingTrig_0_31+0x20>
 800626e: 687b         	ldr	r3, [r7, #0x4]
 8006270: 4313         	orrs	r3, r2
 8006272: 60cb         	str	r3, [r1, #0xc]
; }
 8006274: bf00         	nop
 8006276: 370c         	adds	r7, #0xc
 8006278: 46bd         	mov	sp, r7
 800627a: bc80         	pop	{r7}
 800627c: 4770         	bx	lr
 800627e: bf00         	nop

08006280 <$d>:
 8006280: 00 3c 01 40  	.word	0x40013c00

08006284 <LL_EXTI_DisableFallingTrig_0_31>:
; {
 8006284: b480         	push	{r7}
 8006286: b083         	sub	sp, #0xc
 8006288: af00         	add	r7, sp, #0x0
 800628a: 6078         	str	r0, [r7, #0x4]
;   CLEAR_BIT(EXTI->FTSR, ExtiLine);
 800628c: 4b05         	ldr	r3, [pc, #0x14]         @ 0x80062a4 <LL_EXTI_DisableFallingTrig_0_31+0x20>
 800628e: 68da         	ldr	r2, [r3, #0xc]
 8006290: 687b         	ldr	r3, [r7, #0x4]
 8006292: 43db         	mvns	r3, r3
 8006294: 4903         	ldr	r1, [pc, #0xc]          @ 0x80062a4 <LL_EXTI_DisableFallingTrig_0_31+0x20>
 8006296: 4013         	ands	r3, r2
 8006298: 60cb         	str	r3, [r1, #0xc]
; }
 800629a: bf00         	nop
 800629c: 370c         	adds	r7, #0xc
 800629e: 46bd         	mov	sp, r7
 80062a0: bc80         	pop	{r7}
 80062a2: 4770         	bx	lr

080062a4 <$d>:
 80062a4: 00 3c 01 40  	.word	0x40013c00

080062a8 <LL_EXTI_IsActiveFlag_0_31>:
; {
 80062a8: b480         	push	{r7}
 80062aa: b083         	sub	sp, #0xc
 80062ac: af00         	add	r7, sp, #0x0
 80062ae: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(EXTI->PR, ExtiLine) == (ExtiLine));
 80062b0: 4b07         	ldr	r3, [pc, #0x1c]         @ 0x80062d0 <LL_EXTI_IsActiveFlag_0_31+0x28>
 80062b2: 695a         	ldr	r2, [r3, #0x14]
 80062b4: 687b         	ldr	r3, [r7, #0x4]
 80062b6: 4013         	ands	r3, r2
 80062b8: 687a         	ldr	r2, [r7, #0x4]
 80062ba: 429a         	cmp	r2, r3
 80062bc: bf0c         	ite	eq
 80062be: 2301         	moveq	r3, #0x1
 80062c0: 2300         	movne	r3, #0x0
 80062c2: b2db         	uxtb	r3, r3
; }
 80062c4: 4618         	mov	r0, r3
 80062c6: 370c         	adds	r7, #0xc
 80062c8: 46bd         	mov	sp, r7
 80062ca: bc80         	pop	{r7}
 80062cc: 4770         	bx	lr
 80062ce: bf00         	nop

080062d0 <$d>:
 80062d0: 00 3c 01 40  	.word	0x40013c00

080062d4 <LL_EXTI_ClearFlag_0_31>:
; {
 80062d4: b480         	push	{r7}
 80062d6: b083         	sub	sp, #0xc
 80062d8: af00         	add	r7, sp, #0x0
 80062da: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(EXTI->PR, ExtiLine);
 80062dc: 4a03         	ldr	r2, [pc, #0xc]          @ 0x80062ec <LL_EXTI_ClearFlag_0_31+0x18>
 80062de: 687b         	ldr	r3, [r7, #0x4]
 80062e0: 6153         	str	r3, [r2, #0x14]
; }
 80062e2: bf00         	nop
 80062e4: 370c         	adds	r7, #0xc
 80062e6: 46bd         	mov	sp, r7
 80062e8: bc80         	pop	{r7}
 80062ea: 4770         	bx	lr

080062ec <$d>:
 80062ec: 00 3c 01 40  	.word	0x40013c00

080062f0 <LL_SYSCFG_SetEXTISource>:
; {
 80062f0: b480         	push	{r7}
 80062f2: b087         	sub	sp, #0x1c
 80062f4: af00         	add	r7, sp, #0x0
 80062f6: 6078         	str	r0, [r7, #0x4]
 80062f8: 6039         	str	r1, [r7]
;   MODIFY_REG(SYSCFG->EXTICR[Line & 0xFF], (Line >> 16), Port << POSITION_VAL((Line >> 16)));
 80062fa: 4a16         	ldr	r2, [pc, #0x58]         @ 0x8006354 <LL_SYSCFG_SetEXTISource+0x64>
 80062fc: 683b         	ldr	r3, [r7]
 80062fe: b2db         	uxtb	r3, r3
 8006300: 3302         	adds	r3, #0x2
 8006302: f852 2023    	ldr.w	r2, [r2, r3, lsl #2]
 8006306: 683b         	ldr	r3, [r7]
 8006308: 0c1b         	lsrs	r3, r3, #0x10
 800630a: 43db         	mvns	r3, r3
 800630c: ea02 0103    	and.w	r1, r2, r3
 8006310: 683b         	ldr	r3, [r7]
 8006312: 0c1b         	lsrs	r3, r3, #0x10
 8006314: 613b         	str	r3, [r7, #0x10]
;    __ASM ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8006316: 693b         	ldr	r3, [r7, #0x10]
 8006318: fa93 f3a3    	rbit	r3, r3
 800631c: 60fb         	str	r3, [r7, #0xc]
;   return result;
 800631e: 68fb         	ldr	r3, [r7, #0xc]
 8006320: 617b         	str	r3, [r7, #0x14]
;   if (value == 0U)
 8006322: 697b         	ldr	r3, [r7, #0x14]
 8006324: 2b00         	cmp	r3, #0x0
 8006326: d101         	bne	0x800632c <LL_SYSCFG_SetEXTISource+0x3c> @ imm = #0x2
;     return 32U;
 8006328: 2320         	movs	r3, #0x20
 800632a: e003         	b	0x8006334 <LL_SYSCFG_SetEXTISource+0x44> @ imm = #0x6
;   return __builtin_clz(value);
 800632c: 697b         	ldr	r3, [r7, #0x14]
 800632e: fab3 f383    	clz	r3, r3
 8006332: b2db         	uxtb	r3, r3
;   MODIFY_REG(SYSCFG->EXTICR[Line & 0xFF], (Line >> 16), Port << POSITION_VAL((Line >> 16)));
 8006334: 461a         	mov	r2, r3
 8006336: 687b         	ldr	r3, [r7, #0x4]
 8006338: fa03 f202    	lsl.w	r2, r3, r2
 800633c: 4805         	ldr	r0, [pc, #0x14]         @ 0x8006354 <LL_SYSCFG_SetEXTISource+0x64>
 800633e: 683b         	ldr	r3, [r7]
 8006340: b2db         	uxtb	r3, r3
 8006342: 430a         	orrs	r2, r1
 8006344: 3302         	adds	r3, #0x2
 8006346: f840 2023    	str.w	r2, [r0, r3, lsl #2]
; }
 800634a: bf00         	nop
 800634c: 371c         	adds	r7, #0x1c
 800634e: 46bd         	mov	sp, r7
 8006350: bc80         	pop	{r7}
 8006352: 4770         	bx	lr

08006354 <$d>:
 8006354: 00 38 01 40  	.word	0x40013800

08006358 <LL_SYSCFG_GetEXTISource>:
; {
 8006358: b480         	push	{r7}
 800635a: b087         	sub	sp, #0x1c
 800635c: af00         	add	r7, sp, #0x0
 800635e: 6078         	str	r0, [r7, #0x4]
;   return (uint32_t)(READ_BIT(SYSCFG->EXTICR[Line & 0xFF], (Line >> 16)) >> POSITION_VAL(Line >> 16));
 8006360: 4a10         	ldr	r2, [pc, #0x40]         @ 0x80063a4 <LL_SYSCFG_GetEXTISource+0x4c>
 8006362: 687b         	ldr	r3, [r7, #0x4]
 8006364: b2db         	uxtb	r3, r3
 8006366: 3302         	adds	r3, #0x2
 8006368: f852 2023    	ldr.w	r2, [r2, r3, lsl #2]
 800636c: 687b         	ldr	r3, [r7, #0x4]
 800636e: 0c1b         	lsrs	r3, r3, #0x10
 8006370: 4013         	ands	r3, r2
 8006372: 687a         	ldr	r2, [r7, #0x4]
 8006374: 0c12         	lsrs	r2, r2, #0x10
 8006376: 613a         	str	r2, [r7, #0x10]
;    __ASM ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8006378: 693a         	ldr	r2, [r7, #0x10]
 800637a: fa92 f2a2    	rbit	r2, r2
 800637e: 60fa         	str	r2, [r7, #0xc]
;   return result;
 8006380: 68fa         	ldr	r2, [r7, #0xc]
 8006382: 617a         	str	r2, [r7, #0x14]
;   if (value == 0U)
 8006384: 697a         	ldr	r2, [r7, #0x14]
 8006386: 2a00         	cmp	r2, #0x0
 8006388: d101         	bne	0x800638e <LL_SYSCFG_GetEXTISource+0x36> @ imm = #0x2
;     return 32U;
 800638a: 2220         	movs	r2, #0x20
 800638c: e003         	b	0x8006396 <LL_SYSCFG_GetEXTISource+0x3e> @ imm = #0x6
;   return __builtin_clz(value);
 800638e: 697a         	ldr	r2, [r7, #0x14]
 8006390: fab2 f282    	clz	r2, r2
 8006394: b2d2         	uxtb	r2, r2
;   return (uint32_t)(READ_BIT(SYSCFG->EXTICR[Line & 0xFF], (Line >> 16)) >> POSITION_VAL(Line >> 16));
 8006396: 40d3         	lsrs	r3, r2
; }
 8006398: 4618         	mov	r0, r3
 800639a: 371c         	adds	r7, #0x1c
 800639c: 46bd         	mov	sp, r7
 800639e: bc80         	pop	{r7}
 80063a0: 4770         	bx	lr
 80063a2: bf00         	nop

080063a4 <$d>:
 80063a4: 00 38 01 40  	.word	0x40013800

080063a8 <stm32_exti_isr>:
; {
 80063a8: b580         	push	{r7, lr}
 80063aa: b088         	sub	sp, #0x20
 80063ac: af00         	add	r7, sp, #0x0
 80063ae: 6078         	str	r0, [r7, #0x4]
; 	const struct device *dev = DEVICE_DT_GET(EXTI_NODE);
 80063b0: 4b1f         	ldr	r3, [pc, #0x7c]         @ 0x8006430 <stm32_exti_isr+0x88>
 80063b2: 61bb         	str	r3, [r7, #0x18]
; 	struct stm32_exti_data *data = dev->data;
 80063b4: 69bb         	ldr	r3, [r7, #0x18]
 80063b6: 691b         	ldr	r3, [r3, #0x10]
 80063b8: 617b         	str	r3, [r7, #0x14]
; 	const struct stm32_exti_range *range = exti_range;
 80063ba: 687b         	ldr	r3, [r7, #0x4]
 80063bc: 613b         	str	r3, [r7, #0x10]
; 	for (uint8_t i = 0; i <= range->len; i++) {
 80063be: 2300         	movs	r3, #0x0
 80063c0: 77fb         	strb	r3, [r7, #0x1f]
 80063c2: e02b         	b	0x800641c <stm32_exti_isr+0x74> @ imm = #0x56
; 		line_num = range->start + i;
 80063c4: 693b         	ldr	r3, [r7, #0x10]
 80063c6: 781b         	ldrb	r3, [r3]
 80063c8: 461a         	mov	r2, r3
 80063ca: 7ffb         	ldrb	r3, [r7, #0x1f]
 80063cc: 4413         	add	r3, r2
 80063ce: 60fb         	str	r3, [r7, #0xc]
; 		line = linenum_to_ll_exti_line(line_num);
 80063d0: 68fb         	ldr	r3, [r7, #0xc]
 80063d2: b2db         	uxtb	r3, r3
 80063d4: 4618         	mov	r0, r3
 80063d6: f00f fd0b    	bl	0x8015df0 <linenum_to_ll_exti_line> @ imm = #0xfa16
 80063da: 60b8         	str	r0, [r7, #0x8]
; 		if (stm32_exti_is_pending(line) != 0) {
 80063dc: 68b8         	ldr	r0, [r7, #0x8]
 80063de: f00f fcf0    	bl	0x8015dc2 <stm32_exti_is_pending> @ imm = #0xf9e0
 80063e2: 4603         	mov	r3, r0
 80063e4: 2b00         	cmp	r3, #0x0
 80063e6: d016         	beq	0x8006416 <stm32_exti_isr+0x6e> @ imm = #0x2c
; 			stm32_exti_clear_pending(line);
 80063e8: 68b8         	ldr	r0, [r7, #0x8]
 80063ea: f00f fcf6    	bl	0x8015dda <stm32_exti_clear_pending> @ imm = #0xf9ec
; 			if (!data->cb[line_num].cb) {
 80063ee: 697b         	ldr	r3, [r7, #0x14]
 80063f0: 68fa         	ldr	r2, [r7, #0xc]
 80063f2: f853 3032    	ldr.w	r3, [r3, r2, lsl #3]
 80063f6: 2b00         	cmp	r3, #0x0
 80063f8: d00c         	beq	0x8006414 <stm32_exti_isr+0x6c> @ imm = #0x18
; 			data->cb[line_num].cb(line, data->cb[line_num].data);
 80063fa: 697b         	ldr	r3, [r7, #0x14]
 80063fc: 68fa         	ldr	r2, [r7, #0xc]
 80063fe: f853 2032    	ldr.w	r2, [r3, r2, lsl #3]
 8006402: 6979         	ldr	r1, [r7, #0x14]
 8006404: 68fb         	ldr	r3, [r7, #0xc]
 8006406: 00db         	lsls	r3, r3, #0x3
 8006408: 440b         	add	r3, r1
 800640a: 685b         	ldr	r3, [r3, #0x4]
 800640c: 4619         	mov	r1, r3
 800640e: 68b8         	ldr	r0, [r7, #0x8]
 8006410: 4790         	blx	r2
 8006412: e000         	b	0x8006416 <stm32_exti_isr+0x6e> @ imm = #0x0
; 				continue;
 8006414: bf00         	nop
; 	for (uint8_t i = 0; i <= range->len; i++) {
 8006416: 7ffb         	ldrb	r3, [r7, #0x1f]
 8006418: 3301         	adds	r3, #0x1
 800641a: 77fb         	strb	r3, [r7, #0x1f]
 800641c: 693b         	ldr	r3, [r7, #0x10]
 800641e: 785b         	ldrb	r3, [r3, #0x1]
 8006420: 7ffa         	ldrb	r2, [r7, #0x1f]
 8006422: 429a         	cmp	r2, r3
 8006424: d9ce         	bls	0x80063c4 <stm32_exti_isr+0x1c> @ imm = #-0x64
; }
 8006426: bf00         	nop
 8006428: bf00         	nop
 800642a: 3720         	adds	r7, #0x20
 800642c: 46bd         	mov	sp, r7
 800642e: bd80         	pop	{r7, pc}

08006430 <$d>:
 8006430: 50 dd 01 08  	.word	0x0801dd50

08006434 <stm32_exti_enable_registers>:
; {
 8006434: b580         	push	{r7, lr}
 8006436: b084         	sub	sp, #0x10
 8006438: af00         	add	r7, sp, #0x0
; 	int ret = 0;
 800643a: 2300         	movs	r3, #0x0
 800643c: 60fb         	str	r3, [r7, #0xc]
; 	const struct device *const clk = DEVICE_DT_GET(STM32_CLOCK_CONTROL_NODE);
 800643e: 4b09         	ldr	r3, [pc, #0x24]         @ 0x8006464 <stm32_exti_enable_registers+0x30>
 8006440: 60bb         	str	r3, [r7, #0x8]
; 	struct stm32_pclken pclken = {
 8006442: 4a09         	ldr	r2, [pc, #0x24]         @ 0x8006468 <stm32_exti_enable_registers+0x34>
 8006444: 463b         	mov	r3, r7
 8006446: e892 0003    	ldm.w	r2, {r0, r1}
 800644a: e883 0003    	stm.w	r3, {r0, r1}
; 	ret = clock_control_on(clk, (clock_control_subsys_t) &pclken);
 800644e: 463b         	mov	r3, r7
 8006450: 4619         	mov	r1, r3
 8006452: 68b8         	ldr	r0, [r7, #0x8]
 8006454: f00f fc7a    	bl	0x8015d4c <clock_control_on> @ imm = #0xf8f4
 8006458: 60f8         	str	r0, [r7, #0xc]
; 	return ret;
 800645a: 68fb         	ldr	r3, [r7, #0xc]
; }
 800645c: 4618         	mov	r0, r3
 800645e: 3710         	adds	r7, #0x10
 8006460: 46bd         	mov	sp, r7
 8006462: bd80         	pop	{r7, pc}

08006464 <$d>:
 8006464: 28 dd 01 08  	.word	0x0801dd28
 8006468: 1c ea 01 08  	.word	0x0801ea1c

0800646c <stm32_fill_irq_table>:
; {
 800646c: b480         	push	{r7}
 800646e: b085         	sub	sp, #0x14
 8006470: af00         	add	r7, sp, #0x0
 8006472: 4603         	mov	r3, r0
 8006474: 603a         	str	r2, [r7]
 8006476: 71fb         	strb	r3, [r7, #0x7]
 8006478: 460b         	mov	r3, r1
 800647a: 71bb         	strb	r3, [r7, #0x6]
; 	for (int i = 0; i < len; i++) {
 800647c: 2300         	movs	r3, #0x0
 800647e: 60fb         	str	r3, [r7, #0xc]
 8006480: e00a         	b	0x8006498 <stm32_fill_irq_table+0x2c> @ imm = #0x14
; 		exti_irq_table[start + i] = irqn;
 8006482: f997 2007    	ldrsb.w	r2, [r7, #0x7]
 8006486: 68fb         	ldr	r3, [r7, #0xc]
 8006488: 4413         	add	r3, r2
 800648a: 683a         	ldr	r2, [r7]
 800648c: b251         	sxtb	r1, r2
 800648e: 4a08         	ldr	r2, [pc, #0x20]         @ 0x80064b0 <stm32_fill_irq_table+0x44>
 8006490: 54d1         	strb	r1, [r2, r3]
; 	for (int i = 0; i < len; i++) {
 8006492: 68fb         	ldr	r3, [r7, #0xc]
 8006494: 3301         	adds	r3, #0x1
 8006496: 60fb         	str	r3, [r7, #0xc]
 8006498: f997 3006    	ldrsb.w	r3, [r7, #0x6]
 800649c: 68fa         	ldr	r2, [r7, #0xc]
 800649e: 429a         	cmp	r2, r3
 80064a0: dbef         	blt	0x8006482 <stm32_fill_irq_table+0x16> @ imm = #-0x22
; }
 80064a2: bf00         	nop
 80064a4: bf00         	nop
 80064a6: 3714         	adds	r7, #0x14
 80064a8: 46bd         	mov	sp, r7
 80064aa: bc80         	pop	{r7}
 80064ac: 4770         	bx	lr
 80064ae: bf00         	nop

080064b0 <$d>:
 80064b0: f0 04 00 20  	.word	0x200004f0

080064b4 <stm32_exti_init>:
; {
 80064b4: b580         	push	{r7, lr}
 80064b6: b082         	sub	sp, #0x8
 80064b8: af00         	add	r7, sp, #0x0
 80064ba: 6078         	str	r0, [r7, #0x4]
; 	DT_FOREACH_PROP_ELEM(DT_NODELABEL(exti),
 80064bc: 4b37         	ldr	r3, [pc, #0xdc]         @ 0x800659c <stm32_exti_init+0xe8>
 80064be: 781b         	ldrb	r3, [r3]
 80064c0: b25b         	sxtb	r3, r3
 80064c2: 4a36         	ldr	r2, [pc, #0xd8]         @ 0x800659c <stm32_exti_init+0xe8>
 80064c4: 7852         	ldrb	r2, [r2, #0x1]
 80064c6: b251         	sxtb	r1, r2
 80064c8: 2206         	movs	r2, #0x6
 80064ca: 4618         	mov	r0, r3
 80064cc: f7ff ffce    	bl	0x800646c <stm32_fill_irq_table> @ imm = #-0x64
 80064d0: 2200         	movs	r2, #0x0
 80064d2: 2100         	movs	r1, #0x0
 80064d4: 2006         	movs	r0, #0x6
 80064d6: f00f fb4e    	bl	0x8015b76 <z_arm_irq_priority_set> @ imm = #0xf69c
 80064da: 4b31         	ldr	r3, [pc, #0xc4]         @ 0x80065a0 <stm32_exti_init+0xec>
 80064dc: 781b         	ldrb	r3, [r3]
 80064de: b25b         	sxtb	r3, r3
 80064e0: 4a2f         	ldr	r2, [pc, #0xbc]         @ 0x80065a0 <stm32_exti_init+0xec>
 80064e2: 7852         	ldrb	r2, [r2, #0x1]
 80064e4: b251         	sxtb	r1, r2
 80064e6: 2207         	movs	r2, #0x7
 80064e8: 4618         	mov	r0, r3
 80064ea: f7ff ffbf    	bl	0x800646c <stm32_fill_irq_table> @ imm = #-0x82
 80064ee: 2200         	movs	r2, #0x0
 80064f0: 2100         	movs	r1, #0x0
 80064f2: 2007         	movs	r0, #0x7
 80064f4: f00f fb3f    	bl	0x8015b76 <z_arm_irq_priority_set> @ imm = #0xf67e
 80064f8: 4b2a         	ldr	r3, [pc, #0xa8]         @ 0x80065a4 <stm32_exti_init+0xf0>
 80064fa: 781b         	ldrb	r3, [r3]
 80064fc: b25b         	sxtb	r3, r3
 80064fe: 4a29         	ldr	r2, [pc, #0xa4]         @ 0x80065a4 <stm32_exti_init+0xf0>
 8006500: 7852         	ldrb	r2, [r2, #0x1]
 8006502: b251         	sxtb	r1, r2
 8006504: 2208         	movs	r2, #0x8
 8006506: 4618         	mov	r0, r3
 8006508: f7ff ffb0    	bl	0x800646c <stm32_fill_irq_table> @ imm = #-0xa0
 800650c: 2200         	movs	r2, #0x0
 800650e: 2100         	movs	r1, #0x0
 8006510: 2008         	movs	r0, #0x8
 8006512: f00f fb30    	bl	0x8015b76 <z_arm_irq_priority_set> @ imm = #0xf660
 8006516: 4b24         	ldr	r3, [pc, #0x90]         @ 0x80065a8 <stm32_exti_init+0xf4>
 8006518: 781b         	ldrb	r3, [r3]
 800651a: b25b         	sxtb	r3, r3
 800651c: 4a22         	ldr	r2, [pc, #0x88]         @ 0x80065a8 <stm32_exti_init+0xf4>
 800651e: 7852         	ldrb	r2, [r2, #0x1]
 8006520: b251         	sxtb	r1, r2
 8006522: 2209         	movs	r2, #0x9
 8006524: 4618         	mov	r0, r3
 8006526: f7ff ffa1    	bl	0x800646c <stm32_fill_irq_table> @ imm = #-0xbe
 800652a: 2200         	movs	r2, #0x0
 800652c: 2100         	movs	r1, #0x0
 800652e: 2009         	movs	r0, #0x9
 8006530: f00f fb21    	bl	0x8015b76 <z_arm_irq_priority_set> @ imm = #0xf642
 8006534: 4b1d         	ldr	r3, [pc, #0x74]         @ 0x80065ac <stm32_exti_init+0xf8>
 8006536: 781b         	ldrb	r3, [r3]
 8006538: b25b         	sxtb	r3, r3
 800653a: 4a1c         	ldr	r2, [pc, #0x70]         @ 0x80065ac <stm32_exti_init+0xf8>
 800653c: 7852         	ldrb	r2, [r2, #0x1]
 800653e: b251         	sxtb	r1, r2
 8006540: 220a         	movs	r2, #0xa
 8006542: 4618         	mov	r0, r3
 8006544: f7ff ff92    	bl	0x800646c <stm32_fill_irq_table> @ imm = #-0xdc
 8006548: 2200         	movs	r2, #0x0
 800654a: 2100         	movs	r1, #0x0
 800654c: 200a         	movs	r0, #0xa
 800654e: f00f fb12    	bl	0x8015b76 <z_arm_irq_priority_set> @ imm = #0xf624
 8006552: 4b17         	ldr	r3, [pc, #0x5c]         @ 0x80065b0 <stm32_exti_init+0xfc>
 8006554: 781b         	ldrb	r3, [r3]
 8006556: b25b         	sxtb	r3, r3
 8006558: 4a15         	ldr	r2, [pc, #0x54]         @ 0x80065b0 <stm32_exti_init+0xfc>
 800655a: 7852         	ldrb	r2, [r2, #0x1]
 800655c: b251         	sxtb	r1, r2
 800655e: 2217         	movs	r2, #0x17
 8006560: 4618         	mov	r0, r3
 8006562: f7ff ff83    	bl	0x800646c <stm32_fill_irq_table> @ imm = #-0xfa
 8006566: 2200         	movs	r2, #0x0
 8006568: 2100         	movs	r1, #0x0
 800656a: 2017         	movs	r0, #0x17
 800656c: f00f fb03    	bl	0x8015b76 <z_arm_irq_priority_set> @ imm = #0xf606
 8006570: 4b10         	ldr	r3, [pc, #0x40]         @ 0x80065b4 <stm32_exti_init+0x100>
 8006572: 781b         	ldrb	r3, [r3]
 8006574: b25b         	sxtb	r3, r3
 8006576: 4a0f         	ldr	r2, [pc, #0x3c]         @ 0x80065b4 <stm32_exti_init+0x100>
 8006578: 7852         	ldrb	r2, [r2, #0x1]
 800657a: b251         	sxtb	r1, r2
 800657c: 2228         	movs	r2, #0x28
 800657e: 4618         	mov	r0, r3
 8006580: f7ff ff74    	bl	0x800646c <stm32_fill_irq_table> @ imm = #-0x118
 8006584: 2200         	movs	r2, #0x0
 8006586: 2100         	movs	r1, #0x0
 8006588: 2028         	movs	r0, #0x28
 800658a: f00f faf4    	bl	0x8015b76 <z_arm_irq_priority_set> @ imm = #0xf5e8
; 	return stm32_exti_enable_registers();
 800658e: f7ff ff51    	bl	0x8006434 <stm32_exti_enable_registers> @ imm = #-0x15e
 8006592: 4603         	mov	r3, r0
; }
 8006594: 4618         	mov	r0, r3
 8006596: 3708         	adds	r7, #0x8
 8006598: 46bd         	mov	sp, r7
 800659a: bd80         	pop	{r7, pc}

0800659c <$d>:
 800659c: 50 ff 01 08  	.word	0x0801ff50
 80065a0: 54 ff 01 08  	.word	0x0801ff54
 80065a4: 58 ff 01 08  	.word	0x0801ff58
 80065a8: 5c ff 01 08  	.word	0x0801ff5c
 80065ac: 60 ff 01 08  	.word	0x0801ff60
 80065b0: 64 ff 01 08  	.word	0x0801ff64
 80065b4: 68 ff 01 08  	.word	0x0801ff68

080065b8 <stm32_gpio_intc_enable_line>:
; {
 80065b8: b580         	push	{r7, lr}
 80065ba: b084         	sub	sp, #0x10
 80065bc: af00         	add	r7, sp, #0x0
 80065be: 6078         	str	r0, [r7, #0x4]
; 	uint32_t line_num = ll_exti_line_to_linenum(line);
 80065c0: 6878         	ldr	r0, [r7, #0x4]
 80065c2: f00f fc23    	bl	0x8015e0c <ll_exti_line_to_linenum> @ imm = #0xf846
 80065c6: 4603         	mov	r3, r0
 80065c8: 60fb         	str	r3, [r7, #0xc]
; 	irqnum = exti_irq_table[line_num];
 80065ca: 4a08         	ldr	r2, [pc, #0x20]         @ 0x80065ec <stm32_gpio_intc_enable_line+0x34>
 80065cc: 68fb         	ldr	r3, [r7, #0xc]
 80065ce: 4413         	add	r3, r2
 80065d0: f993 3000    	ldrsb.w	r3, [r3]
 80065d4: 60bb         	str	r3, [r7, #0x8]
; 	LL_EXTI_EnableIT_0_31(line);
 80065d6: 6878         	ldr	r0, [r7, #0x4]
 80065d8: f7ff fdfa    	bl	0x80061d0 <LL_EXTI_EnableIT_0_31> @ imm = #-0x40c
; 	irq_enable(irqnum);
 80065dc: 68b8         	ldr	r0, [r7, #0x8]
 80065de: f00f fabd    	bl	0x8015b5c <arch_irq_enable> @ imm = #0xf57a
; }
 80065e2: bf00         	nop
 80065e4: 3710         	adds	r7, #0x10
 80065e6: 46bd         	mov	sp, r7
 80065e8: bd80         	pop	{r7, pc}
 80065ea: bf00         	nop

080065ec <$d>:
 80065ec: f0 04 00 20  	.word	0x200004f0

080065f0 <stm32_gpio_intc_select_line_trigger>:
; {
 80065f0: b580         	push	{r7, lr}
 80065f2: b082         	sub	sp, #0x8
 80065f4: af00         	add	r7, sp, #0x0
 80065f6: 6078         	str	r0, [r7, #0x4]
 80065f8: 6039         	str	r1, [r7]
; 	z_stm32_hsem_lock(CFG_HW_EXTI_SEMID, HSEM_LOCK_DEFAULT_RETRY);
 80065fa: f44f 1180    	mov.w	r1, #0x100000
 80065fe: 2000         	movs	r0, #0x0
 8006600: f00f fbb6    	bl	0x8015d70 <z_stm32_hsem_lock> @ imm = #0xf76c
; 	switch (trg) {
 8006604: 683b         	ldr	r3, [r7]
 8006606: 2b03         	cmp	r3, #0x3
 8006608: d826         	bhi	0x8006658 <stm32_gpio_intc_select_line_trigger+0x68> @ imm = #0x4c
 800660a: a201         	adr	r2, #4 <stm32_gpio_intc_select_line_trigger+0x1f>
 800660c: f852 f023    	ldr.w	pc, [r2, r3, lsl #2]

08006610 <$d>:
 8006610: 21 66 00 08  	.word	0x08006621
 8006614: 2f 66 00 08  	.word	0x0800662f
 8006618: 3d 66 00 08  	.word	0x0800663d
 800661c: 4b 66 00 08  	.word	0x0800664b

08006620 <$t>:
; 		LL_EXTI_DisableRisingTrig_0_31(line);
 8006620: 6878         	ldr	r0, [r7, #0x4]
 8006622: f7ff fe0b    	bl	0x800623c <LL_EXTI_DisableRisingTrig_0_31> @ imm = #-0x3ea
; 		LL_EXTI_DisableFallingTrig_0_31(line);
 8006626: 6878         	ldr	r0, [r7, #0x4]
 8006628: f7ff fe2c    	bl	0x8006284 <LL_EXTI_DisableFallingTrig_0_31> @ imm = #-0x3a8
; 		break;
 800662c: e015         	b	0x800665a <stm32_gpio_intc_select_line_trigger+0x6a> @ imm = #0x2a
; 		LL_EXTI_EnableRisingTrig_0_31(line);
 800662e: 6878         	ldr	r0, [r7, #0x4]
 8006630: f7ff fdf2    	bl	0x8006218 <LL_EXTI_EnableRisingTrig_0_31> @ imm = #-0x41c
; 		LL_EXTI_DisableFallingTrig_0_31(line);
 8006634: 6878         	ldr	r0, [r7, #0x4]
 8006636: f7ff fe25    	bl	0x8006284 <LL_EXTI_DisableFallingTrig_0_31> @ imm = #-0x3b6
; 		break;
 800663a: e00e         	b	0x800665a <stm32_gpio_intc_select_line_trigger+0x6a> @ imm = #0x1c
; 		LL_EXTI_EnableFallingTrig_0_31(line);
 800663c: 6878         	ldr	r0, [r7, #0x4]
 800663e: f7ff fe0f    	bl	0x8006260 <LL_EXTI_EnableFallingTrig_0_31> @ imm = #-0x3e2
; 		LL_EXTI_DisableRisingTrig_0_31(line);
 8006642: 6878         	ldr	r0, [r7, #0x4]
 8006644: f7ff fdfa    	bl	0x800623c <LL_EXTI_DisableRisingTrig_0_31> @ imm = #-0x40c
; 		break;
 8006648: e007         	b	0x800665a <stm32_gpio_intc_select_line_trigger+0x6a> @ imm = #0xe
; 		LL_EXTI_EnableRisingTrig_0_31(line);
 800664a: 6878         	ldr	r0, [r7, #0x4]
 800664c: f7ff fde4    	bl	0x8006218 <LL_EXTI_EnableRisingTrig_0_31> @ imm = #-0x438
; 		LL_EXTI_EnableFallingTrig_0_31(line);
 8006650: 6878         	ldr	r0, [r7, #0x4]
 8006652: f7ff fe05    	bl	0x8006260 <LL_EXTI_EnableFallingTrig_0_31> @ imm = #-0x3f6
; 		break;
 8006656: e000         	b	0x800665a <stm32_gpio_intc_select_line_trigger+0x6a> @ imm = #0x0
; 		break;
 8006658: bf00         	nop
; 	z_stm32_hsem_unlock(CFG_HW_EXTI_SEMID);
 800665a: 2000         	movs	r0, #0x0
 800665c: f00f fb92    	bl	0x8015d84 <z_stm32_hsem_unlock> @ imm = #0xf724
; }
 8006660: bf00         	nop
 8006662: 3708         	adds	r7, #0x8
 8006664: 46bd         	mov	sp, r7
 8006666: bd80         	pop	{r7, pc}

08006668 <stm32_gpio_intc_set_irq_callback>:
; {
 8006668: b580         	push	{r7, lr}
 800666a: b088         	sub	sp, #0x20
 800666c: af00         	add	r7, sp, #0x0
 800666e: 60f8         	str	r0, [r7, #0xc]
 8006670: 60b9         	str	r1, [r7, #0x8]
 8006672: 607a         	str	r2, [r7, #0x4]
; 	const struct device *const dev = DEVICE_DT_GET(EXTI_NODE);
 8006674: 4b19         	ldr	r3, [pc, #0x64]         @ 0x80066dc <stm32_gpio_intc_set_irq_callback+0x74>
 8006676: 61fb         	str	r3, [r7, #0x1c]
; 	struct stm32_exti_data *data = dev->data;
 8006678: 69fb         	ldr	r3, [r7, #0x1c]
 800667a: 691b         	ldr	r3, [r3, #0x10]
 800667c: 61bb         	str	r3, [r7, #0x18]
; 	uint32_t line_num = ll_exti_line_to_linenum(line);
 800667e: 68f8         	ldr	r0, [r7, #0xc]
 8006680: f00f fbc4    	bl	0x8015e0c <ll_exti_line_to_linenum> @ imm = #0xf788
 8006684: 4603         	mov	r3, r0
 8006686: 617b         	str	r3, [r7, #0x14]
; 	if ((data->cb[line_num].cb == cb) && (data->cb[line_num].data == user)) {
 8006688: 69bb         	ldr	r3, [r7, #0x18]
 800668a: 697a         	ldr	r2, [r7, #0x14]
 800668c: f853 3032    	ldr.w	r3, [r3, r2, lsl #3]
 8006690: 68ba         	ldr	r2, [r7, #0x8]
 8006692: 429a         	cmp	r2, r3
 8006694: d109         	bne	0x80066aa <stm32_gpio_intc_set_irq_callback+0x42> @ imm = #0x12
 8006696: 69ba         	ldr	r2, [r7, #0x18]
 8006698: 697b         	ldr	r3, [r7, #0x14]
 800669a: 00db         	lsls	r3, r3, #0x3
 800669c: 4413         	add	r3, r2
 800669e: 685b         	ldr	r3, [r3, #0x4]
 80066a0: 687a         	ldr	r2, [r7, #0x4]
 80066a2: 429a         	cmp	r2, r3
 80066a4: d101         	bne	0x80066aa <stm32_gpio_intc_set_irq_callback+0x42> @ imm = #0x2
; 		return 0;
 80066a6: 2300         	movs	r3, #0x0
 80066a8: e014         	b	0x80066d4 <stm32_gpio_intc_set_irq_callback+0x6c> @ imm = #0x28
; 	if (data->cb[line_num].cb != NULL) {
 80066aa: 69bb         	ldr	r3, [r7, #0x18]
 80066ac: 697a         	ldr	r2, [r7, #0x14]
 80066ae: f853 3032    	ldr.w	r3, [r3, r2, lsl #3]
 80066b2: 2b00         	cmp	r3, #0x0
 80066b4: d002         	beq	0x80066bc <stm32_gpio_intc_set_irq_callback+0x54> @ imm = #0x4
; 		return -EBUSY;
 80066b6: f06f 030f    	mvn	r3, #0xf
 80066ba: e00b         	b	0x80066d4 <stm32_gpio_intc_set_irq_callback+0x6c> @ imm = #0x16
; 	data->cb[line_num].cb = cb;
 80066bc: 69bb         	ldr	r3, [r7, #0x18]
 80066be: 697a         	ldr	r2, [r7, #0x14]
 80066c0: 68b9         	ldr	r1, [r7, #0x8]
 80066c2: f843 1032    	str.w	r1, [r3, r2, lsl #3]
; 	data->cb[line_num].data = user;
 80066c6: 69ba         	ldr	r2, [r7, #0x18]
 80066c8: 697b         	ldr	r3, [r7, #0x14]
 80066ca: 00db         	lsls	r3, r3, #0x3
 80066cc: 4413         	add	r3, r2
 80066ce: 687a         	ldr	r2, [r7, #0x4]
 80066d0: 605a         	str	r2, [r3, #0x4]
; 	return 0;
 80066d2: 2300         	movs	r3, #0x0
; }
 80066d4: 4618         	mov	r0, r3
 80066d6: 3720         	adds	r7, #0x20
 80066d8: 46bd         	mov	sp, r7
 80066da: bd80         	pop	{r7, pc}

080066dc <$d>:
 80066dc: 50 dd 01 08  	.word	0x0801dd50

080066e0 <stm32_gpio_intc_remove_irq_callback>:
; {
 80066e0: b580         	push	{r7, lr}
 80066e2: b086         	sub	sp, #0x18
 80066e4: af00         	add	r7, sp, #0x0
 80066e6: 6078         	str	r0, [r7, #0x4]
; 	const struct device *const dev = DEVICE_DT_GET(EXTI_NODE);
 80066e8: 4b0c         	ldr	r3, [pc, #0x30]         @ 0x800671c <stm32_gpio_intc_remove_irq_callback+0x3c>
 80066ea: 617b         	str	r3, [r7, #0x14]
; 	struct stm32_exti_data *data = dev->data;
 80066ec: 697b         	ldr	r3, [r7, #0x14]
 80066ee: 691b         	ldr	r3, [r3, #0x10]
 80066f0: 613b         	str	r3, [r7, #0x10]
; 	uint32_t line_num = ll_exti_line_to_linenum(line);
 80066f2: 6878         	ldr	r0, [r7, #0x4]
 80066f4: f00f fb8a    	bl	0x8015e0c <ll_exti_line_to_linenum> @ imm = #0xf714
 80066f8: 4603         	mov	r3, r0
 80066fa: 60fb         	str	r3, [r7, #0xc]
; 	data->cb[line_num].cb = NULL;
 80066fc: 693b         	ldr	r3, [r7, #0x10]
 80066fe: 68fa         	ldr	r2, [r7, #0xc]
 8006700: 2100         	movs	r1, #0x0
 8006702: f843 1032    	str.w	r1, [r3, r2, lsl #3]
; 	data->cb[line_num].data = NULL;
 8006706: 693a         	ldr	r2, [r7, #0x10]
 8006708: 68fb         	ldr	r3, [r7, #0xc]
 800670a: 00db         	lsls	r3, r3, #0x3
 800670c: 4413         	add	r3, r2
 800670e: 2200         	movs	r2, #0x0
 8006710: 605a         	str	r2, [r3, #0x4]
; }
 8006712: bf00         	nop
 8006714: 3718         	adds	r7, #0x18
 8006716: 46bd         	mov	sp, r7
 8006718: bd80         	pop	{r7, pc}
 800671a: bf00         	nop

0800671c <$d>:
 800671c: 50 dd 01 08  	.word	0x0801dd50

08006720 <LL_RCC_HSE_DisableBypass>:
; {
 8006720: b480         	push	{r7}
 8006722: af00         	add	r7, sp, #0x0
;   CLEAR_BIT(RCC->CR, RCC_CR_HSEBYP);
 8006724: 4b04         	ldr	r3, [pc, #0x10]         @ 0x8006738 <LL_RCC_HSE_DisableBypass+0x18>
 8006726: 681b         	ldr	r3, [r3]
 8006728: 4a03         	ldr	r2, [pc, #0xc]          @ 0x8006738 <LL_RCC_HSE_DisableBypass+0x18>
 800672a: f423 2380    	bic	r3, r3, #0x40000
 800672e: 6013         	str	r3, [r2]
; }
 8006730: bf00         	nop
 8006732: 46bd         	mov	sp, r7
 8006734: bc80         	pop	{r7}
 8006736: 4770         	bx	lr

08006738 <$d>:
 8006738: 00 38 02 40  	.word	0x40023800

0800673c <LL_RCC_HSE_Enable>:
; {
 800673c: b480         	push	{r7}
 800673e: af00         	add	r7, sp, #0x0
;   SET_BIT(RCC->CR, RCC_CR_HSEON);
 8006740: 4b04         	ldr	r3, [pc, #0x10]         @ 0x8006754 <LL_RCC_HSE_Enable+0x18>
 8006742: 681b         	ldr	r3, [r3]
 8006744: 4a03         	ldr	r2, [pc, #0xc]          @ 0x8006754 <LL_RCC_HSE_Enable+0x18>
 8006746: f443 3380    	orr	r3, r3, #0x10000
 800674a: 6013         	str	r3, [r2]
; }
 800674c: bf00         	nop
 800674e: 46bd         	mov	sp, r7
 8006750: bc80         	pop	{r7}
 8006752: 4770         	bx	lr

08006754 <$d>:
 8006754: 00 38 02 40  	.word	0x40023800

08006758 <LL_RCC_HSE_IsReady>:
; {
 8006758: b480         	push	{r7}
 800675a: af00         	add	r7, sp, #0x0
;   return (READ_BIT(RCC->CR, RCC_CR_HSERDY) == (RCC_CR_HSERDY));
 800675c: 4b06         	ldr	r3, [pc, #0x18]         @ 0x8006778 <LL_RCC_HSE_IsReady+0x20>
 800675e: 681b         	ldr	r3, [r3]
 8006760: f403 3300    	and	r3, r3, #0x20000
 8006764: f5b3 3f00    	cmp.w	r3, #0x20000
 8006768: bf0c         	ite	eq
 800676a: 2301         	moveq	r3, #0x1
 800676c: 2300         	movne	r3, #0x0
 800676e: b2db         	uxtb	r3, r3
; }
 8006770: 4618         	mov	r0, r3
 8006772: 46bd         	mov	sp, r7
 8006774: bc80         	pop	{r7}
 8006776: 4770         	bx	lr

08006778 <$d>:
 8006778: 00 38 02 40  	.word	0x40023800

0800677c <LL_RCC_HSI_Enable>:
; {
 800677c: b480         	push	{r7}
 800677e: af00         	add	r7, sp, #0x0
;   SET_BIT(RCC->CR, RCC_CR_HSION);
 8006780: 4b04         	ldr	r3, [pc, #0x10]         @ 0x8006794 <LL_RCC_HSI_Enable+0x18>
 8006782: 681b         	ldr	r3, [r3]
 8006784: 4a03         	ldr	r2, [pc, #0xc]          @ 0x8006794 <LL_RCC_HSI_Enable+0x18>
 8006786: f043 0301    	orr	r3, r3, #0x1
 800678a: 6013         	str	r3, [r2]
; }
 800678c: bf00         	nop
 800678e: 46bd         	mov	sp, r7
 8006790: bc80         	pop	{r7}
 8006792: 4770         	bx	lr

08006794 <$d>:
 8006794: 00 38 02 40  	.word	0x40023800

08006798 <LL_RCC_HSI_IsReady>:
; {
 8006798: b480         	push	{r7}
 800679a: af00         	add	r7, sp, #0x0
;   return (READ_BIT(RCC->CR, RCC_CR_HSIRDY) == (RCC_CR_HSIRDY));
 800679c: 4b06         	ldr	r3, [pc, #0x18]         @ 0x80067b8 <LL_RCC_HSI_IsReady+0x20>
 800679e: 681b         	ldr	r3, [r3]
 80067a0: f003 0302    	and	r3, r3, #0x2
 80067a4: 2b02         	cmp	r3, #0x2
 80067a6: bf0c         	ite	eq
 80067a8: 2301         	moveq	r3, #0x1
 80067aa: 2300         	movne	r3, #0x0
 80067ac: b2db         	uxtb	r3, r3
; }
 80067ae: 4618         	mov	r0, r3
 80067b0: 46bd         	mov	sp, r7
 80067b2: bc80         	pop	{r7}
 80067b4: 4770         	bx	lr
 80067b6: bf00         	nop

080067b8 <$d>:
 80067b8: 00 38 02 40  	.word	0x40023800

080067bc <LL_RCC_LSI_Enable>:
; {
 80067bc: b480         	push	{r7}
 80067be: af00         	add	r7, sp, #0x0
;   SET_BIT(RCC->CSR, RCC_CSR_LSION);
 80067c0: 4b04         	ldr	r3, [pc, #0x10]         @ 0x80067d4 <LL_RCC_LSI_Enable+0x18>
 80067c2: 6f5b         	ldr	r3, [r3, #0x74]
 80067c4: 4a03         	ldr	r2, [pc, #0xc]          @ 0x80067d4 <LL_RCC_LSI_Enable+0x18>
 80067c6: f043 0301    	orr	r3, r3, #0x1
 80067ca: 6753         	str	r3, [r2, #0x74]
; }
 80067cc: bf00         	nop
 80067ce: 46bd         	mov	sp, r7
 80067d0: bc80         	pop	{r7}
 80067d2: 4770         	bx	lr

080067d4 <$d>:
 80067d4: 00 38 02 40  	.word	0x40023800

080067d8 <LL_RCC_LSI_IsReady>:
; {
 80067d8: b480         	push	{r7}
 80067da: af00         	add	r7, sp, #0x0
;   return (READ_BIT(RCC->CSR, RCC_CSR_LSIRDY) == (RCC_CSR_LSIRDY));
 80067dc: 4b06         	ldr	r3, [pc, #0x18]         @ 0x80067f8 <LL_RCC_LSI_IsReady+0x20>
 80067de: 6f5b         	ldr	r3, [r3, #0x74]
 80067e0: f003 0302    	and	r3, r3, #0x2
 80067e4: 2b02         	cmp	r3, #0x2
 80067e6: bf0c         	ite	eq
 80067e8: 2301         	moveq	r3, #0x1
 80067ea: 2300         	movne	r3, #0x0
 80067ec: b2db         	uxtb	r3, r3
; }
 80067ee: 4618         	mov	r0, r3
 80067f0: 46bd         	mov	sp, r7
 80067f2: bc80         	pop	{r7}
 80067f4: 4770         	bx	lr
 80067f6: bf00         	nop

080067f8 <$d>:
 80067f8: 00 38 02 40  	.word	0x40023800

080067fc <LL_RCC_SetSysClkSource>:
; {
 80067fc: b480         	push	{r7}
 80067fe: b083         	sub	sp, #0xc
 8006800: af00         	add	r7, sp, #0x0
 8006802: 6078         	str	r0, [r7, #0x4]
;   MODIFY_REG(RCC->CFGR, RCC_CFGR_SW, Source);
 8006804: 4b06         	ldr	r3, [pc, #0x18]         @ 0x8006820 <LL_RCC_SetSysClkSource+0x24>
 8006806: 689b         	ldr	r3, [r3, #0x8]
 8006808: f023 0203    	bic	r2, r3, #0x3
 800680c: 4904         	ldr	r1, [pc, #0x10]         @ 0x8006820 <LL_RCC_SetSysClkSource+0x24>
 800680e: 687b         	ldr	r3, [r7, #0x4]
 8006810: 4313         	orrs	r3, r2
 8006812: 608b         	str	r3, [r1, #0x8]
; }
 8006814: bf00         	nop
 8006816: 370c         	adds	r7, #0xc
 8006818: 46bd         	mov	sp, r7
 800681a: bc80         	pop	{r7}
 800681c: 4770         	bx	lr
 800681e: bf00         	nop

08006820 <$d>:
 8006820: 00 38 02 40  	.word	0x40023800

08006824 <LL_RCC_GetSysClkSource>:
; {
 8006824: b480         	push	{r7}
 8006826: af00         	add	r7, sp, #0x0
;   return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_SWS));
 8006828: 4b03         	ldr	r3, [pc, #0xc]          @ 0x8006838 <LL_RCC_GetSysClkSource+0x14>
 800682a: 689b         	ldr	r3, [r3, #0x8]
 800682c: f003 030c    	and	r3, r3, #0xc
; }
 8006830: 4618         	mov	r0, r3
 8006832: 46bd         	mov	sp, r7
 8006834: bc80         	pop	{r7}
 8006836: 4770         	bx	lr

08006838 <$d>:
 8006838: 00 38 02 40  	.word	0x40023800

0800683c <LL_RCC_SetAHBPrescaler>:
; {
 800683c: b480         	push	{r7}
 800683e: b083         	sub	sp, #0xc
 8006840: af00         	add	r7, sp, #0x0
 8006842: 6078         	str	r0, [r7, #0x4]
;   MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, Prescaler);
 8006844: 4b06         	ldr	r3, [pc, #0x18]         @ 0x8006860 <LL_RCC_SetAHBPrescaler+0x24>
 8006846: 689b         	ldr	r3, [r3, #0x8]
 8006848: f023 02f0    	bic	r2, r3, #0xf0
 800684c: 4904         	ldr	r1, [pc, #0x10]         @ 0x8006860 <LL_RCC_SetAHBPrescaler+0x24>
 800684e: 687b         	ldr	r3, [r7, #0x4]
 8006850: 4313         	orrs	r3, r2
 8006852: 608b         	str	r3, [r1, #0x8]
; }
 8006854: bf00         	nop
 8006856: 370c         	adds	r7, #0xc
 8006858: 46bd         	mov	sp, r7
 800685a: bc80         	pop	{r7}
 800685c: 4770         	bx	lr
 800685e: bf00         	nop

08006860 <$d>:
 8006860: 00 38 02 40  	.word	0x40023800

08006864 <LL_RCC_SetAPB1Prescaler>:
; {
 8006864: b480         	push	{r7}
 8006866: b083         	sub	sp, #0xc
 8006868: af00         	add	r7, sp, #0x0
 800686a: 6078         	str	r0, [r7, #0x4]
;   MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, Prescaler);
 800686c: 4b06         	ldr	r3, [pc, #0x18]         @ 0x8006888 <LL_RCC_SetAPB1Prescaler+0x24>
 800686e: 689b         	ldr	r3, [r3, #0x8]
 8006870: f423 52e0    	bic	r2, r3, #0x1c00
 8006874: 4904         	ldr	r1, [pc, #0x10]         @ 0x8006888 <LL_RCC_SetAPB1Prescaler+0x24>
 8006876: 687b         	ldr	r3, [r7, #0x4]
 8006878: 4313         	orrs	r3, r2
 800687a: 608b         	str	r3, [r1, #0x8]
; }
 800687c: bf00         	nop
 800687e: 370c         	adds	r7, #0xc
 8006880: 46bd         	mov	sp, r7
 8006882: bc80         	pop	{r7}
 8006884: 4770         	bx	lr
 8006886: bf00         	nop

08006888 <$d>:
 8006888: 00 38 02 40  	.word	0x40023800

0800688c <LL_RCC_SetAPB2Prescaler>:
; {
 800688c: b480         	push	{r7}
 800688e: b083         	sub	sp, #0xc
 8006890: af00         	add	r7, sp, #0x0
 8006892: 6078         	str	r0, [r7, #0x4]
;   MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, Prescaler);
 8006894: 4b06         	ldr	r3, [pc, #0x18]         @ 0x80068b0 <LL_RCC_SetAPB2Prescaler+0x24>
 8006896: 689b         	ldr	r3, [r3, #0x8]
 8006898: f423 4260    	bic	r2, r3, #0xe000
 800689c: 4904         	ldr	r1, [pc, #0x10]         @ 0x80068b0 <LL_RCC_SetAPB2Prescaler+0x24>
 800689e: 687b         	ldr	r3, [r7, #0x4]
 80068a0: 4313         	orrs	r3, r2
 80068a2: 608b         	str	r3, [r1, #0x8]
; }
 80068a4: bf00         	nop
 80068a6: 370c         	adds	r7, #0xc
 80068a8: 46bd         	mov	sp, r7
 80068aa: bc80         	pop	{r7}
 80068ac: 4770         	bx	lr
 80068ae: bf00         	nop

080068b0 <$d>:
 80068b0: 00 38 02 40  	.word	0x40023800

080068b4 <LL_RCC_GetAHBPrescaler>:
; {
 80068b4: b480         	push	{r7}
 80068b6: af00         	add	r7, sp, #0x0
;   return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_HPRE));
 80068b8: 4b03         	ldr	r3, [pc, #0xc]          @ 0x80068c8 <LL_RCC_GetAHBPrescaler+0x14>
 80068ba: 689b         	ldr	r3, [r3, #0x8]
 80068bc: f003 03f0    	and	r3, r3, #0xf0
; }
 80068c0: 4618         	mov	r0, r3
 80068c2: 46bd         	mov	sp, r7
 80068c4: bc80         	pop	{r7}
 80068c6: 4770         	bx	lr

080068c8 <$d>:
 80068c8: 00 38 02 40  	.word	0x40023800

080068cc <LL_RCC_PLL_Enable>:
; {
 80068cc: b480         	push	{r7}
 80068ce: af00         	add	r7, sp, #0x0
;   SET_BIT(RCC->CR, RCC_CR_PLLON);
 80068d0: 4b04         	ldr	r3, [pc, #0x10]         @ 0x80068e4 <LL_RCC_PLL_Enable+0x18>
 80068d2: 681b         	ldr	r3, [r3]
 80068d4: 4a03         	ldr	r2, [pc, #0xc]          @ 0x80068e4 <LL_RCC_PLL_Enable+0x18>
 80068d6: f043 7380    	orr	r3, r3, #0x1000000
 80068da: 6013         	str	r3, [r2]
; }
 80068dc: bf00         	nop
 80068de: 46bd         	mov	sp, r7
 80068e0: bc80         	pop	{r7}
 80068e2: 4770         	bx	lr

080068e4 <$d>:
 80068e4: 00 38 02 40  	.word	0x40023800

080068e8 <LL_RCC_PLL_Disable>:
; {
 80068e8: b480         	push	{r7}
 80068ea: af00         	add	r7, sp, #0x0
;   CLEAR_BIT(RCC->CR, RCC_CR_PLLON);
 80068ec: 4b04         	ldr	r3, [pc, #0x10]         @ 0x8006900 <LL_RCC_PLL_Disable+0x18>
 80068ee: 681b         	ldr	r3, [r3]
 80068f0: 4a03         	ldr	r2, [pc, #0xc]          @ 0x8006900 <LL_RCC_PLL_Disable+0x18>
 80068f2: f023 7380    	bic	r3, r3, #0x1000000
 80068f6: 6013         	str	r3, [r2]
; }
 80068f8: bf00         	nop
 80068fa: 46bd         	mov	sp, r7
 80068fc: bc80         	pop	{r7}
 80068fe: 4770         	bx	lr

08006900 <$d>:
 8006900: 00 38 02 40  	.word	0x40023800

08006904 <LL_RCC_PLL_IsReady>:
; {
 8006904: b480         	push	{r7}
 8006906: af00         	add	r7, sp, #0x0
;   return (READ_BIT(RCC->CR, RCC_CR_PLLRDY) == (RCC_CR_PLLRDY));
 8006908: 4b06         	ldr	r3, [pc, #0x18]         @ 0x8006924 <LL_RCC_PLL_IsReady+0x20>
 800690a: 681b         	ldr	r3, [r3]
 800690c: f003 7300    	and	r3, r3, #0x2000000
 8006910: f1b3 7f00    	cmp.w	r3, #0x2000000
 8006914: bf0c         	ite	eq
 8006916: 2301         	moveq	r3, #0x1
 8006918: 2300         	movne	r3, #0x0
 800691a: b2db         	uxtb	r3, r3
; }
 800691c: 4618         	mov	r0, r3
 800691e: 46bd         	mov	sp, r7
 8006920: bc80         	pop	{r7}
 8006922: 4770         	bx	lr

08006924 <$d>:
 8006924: 00 38 02 40  	.word	0x40023800

08006928 <enabled_clock>:
; {
 8006928: b480         	push	{r7}
 800692a: b085         	sub	sp, #0x14
 800692c: af00         	add	r7, sp, #0x0
 800692e: 6078         	str	r0, [r7, #0x4]
; 	int r = 0;
 8006930: 2300         	movs	r3, #0x0
 8006932: 60fb         	str	r3, [r7, #0xc]
; 	switch (src_clk) {
 8006934: 687b         	ldr	r3, [r7, #0x4]
 8006936: 3b01         	subs	r3, #0x1
 8006938: 2b08         	cmp	r3, #0x8
 800693a: d825         	bhi	0x8006988 <enabled_clock+0x60> @ imm = #0x4a
 800693c: a201         	adr	r2, #4 <enabled_clock+0x19>
 800693e: f852 f023    	ldr.w	pc, [r2, r3, lsl #2]
 8006942: bf00         	nop

08006944 <$d>:
 8006944: 8f 69 00 08  	.word	0x0800698f
 8006948: 71 69 00 08  	.word	0x08006971
 800694c: 8f 69 00 08  	.word	0x0800698f
 8006950: 69 69 00 08  	.word	0x08006969
 8006954: 8f 69 00 08  	.word	0x0800698f
 8006958: 8f 69 00 08  	.word	0x0800698f
 800695c: 8f 69 00 08  	.word	0x0800698f
 8006960: 79 69 00 08  	.word	0x08006979
 8006964: 81 69 00 08  	.word	0x08006981

08006968 <$t>:
; 			r = -ENOTSUP;
 8006968: f06f 0385    	mvn	r3, #0x85
 800696c: 60fb         	str	r3, [r7, #0xc]
; 		break;
 800696e: e00f         	b	0x8006990 <enabled_clock+0x68> @ imm = #0x1e
; 			r = -ENOTSUP;
 8006970: f06f 0385    	mvn	r3, #0x85
 8006974: 60fb         	str	r3, [r7, #0xc]
; 		break;
 8006976: e00b         	b	0x8006990 <enabled_clock+0x68> @ imm = #0x16
; 			r = -ENOTSUP;
 8006978: f06f 0385    	mvn	r3, #0x85
 800697c: 60fb         	str	r3, [r7, #0xc]
; 		break;
 800697e: e007         	b	0x8006990 <enabled_clock+0x68> @ imm = #0xe
; 			r = -ENOTSUP;
 8006980: f06f 0385    	mvn	r3, #0x85
 8006984: 60fb         	str	r3, [r7, #0xc]
; 		break;
 8006986: e003         	b	0x8006990 <enabled_clock+0x68> @ imm = #0x6
; 		return -ENOTSUP;
 8006988: f06f 0385    	mvn	r3, #0x85
 800698c: e001         	b	0x8006992 <enabled_clock+0x6a> @ imm = #0x2
; 		break;
 800698e: bf00         	nop
; 	return r;
 8006990: 68fb         	ldr	r3, [r7, #0xc]
; }
 8006992: 4618         	mov	r0, r3
 8006994: 3714         	adds	r7, #0x14
 8006996: 46bd         	mov	sp, r7
 8006998: bc80         	pop	{r7}
 800699a: 4770         	bx	lr

0800699c <stm32_clock_control_get_subsys_rate>:
; {
 800699c: b580         	push	{r7, lr}
 800699e: b08a         	sub	sp, #0x28
 80069a0: af00         	add	r7, sp, #0x0
 80069a2: 60f8         	str	r0, [r7, #0xc]
 80069a4: 60b9         	str	r1, [r7, #0x8]
 80069a6: 607a         	str	r2, [r7, #0x4]
; 	struct stm32_pclken *pclken = (struct stm32_pclken *)(sub_system);
 80069a8: 68bb         	ldr	r3, [r7, #0x8]
 80069aa: 627b         	str	r3, [r7, #0x24]
; 	uint32_t ahb_clock = SystemCoreClock;
 80069ac: 4b78         	ldr	r3, [pc, #0x1e0]        @ 0x8006b90 <stm32_clock_control_get_subsys_rate+0x1f4>
 80069ae: 681b         	ldr	r3, [r3]
 80069b0: 623b         	str	r3, [r7, #0x20]
; 	uint32_t apb1_clock = get_bus_clock(ahb_clock, STM32_APB1_PRESCALER);
 80069b2: 2104         	movs	r1, #0x4
 80069b4: 6a38         	ldr	r0, [r7, #0x20]
 80069b6: f00f faa2    	bl	0x8015efe <get_bus_clock> @ imm = #0xf544
 80069ba: 61f8         	str	r0, [r7, #0x1c]
; 	uint32_t apb2_clock = get_bus_clock(ahb_clock, STM32_APB2_PRESCALER);
 80069bc: 2102         	movs	r1, #0x2
 80069be: 6a38         	ldr	r0, [r7, #0x20]
 80069c0: f00f fa9d    	bl	0x8015efe <get_bus_clock> @ imm = #0xf53a
 80069c4: 61b8         	str	r0, [r7, #0x18]
; 	uint32_t ahb3_clock = ahb_clock;
 80069c6: 6a3b         	ldr	r3, [r7, #0x20]
 80069c8: 617b         	str	r3, [r7, #0x14]
; 	switch (pclken->bus) {
 80069ca: 6a7b         	ldr	r3, [r7, #0x24]
 80069cc: 681b         	ldr	r3, [r3]
 80069ce: 2b44         	cmp	r3, #0x44
 80069d0: f200 8092    	bhi.w	0x8006af8 <stm32_clock_control_get_subsys_rate+0x15c> @ imm = #0x124
 80069d4: 2b00         	cmp	r3, #0x0
 80069d6: f000 80d2    	beq.w	0x8006b7e <stm32_clock_control_get_subsys_rate+0x1e2> @ imm = #0x1a4
 80069da: 3b01         	subs	r3, #0x1
 80069dc: 2b43         	cmp	r3, #0x43
 80069de: f200 80ce    	bhi.w	0x8006b7e <stm32_clock_control_get_subsys_rate+0x1e2> @ imm = #0x19c
 80069e2: a201         	adr	r2, #4 <stm32_clock_control_get_subsys_rate+0x4b>
 80069e4: f852 f023    	ldr.w	pc, [r2, r3, lsl #2]

080069e8 <$d>:
 80069e8: 27 6b 00 08  	.word	0x08006b27
 80069ec: 5d 6b 00 08  	.word	0x08006b5d
 80069f0: 65 6b 00 08  	.word	0x08006b65
 80069f4: 6f 6b 00 08  	.word	0x08006b6f
 80069f8: 77 6b 00 08  	.word	0x08006b77
 80069fc: 31 6b 00 08  	.word	0x08006b31
 8006a00: 47 6b 00 08  	.word	0x08006b47
 8006a04: 7f 6b 00 08  	.word	0x08006b7f
 8006a08: 7f 6b 00 08  	.word	0x08006b7f
 8006a0c: 7f 6b 00 08  	.word	0x08006b7f
 8006a10: 7f 6b 00 08  	.word	0x08006b7f
 8006a14: 7f 6b 00 08  	.word	0x08006b7f
 8006a18: 7f 6b 00 08  	.word	0x08006b7f
 8006a1c: 7f 6b 00 08  	.word	0x08006b7f
 8006a20: 7f 6b 00 08  	.word	0x08006b7f
 8006a24: 7f 6b 00 08  	.word	0x08006b7f
 8006a28: 7f 6b 00 08  	.word	0x08006b7f
 8006a2c: 7f 6b 00 08  	.word	0x08006b7f
 8006a30: 7f 6b 00 08  	.word	0x08006b7f
 8006a34: 7f 6b 00 08  	.word	0x08006b7f
 8006a38: 7f 6b 00 08  	.word	0x08006b7f
 8006a3c: 7f 6b 00 08  	.word	0x08006b7f
 8006a40: 7f 6b 00 08  	.word	0x08006b7f
 8006a44: 7f 6b 00 08  	.word	0x08006b7f
 8006a48: 7f 6b 00 08  	.word	0x08006b7f
 8006a4c: 7f 6b 00 08  	.word	0x08006b7f
 8006a50: 7f 6b 00 08  	.word	0x08006b7f
 8006a54: 7f 6b 00 08  	.word	0x08006b7f
 8006a58: 7f 6b 00 08  	.word	0x08006b7f
 8006a5c: 7f 6b 00 08  	.word	0x08006b7f
 8006a60: 7f 6b 00 08  	.word	0x08006b7f
 8006a64: 7f 6b 00 08  	.word	0x08006b7f
 8006a68: 7f 6b 00 08  	.word	0x08006b7f
 8006a6c: 7f 6b 00 08  	.word	0x08006b7f
 8006a70: 7f 6b 00 08  	.word	0x08006b7f
 8006a74: 7f 6b 00 08  	.word	0x08006b7f
 8006a78: 7f 6b 00 08  	.word	0x08006b7f
 8006a7c: 7f 6b 00 08  	.word	0x08006b7f
 8006a80: 7f 6b 00 08  	.word	0x08006b7f
 8006a84: 7f 6b 00 08  	.word	0x08006b7f
 8006a88: 7f 6b 00 08  	.word	0x08006b7f
 8006a8c: 7f 6b 00 08  	.word	0x08006b7f
 8006a90: 7f 6b 00 08  	.word	0x08006b7f
 8006a94: 7f 6b 00 08  	.word	0x08006b7f
 8006a98: 7f 6b 00 08  	.word	0x08006b7f
 8006a9c: 7f 6b 00 08  	.word	0x08006b7f
 8006aa0: 7f 6b 00 08  	.word	0x08006b7f
 8006aa4: ff 6a 00 08  	.word	0x08006aff
 8006aa8: 7f 6b 00 08  	.word	0x08006b7f
 8006aac: 7f 6b 00 08  	.word	0x08006b7f
 8006ab0: 7f 6b 00 08  	.word	0x08006b7f
 8006ab4: ff 6a 00 08  	.word	0x08006aff
 8006ab8: 7f 6b 00 08  	.word	0x08006b7f
 8006abc: 7f 6b 00 08  	.word	0x08006b7f
 8006ac0: 7f 6b 00 08  	.word	0x08006b7f
 8006ac4: 07 6b 00 08  	.word	0x08006b07
 8006ac8: 7f 6b 00 08  	.word	0x08006b7f
 8006acc: 7f 6b 00 08  	.word	0x08006b7f
 8006ad0: 7f 6b 00 08  	.word	0x08006b7f
 8006ad4: 7f 6b 00 08  	.word	0x08006b7f
 8006ad8: 7f 6b 00 08  	.word	0x08006b7f
 8006adc: 7f 6b 00 08  	.word	0x08006b7f
 8006ae0: 7f 6b 00 08  	.word	0x08006b7f
 8006ae4: 0f 6b 00 08  	.word	0x08006b0f
 8006ae8: 7f 6b 00 08  	.word	0x08006b7f
 8006aec: 7f 6b 00 08  	.word	0x08006b7f
 8006af0: 7f 6b 00 08  	.word	0x08006b7f
 8006af4: 17 6b 00 08  	.word	0x08006b17

08006af8 <$t>:
 8006af8: 2ba8         	cmp	r3, #0xa8
 8006afa: d010         	beq	0x8006b1e <stm32_clock_control_get_subsys_rate+0x182> @ imm = #0x20
 8006afc: e03f         	b	0x8006b7e <stm32_clock_control_get_subsys_rate+0x1e2> @ imm = #0x7e
; 		*rate = ahb_clock;
 8006afe: 687b         	ldr	r3, [r7, #0x4]
 8006b00: 6a3a         	ldr	r2, [r7, #0x20]
 8006b02: 601a         	str	r2, [r3]
; 		break;
 8006b04: e03e         	b	0x8006b84 <stm32_clock_control_get_subsys_rate+0x1e8> @ imm = #0x7c
; 		*rate = ahb3_clock;
 8006b06: 687b         	ldr	r3, [r7, #0x4]
 8006b08: 697a         	ldr	r2, [r7, #0x14]
 8006b0a: 601a         	str	r2, [r3]
; 		break;
 8006b0c: e03a         	b	0x8006b84 <stm32_clock_control_get_subsys_rate+0x1e8> @ imm = #0x74
; 		*rate = apb1_clock;
 8006b0e: 687b         	ldr	r3, [r7, #0x4]
 8006b10: 69fa         	ldr	r2, [r7, #0x1c]
 8006b12: 601a         	str	r2, [r3]
; 		break;
 8006b14: e036         	b	0x8006b84 <stm32_clock_control_get_subsys_rate+0x1e8> @ imm = #0x6c
; 		*rate = apb2_clock;
 8006b16: 687b         	ldr	r3, [r7, #0x4]
 8006b18: 69ba         	ldr	r2, [r7, #0x18]
 8006b1a: 601a         	str	r2, [r3]
; 		break;
 8006b1c: e032         	b	0x8006b84 <stm32_clock_control_get_subsys_rate+0x1e8> @ imm = #0x64
; 		*rate = ahb3_clock;
 8006b1e: 687b         	ldr	r3, [r7, #0x4]
 8006b20: 697a         	ldr	r2, [r7, #0x14]
 8006b22: 601a         	str	r2, [r3]
; 		break;
 8006b24: e02e         	b	0x8006b84 <stm32_clock_control_get_subsys_rate+0x1e8> @ imm = #0x5c
; 		*rate = SystemCoreClock * STM32_CORE_PRESCALER;
 8006b26: 4b1a         	ldr	r3, [pc, #0x68]         @ 0x8006b90 <stm32_clock_control_get_subsys_rate+0x1f4>
 8006b28: 681a         	ldr	r2, [r3]
 8006b2a: 687b         	ldr	r3, [r7, #0x4]
 8006b2c: 601a         	str	r2, [r3]
; 		break;
 8006b2e: e029         	b	0x8006b84 <stm32_clock_control_get_subsys_rate+0x1e8> @ imm = #0x52
; 		*rate = get_pll_div_frequency(get_pllsrc_frequency(),
 8006b30: f000 f8f0    	bl	0x8006d14 <get_pllsrc_frequency> @ imm = #0x1e0
 8006b34: 2302         	movs	r3, #0x2
 8006b36: 22a8         	movs	r2, #0xa8
 8006b38: 2106         	movs	r1, #0x6
 8006b3a: f00f f9ca    	bl	0x8015ed2 <get_pll_div_frequency> @ imm = #0xf394
 8006b3e: 4602         	mov	r2, r0
 8006b40: 687b         	ldr	r3, [r7, #0x4]
 8006b42: 601a         	str	r2, [r3]
; 		break;
 8006b44: e01e         	b	0x8006b84 <stm32_clock_control_get_subsys_rate+0x1e8> @ imm = #0x3c
; 		*rate = get_pll_div_frequency(get_pllsrc_frequency(),
 8006b46: f000 f8e5    	bl	0x8006d14 <get_pllsrc_frequency> @ imm = #0x1ca
 8006b4a: 2304         	movs	r3, #0x4
 8006b4c: 22a8         	movs	r2, #0xa8
 8006b4e: 2106         	movs	r1, #0x6
 8006b50: f00f f9bf    	bl	0x8015ed2 <get_pll_div_frequency> @ imm = #0xf37e
 8006b54: 4602         	mov	r2, r0
 8006b56: 687b         	ldr	r3, [r7, #0x4]
 8006b58: 601a         	str	r2, [r3]
; 		break;
 8006b5a: e013         	b	0x8006b84 <stm32_clock_control_get_subsys_rate+0x1e8> @ imm = #0x26
; 		*rate = STM32_LSE_FREQ;
 8006b5c: 687b         	ldr	r3, [r7, #0x4]
 8006b5e: 2200         	movs	r2, #0x0
 8006b60: 601a         	str	r2, [r3]
; 		break;
 8006b62: e00f         	b	0x8006b84 <stm32_clock_control_get_subsys_rate+0x1e8> @ imm = #0x1e
; 		*rate = STM32_LSI_FREQ;
 8006b64: 687b         	ldr	r3, [r7, #0x4]
 8006b66: f44f 42fa    	mov.w	r2, #0x7d00
 8006b6a: 601a         	str	r2, [r3]
; 		break;
 8006b6c: e00a         	b	0x8006b84 <stm32_clock_control_get_subsys_rate+0x1e8> @ imm = #0x14
; 		*rate = STM32_HSI_FREQ;
 8006b6e: 687b         	ldr	r3, [r7, #0x4]
 8006b70: 2200         	movs	r2, #0x0
 8006b72: 601a         	str	r2, [r3]
; 		break;
 8006b74: e006         	b	0x8006b84 <stm32_clock_control_get_subsys_rate+0x1e8> @ imm = #0xc
; 		*rate = STM32_HSE_FREQ;
 8006b76: 687b         	ldr	r3, [r7, #0x4]
 8006b78: 4a06         	ldr	r2, [pc, #0x18]         @ 0x8006b94 <stm32_clock_control_get_subsys_rate+0x1f8>
 8006b7a: 601a         	str	r2, [r3]
; 		break;
 8006b7c: e002         	b	0x8006b84 <stm32_clock_control_get_subsys_rate+0x1e8> @ imm = #0x4
; 		return -ENOTSUP;
 8006b7e: f06f 0385    	mvn	r3, #0x85
 8006b82: e000         	b	0x8006b86 <stm32_clock_control_get_subsys_rate+0x1ea> @ imm = #0x0
; 	return 0;
 8006b84: 2300         	movs	r3, #0x0
; }
 8006b86: 4618         	mov	r0, r3
 8006b88: 3728         	adds	r7, #0x28
 8006b8a: 46bd         	mov	sp, r7
 8006b8c: bd80         	pop	{r7, pc}
 8006b8e: bf00         	nop

08006b90 <$d>:
 8006b90: 90 05 00 20  	.word	0x20000590
 8006b94: 00 1b b7 00  	.word	0x00b71b00

08006b98 <set_up_plls>:
; {
 8006b98: b580         	push	{r7, lr}
 8006b9a: af00         	add	r7, sp, #0x0
; 	if (LL_RCC_GetSysClkSource() == LL_RCC_SYS_CLKSOURCE_STATUS_PLL) {
 8006b9c: f7ff fe42    	bl	0x8006824 <LL_RCC_GetSysClkSource> @ imm = #-0x37c
 8006ba0: 4603         	mov	r3, r0
 8006ba2: 2b08         	cmp	r3, #0x8
 8006ba4: d104         	bne	0x8006bb0 <set_up_plls+0x18> @ imm = #0x8
; 		stm32_clock_switch_to_hsi();
 8006ba6: f00f fab6    	bl	0x8016116 <stm32_clock_switch_to_hsi> @ imm = #0xf56c
; 		LL_RCC_SetAHBPrescaler(ahb_prescaler(1));
 8006baa: 2000         	movs	r0, #0x0
 8006bac: f7ff fe46    	bl	0x800683c <LL_RCC_SetAHBPrescaler> @ imm = #-0x374
; 	LL_RCC_PLL_Disable();
 8006bb0: f7ff fe9a    	bl	0x80068e8 <LL_RCC_PLL_Disable> @ imm = #-0x2cc
; 	MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLLP, pllp(STM32_PLL_P_DIVISOR));
 8006bb4: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x8006bec <set_up_plls+0x54>
 8006bb6: 685b         	ldr	r3, [r3, #0x4]
 8006bb8: 4a0c         	ldr	r2, [pc, #0x30]         @ 0x8006bec <set_up_plls+0x54>
 8006bba: f423 3340    	bic	r3, r3, #0x30000
 8006bbe: 6053         	str	r3, [r2, #0x4]
; 	MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLLQ, pllq(STM32_PLL_Q_DIVISOR));
 8006bc0: 4b0a         	ldr	r3, [pc, #0x28]         @ 0x8006bec <set_up_plls+0x54>
 8006bc2: 685b         	ldr	r3, [r3, #0x4]
 8006bc4: f023 6370    	bic	r3, r3, #0xf000000
 8006bc8: 4a08         	ldr	r2, [pc, #0x20]         @ 0x8006bec <set_up_plls+0x54>
 8006bca: f043 6380    	orr	r3, r3, #0x4000000
 8006bce: 6053         	str	r3, [r2, #0x4]
; 	config_pll_sysclock();
 8006bd0: f00f fae4    	bl	0x801619c <config_pll_sysclock> @ imm = #0xf5c8
; 	LL_RCC_PLL_Enable();
 8006bd4: f7ff fe7a    	bl	0x80068cc <LL_RCC_PLL_Enable> @ imm = #-0x30c
; 	while (LL_RCC_PLL_IsReady() != 1U) {
 8006bd8: bf00         	nop
 8006bda: f7ff fe93    	bl	0x8006904 <LL_RCC_PLL_IsReady> @ imm = #-0x2da
 8006bde: 4603         	mov	r3, r0
 8006be0: 2b01         	cmp	r3, #0x1
 8006be2: d1fa         	bne	0x8006bda <set_up_plls+0x42> @ imm = #-0xc
; }
 8006be4: bf00         	nop
 8006be6: bf00         	nop
 8006be8: bd80         	pop	{r7, pc}
 8006bea: bf00         	nop

08006bec <$d>:
 8006bec: 00 38 02 40  	.word	0x40023800

08006bf0 <stm32_clock_control_init>:
; {
 8006bf0: b590         	push	{r4, r7, lr}
 8006bf2: b085         	sub	sp, #0x14
 8006bf4: af00         	add	r7, sp, #0x0
 8006bf6: 6078         	str	r0, [r7, #0x4]
; 	config_enable_default_clocks();
 8006bf8: f00f fadb    	bl	0x80161b2 <config_enable_default_clocks> @ imm = #0xf5b6
; 	config_regulator_voltage(CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC);
 8006bfc: 4823         	ldr	r0, [pc, #0x8c]         @ 0x8006c8c <stm32_clock_control_init+0x9c>
 8006bfe: f00f fabc    	bl	0x801617a <config_regulator_voltage> @ imm = #0xf578
; 	old_flash_freq = RCC_CALC_FLASH_FREQ(HAL_RCC_GetSysClockFreq(),
 8006c02: f006 fa1d    	bl	0x800d040 <HAL_RCC_GetSysClockFreq> @ imm = #0x643a
 8006c06: 4604         	mov	r4, r0
 8006c08: f7ff fe54    	bl	0x80068b4 <LL_RCC_GetAHBPrescaler> @ imm = #-0x358
 8006c0c: 4603         	mov	r3, r0
 8006c0e: 091b         	lsrs	r3, r3, #0x4
 8006c10: f003 030f    	and	r3, r3, #0xf
 8006c14: 4a1e         	ldr	r2, [pc, #0x78]         @ 0x8006c90 <stm32_clock_control_init+0xa0>
 8006c16: 5cd3         	ldrb	r3, [r2, r3]
 8006c18: fa24 f303    	lsr.w	r3, r4, r3
 8006c1c: 60fb         	str	r3, [r7, #0xc]
; 	new_flash_freq = RCC_CALC_FLASH_FREQ(CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC,
 8006c1e: 4b1c         	ldr	r3, [pc, #0x70]         @ 0x8006c90 <stm32_clock_control_init+0xa0>
 8006c20: 781b         	ldrb	r3, [r3]
 8006c22: 461a         	mov	r2, r3
 8006c24: 4b19         	ldr	r3, [pc, #0x64]         @ 0x8006c8c <stm32_clock_control_init+0x9c>
 8006c26: 4113         	asrs	r3, r2
 8006c28: 60bb         	str	r3, [r7, #0x8]
; 	if (old_flash_freq < new_flash_freq) {
 8006c2a: 68fa         	ldr	r2, [r7, #0xc]
 8006c2c: 68bb         	ldr	r3, [r7, #0x8]
 8006c2e: 429a         	cmp	r2, r3
 8006c30: d202         	bhs	0x8006c38 <stm32_clock_control_init+0x48> @ imm = #0x4
; 		LL_SetFlashLatency(new_flash_freq);
 8006c32: 68b8         	ldr	r0, [r7, #0x8]
 8006c34: f006 fbf6    	bl	0x800d424 <LL_SetFlashLatency> @ imm = #0x67ec
; 	set_up_fixed_clock_sources();
 8006c38: f00f fa88    	bl	0x801614c <set_up_fixed_clock_sources> @ imm = #0xf510
; 	set_up_plls();
 8006c3c: f7ff ffac    	bl	0x8006b98 <set_up_plls> @ imm = #-0xa8
; 		LL_RCC_SetAHBPrescaler(ahb_prescaler(STM32_CORE_PRESCALER));
 8006c40: 2000         	movs	r0, #0x0
 8006c42: f7ff fdfb    	bl	0x800683c <LL_RCC_SetAHBPrescaler> @ imm = #-0x40a
; 	LL_RCC_SetSysClkSource(LL_RCC_SYS_CLKSOURCE_PLL);
 8006c46: 2002         	movs	r0, #0x2
 8006c48: f7ff fdd8    	bl	0x80067fc <LL_RCC_SetSysClkSource> @ imm = #-0x450
; 	while (LL_RCC_GetSysClkSource() != LL_RCC_SYS_CLKSOURCE_STATUS_PLL) {
 8006c4c: bf00         	nop
 8006c4e: f7ff fde9    	bl	0x8006824 <LL_RCC_GetSysClkSource> @ imm = #-0x42e
 8006c52: 4603         	mov	r3, r0
 8006c54: 2b08         	cmp	r3, #0x8
 8006c56: d1fa         	bne	0x8006c4e <stm32_clock_control_init+0x5e> @ imm = #-0xc
; 	if (old_flash_freq >= new_flash_freq) {
 8006c58: 68fa         	ldr	r2, [r7, #0xc]
 8006c5a: 68bb         	ldr	r3, [r7, #0x8]
 8006c5c: 429a         	cmp	r2, r3
 8006c5e: d302         	blo	0x8006c66 <stm32_clock_control_init+0x76> @ imm = #0x4
; 		LL_SetFlashLatency(new_flash_freq);
 8006c60: 68b8         	ldr	r0, [r7, #0x8]
 8006c62: f006 fbdf    	bl	0x800d424 <LL_SetFlashLatency> @ imm = #0x67be
; 	SystemCoreClock = CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC;
 8006c66: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x8006c94 <stm32_clock_control_init+0xa4>
 8006c68: 4a08         	ldr	r2, [pc, #0x20]         @ 0x8006c8c <stm32_clock_control_init+0x9c>
 8006c6a: 601a         	str	r2, [r3]
; 	LL_RCC_SetAPB1Prescaler(apb1_prescaler(STM32_APB1_PRESCALER));
 8006c6c: f44f 50a0    	mov.w	r0, #0x1400
 8006c70: f7ff fdf8    	bl	0x8006864 <LL_RCC_SetAPB1Prescaler> @ imm = #-0x410
; 	LL_RCC_SetAPB2Prescaler(apb2_prescaler(STM32_APB2_PRESCALER));
 8006c74: f44f 4000    	mov.w	r0, #0x8000
 8006c78: f7ff fe08    	bl	0x800688c <LL_RCC_SetAPB2Prescaler> @ imm = #-0x3f0
; 	stm32_clock_control_mco_init();
 8006c7c: f00f f923    	bl	0x8015ec6 <stm32_clock_control_mco_init> @ imm = #0xf246
; 	return 0;
 8006c80: 2300         	movs	r3, #0x0
; }
 8006c82: 4618         	mov	r0, r3
 8006c84: 3714         	adds	r7, #0x14
 8006c86: 46bd         	mov	sp, r7
 8006c88: bd90         	pop	{r4, r7, pc}
 8006c8a: bf00         	nop

08006c8c <$d>:
 8006c8c: 00 7a 03 0a  	.word	0x0a037a00
 8006c90: dc 06 02 08  	.word	0x080206dc
 8006c94: 90 05 00 20  	.word	0x20000590

08006c98 <LL_APB1_GRP1_EnableClock>:
; {
 8006c98: b480         	push	{r7}
 8006c9a: b085         	sub	sp, #0x14
 8006c9c: af00         	add	r7, sp, #0x0
 8006c9e: 6078         	str	r0, [r7, #0x4]
;   SET_BIT(RCC->APB1ENR, Periphs);
 8006ca0: 4b08         	ldr	r3, [pc, #0x20]         @ 0x8006cc4 <LL_APB1_GRP1_EnableClock+0x2c>
 8006ca2: 6c1a         	ldr	r2, [r3, #0x40]
 8006ca4: 4907         	ldr	r1, [pc, #0x1c]         @ 0x8006cc4 <LL_APB1_GRP1_EnableClock+0x2c>
 8006ca6: 687b         	ldr	r3, [r7, #0x4]
 8006ca8: 4313         	orrs	r3, r2
 8006caa: 640b         	str	r3, [r1, #0x40]
;   tmpreg = READ_BIT(RCC->APB1ENR, Periphs);
 8006cac: 4b05         	ldr	r3, [pc, #0x14]         @ 0x8006cc4 <LL_APB1_GRP1_EnableClock+0x2c>
 8006cae: 6c1a         	ldr	r2, [r3, #0x40]
 8006cb0: 687b         	ldr	r3, [r7, #0x4]
 8006cb2: 4013         	ands	r3, r2
 8006cb4: 60fb         	str	r3, [r7, #0xc]
;   (void)tmpreg;
 8006cb6: 68fb         	ldr	r3, [r7, #0xc]
; }
 8006cb8: bf00         	nop
 8006cba: 3714         	adds	r7, #0x14
 8006cbc: 46bd         	mov	sp, r7
 8006cbe: bc80         	pop	{r7}
 8006cc0: 4770         	bx	lr
 8006cc2: bf00         	nop

08006cc4 <$d>:
 8006cc4: 00 38 02 40  	.word	0x40023800

08006cc8 <LL_RCC_PLL_ConfigDomain_SYS>:
; {
 8006cc8: b480         	push	{r7}
 8006cca: b085         	sub	sp, #0x14
 8006ccc: af00         	add	r7, sp, #0x0
 8006cce: 60f8         	str	r0, [r7, #0xc]
 8006cd0: 60b9         	str	r1, [r7, #0x8]
 8006cd2: 607a         	str	r2, [r7, #0x4]
 8006cd4: 603b         	str	r3, [r7]
;   MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC | RCC_PLLCFGR_PLLM | RCC_PLLCFGR_PLLN,
 8006cd6: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x8006d0c <LL_RCC_PLL_ConfigDomain_SYS+0x44>
 8006cd8: 685a         	ldr	r2, [r3, #0x4]
 8006cda: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x8006d10 <LL_RCC_PLL_ConfigDomain_SYS+0x48>
 8006cdc: 4013         	ands	r3, r2
 8006cde: 68f9         	ldr	r1, [r7, #0xc]
 8006ce0: 68ba         	ldr	r2, [r7, #0x8]
 8006ce2: 4311         	orrs	r1, r2
 8006ce4: 687a         	ldr	r2, [r7, #0x4]
 8006ce6: 0192         	lsls	r2, r2, #0x6
 8006ce8: 430a         	orrs	r2, r1
 8006cea: 4908         	ldr	r1, [pc, #0x20]         @ 0x8006d0c <LL_RCC_PLL_ConfigDomain_SYS+0x44>
 8006cec: 4313         	orrs	r3, r2
 8006cee: 604b         	str	r3, [r1, #0x4]
;   MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLLP, PLLP_R);
 8006cf0: 4b06         	ldr	r3, [pc, #0x18]         @ 0x8006d0c <LL_RCC_PLL_ConfigDomain_SYS+0x44>
 8006cf2: 685b         	ldr	r3, [r3, #0x4]
 8006cf4: f423 3240    	bic	r2, r3, #0x30000
 8006cf8: 4904         	ldr	r1, [pc, #0x10]         @ 0x8006d0c <LL_RCC_PLL_ConfigDomain_SYS+0x44>
 8006cfa: 683b         	ldr	r3, [r7]
 8006cfc: 4313         	orrs	r3, r2
 8006cfe: 604b         	str	r3, [r1, #0x4]
; }
 8006d00: bf00         	nop
 8006d02: 3714         	adds	r7, #0x14
 8006d04: 46bd         	mov	sp, r7
 8006d06: bc80         	pop	{r7}
 8006d08: 4770         	bx	lr
 8006d0a: bf00         	nop

08006d0c <$d>:
 8006d0c: 00 38 02 40  	.word	0x40023800
 8006d10: 00 80 bf ff  	.word	0xffbf8000

08006d14 <get_pllsrc_frequency>:
; {
 8006d14: b480         	push	{r7}
 8006d16: af00         	add	r7, sp, #0x0
; 		return STM32_HSE_FREQ;
 8006d18: 4b02         	ldr	r3, [pc, #0x8]          @ 0x8006d24 <get_pllsrc_frequency+0x10>
; }
 8006d1a: 4618         	mov	r0, r3
 8006d1c: 46bd         	mov	sp, r7
 8006d1e: bc80         	pop	{r7}
 8006d20: 4770         	bx	lr
 8006d22: bf00         	nop

08006d24 <$d>:
 8006d24: 00 1b b7 00  	.word	0x00b71b00

08006d28 <console_out>:
; {
 8006d28: b580         	push	{r7, lr}
 8006d2a: b082         	sub	sp, #0x8
 8006d2c: af00         	add	r7, sp, #0x0
 8006d2e: 6078         	str	r0, [r7, #0x4]
; 	if (pm_device_runtime_get(uart_console_dev) < 0) {
 8006d30: 4b12         	ldr	r3, [pc, #0x48]         @ 0x8006d7c <console_out+0x54>
 8006d32: 4618         	mov	r0, r3
 8006d34: f00f fa73    	bl	0x801621e <pm_device_runtime_get> @ imm = #0xf4e6
 8006d38: 4603         	mov	r3, r0
 8006d3a: 2b00         	cmp	r3, #0x0
 8006d3c: da01         	bge	0x8006d42 <console_out+0x1a> @ imm = #0x2
; 		return c;
 8006d3e: 6879         	ldr	r1, [r7, #0x4]
 8006d40: e017         	b	0x8006d72 <console_out+0x4a> @ imm = #0x2e
; 	if ('\n' == c) {
 8006d42: 687b         	ldr	r3, [r7, #0x4]
 8006d44: 2b0a         	cmp	r3, #0xa
 8006d46: d104         	bne	0x8006d52 <console_out+0x2a> @ imm = #0x8
; 		uart_poll_out(uart_console_dev, '\r');
 8006d48: 4b0c         	ldr	r3, [pc, #0x30]         @ 0x8006d7c <console_out+0x54>
 8006d4a: 210d         	movs	r1, #0xd
 8006d4c: 4618         	mov	r0, r3
 8006d4e: f00f fa57    	bl	0x8016200 <uart_poll_out> @ imm = #0xf4ae
; 	uart_poll_out(uart_console_dev, c);
 8006d52: 4a0a         	ldr	r2, [pc, #0x28]         @ 0x8006d7c <console_out+0x54>
 8006d54: 687b         	ldr	r3, [r7, #0x4]
 8006d56: b2db         	uxtb	r3, r3
 8006d58: 4619         	mov	r1, r3
 8006d5a: 4610         	mov	r0, r2
 8006d5c: f00f fa50    	bl	0x8016200 <uart_poll_out> @ imm = #0xf4a0
; 	(void)pm_device_runtime_put_async(uart_console_dev, K_MSEC(1));
 8006d60: 4906         	ldr	r1, [pc, #0x18]         @ 0x8006d7c <console_out+0x54>
 8006d62: f04f 020a    	mov.w	r2, #0xa
 8006d66: f04f 0300    	mov.w	r3, #0x0
 8006d6a: 4608         	mov	r0, r1
 8006d6c: f00f fa61    	bl	0x8016232 <pm_device_runtime_put_async> @ imm = #0xf4c2
; 	return c;
 8006d70: 6879         	ldr	r1, [r7, #0x4]
; }
 8006d72: 460b         	mov	r3, r1
 8006d74: 4618         	mov	r0, r3
 8006d76: 3708         	adds	r7, #0x8
 8006d78: 46bd         	mov	sp, r7
 8006d7a: bd80         	pop	{r7, pc}

08006d7c <$d>:
 8006d7c: 40 de 01 08  	.word	0x0801de40

08006d80 <uart_console_hook_install>:
; {
 8006d80: b580         	push	{r7, lr}
 8006d82: af00         	add	r7, sp, #0x0
; 	__stdout_hook_install(console_out);
 8006d84: 4803         	ldr	r0, [pc, #0xc]          @ 0x8006d94 <uart_console_hook_install+0x14>
 8006d86: f7ff f9a9    	bl	0x80060dc <__stdout_hook_install> @ imm = #-0xcae
; 	__printk_hook_install(console_out);
 8006d8a: 4802         	ldr	r0, [pc, #0x8]          @ 0x8006d94 <uart_console_hook_install+0x14>
 8006d8c: f7fd f93c    	bl	0x8004008 <__printk_hook_install> @ imm = #-0x2d88
; }
 8006d90: bf00         	nop
 8006d92: bd80         	pop	{r7, pc}

08006d94 <$d>:
 8006d94: 29 6d 00 08  	.word	0x08006d29

08006d98 <uart_console_init>:
; {
 8006d98: b580         	push	{r7, lr}
 8006d9a: af00         	add	r7, sp, #0x0
; 	if (!device_is_ready(uart_console_dev)) {
 8006d9c: 4b08         	ldr	r3, [pc, #0x20]         @ 0x8006dc0 <uart_console_init+0x28>
 8006d9e: 4618         	mov	r0, r3
 8006da0: f00f fa0f    	bl	0x80161c2 <device_is_ready> @ imm = #0xf41e
 8006da4: 4603         	mov	r3, r0
 8006da6: f083 0301    	eor	r3, r3, #0x1
 8006daa: b2db         	uxtb	r3, r3
 8006dac: 2b00         	cmp	r3, #0x0
 8006dae: d002         	beq	0x8006db6 <uart_console_init+0x1e> @ imm = #0x4
; 		return -ENODEV;
 8006db0: f06f 0312    	mvn	r3, #0x12
 8006db4: e002         	b	0x8006dbc <uart_console_init+0x24> @ imm = #0x4
; 	uart_console_hook_install();
 8006db6: f7ff ffe3    	bl	0x8006d80 <uart_console_hook_install> @ imm = #-0x3a
; 	return 0;
 8006dba: 2300         	movs	r3, #0x0
; }
 8006dbc: 4618         	mov	r0, r3
 8006dbe: bd80         	pop	{r7, pc}

08006dc0 <$d>:
 8006dc0: 40 de 01 08  	.word	0x0801de40

08006dc4 <LL_DMA_SetDataLength>:
; {
 8006dc4: b480         	push	{r7}
 8006dc6: b085         	sub	sp, #0x14
 8006dc8: af00         	add	r7, sp, #0x0
 8006dca: 60f8         	str	r0, [r7, #0xc]
 8006dcc: 60b9         	str	r1, [r7, #0x8]
 8006dce: 607a         	str	r2, [r7, #0x4]
;   MODIFY_REG(((DMA_Stream_TypeDef*)((uint32_t)((uint32_t)DMAx + STREAM_OFFSET_TAB[Stream])))->NDTR, DMA_SxNDT, NbData);
 8006dd0: 4a0c         	ldr	r2, [pc, #0x30]         @ 0x8006e04 <LL_DMA_SetDataLength+0x40>
 8006dd2: 68bb         	ldr	r3, [r7, #0x8]
 8006dd4: 4413         	add	r3, r2
 8006dd6: 781b         	ldrb	r3, [r3]
 8006dd8: 461a         	mov	r2, r3
 8006dda: 68fb         	ldr	r3, [r7, #0xc]
 8006ddc: 4413         	add	r3, r2
 8006dde: 685b         	ldr	r3, [r3, #0x4]
 8006de0: 0c1b         	lsrs	r3, r3, #0x10
 8006de2: 041b         	lsls	r3, r3, #0x10
 8006de4: 4907         	ldr	r1, [pc, #0x1c]         @ 0x8006e04 <LL_DMA_SetDataLength+0x40>
 8006de6: 68ba         	ldr	r2, [r7, #0x8]
 8006de8: 440a         	add	r2, r1
 8006dea: 7812         	ldrb	r2, [r2]
 8006dec: 4611         	mov	r1, r2
 8006dee: 68fa         	ldr	r2, [r7, #0xc]
 8006df0: 440a         	add	r2, r1
 8006df2: 4611         	mov	r1, r2
 8006df4: 687a         	ldr	r2, [r7, #0x4]
 8006df6: 4313         	orrs	r3, r2
 8006df8: 604b         	str	r3, [r1, #0x4]
; }
 8006dfa: bf00         	nop
 8006dfc: 3714         	adds	r7, #0x14
 8006dfe: 46bd         	mov	sp, r7
 8006e00: bc80         	pop	{r7}
 8006e02: 4770         	bx	lr

08006e04 <$d>:
 8006e04: 6c ff 01 08  	.word	0x0801ff6c

08006e08 <LL_DMA_GetDataLength>:
; {
 8006e08: b480         	push	{r7}
 8006e0a: b083         	sub	sp, #0xc
 8006e0c: af00         	add	r7, sp, #0x0
 8006e0e: 6078         	str	r0, [r7, #0x4]
 8006e10: 6039         	str	r1, [r7]
;   return (READ_BIT(((DMA_Stream_TypeDef*)((uint32_t)((uint32_t)DMAx + STREAM_OFFSET_TAB[Stream])))->NDTR, DMA_SxNDT));
 8006e12: 4a07         	ldr	r2, [pc, #0x1c]         @ 0x8006e30 <LL_DMA_GetDataLength+0x28>
 8006e14: 683b         	ldr	r3, [r7]
 8006e16: 4413         	add	r3, r2
 8006e18: 781b         	ldrb	r3, [r3]
 8006e1a: 461a         	mov	r2, r3
 8006e1c: 687b         	ldr	r3, [r7, #0x4]
 8006e1e: 4413         	add	r3, r2
 8006e20: 685b         	ldr	r3, [r3, #0x4]
 8006e22: b29b         	uxth	r3, r3
; }
 8006e24: 4618         	mov	r0, r3
 8006e26: 370c         	adds	r7, #0xc
 8006e28: 46bd         	mov	sp, r7
 8006e2a: bc80         	pop	{r7}
 8006e2c: 4770         	bx	lr
 8006e2e: bf00         	nop

08006e30 <$d>:
 8006e30: 6c ff 01 08  	.word	0x0801ff6c

08006e34 <LL_DMA_DisableFifoMode>:
; {
 8006e34: b480         	push	{r7}
 8006e36: b083         	sub	sp, #0xc
 8006e38: af00         	add	r7, sp, #0x0
 8006e3a: 6078         	str	r0, [r7, #0x4]
 8006e3c: 6039         	str	r1, [r7]
;   CLEAR_BIT(((DMA_Stream_TypeDef *)((uint32_t)((uint32_t)DMAx + STREAM_OFFSET_TAB[Stream])))->FCR, DMA_SxFCR_DMDIS);
 8006e3e: 4a0b         	ldr	r2, [pc, #0x2c]         @ 0x8006e6c <LL_DMA_DisableFifoMode+0x38>
 8006e40: 683b         	ldr	r3, [r7]
 8006e42: 4413         	add	r3, r2
 8006e44: 781b         	ldrb	r3, [r3]
 8006e46: 461a         	mov	r2, r3
 8006e48: 687b         	ldr	r3, [r7, #0x4]
 8006e4a: 4413         	add	r3, r2
 8006e4c: 695b         	ldr	r3, [r3, #0x14]
 8006e4e: 4907         	ldr	r1, [pc, #0x1c]         @ 0x8006e6c <LL_DMA_DisableFifoMode+0x38>
 8006e50: 683a         	ldr	r2, [r7]
 8006e52: 440a         	add	r2, r1
 8006e54: 7812         	ldrb	r2, [r2]
 8006e56: 4611         	mov	r1, r2
 8006e58: 687a         	ldr	r2, [r7, #0x4]
 8006e5a: 440a         	add	r2, r1
 8006e5c: f023 0304    	bic	r3, r3, #0x4
 8006e60: 6153         	str	r3, [r2, #0x14]
; }
 8006e62: bf00         	nop
 8006e64: 370c         	adds	r7, #0xc
 8006e66: 46bd         	mov	sp, r7
 8006e68: bc80         	pop	{r7}
 8006e6a: 4770         	bx	lr

08006e6c <$d>:
 8006e6c: 6c ff 01 08  	.word	0x0801ff6c

08006e70 <LL_DMA_EnableFifoMode>:
; {
 8006e70: b480         	push	{r7}
 8006e72: b083         	sub	sp, #0xc
 8006e74: af00         	add	r7, sp, #0x0
 8006e76: 6078         	str	r0, [r7, #0x4]
 8006e78: 6039         	str	r1, [r7]
;   SET_BIT(((DMA_Stream_TypeDef *)((uint32_t)((uint32_t)DMAx + STREAM_OFFSET_TAB[Stream])))->FCR, DMA_SxFCR_DMDIS);
 8006e7a: 4a0b         	ldr	r2, [pc, #0x2c]         @ 0x8006ea8 <LL_DMA_EnableFifoMode+0x38>
 8006e7c: 683b         	ldr	r3, [r7]
 8006e7e: 4413         	add	r3, r2
 8006e80: 781b         	ldrb	r3, [r3]
 8006e82: 461a         	mov	r2, r3
 8006e84: 687b         	ldr	r3, [r7, #0x4]
 8006e86: 4413         	add	r3, r2
 8006e88: 695b         	ldr	r3, [r3, #0x14]
 8006e8a: 4907         	ldr	r1, [pc, #0x1c]         @ 0x8006ea8 <LL_DMA_EnableFifoMode+0x38>
 8006e8c: 683a         	ldr	r2, [r7]
 8006e8e: 440a         	add	r2, r1
 8006e90: 7812         	ldrb	r2, [r2]
 8006e92: 4611         	mov	r1, r2
 8006e94: 687a         	ldr	r2, [r7, #0x4]
 8006e96: 440a         	add	r2, r1
 8006e98: f043 0304    	orr	r3, r3, #0x4
 8006e9c: 6153         	str	r3, [r2, #0x14]
; }
 8006e9e: bf00         	nop
 8006ea0: 370c         	adds	r7, #0xc
 8006ea2: 46bd         	mov	sp, r7
 8006ea4: bc80         	pop	{r7}
 8006ea6: 4770         	bx	lr

08006ea8 <$d>:
 8006ea8: 6c ff 01 08  	.word	0x0801ff6c

08006eac <LL_DMA_SetMemoryAddress>:
; {
 8006eac: b480         	push	{r7}
 8006eae: b085         	sub	sp, #0x14
 8006eb0: af00         	add	r7, sp, #0x0
 8006eb2: 60f8         	str	r0, [r7, #0xc]
 8006eb4: 60b9         	str	r1, [r7, #0x8]
 8006eb6: 607a         	str	r2, [r7, #0x4]
;   WRITE_REG(((DMA_Stream_TypeDef*)((uint32_t)((uint32_t)DMAx + STREAM_OFFSET_TAB[Stream])))->M0AR, MemoryAddress);
 8006eb8: 4a07         	ldr	r2, [pc, #0x1c]         @ 0x8006ed8 <LL_DMA_SetMemoryAddress+0x2c>
 8006eba: 68bb         	ldr	r3, [r7, #0x8]
 8006ebc: 4413         	add	r3, r2
 8006ebe: 781b         	ldrb	r3, [r3]
 8006ec0: 461a         	mov	r2, r3
 8006ec2: 68fb         	ldr	r3, [r7, #0xc]
 8006ec4: 4413         	add	r3, r2
 8006ec6: 461a         	mov	r2, r3
 8006ec8: 687b         	ldr	r3, [r7, #0x4]
 8006eca: 60d3         	str	r3, [r2, #0xc]
; }
 8006ecc: bf00         	nop
 8006ece: 3714         	adds	r7, #0x14
 8006ed0: 46bd         	mov	sp, r7
 8006ed2: bc80         	pop	{r7}
 8006ed4: 4770         	bx	lr
 8006ed6: bf00         	nop

08006ed8 <$d>:
 8006ed8: 6c ff 01 08  	.word	0x0801ff6c

08006edc <LL_DMA_SetPeriphAddress>:
; {
 8006edc: b480         	push	{r7}
 8006ede: b085         	sub	sp, #0x14
 8006ee0: af00         	add	r7, sp, #0x0
 8006ee2: 60f8         	str	r0, [r7, #0xc]
 8006ee4: 60b9         	str	r1, [r7, #0x8]
 8006ee6: 607a         	str	r2, [r7, #0x4]
;   WRITE_REG(((DMA_Stream_TypeDef*)((uint32_t)((uint32_t)DMAx + STREAM_OFFSET_TAB[Stream])))->PAR, PeriphAddress);
 8006ee8: 4a07         	ldr	r2, [pc, #0x1c]         @ 0x8006f08 <LL_DMA_SetPeriphAddress+0x2c>
 8006eea: 68bb         	ldr	r3, [r7, #0x8]
 8006eec: 4413         	add	r3, r2
 8006eee: 781b         	ldrb	r3, [r3]
 8006ef0: 461a         	mov	r2, r3
 8006ef2: 68fb         	ldr	r3, [r7, #0xc]
 8006ef4: 4413         	add	r3, r2
 8006ef6: 461a         	mov	r2, r3
 8006ef8: 687b         	ldr	r3, [r7, #0x4]
 8006efa: 6093         	str	r3, [r2, #0x8]
; }
 8006efc: bf00         	nop
 8006efe: 3714         	adds	r7, #0x14
 8006f00: 46bd         	mov	sp, r7
 8006f02: bc80         	pop	{r7}
 8006f04: 4770         	bx	lr
 8006f06: bf00         	nop

08006f08 <$d>:
 8006f08: 6c ff 01 08  	.word	0x0801ff6c

08006f0c <LL_DMA_EnableIT_HT>:
; {
 8006f0c: b480         	push	{r7}
 8006f0e: b083         	sub	sp, #0xc
 8006f10: af00         	add	r7, sp, #0x0
 8006f12: 6078         	str	r0, [r7, #0x4]
 8006f14: 6039         	str	r1, [r7]
;   SET_BIT(((DMA_Stream_TypeDef *)((uint32_t)((uint32_t)DMAx + STREAM_OFFSET_TAB[Stream])))->CR, DMA_SxCR_HTIE);
 8006f16: 4a0b         	ldr	r2, [pc, #0x2c]         @ 0x8006f44 <LL_DMA_EnableIT_HT+0x38>
 8006f18: 683b         	ldr	r3, [r7]
 8006f1a: 4413         	add	r3, r2
 8006f1c: 781b         	ldrb	r3, [r3]
 8006f1e: 461a         	mov	r2, r3
 8006f20: 687b         	ldr	r3, [r7, #0x4]
 8006f22: 4413         	add	r3, r2
 8006f24: 681b         	ldr	r3, [r3]
 8006f26: 4907         	ldr	r1, [pc, #0x1c]         @ 0x8006f44 <LL_DMA_EnableIT_HT+0x38>
 8006f28: 683a         	ldr	r2, [r7]
 8006f2a: 440a         	add	r2, r1
 8006f2c: 7812         	ldrb	r2, [r2]
 8006f2e: 4611         	mov	r1, r2
 8006f30: 687a         	ldr	r2, [r7, #0x4]
 8006f32: 440a         	add	r2, r1
 8006f34: f043 0308    	orr	r3, r3, #0x8
 8006f38: 6013         	str	r3, [r2]
; }
 8006f3a: bf00         	nop
 8006f3c: 370c         	adds	r7, #0xc
 8006f3e: 46bd         	mov	sp, r7
 8006f40: bc80         	pop	{r7}
 8006f42: 4770         	bx	lr

08006f44 <$d>:
 8006f44: 6c ff 01 08  	.word	0x0801ff6c

08006f48 <LL_DMA_EnableIT_TC>:
; {
 8006f48: b480         	push	{r7}
 8006f4a: b083         	sub	sp, #0xc
 8006f4c: af00         	add	r7, sp, #0x0
 8006f4e: 6078         	str	r0, [r7, #0x4]
 8006f50: 6039         	str	r1, [r7]
;   SET_BIT(((DMA_Stream_TypeDef *)((uint32_t)((uint32_t)DMAx + STREAM_OFFSET_TAB[Stream])))->CR, DMA_SxCR_TCIE);
 8006f52: 4a0b         	ldr	r2, [pc, #0x2c]         @ 0x8006f80 <LL_DMA_EnableIT_TC+0x38>
 8006f54: 683b         	ldr	r3, [r7]
 8006f56: 4413         	add	r3, r2
 8006f58: 781b         	ldrb	r3, [r3]
 8006f5a: 461a         	mov	r2, r3
 8006f5c: 687b         	ldr	r3, [r7, #0x4]
 8006f5e: 4413         	add	r3, r2
 8006f60: 681b         	ldr	r3, [r3]
 8006f62: 4907         	ldr	r1, [pc, #0x1c]         @ 0x8006f80 <LL_DMA_EnableIT_TC+0x38>
 8006f64: 683a         	ldr	r2, [r7]
 8006f66: 440a         	add	r2, r1
 8006f68: 7812         	ldrb	r2, [r2]
 8006f6a: 4611         	mov	r1, r2
 8006f6c: 687a         	ldr	r2, [r7, #0x4]
 8006f6e: 440a         	add	r2, r1
 8006f70: f043 0310    	orr	r3, r3, #0x10
 8006f74: 6013         	str	r3, [r2]
; }
 8006f76: bf00         	nop
 8006f78: 370c         	adds	r7, #0xc
 8006f7a: 46bd         	mov	sp, r7
 8006f7c: bc80         	pop	{r7}
 8006f7e: 4770         	bx	lr

08006f80 <$d>:
 8006f80: 6c ff 01 08  	.word	0x0801ff6c

08006f84 <LL_DMA_EnableIT_FE>:
; {
 8006f84: b480         	push	{r7}
 8006f86: b083         	sub	sp, #0xc
 8006f88: af00         	add	r7, sp, #0x0
 8006f8a: 6078         	str	r0, [r7, #0x4]
 8006f8c: 6039         	str	r1, [r7]
;   SET_BIT(((DMA_Stream_TypeDef *)((uint32_t)((uint32_t)DMAx + STREAM_OFFSET_TAB[Stream])))->FCR, DMA_SxFCR_FEIE);
 8006f8e: 4a0b         	ldr	r2, [pc, #0x2c]         @ 0x8006fbc <LL_DMA_EnableIT_FE+0x38>
 8006f90: 683b         	ldr	r3, [r7]
 8006f92: 4413         	add	r3, r2
 8006f94: 781b         	ldrb	r3, [r3]
 8006f96: 461a         	mov	r2, r3
 8006f98: 687b         	ldr	r3, [r7, #0x4]
 8006f9a: 4413         	add	r3, r2
 8006f9c: 695b         	ldr	r3, [r3, #0x14]
 8006f9e: 4907         	ldr	r1, [pc, #0x1c]         @ 0x8006fbc <LL_DMA_EnableIT_FE+0x38>
 8006fa0: 683a         	ldr	r2, [r7]
 8006fa2: 440a         	add	r2, r1
 8006fa4: 7812         	ldrb	r2, [r2]
 8006fa6: 4611         	mov	r1, r2
 8006fa8: 687a         	ldr	r2, [r7, #0x4]
 8006faa: 440a         	add	r2, r1
 8006fac: f043 0380    	orr	r3, r3, #0x80
 8006fb0: 6153         	str	r3, [r2, #0x14]
; }
 8006fb2: bf00         	nop
 8006fb4: 370c         	adds	r7, #0xc
 8006fb6: 46bd         	mov	sp, r7
 8006fb8: bc80         	pop	{r7}
 8006fba: 4770         	bx	lr

08006fbc <$d>:
 8006fbc: 6c ff 01 08  	.word	0x0801ff6c

08006fc0 <LL_DMA_DisableIT_TC>:
; {
 8006fc0: b480         	push	{r7}
 8006fc2: b083         	sub	sp, #0xc
 8006fc4: af00         	add	r7, sp, #0x0
 8006fc6: 6078         	str	r0, [r7, #0x4]
 8006fc8: 6039         	str	r1, [r7]
;   CLEAR_BIT(((DMA_Stream_TypeDef *)((uint32_t)((uint32_t)DMAx + STREAM_OFFSET_TAB[Stream])))->CR, DMA_SxCR_TCIE);
 8006fca: 4a0b         	ldr	r2, [pc, #0x2c]         @ 0x8006ff8 <LL_DMA_DisableIT_TC+0x38>
 8006fcc: 683b         	ldr	r3, [r7]
 8006fce: 4413         	add	r3, r2
 8006fd0: 781b         	ldrb	r3, [r3]
 8006fd2: 461a         	mov	r2, r3
 8006fd4: 687b         	ldr	r3, [r7, #0x4]
 8006fd6: 4413         	add	r3, r2
 8006fd8: 681b         	ldr	r3, [r3]
 8006fda: 4907         	ldr	r1, [pc, #0x1c]         @ 0x8006ff8 <LL_DMA_DisableIT_TC+0x38>
 8006fdc: 683a         	ldr	r2, [r7]
 8006fde: 440a         	add	r2, r1
 8006fe0: 7812         	ldrb	r2, [r2]
 8006fe2: 4611         	mov	r1, r2
 8006fe4: 687a         	ldr	r2, [r7, #0x4]
 8006fe6: 440a         	add	r2, r1
 8006fe8: f023 0310    	bic	r3, r3, #0x10
 8006fec: 6013         	str	r3, [r2]
; }
 8006fee: bf00         	nop
 8006ff0: 370c         	adds	r7, #0xc
 8006ff2: 46bd         	mov	sp, r7
 8006ff4: bc80         	pop	{r7}
 8006ff6: 4770         	bx	lr

08006ff8 <$d>:
 8006ff8: 6c ff 01 08  	.word	0x0801ff6c

08006ffc <LL_DMA_DisableIT_FE>:
; {
 8006ffc: b480         	push	{r7}
 8006ffe: b083         	sub	sp, #0xc
 8007000: af00         	add	r7, sp, #0x0
 8007002: 6078         	str	r0, [r7, #0x4]
 8007004: 6039         	str	r1, [r7]
;   CLEAR_BIT(((DMA_Stream_TypeDef *)((uint32_t)((uint32_t)DMAx + STREAM_OFFSET_TAB[Stream])))->FCR, DMA_SxFCR_FEIE);
 8007006: 4a0b         	ldr	r2, [pc, #0x2c]         @ 0x8007034 <LL_DMA_DisableIT_FE+0x38>
 8007008: 683b         	ldr	r3, [r7]
 800700a: 4413         	add	r3, r2
 800700c: 781b         	ldrb	r3, [r3]
 800700e: 461a         	mov	r2, r3
 8007010: 687b         	ldr	r3, [r7, #0x4]
 8007012: 4413         	add	r3, r2
 8007014: 695b         	ldr	r3, [r3, #0x14]
 8007016: 4907         	ldr	r1, [pc, #0x1c]         @ 0x8007034 <LL_DMA_DisableIT_FE+0x38>
 8007018: 683a         	ldr	r2, [r7]
 800701a: 440a         	add	r2, r1
 800701c: 7812         	ldrb	r2, [r2]
 800701e: 4611         	mov	r1, r2
 8007020: 687a         	ldr	r2, [r7, #0x4]
 8007022: 440a         	add	r2, r1
 8007024: f023 0380    	bic	r3, r3, #0x80
 8007028: 6153         	str	r3, [r2, #0x14]
; }
 800702a: bf00         	nop
 800702c: 370c         	adds	r7, #0xc
 800702e: 46bd         	mov	sp, r7
 8007030: bc80         	pop	{r7}
 8007032: 4770         	bx	lr

08007034 <$d>:
 8007034: 6c ff 01 08  	.word	0x0801ff6c

08007038 <dma_stm32_irq_handler>:
; {
 8007038: b590         	push	{r4, r7, lr}
 800703a: b08f         	sub	sp, #0x3c
 800703c: af04         	add	r7, sp, #0x10
 800703e: 6078         	str	r0, [r7, #0x4]
 8007040: 6039         	str	r1, [r7]
; 	const struct dma_stm32_config *config = dev->config;
 8007042: 687b         	ldr	r3, [r7, #0x4]
 8007044: 685b         	ldr	r3, [r3, #0x4]
 8007046: 627b         	str	r3, [r7, #0x24]
; 	DMA_TypeDef *dma = (DMA_TypeDef *)(config->base);
 8007048: 6a7b         	ldr	r3, [r7, #0x24]
 800704a: 691b         	ldr	r3, [r3, #0x10]
 800704c: 623b         	str	r3, [r7, #0x20]
; 	stream = &config->streams[id];
 800704e: 6a7b         	ldr	r3, [r7, #0x24]
 8007050: 6999         	ldr	r1, [r3, #0x18]
 8007052: 683a         	ldr	r2, [r7]
 8007054: 4613         	mov	r3, r2
 8007056: 00db         	lsls	r3, r3, #0x3
 8007058: 1a9b         	subs	r3, r3, r2
 800705a: 009b         	lsls	r3, r3, #0x2
 800705c: 440b         	add	r3, r1
 800705e: 61fb         	str	r3, [r7, #0x1c]
; 	if ((stream->hal_override != true) && (stream->busy == false)) {
 8007060: 69fb         	ldr	r3, [r7, #0x1c]
 8007062: 795b         	ldrb	r3, [r3, #0x5]
 8007064: f083 0301    	eor	r3, r3, #0x1
 8007068: b2db         	uxtb	r3, r3
 800706a: 2b00         	cmp	r3, #0x0
 800706c: d00c         	beq	0x8007088 <dma_stm32_irq_handler+0x50> @ imm = #0x18
 800706e: 69fb         	ldr	r3, [r7, #0x1c]
 8007070: 799b         	ldrb	r3, [r3, #0x6]
 8007072: b2db         	uxtb	r3, r3
 8007074: f083 0301    	eor	r3, r3, #0x1
 8007078: b2db         	uxtb	r3, r3
 800707a: 2b00         	cmp	r3, #0x0
 800707c: d004         	beq	0x8007088 <dma_stm32_irq_handler+0x50> @ imm = #0x8
; 		dma_stm32_clear_stream_irq(dev, id);
 800707e: 6839         	ldr	r1, [r7]
 8007080: 6878         	ldr	r0, [r7, #0x4]
 8007082: f00f f93f    	bl	0x8016304 <dma_stm32_clear_stream_irq> @ imm = #0xf27e
; 		return;
 8007086: e09a         	b	0x80071be <dma_stm32_irq_handler+0x186> @ imm = #0x134
; 	callback_arg = id + STM32_DMA_STREAM_OFFSET;
 8007088: 683b         	ldr	r3, [r7]
 800708a: 61bb         	str	r3, [r7, #0x18]
; 	if (stm32_dma_is_ht_irq_active(dma, id)) {
 800708c: 6839         	ldr	r1, [r7]
 800708e: 6a38         	ldr	r0, [r7, #0x20]
 8007090: f010 f921    	bl	0x80172d6 <stm32_dma_is_ht_irq_active> @ imm = #0x10242
 8007094: 4603         	mov	r3, r0
 8007096: 2b00         	cmp	r3, #0x0
 8007098: d013         	beq	0x80070c2 <dma_stm32_irq_handler+0x8a> @ imm = #0x26
; 		if (!stream->hal_override) {
 800709a: 69fb         	ldr	r3, [r7, #0x1c]
 800709c: 795b         	ldrb	r3, [r3, #0x5]
 800709e: f083 0301    	eor	r3, r3, #0x1
 80070a2: b2db         	uxtb	r3, r3
 80070a4: 2b00         	cmp	r3, #0x0
 80070a6: d003         	beq	0x80070b0 <dma_stm32_irq_handler+0x78> @ imm = #0x6
; 			dma_stm32_clear_ht(dma, id);
 80070a8: 6839         	ldr	r1, [r7]
 80070aa: 6a38         	ldr	r0, [r7, #0x20]
 80070ac: f000 ff86    	bl	0x8007fbc <dma_stm32_clear_ht> @ imm = #0xf0c
; 		stream->dma_callback(dev, stream->user_data, callback_arg, DMA_STATUS_BLOCK);
 80070b0: 69fb         	ldr	r3, [r7, #0x1c]
 80070b2: 695c         	ldr	r4, [r3, #0x14]
 80070b4: 69fb         	ldr	r3, [r7, #0x1c]
 80070b6: 6919         	ldr	r1, [r3, #0x10]
 80070b8: 2301         	movs	r3, #0x1
 80070ba: 69ba         	ldr	r2, [r7, #0x18]
 80070bc: 6878         	ldr	r0, [r7, #0x4]
 80070be: 47a0         	blx	r4
 80070c0: e07d         	b	0x80071be <dma_stm32_irq_handler+0x186> @ imm = #0xfa
; 	} else if (stm32_dma_is_tc_irq_active(dma, id)) {
 80070c2: 6839         	ldr	r1, [r7]
 80070c4: 6a38         	ldr	r0, [r7, #0x20]
 80070c6: f010 f8e5    	bl	0x8017294 <stm32_dma_is_tc_irq_active> @ imm = #0x101ca
 80070ca: 4603         	mov	r3, r0
 80070cc: 2b00         	cmp	r3, #0x0
 80070ce: d01d         	beq	0x800710c <dma_stm32_irq_handler+0xd4> @ imm = #0x3a
; 		if (!stream->cyclic) {
 80070d0: 69fb         	ldr	r3, [r7, #0x1c]
 80070d2: 7e1b         	ldrb	r3, [r3, #0x18]
 80070d4: f083 0301    	eor	r3, r3, #0x1
 80070d8: b2db         	uxtb	r3, r3
 80070da: 2b00         	cmp	r3, #0x0
 80070dc: d002         	beq	0x80070e4 <dma_stm32_irq_handler+0xac> @ imm = #0x4
; 			stream->busy = false;
 80070de: 69fb         	ldr	r3, [r7, #0x1c]
 80070e0: 2200         	movs	r2, #0x0
 80070e2: 719a         	strb	r2, [r3, #0x6]
; 		if (!stream->hal_override) {
 80070e4: 69fb         	ldr	r3, [r7, #0x1c]
 80070e6: 795b         	ldrb	r3, [r3, #0x5]
 80070e8: f083 0301    	eor	r3, r3, #0x1
 80070ec: b2db         	uxtb	r3, r3
 80070ee: 2b00         	cmp	r3, #0x0
 80070f0: d003         	beq	0x80070fa <dma_stm32_irq_handler+0xc2> @ imm = #0x6
; 			dma_stm32_clear_tc(dma, id);
 80070f2: 6839         	ldr	r1, [r7]
 80070f4: 6a38         	ldr	r0, [r7, #0x20]
 80070f6: f000 ff73    	bl	0x8007fe0 <dma_stm32_clear_tc> @ imm = #0xee6
; 		stream->dma_callback(dev, stream->user_data, callback_arg, DMA_STATUS_COMPLETE);
 80070fa: 69fb         	ldr	r3, [r7, #0x1c]
 80070fc: 695c         	ldr	r4, [r3, #0x14]
 80070fe: 69fb         	ldr	r3, [r7, #0x1c]
 8007100: 6919         	ldr	r1, [r3, #0x10]
 8007102: 2300         	movs	r3, #0x0
 8007104: 69ba         	ldr	r2, [r7, #0x18]
 8007106: 6878         	ldr	r0, [r7, #0x4]
 8007108: 47a0         	blx	r4
 800710a: e058         	b	0x80071be <dma_stm32_irq_handler+0x186> @ imm = #0xb0
; 	} else if (stm32_dma_is_unexpected_irq_happened(dma, id)) {
 800710c: 6839         	ldr	r1, [r7]
 800710e: 6a38         	ldr	r0, [r7, #0x20]
 8007110: f001 f874    	bl	0x80081fc <stm32_dma_is_unexpected_irq_happened> @ imm = #0x10e8
 8007114: 4603         	mov	r3, r0
 8007116: 2b00         	cmp	r3, #0x0
 8007118: d023         	beq	0x8007162 <dma_stm32_irq_handler+0x12a> @ imm = #0x46
; 		LOG_ERR("Unexpected irq happened.");
 800711a: 2303         	movs	r3, #0x3
 800711c: 2b00         	cmp	r3, #0x0
 800711e: d016         	beq	0x800714e <dma_stm32_irq_handler+0x116> @ imm = #0x2c
 8007120: 2301         	movs	r3, #0x1
 8007122: 73fb         	strb	r3, [r7, #0xf]
 8007124: 7bfb         	ldrb	r3, [r7, #0xf]
 8007126: f083 0301    	eor	r3, r3, #0x1
 800712a: b2db         	uxtb	r3, r3
 800712c: 2b00         	cmp	r3, #0x0
 800712e: d10e         	bne	0x800714e <dma_stm32_irq_handler+0x116> @ imm = #0x1c
 8007130: 4b24         	ldr	r3, [pc, #0x90]         @ 0x80071c4 <dma_stm32_irq_handler+0x18c>
 8007132: 6819         	ldr	r1, [r3]
 8007134: 4b24         	ldr	r3, [pc, #0x90]         @ 0x80071c8 <dma_stm32_irq_handler+0x190>
 8007136: 9302         	str	r3, [sp, #0x8]
 8007138: 2300         	movs	r3, #0x0
 800713a: 9301         	str	r3, [sp, #0x4]
 800713c: 2300         	movs	r3, #0x0
 800713e: 9300         	str	r3, [sp]
 8007140: 2300         	movs	r3, #0x0
 8007142: 2201         	movs	r2, #0x1
 8007144: 2000         	movs	r0, #0x0
 8007146: f00f f8ac    	bl	0x80162a2 <z_log_msg_runtime_create> @ imm = #0xf158
 800714a: 2300         	movs	r3, #0x0
 800714c: 60bb         	str	r3, [r7, #0x8]
; 		stream->dma_callback(dev, stream->user_data,
 800714e: 69fb         	ldr	r3, [r7, #0x1c]
 8007150: 695c         	ldr	r4, [r3, #0x14]
 8007152: 69fb         	ldr	r3, [r7, #0x1c]
 8007154: 6919         	ldr	r1, [r3, #0x10]
 8007156: f06f 0304    	mvn	r3, #0x4
 800715a: 69ba         	ldr	r2, [r7, #0x18]
 800715c: 6878         	ldr	r0, [r7, #0x4]
 800715e: 47a0         	blx	r4
 8007160: e02d         	b	0x80071be <dma_stm32_irq_handler+0x186> @ imm = #0x5a
; 		LOG_ERR("Transfer Error.");
 8007162: 2303         	movs	r3, #0x3
 8007164: 2b00         	cmp	r3, #0x0
 8007166: d016         	beq	0x8007196 <dma_stm32_irq_handler+0x15e> @ imm = #0x2c
 8007168: 2301         	movs	r3, #0x1
 800716a: 75fb         	strb	r3, [r7, #0x17]
 800716c: 7dfb         	ldrb	r3, [r7, #0x17]
 800716e: f083 0301    	eor	r3, r3, #0x1
 8007172: b2db         	uxtb	r3, r3
 8007174: 2b00         	cmp	r3, #0x0
 8007176: d10e         	bne	0x8007196 <dma_stm32_irq_handler+0x15e> @ imm = #0x1c
 8007178: 4b12         	ldr	r3, [pc, #0x48]         @ 0x80071c4 <dma_stm32_irq_handler+0x18c>
 800717a: 6819         	ldr	r1, [r3]
 800717c: 4b13         	ldr	r3, [pc, #0x4c]         @ 0x80071cc <dma_stm32_irq_handler+0x194>
 800717e: 9302         	str	r3, [sp, #0x8]
 8007180: 2300         	movs	r3, #0x0
 8007182: 9301         	str	r3, [sp, #0x4]
 8007184: 2300         	movs	r3, #0x0
 8007186: 9300         	str	r3, [sp]
 8007188: 2300         	movs	r3, #0x0
 800718a: 2201         	movs	r2, #0x1
 800718c: 2000         	movs	r0, #0x0
 800718e: f00f f888    	bl	0x80162a2 <z_log_msg_runtime_create> @ imm = #0xf110
 8007192: 2300         	movs	r3, #0x0
 8007194: 613b         	str	r3, [r7, #0x10]
; 		stream->busy = false;
 8007196: 69fb         	ldr	r3, [r7, #0x1c]
 8007198: 2200         	movs	r2, #0x0
 800719a: 719a         	strb	r2, [r3, #0x6]
; 		dma_stm32_dump_stream_irq(dev, id);
 800719c: 6839         	ldr	r1, [r7]
 800719e: 6878         	ldr	r0, [r7, #0x4]
 80071a0: f00f f89d    	bl	0x80162de <dma_stm32_dump_stream_irq> @ imm = #0xf13a
; 		dma_stm32_clear_stream_irq(dev, id);
 80071a4: 6839         	ldr	r1, [r7]
 80071a6: 6878         	ldr	r0, [r7, #0x4]
 80071a8: f00f f8ac    	bl	0x8016304 <dma_stm32_clear_stream_irq> @ imm = #0xf158
; 		stream->dma_callback(dev, stream->user_data,
 80071ac: 69fb         	ldr	r3, [r7, #0x1c]
 80071ae: 695c         	ldr	r4, [r3, #0x14]
 80071b0: 69fb         	ldr	r3, [r7, #0x1c]
 80071b2: 6919         	ldr	r1, [r3, #0x10]
 80071b4: f06f 0304    	mvn	r3, #0x4
 80071b8: 69ba         	ldr	r2, [r7, #0x18]
 80071ba: 6878         	ldr	r0, [r7, #0x4]
 80071bc: 47a0         	blx	r4
; }
 80071be: 372c         	adds	r7, #0x2c
 80071c0: 46bd         	mov	sp, r7
 80071c2: bd90         	pop	{r4, r7, pc}

080071c4 <$d>:
 80071c4: 00 05 00 20  	.word	0x20000500
 80071c8: 60 ea 01 08  	.word	0x0801ea60
 80071cc: 7c ea 01 08  	.word	0x0801ea7c

080071d0 <dma_stm32_get_priority>:
; {
 80071d0: b580         	push	{r7, lr}
 80071d2: b088         	sub	sp, #0x20
 80071d4: af04         	add	r7, sp, #0x10
 80071d6: 4603         	mov	r3, r0
 80071d8: 6039         	str	r1, [r7]
 80071da: 71fb         	strb	r3, [r7, #0x7]
; 	switch (priority) {
 80071dc: 79fb         	ldrb	r3, [r7, #0x7]
 80071de: 2b03         	cmp	r3, #0x3
 80071e0: d81d         	bhi	0x800721e <dma_stm32_get_priority+0x4e> @ imm = #0x3a
 80071e2: a201         	adr	r2, #4 <dma_stm32_get_priority+0x17>
 80071e4: f852 f023    	ldr.w	pc, [r2, r3, lsl #2]

080071e8 <$d>:
 80071e8: f9 71 00 08  	.word	0x080071f9
 80071ec: 01 72 00 08  	.word	0x08007201
 80071f0: 0b 72 00 08  	.word	0x0800720b
 80071f4: 15 72 00 08  	.word	0x08007215

080071f8 <$t>:
; 		*ll_priority = LL_DMA_PRIORITY_LOW;
 80071f8: 683b         	ldr	r3, [r7]
 80071fa: 2200         	movs	r2, #0x0
 80071fc: 601a         	str	r2, [r3]
; 		break;
 80071fe: e02d         	b	0x800725c <dma_stm32_get_priority+0x8c> @ imm = #0x5a
; 		*ll_priority = LL_DMA_PRIORITY_MEDIUM;
 8007200: 683b         	ldr	r3, [r7]
 8007202: f44f 3280    	mov.w	r2, #0x10000
 8007206: 601a         	str	r2, [r3]
; 		break;
 8007208: e028         	b	0x800725c <dma_stm32_get_priority+0x8c> @ imm = #0x50
; 		*ll_priority = LL_DMA_PRIORITY_HIGH;
 800720a: 683b         	ldr	r3, [r7]
 800720c: f44f 3200    	mov.w	r2, #0x20000
 8007210: 601a         	str	r2, [r3]
; 		break;
 8007212: e023         	b	0x800725c <dma_stm32_get_priority+0x8c> @ imm = #0x46
; 		*ll_priority = LL_DMA_PRIORITY_VERYHIGH;
 8007214: 683b         	ldr	r3, [r7]
 8007216: f44f 3240    	mov.w	r2, #0x30000
 800721a: 601a         	str	r2, [r3]
; 		break;
 800721c: e01e         	b	0x800725c <dma_stm32_get_priority+0x8c> @ imm = #0x3c
; 		LOG_ERR("Priority error. %d", priority);
 800721e: 2303         	movs	r3, #0x3
 8007220: 2b00         	cmp	r3, #0x0
 8007222: d018         	beq	0x8007256 <dma_stm32_get_priority+0x86> @ imm = #0x30
 8007224: 2301         	movs	r3, #0x1
 8007226: 73fb         	strb	r3, [r7, #0xf]
 8007228: 7bfb         	ldrb	r3, [r7, #0xf]
 800722a: f083 0301    	eor	r3, r3, #0x1
 800722e: b2db         	uxtb	r3, r3
 8007230: 2b00         	cmp	r3, #0x0
 8007232: d110         	bne	0x8007256 <dma_stm32_get_priority+0x86> @ imm = #0x20
 8007234: 4b0c         	ldr	r3, [pc, #0x30]         @ 0x8007268 <dma_stm32_get_priority+0x98>
 8007236: 6819         	ldr	r1, [r3]
 8007238: 79fb         	ldrb	r3, [r7, #0x7]
 800723a: 9303         	str	r3, [sp, #0xc]
 800723c: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x800726c <dma_stm32_get_priority+0x9c>
 800723e: 9302         	str	r3, [sp, #0x8]
 8007240: 2300         	movs	r3, #0x0
 8007242: 9301         	str	r3, [sp, #0x4]
 8007244: 2300         	movs	r3, #0x0
 8007246: 9300         	str	r3, [sp]
 8007248: 2300         	movs	r3, #0x0
 800724a: 2201         	movs	r2, #0x1
 800724c: 2000         	movs	r0, #0x0
 800724e: f00f f828    	bl	0x80162a2 <z_log_msg_runtime_create> @ imm = #0xf050
 8007252: 2300         	movs	r3, #0x0
 8007254: 60bb         	str	r3, [r7, #0x8]
; 		return -EINVAL;
 8007256: f06f 0315    	mvn	r3, #0x15
 800725a: e000         	b	0x800725e <dma_stm32_get_priority+0x8e> @ imm = #0x0
; 	return 0;
 800725c: 2300         	movs	r3, #0x0
; }
 800725e: 4618         	mov	r0, r3
 8007260: 3710         	adds	r7, #0x10
 8007262: 46bd         	mov	sp, r7
 8007264: bd80         	pop	{r7, pc}
 8007266: bf00         	nop

08007268 <$d>:
 8007268: 00 05 00 20  	.word	0x20000500
 800726c: 8c ea 01 08  	.word	0x0801ea8c

08007270 <dma_stm32_get_direction>:
; {
 8007270: b580         	push	{r7, lr}
 8007272: b088         	sub	sp, #0x20
 8007274: af04         	add	r7, sp, #0x10
 8007276: 4603         	mov	r3, r0
 8007278: 6039         	str	r1, [r7]
 800727a: 71fb         	strb	r3, [r7, #0x7]
; 	switch (direction) {
 800727c: 79fb         	ldrb	r3, [r7, #0x7]
 800727e: 2b02         	cmp	r3, #0x2
 8007280: d00e         	beq	0x80072a0 <dma_stm32_get_direction+0x30> @ imm = #0x1c
 8007282: 2b02         	cmp	r3, #0x2
 8007284: dc10         	bgt	0x80072a8 <dma_stm32_get_direction+0x38> @ imm = #0x20
 8007286: 2b00         	cmp	r3, #0x0
 8007288: d002         	beq	0x8007290 <dma_stm32_get_direction+0x20> @ imm = #0x4
 800728a: 2b01         	cmp	r3, #0x1
 800728c: d004         	beq	0x8007298 <dma_stm32_get_direction+0x28> @ imm = #0x8
 800728e: e00b         	b	0x80072a8 <dma_stm32_get_direction+0x38> @ imm = #0x16
; 		*ll_direction = LL_DMA_DIRECTION_MEMORY_TO_MEMORY;
 8007290: 683b         	ldr	r3, [r7]
 8007292: 2280         	movs	r2, #0x80
 8007294: 601a         	str	r2, [r3]
; 		break;
 8007296: e026         	b	0x80072e6 <dma_stm32_get_direction+0x76> @ imm = #0x4c
; 		*ll_direction = LL_DMA_DIRECTION_MEMORY_TO_PERIPH;
 8007298: 683b         	ldr	r3, [r7]
 800729a: 2240         	movs	r2, #0x40
 800729c: 601a         	str	r2, [r3]
; 		break;
 800729e: e022         	b	0x80072e6 <dma_stm32_get_direction+0x76> @ imm = #0x44
; 		*ll_direction = LL_DMA_DIRECTION_PERIPH_TO_MEMORY;
 80072a0: 683b         	ldr	r3, [r7]
 80072a2: 2200         	movs	r2, #0x0
 80072a4: 601a         	str	r2, [r3]
; 		break;
 80072a6: e01e         	b	0x80072e6 <dma_stm32_get_direction+0x76> @ imm = #0x3c
; 		LOG_ERR("Direction error. %d", direction);
 80072a8: 2303         	movs	r3, #0x3
 80072aa: 2b00         	cmp	r3, #0x0
 80072ac: d018         	beq	0x80072e0 <dma_stm32_get_direction+0x70> @ imm = #0x30
 80072ae: 2301         	movs	r3, #0x1
 80072b0: 73fb         	strb	r3, [r7, #0xf]
 80072b2: 7bfb         	ldrb	r3, [r7, #0xf]
 80072b4: f083 0301    	eor	r3, r3, #0x1
 80072b8: b2db         	uxtb	r3, r3
 80072ba: 2b00         	cmp	r3, #0x0
 80072bc: d110         	bne	0x80072e0 <dma_stm32_get_direction+0x70> @ imm = #0x20
 80072be: 4b0c         	ldr	r3, [pc, #0x30]         @ 0x80072f0 <dma_stm32_get_direction+0x80>
 80072c0: 6819         	ldr	r1, [r3]
 80072c2: 79fb         	ldrb	r3, [r7, #0x7]
 80072c4: 9303         	str	r3, [sp, #0xc]
 80072c6: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x80072f4 <dma_stm32_get_direction+0x84>
 80072c8: 9302         	str	r3, [sp, #0x8]
 80072ca: 2300         	movs	r3, #0x0
 80072cc: 9301         	str	r3, [sp, #0x4]
 80072ce: 2300         	movs	r3, #0x0
 80072d0: 9300         	str	r3, [sp]
 80072d2: 2300         	movs	r3, #0x0
 80072d4: 2201         	movs	r2, #0x1
 80072d6: 2000         	movs	r0, #0x0
 80072d8: f00e ffe3    	bl	0x80162a2 <z_log_msg_runtime_create> @ imm = #0xefc6
 80072dc: 2300         	movs	r3, #0x0
 80072de: 60bb         	str	r3, [r7, #0x8]
; 		return -EINVAL;
 80072e0: f06f 0315    	mvn	r3, #0x15
 80072e4: e000         	b	0x80072e8 <dma_stm32_get_direction+0x78> @ imm = #0x0
; 	return 0;
 80072e6: 2300         	movs	r3, #0x0
; }
 80072e8: 4618         	mov	r0, r3
 80072ea: 3710         	adds	r7, #0x10
 80072ec: 46bd         	mov	sp, r7
 80072ee: bd80         	pop	{r7, pc}

080072f0 <$d>:
 80072f0: 00 05 00 20  	.word	0x20000500
 80072f4: a0 ea 01 08  	.word	0x0801eaa0

080072f8 <dma_stm32_get_memory_increment>:
; {
 80072f8: b580         	push	{r7, lr}
 80072fa: b088         	sub	sp, #0x20
 80072fc: af04         	add	r7, sp, #0x10
 80072fe: 4603         	mov	r3, r0
 8007300: 6039         	str	r1, [r7]
 8007302: 71fb         	strb	r3, [r7, #0x7]
; 	switch (increment) {
 8007304: 79fb         	ldrb	r3, [r7, #0x7]
 8007306: 2b02         	cmp	r3, #0x2
 8007308: d00b         	beq	0x8007322 <dma_stm32_get_memory_increment+0x2a> @ imm = #0x16
 800730a: 2b02         	cmp	r3, #0x2
 800730c: dc10         	bgt	0x8007330 <dma_stm32_get_memory_increment+0x38> @ imm = #0x20
 800730e: 2b00         	cmp	r3, #0x0
 8007310: d002         	beq	0x8007318 <dma_stm32_get_memory_increment+0x20> @ imm = #0x4
 8007312: 2b01         	cmp	r3, #0x1
 8007314: d009         	beq	0x800732a <dma_stm32_get_memory_increment+0x32> @ imm = #0x12
 8007316: e00b         	b	0x8007330 <dma_stm32_get_memory_increment+0x38> @ imm = #0x16
; 		*ll_increment = LL_DMA_MEMORY_INCREMENT;
 8007318: 683b         	ldr	r3, [r7]
 800731a: f44f 6280    	mov.w	r2, #0x400
 800731e: 601a         	str	r2, [r3]
; 		break;
 8007320: e025         	b	0x800736e <dma_stm32_get_memory_increment+0x76> @ imm = #0x4a
; 		*ll_increment = LL_DMA_MEMORY_NOINCREMENT;
 8007322: 683b         	ldr	r3, [r7]
 8007324: 2200         	movs	r2, #0x0
 8007326: 601a         	str	r2, [r3]
; 		break;
 8007328: e021         	b	0x800736e <dma_stm32_get_memory_increment+0x76> @ imm = #0x42
; 		return -ENOTSUP;
 800732a: f06f 0385    	mvn	r3, #0x85
 800732e: e01f         	b	0x8007370 <dma_stm32_get_memory_increment+0x78> @ imm = #0x3e
; 		LOG_ERR("Memory increment error. %d", increment);
 8007330: 2303         	movs	r3, #0x3
 8007332: 2b00         	cmp	r3, #0x0
 8007334: d018         	beq	0x8007368 <dma_stm32_get_memory_increment+0x70> @ imm = #0x30
 8007336: 2301         	movs	r3, #0x1
 8007338: 73fb         	strb	r3, [r7, #0xf]
 800733a: 7bfb         	ldrb	r3, [r7, #0xf]
 800733c: f083 0301    	eor	r3, r3, #0x1
 8007340: b2db         	uxtb	r3, r3
 8007342: 2b00         	cmp	r3, #0x0
 8007344: d110         	bne	0x8007368 <dma_stm32_get_memory_increment+0x70> @ imm = #0x20
 8007346: 4b0c         	ldr	r3, [pc, #0x30]         @ 0x8007378 <dma_stm32_get_memory_increment+0x80>
 8007348: 6819         	ldr	r1, [r3]
 800734a: 79fb         	ldrb	r3, [r7, #0x7]
 800734c: 9303         	str	r3, [sp, #0xc]
 800734e: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x800737c <dma_stm32_get_memory_increment+0x84>
 8007350: 9302         	str	r3, [sp, #0x8]
 8007352: 2300         	movs	r3, #0x0
 8007354: 9301         	str	r3, [sp, #0x4]
 8007356: 2300         	movs	r3, #0x0
 8007358: 9300         	str	r3, [sp]
 800735a: 2300         	movs	r3, #0x0
 800735c: 2201         	movs	r2, #0x1
 800735e: 2000         	movs	r0, #0x0
 8007360: f00e ff9f    	bl	0x80162a2 <z_log_msg_runtime_create> @ imm = #0xef3e
 8007364: 2300         	movs	r3, #0x0
 8007366: 60bb         	str	r3, [r7, #0x8]
; 		return -EINVAL;
 8007368: f06f 0315    	mvn	r3, #0x15
 800736c: e000         	b	0x8007370 <dma_stm32_get_memory_increment+0x78> @ imm = #0x0
; 	return 0;
 800736e: 2300         	movs	r3, #0x0
; }
 8007370: 4618         	mov	r0, r3
 8007372: 3710         	adds	r7, #0x10
 8007374: 46bd         	mov	sp, r7
 8007376: bd80         	pop	{r7, pc}

08007378 <$d>:
 8007378: 00 05 00 20  	.word	0x20000500
 800737c: b4 ea 01 08  	.word	0x0801eab4

08007380 <dma_stm32_get_periph_increment>:
; {
 8007380: b580         	push	{r7, lr}
 8007382: b088         	sub	sp, #0x20
 8007384: af04         	add	r7, sp, #0x10
 8007386: 4603         	mov	r3, r0
 8007388: 6039         	str	r1, [r7]
 800738a: 71fb         	strb	r3, [r7, #0x7]
; 	switch (increment) {
 800738c: 79fb         	ldrb	r3, [r7, #0x7]
 800738e: 2b02         	cmp	r3, #0x2
 8007390: d00b         	beq	0x80073aa <dma_stm32_get_periph_increment+0x2a> @ imm = #0x16
 8007392: 2b02         	cmp	r3, #0x2
 8007394: dc10         	bgt	0x80073b8 <dma_stm32_get_periph_increment+0x38> @ imm = #0x20
 8007396: 2b00         	cmp	r3, #0x0
 8007398: d002         	beq	0x80073a0 <dma_stm32_get_periph_increment+0x20> @ imm = #0x4
 800739a: 2b01         	cmp	r3, #0x1
 800739c: d009         	beq	0x80073b2 <dma_stm32_get_periph_increment+0x32> @ imm = #0x12
 800739e: e00b         	b	0x80073b8 <dma_stm32_get_periph_increment+0x38> @ imm = #0x16
; 		*ll_increment = LL_DMA_PERIPH_INCREMENT;
 80073a0: 683b         	ldr	r3, [r7]
 80073a2: f44f 7200    	mov.w	r2, #0x200
 80073a6: 601a         	str	r2, [r3]
; 		break;
 80073a8: e025         	b	0x80073f6 <dma_stm32_get_periph_increment+0x76> @ imm = #0x4a
; 		*ll_increment = LL_DMA_PERIPH_NOINCREMENT;
 80073aa: 683b         	ldr	r3, [r7]
 80073ac: 2200         	movs	r2, #0x0
 80073ae: 601a         	str	r2, [r3]
; 		break;
 80073b0: e021         	b	0x80073f6 <dma_stm32_get_periph_increment+0x76> @ imm = #0x42
; 		return -ENOTSUP;
 80073b2: f06f 0385    	mvn	r3, #0x85
 80073b6: e01f         	b	0x80073f8 <dma_stm32_get_periph_increment+0x78> @ imm = #0x3e
; 		LOG_ERR("Periph increment error. %d", increment);
 80073b8: 2303         	movs	r3, #0x3
 80073ba: 2b00         	cmp	r3, #0x0
 80073bc: d018         	beq	0x80073f0 <dma_stm32_get_periph_increment+0x70> @ imm = #0x30
 80073be: 2301         	movs	r3, #0x1
 80073c0: 73fb         	strb	r3, [r7, #0xf]
 80073c2: 7bfb         	ldrb	r3, [r7, #0xf]
 80073c4: f083 0301    	eor	r3, r3, #0x1
 80073c8: b2db         	uxtb	r3, r3
 80073ca: 2b00         	cmp	r3, #0x0
 80073cc: d110         	bne	0x80073f0 <dma_stm32_get_periph_increment+0x70> @ imm = #0x20
 80073ce: 4b0c         	ldr	r3, [pc, #0x30]         @ 0x8007400 <dma_stm32_get_periph_increment+0x80>
 80073d0: 6819         	ldr	r1, [r3]
 80073d2: 79fb         	ldrb	r3, [r7, #0x7]
 80073d4: 9303         	str	r3, [sp, #0xc]
 80073d6: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x8007404 <dma_stm32_get_periph_increment+0x84>
 80073d8: 9302         	str	r3, [sp, #0x8]
 80073da: 2300         	movs	r3, #0x0
 80073dc: 9301         	str	r3, [sp, #0x4]
 80073de: 2300         	movs	r3, #0x0
 80073e0: 9300         	str	r3, [sp]
 80073e2: 2300         	movs	r3, #0x0
 80073e4: 2201         	movs	r2, #0x1
 80073e6: 2000         	movs	r0, #0x0
 80073e8: f00e ff5b    	bl	0x80162a2 <z_log_msg_runtime_create> @ imm = #0xeeb6
 80073ec: 2300         	movs	r3, #0x0
 80073ee: 60bb         	str	r3, [r7, #0x8]
; 		return -EINVAL;
 80073f0: f06f 0315    	mvn	r3, #0x15
 80073f4: e000         	b	0x80073f8 <dma_stm32_get_periph_increment+0x78> @ imm = #0x0
; 	return 0;
 80073f6: 2300         	movs	r3, #0x0
; }
 80073f8: 4618         	mov	r0, r3
 80073fa: 3710         	adds	r7, #0x10
 80073fc: 46bd         	mov	sp, r7
 80073fe: bd80         	pop	{r7, pc}

08007400 <$d>:
 8007400: 00 05 00 20  	.word	0x20000500
 8007404: d0 ea 01 08  	.word	0x0801ead0

08007408 <dma_stm32_configure>:
; {
 8007408: b580         	push	{r7, lr}
 800740a: b0be         	sub	sp, #0xf8
 800740c: af06         	add	r7, sp, #0x18
 800740e: 60f8         	str	r0, [r7, #0xc]
 8007410: 60b9         	str	r1, [r7, #0x8]
 8007412: 607a         	str	r2, [r7, #0x4]
; 	const struct dma_stm32_config *dev_config = dev->config;
 8007414: 68fb         	ldr	r3, [r7, #0xc]
 8007416: 685b         	ldr	r3, [r3, #0x4]
 8007418: f8c7 30c8    	str.w	r3, [r7, #0xc8]
; 				&dev_config->streams[id - STM32_DMA_STREAM_OFFSET];
 800741c: f8d7 30c8    	ldr.w	r3, [r7, #0xc8]
 8007420: 6999         	ldr	r1, [r3, #0x18]
 8007422: 68ba         	ldr	r2, [r7, #0x8]
 8007424: 4613         	mov	r3, r2
 8007426: 00db         	lsls	r3, r3, #0x3
 8007428: 1a9b         	subs	r3, r3, r2
 800742a: 009b         	lsls	r3, r3, #0x2
; 	struct dma_stm32_stream *stream =
 800742c: 440b         	add	r3, r1
 800742e: f8c7 30d0    	str.w	r3, [r7, #0xd0]
; 	DMA_TypeDef *dma = (DMA_TypeDef *)dev_config->base;
 8007432: f8d7 30c8    	ldr.w	r3, [r7, #0xc8]
 8007436: 691b         	ldr	r3, [r3, #0x10]
 8007438: f8c7 30cc    	str.w	r3, [r7, #0xcc]
; 	LL_DMA_StructInit(&DMA_InitStruct);
 800743c: f107 0310    	add.w	r3, r7, #0x10
 8007440: 4618         	mov	r0, r3
 8007442: f014 fb30    	bl	0x801baa6 <LL_DMA_StructInit> @ imm = #0x14660
; 	if (id >= dev_config->max_streams) {
 8007446: f8d7 30c8    	ldr.w	r3, [r7, #0xc8]
 800744a: 695b         	ldr	r3, [r3, #0x14]
 800744c: 68ba         	ldr	r2, [r7, #0x8]
 800744e: 429a         	cmp	r2, r3
 8007450: d321         	blo	0x8007496 <dma_stm32_configure+0x8e> @ imm = #0x42
; 		LOG_ERR("cannot configure the dma stream %d.", id);
 8007452: 2303         	movs	r3, #0x3
 8007454: 2b00         	cmp	r3, #0x0
 8007456: d01a         	beq	0x800748e <dma_stm32_configure+0x86> @ imm = #0x34
 8007458: 2301         	movs	r3, #0x1
 800745a: f887 305b    	strb.w	r3, [r7, #0x5b]
 800745e: f897 305b    	ldrb.w	r3, [r7, #0x5b]
 8007462: f083 0301    	eor	r3, r3, #0x1
 8007466: b2db         	uxtb	r3, r3
 8007468: 2b00         	cmp	r3, #0x0
 800746a: d110         	bne	0x800748e <dma_stm32_configure+0x86> @ imm = #0x20
 800746c: 4b9b         	ldr	r3, [pc, #0x26c]        @ 0x80076dc <dma_stm32_configure+0x2d4>
 800746e: 6819         	ldr	r1, [r3]
 8007470: 68bb         	ldr	r3, [r7, #0x8]
 8007472: 9303         	str	r3, [sp, #0xc]
 8007474: 4b9a         	ldr	r3, [pc, #0x268]        @ 0x80076e0 <dma_stm32_configure+0x2d8>
 8007476: 9302         	str	r3, [sp, #0x8]
 8007478: 2300         	movs	r3, #0x0
 800747a: 9301         	str	r3, [sp, #0x4]
 800747c: 2300         	movs	r3, #0x0
 800747e: 9300         	str	r3, [sp]
 8007480: 2300         	movs	r3, #0x0
 8007482: 2201         	movs	r2, #0x1
 8007484: 2000         	movs	r0, #0x0
 8007486: f00e ff0c    	bl	0x80162a2 <z_log_msg_runtime_create> @ imm = #0xee18
 800748a: 2300         	movs	r3, #0x0
 800748c: 657b         	str	r3, [r7, #0x54]
; 		return -EINVAL;
 800748e: f06f 0315    	mvn	r3, #0x15
 8007492: f000 bc1f    	b.w	0x8007cd4 <dma_stm32_configure+0x8cc> @ imm = #0x83e
; 	if (stream->busy) {
 8007496: f8d7 30d0    	ldr.w	r3, [r7, #0xd0]
 800749a: 799b         	ldrb	r3, [r3, #0x6]
 800749c: b2db         	uxtb	r3, r3
 800749e: 2b00         	cmp	r3, #0x0
 80074a0: d020         	beq	0x80074e4 <dma_stm32_configure+0xdc> @ imm = #0x40
; 		LOG_ERR("dma stream %d is busy.", id);
 80074a2: 2303         	movs	r3, #0x3
 80074a4: 2b00         	cmp	r3, #0x0
 80074a6: d01a         	beq	0x80074de <dma_stm32_configure+0xd6> @ imm = #0x34
 80074a8: 2301         	movs	r3, #0x1
 80074aa: f887 3063    	strb.w	r3, [r7, #0x63]
 80074ae: f897 3063    	ldrb.w	r3, [r7, #0x63]
 80074b2: f083 0301    	eor	r3, r3, #0x1
 80074b6: b2db         	uxtb	r3, r3
 80074b8: 2b00         	cmp	r3, #0x0
 80074ba: d110         	bne	0x80074de <dma_stm32_configure+0xd6> @ imm = #0x20
 80074bc: 4b87         	ldr	r3, [pc, #0x21c]        @ 0x80076dc <dma_stm32_configure+0x2d4>
 80074be: 6819         	ldr	r1, [r3]
 80074c0: 68bb         	ldr	r3, [r7, #0x8]
 80074c2: 9303         	str	r3, [sp, #0xc]
 80074c4: 4b87         	ldr	r3, [pc, #0x21c]        @ 0x80076e4 <dma_stm32_configure+0x2dc>
 80074c6: 9302         	str	r3, [sp, #0x8]
 80074c8: 2300         	movs	r3, #0x0
 80074ca: 9301         	str	r3, [sp, #0x4]
 80074cc: 2300         	movs	r3, #0x0
 80074ce: 9300         	str	r3, [sp]
 80074d0: 2300         	movs	r3, #0x0
 80074d2: 2201         	movs	r2, #0x1
 80074d4: 2000         	movs	r0, #0x0
 80074d6: f00e fee4    	bl	0x80162a2 <z_log_msg_runtime_create> @ imm = #0xedc8
 80074da: 2300         	movs	r3, #0x0
 80074dc: 65fb         	str	r3, [r7, #0x5c]
; 		return -EBUSY;
 80074de: f06f 030f    	mvn	r3, #0xf
 80074e2: e3f7         	b	0x8007cd4 <dma_stm32_configure+0x8cc> @ imm = #0x7ee
; 	if (dma_stm32_disable_stream(dma, id) != 0) {
 80074e4: 68b9         	ldr	r1, [r7, #0x8]
 80074e6: f8d7 00cc    	ldr.w	r0, [r7, #0xcc]
 80074ea: f00e ff26    	bl	0x801633a <dma_stm32_disable_stream> @ imm = #0xee4c
 80074ee: 4603         	mov	r3, r0
 80074f0: 2b00         	cmp	r3, #0x0
 80074f2: d020         	beq	0x8007536 <dma_stm32_configure+0x12e> @ imm = #0x40
; 		LOG_ERR("could not disable dma stream %d.", id);
 80074f4: 2303         	movs	r3, #0x3
 80074f6: 2b00         	cmp	r3, #0x0
 80074f8: d01a         	beq	0x8007530 <dma_stm32_configure+0x128> @ imm = #0x34
 80074fa: 2301         	movs	r3, #0x1
 80074fc: f887 306b    	strb.w	r3, [r7, #0x6b]
 8007500: f897 306b    	ldrb.w	r3, [r7, #0x6b]
 8007504: f083 0301    	eor	r3, r3, #0x1
 8007508: b2db         	uxtb	r3, r3
 800750a: 2b00         	cmp	r3, #0x0
 800750c: d110         	bne	0x8007530 <dma_stm32_configure+0x128> @ imm = #0x20
 800750e: 4b73         	ldr	r3, [pc, #0x1cc]        @ 0x80076dc <dma_stm32_configure+0x2d4>
 8007510: 6819         	ldr	r1, [r3]
 8007512: 68bb         	ldr	r3, [r7, #0x8]
 8007514: 9303         	str	r3, [sp, #0xc]
 8007516: 4b74         	ldr	r3, [pc, #0x1d0]        @ 0x80076e8 <dma_stm32_configure+0x2e0>
 8007518: 9302         	str	r3, [sp, #0x8]
 800751a: 2300         	movs	r3, #0x0
 800751c: 9301         	str	r3, [sp, #0x4]
 800751e: 2300         	movs	r3, #0x0
 8007520: 9300         	str	r3, [sp]
 8007522: 2300         	movs	r3, #0x0
 8007524: 2201         	movs	r2, #0x1
 8007526: 2000         	movs	r0, #0x0
 8007528: f00e febb    	bl	0x80162a2 <z_log_msg_runtime_create> @ imm = #0xed76
 800752c: 2300         	movs	r3, #0x0
 800752e: 667b         	str	r3, [r7, #0x64]
; 		return -EBUSY;
 8007530: f06f 030f    	mvn	r3, #0xf
 8007534: e3ce         	b	0x8007cd4 <dma_stm32_configure+0x8cc> @ imm = #0x79c
; 	dma_stm32_clear_stream_irq(dev, id);
 8007536: 68b9         	ldr	r1, [r7, #0x8]
 8007538: 68f8         	ldr	r0, [r7, #0xc]
 800753a: f00e fee3    	bl	0x8016304 <dma_stm32_clear_stream_irq> @ imm = #0xedc6
; 	if (config->linked_channel == STM32_DMA_HAL_OVERRIDE) {
 800753e: 687b         	ldr	r3, [r7, #0x4]
 8007540: 885b         	ldrh	r3, [r3, #0x2]
 8007542: f403 637e    	and	r3, r3, #0xfe0
 8007546: b29b         	uxth	r3, r3
 8007548: f5b3 6f7e    	cmp.w	r3, #0xfe0
 800754c: d117         	bne	0x800757e <dma_stm32_configure+0x176> @ imm = #0x2e
; 		stream->busy = true;
 800754e: f8d7 30d0    	ldr.w	r3, [r7, #0xd0]
 8007552: 2201         	movs	r2, #0x1
 8007554: 719a         	strb	r2, [r3, #0x6]
; 		stream->hal_override = true;
 8007556: f8d7 30d0    	ldr.w	r3, [r7, #0xd0]
 800755a: 2201         	movs	r2, #0x1
 800755c: 715a         	strb	r2, [r3, #0x5]
; 		stream->dma_callback = config->dma_callback;
 800755e: 687b         	ldr	r3, [r7, #0x4]
 8007560: 699a         	ldr	r2, [r3, #0x18]
 8007562: f8d7 30d0    	ldr.w	r3, [r7, #0xd0]
 8007566: 615a         	str	r2, [r3, #0x14]
; 		stream->user_data = config->user_data;
 8007568: 687b         	ldr	r3, [r7, #0x4]
 800756a: 695a         	ldr	r2, [r3, #0x14]
 800756c: f8d7 30d0    	ldr.w	r3, [r7, #0xd0]
 8007570: 611a         	str	r2, [r3, #0x10]
; 		stream->cyclic = false;
 8007572: f8d7 30d0    	ldr.w	r3, [r7, #0xd0]
 8007576: 2200         	movs	r2, #0x0
 8007578: 761a         	strb	r2, [r3, #0x18]
; 		return 0;
 800757a: 2300         	movs	r3, #0x0
 800757c: e3aa         	b	0x8007cd4 <dma_stm32_configure+0x8cc> @ imm = #0x754
; 	if (config->head_block->block_size > DMA_STM32_MAX_DATA_ITEMS) {
 800757e: 687b         	ldr	r3, [r7, #0x4]
 8007580: 691b         	ldr	r3, [r3, #0x10]
 8007582: 695b         	ldr	r3, [r3, #0x14]
 8007584: f5b3 3f80    	cmp.w	r3, #0x10000
 8007588: d322         	blo	0x80075d0 <dma_stm32_configure+0x1c8> @ imm = #0x44
; 		LOG_ERR("Data size too big: %d\n",
 800758a: 2303         	movs	r3, #0x3
 800758c: 2b00         	cmp	r3, #0x0
 800758e: d01c         	beq	0x80075ca <dma_stm32_configure+0x1c2> @ imm = #0x38
 8007590: 2301         	movs	r3, #0x1
 8007592: f887 3073    	strb.w	r3, [r7, #0x73]
 8007596: f897 3073    	ldrb.w	r3, [r7, #0x73]
 800759a: f083 0301    	eor	r3, r3, #0x1
 800759e: b2db         	uxtb	r3, r3
 80075a0: 2b00         	cmp	r3, #0x0
 80075a2: d112         	bne	0x80075ca <dma_stm32_configure+0x1c2> @ imm = #0x24
 80075a4: 4b4d         	ldr	r3, [pc, #0x134]        @ 0x80076dc <dma_stm32_configure+0x2d4>
 80075a6: 6819         	ldr	r1, [r3]
 80075a8: 687b         	ldr	r3, [r7, #0x4]
 80075aa: 691b         	ldr	r3, [r3, #0x10]
 80075ac: 695b         	ldr	r3, [r3, #0x14]
 80075ae: 9303         	str	r3, [sp, #0xc]
 80075b0: 4b4e         	ldr	r3, [pc, #0x138]        @ 0x80076ec <dma_stm32_configure+0x2e4>
 80075b2: 9302         	str	r3, [sp, #0x8]
 80075b4: 2300         	movs	r3, #0x0
 80075b6: 9301         	str	r3, [sp, #0x4]
 80075b8: 2300         	movs	r3, #0x0
 80075ba: 9300         	str	r3, [sp]
 80075bc: 2300         	movs	r3, #0x0
 80075be: 2201         	movs	r2, #0x1
 80075c0: 2000         	movs	r0, #0x0
 80075c2: f00e fe6e    	bl	0x80162a2 <z_log_msg_runtime_create> @ imm = #0xecdc
 80075c6: 2300         	movs	r3, #0x0
 80075c8: 66fb         	str	r3, [r7, #0x6c]
; 		return -EINVAL;
 80075ca: f06f 0315    	mvn	r3, #0x15
 80075ce: e381         	b	0x8007cd4 <dma_stm32_configure+0x8cc> @ imm = #0x702
; 	if ((config->channel_direction == MEMORY_TO_MEMORY) &&
 80075d0: 687b         	ldr	r3, [r7, #0x4]
 80075d2: 785b         	ldrb	r3, [r3, #0x1]
 80075d4: f003 0307    	and	r3, r3, #0x7
 80075d8: b2db         	uxtb	r3, r3
 80075da: 2b00         	cmp	r3, #0x0
 80075dc: d12a         	bne	0x8007634 <dma_stm32_configure+0x22c> @ imm = #0x54
; 		(!dev_config->support_m2m)) {
 80075de: f8d7 30c8    	ldr.w	r3, [r7, #0xc8]
 80075e2: 7b1b         	ldrb	r3, [r3, #0xc]
 80075e4: f083 0301    	eor	r3, r3, #0x1
 80075e8: b2db         	uxtb	r3, r3
; 	if ((config->channel_direction == MEMORY_TO_MEMORY) &&
 80075ea: 2b00         	cmp	r3, #0x0
 80075ec: d022         	beq	0x8007634 <dma_stm32_configure+0x22c> @ imm = #0x44
; 		LOG_ERR("Memcopy not supported for device %s",
 80075ee: 2303         	movs	r3, #0x3
 80075f0: 2b00         	cmp	r3, #0x0
 80075f2: d01c         	beq	0x800762e <dma_stm32_configure+0x226> @ imm = #0x38
 80075f4: 2301         	movs	r3, #0x1
 80075f6: f887 30d6    	strb.w	r3, [r7, #0xd6]
 80075fa: f897 30d6    	ldrb.w	r3, [r7, #0xd6]
 80075fe: f083 0301    	eor	r3, r3, #0x1
 8007602: b2db         	uxtb	r3, r3
 8007604: 2b00         	cmp	r3, #0x0
 8007606: d112         	bne	0x800762e <dma_stm32_configure+0x226> @ imm = #0x24
 8007608: 4b34         	ldr	r3, [pc, #0xd0]         @ 0x80076dc <dma_stm32_configure+0x2d4>
 800760a: 6819         	ldr	r1, [r3]
 800760c: 68fb         	ldr	r3, [r7, #0xc]
 800760e: 681b         	ldr	r3, [r3]
 8007610: 9303         	str	r3, [sp, #0xc]
 8007612: 4b37         	ldr	r3, [pc, #0xdc]         @ 0x80076f0 <dma_stm32_configure+0x2e8>
 8007614: 9302         	str	r3, [sp, #0x8]
 8007616: 2300         	movs	r3, #0x0
 8007618: 9301         	str	r3, [sp, #0x4]
 800761a: 2300         	movs	r3, #0x0
 800761c: 9300         	str	r3, [sp]
 800761e: 2300         	movs	r3, #0x0
 8007620: 2201         	movs	r2, #0x1
 8007622: 2000         	movs	r0, #0x0
 8007624: f00e fe3d    	bl	0x80162a2 <z_log_msg_runtime_create> @ imm = #0xec7a
 8007628: 2300         	movs	r3, #0x0
 800762a: f8c7 30d8    	str.w	r3, [r7, #0xd8]
; 		return -ENOTSUP;
 800762e: f06f 0385    	mvn	r3, #0x85
 8007632: e34f         	b	0x8007cd4 <dma_stm32_configure+0x8cc> @ imm = #0x69e
; 	if ((config->dest_data_size != config->source_data_size)) {
 8007634: 687b         	ldr	r3, [r7, #0x4]
 8007636: 88da         	ldrh	r2, [r3, #0x6]
 8007638: 687b         	ldr	r3, [r7, #0x4]
 800763a: 889b         	ldrh	r3, [r3, #0x4]
 800763c: 429a         	cmp	r2, r3
 800763e: d01e         	beq	0x800767e <dma_stm32_configure+0x276> @ imm = #0x3c
; 		LOG_ERR("source and dest data size differ.");
 8007640: 2303         	movs	r3, #0x3
 8007642: 2b00         	cmp	r3, #0x0
 8007644: d018         	beq	0x8007678 <dma_stm32_configure+0x270> @ imm = #0x30
 8007646: 2301         	movs	r3, #0x1
 8007648: f887 307b    	strb.w	r3, [r7, #0x7b]
 800764c: f897 307b    	ldrb.w	r3, [r7, #0x7b]
 8007650: f083 0301    	eor	r3, r3, #0x1
 8007654: b2db         	uxtb	r3, r3
 8007656: 2b00         	cmp	r3, #0x0
 8007658: d10e         	bne	0x8007678 <dma_stm32_configure+0x270> @ imm = #0x1c
 800765a: 4b20         	ldr	r3, [pc, #0x80]         @ 0x80076dc <dma_stm32_configure+0x2d4>
 800765c: 6819         	ldr	r1, [r3]
 800765e: 4b25         	ldr	r3, [pc, #0x94]         @ 0x80076f4 <dma_stm32_configure+0x2ec>
 8007660: 9302         	str	r3, [sp, #0x8]
 8007662: 2300         	movs	r3, #0x0
 8007664: 9301         	str	r3, [sp, #0x4]
 8007666: 2300         	movs	r3, #0x0
 8007668: 9300         	str	r3, [sp]
 800766a: 2300         	movs	r3, #0x0
 800766c: 2201         	movs	r2, #0x1
 800766e: 2000         	movs	r0, #0x0
 8007670: f00e fe17    	bl	0x80162a2 <z_log_msg_runtime_create> @ imm = #0xec2e
 8007674: 2300         	movs	r3, #0x0
 8007676: 677b         	str	r3, [r7, #0x74]
; 		return -EINVAL;
 8007678: f06f 0315    	mvn	r3, #0x15
 800767c: e32a         	b	0x8007cd4 <dma_stm32_configure+0x8cc> @ imm = #0x654
; 	if (config->source_data_size != 4U &&
 800767e: 687b         	ldr	r3, [r7, #0x4]
 8007680: 889b         	ldrh	r3, [r3, #0x4]
 8007682: 2b04         	cmp	r3, #0x4
 8007684: d03a         	beq	0x80076fc <dma_stm32_configure+0x2f4> @ imm = #0x74
; 	    config->source_data_size != 2U &&
 8007686: 687b         	ldr	r3, [r7, #0x4]
 8007688: 889b         	ldrh	r3, [r3, #0x4]
; 	if (config->source_data_size != 4U &&
 800768a: 2b02         	cmp	r3, #0x2
 800768c: d036         	beq	0x80076fc <dma_stm32_configure+0x2f4> @ imm = #0x6c
; 	    config->source_data_size != 1U) {
 800768e: 687b         	ldr	r3, [r7, #0x4]
 8007690: 889b         	ldrh	r3, [r3, #0x4]
; 	    config->source_data_size != 2U &&
 8007692: 2b01         	cmp	r3, #0x1
 8007694: d032         	beq	0x80076fc <dma_stm32_configure+0x2f4> @ imm = #0x64
; 		LOG_ERR("source and dest unit size error, %d",
 8007696: 2303         	movs	r3, #0x3
 8007698: 2b00         	cmp	r3, #0x0
 800769a: d01c         	beq	0x80076d6 <dma_stm32_configure+0x2ce> @ imm = #0x38
 800769c: 2301         	movs	r3, #0x1
 800769e: f887 30d7    	strb.w	r3, [r7, #0xd7]
 80076a2: f897 30d7    	ldrb.w	r3, [r7, #0xd7]
 80076a6: f083 0301    	eor	r3, r3, #0x1
 80076aa: b2db         	uxtb	r3, r3
 80076ac: 2b00         	cmp	r3, #0x0
 80076ae: d112         	bne	0x80076d6 <dma_stm32_configure+0x2ce> @ imm = #0x24
 80076b0: 4b0a         	ldr	r3, [pc, #0x28]         @ 0x80076dc <dma_stm32_configure+0x2d4>
 80076b2: 6819         	ldr	r1, [r3]
 80076b4: 687b         	ldr	r3, [r7, #0x4]
 80076b6: 889b         	ldrh	r3, [r3, #0x4]
 80076b8: 9303         	str	r3, [sp, #0xc]
 80076ba: 4b0f         	ldr	r3, [pc, #0x3c]         @ 0x80076f8 <dma_stm32_configure+0x2f0>
 80076bc: 9302         	str	r3, [sp, #0x8]
 80076be: 2300         	movs	r3, #0x0
 80076c0: 9301         	str	r3, [sp, #0x4]
 80076c2: 2300         	movs	r3, #0x0
 80076c4: 9300         	str	r3, [sp]
 80076c6: 2300         	movs	r3, #0x0
 80076c8: 2201         	movs	r2, #0x1
 80076ca: 2000         	movs	r0, #0x0
 80076cc: f00e fde9    	bl	0x80162a2 <z_log_msg_runtime_create> @ imm = #0xebd2
 80076d0: 2300         	movs	r3, #0x0
 80076d2: f8c7 30dc    	str.w	r3, [r7, #0xdc]
; 		return -EINVAL;
 80076d6: f06f 0315    	mvn	r3, #0x15
 80076da: e2fb         	b	0x8007cd4 <dma_stm32_configure+0x8cc> @ imm = #0x5f6

080076dc <$d>:
 80076dc: 00 05 00 20  	.word	0x20000500
 80076e0: ec ea 01 08  	.word	0x0801eaec
 80076e4: 10 eb 01 08  	.word	0x0801eb10
 80076e8: 28 eb 01 08  	.word	0x0801eb28
 80076ec: 4c eb 01 08  	.word	0x0801eb4c
 80076f0: 64 eb 01 08  	.word	0x0801eb64
 80076f4: 88 eb 01 08  	.word	0x0801eb88
 80076f8: ac eb 01 08  	.word	0x0801ebac

080076fc <$t>:
; 	if (config->head_block->source_reload_en !=
 80076fc: 687b         	ldr	r3, [r7, #0x4]
 80076fe: 691b         	ldr	r3, [r3, #0x10]
 8007700: 7f1b         	ldrb	r3, [r3, #0x1c]
 8007702: f3c3 1380    	ubfx	r3, r3, #0x6, #0x1
 8007706: b2da         	uxtb	r2, r3
; 		config->head_block->dest_reload_en) {
 8007708: 687b         	ldr	r3, [r7, #0x4]
 800770a: 691b         	ldr	r3, [r3, #0x10]
 800770c: 7f1b         	ldrb	r3, [r3, #0x1c]
 800770e: f3c3 13c0    	ubfx	r3, r3, #0x7, #0x1
 8007712: b2db         	uxtb	r3, r3
; 	if (config->head_block->source_reload_en !=
 8007714: 429a         	cmp	r2, r3
 8007716: d01e         	beq	0x8007756 <dma_stm32_configure+0x34e> @ imm = #0x3c
; 		LOG_ERR("source_reload_en and dest_reload_en must "
 8007718: 2303         	movs	r3, #0x3
 800771a: 2b00         	cmp	r3, #0x0
 800771c: d018         	beq	0x8007750 <dma_stm32_configure+0x348> @ imm = #0x30
 800771e: 2301         	movs	r3, #0x1
 8007720: f887 3083    	strb.w	r3, [r7, #0x83]
 8007724: f897 3083    	ldrb.w	r3, [r7, #0x83]
 8007728: f083 0301    	eor	r3, r3, #0x1
 800772c: b2db         	uxtb	r3, r3
 800772e: 2b00         	cmp	r3, #0x0
 8007730: d10e         	bne	0x8007750 <dma_stm32_configure+0x348> @ imm = #0x1c
 8007732: 4b9c         	ldr	r3, [pc, #0x270]        @ 0x80079a4 <dma_stm32_configure+0x59c>
 8007734: 6819         	ldr	r1, [r3]
 8007736: 4b9c         	ldr	r3, [pc, #0x270]        @ 0x80079a8 <dma_stm32_configure+0x5a0>
 8007738: 9302         	str	r3, [sp, #0x8]
 800773a: 2300         	movs	r3, #0x0
 800773c: 9301         	str	r3, [sp, #0x4]
 800773e: 2300         	movs	r3, #0x0
 8007740: 9300         	str	r3, [sp]
 8007742: 2300         	movs	r3, #0x0
 8007744: 2201         	movs	r2, #0x1
 8007746: 2000         	movs	r0, #0x0
 8007748: f00e fdab    	bl	0x80162a2 <z_log_msg_runtime_create> @ imm = #0xeb56
 800774c: 2300         	movs	r3, #0x0
 800774e: 67fb         	str	r3, [r7, #0x7c]
; 		return -EINVAL;
 8007750: f06f 0315    	mvn	r3, #0x15
 8007754: e2be         	b	0x8007cd4 <dma_stm32_configure+0x8cc> @ imm = #0x57c
; 	stream->busy		= true;
 8007756: f8d7 30d0    	ldr.w	r3, [r7, #0xd0]
 800775a: 2201         	movs	r2, #0x1
 800775c: 719a         	strb	r2, [r3, #0x6]
; 	stream->dma_callback	= config->dma_callback;
 800775e: 687b         	ldr	r3, [r7, #0x4]
 8007760: 699a         	ldr	r2, [r3, #0x18]
 8007762: f8d7 30d0    	ldr.w	r3, [r7, #0xd0]
 8007766: 615a         	str	r2, [r3, #0x14]
; 	stream->direction	= config->channel_direction;
 8007768: 687b         	ldr	r3, [r7, #0x4]
 800776a: 785b         	ldrb	r3, [r3, #0x1]
 800776c: f3c3 0302    	ubfx	r3, r3, #0x0, #0x3
 8007770: b2db         	uxtb	r3, r3
 8007772: 461a         	mov	r2, r3
 8007774: f8d7 30d0    	ldr.w	r3, [r7, #0xd0]
 8007778: 601a         	str	r2, [r3]
; 	stream->user_data       = config->user_data;
 800777a: 687b         	ldr	r3, [r7, #0x4]
 800777c: 695a         	ldr	r2, [r3, #0x14]
 800777e: f8d7 30d0    	ldr.w	r3, [r7, #0xd0]
 8007782: 611a         	str	r2, [r3, #0x10]
; 	stream->src_size	= config->source_data_size;
 8007784: 687b         	ldr	r3, [r7, #0x4]
 8007786: 889b         	ldrh	r3, [r3, #0x4]
 8007788: 461a         	mov	r2, r3
 800778a: f8d7 30d0    	ldr.w	r3, [r7, #0xd0]
 800778e: 609a         	str	r2, [r3, #0x8]
; 	stream->dst_size	= config->dest_data_size;
 8007790: 687b         	ldr	r3, [r7, #0x4]
 8007792: 88db         	ldrh	r3, [r3, #0x6]
 8007794: 461a         	mov	r2, r3
 8007796: f8d7 30d0    	ldr.w	r3, [r7, #0xd0]
 800779a: 60da         	str	r2, [r3, #0xc]
; 	stream->cyclic		= config->head_block->source_reload_en;
 800779c: 687b         	ldr	r3, [r7, #0x4]
 800779e: 691b         	ldr	r3, [r3, #0x10]
 80077a0: 7f1b         	ldrb	r3, [r3, #0x1c]
 80077a2: f3c3 1380    	ubfx	r3, r3, #0x6, #0x1
 80077a6: b2db         	uxtb	r3, r3
 80077a8: 2b00         	cmp	r3, #0x0
 80077aa: bf14         	ite	ne
 80077ac: 2301         	movne	r3, #0x1
 80077ae: 2300         	moveq	r3, #0x0
 80077b0: b2da         	uxtb	r2, r3
 80077b2: f8d7 30d0    	ldr.w	r3, [r7, #0xd0]
 80077b6: 761a         	strb	r2, [r3, #0x18]
; 	if (config->head_block->source_address == 0) {
 80077b8: 687b         	ldr	r3, [r7, #0x4]
 80077ba: 691b         	ldr	r3, [r3, #0x10]
 80077bc: 681b         	ldr	r3, [r3]
 80077be: 2b00         	cmp	r3, #0x0
 80077c0: d11c         	bne	0x80077fc <dma_stm32_configure+0x3f4> @ imm = #0x38
; 		LOG_WRN("source_buffer address is null.");
 80077c2: 2303         	movs	r3, #0x3
 80077c4: 2b01         	cmp	r3, #0x1
 80077c6: d919         	bls	0x80077fc <dma_stm32_configure+0x3f4> @ imm = #0x32
 80077c8: 2301         	movs	r3, #0x1
 80077ca: f887 30c3    	strb.w	r3, [r7, #0xc3]
 80077ce: f897 30c3    	ldrb.w	r3, [r7, #0xc3]
 80077d2: f083 0301    	eor	r3, r3, #0x1
 80077d6: b2db         	uxtb	r3, r3
 80077d8: 2b00         	cmp	r3, #0x0
 80077da: d10f         	bne	0x80077fc <dma_stm32_configure+0x3f4> @ imm = #0x1e
 80077dc: 4b71         	ldr	r3, [pc, #0x1c4]        @ 0x80079a4 <dma_stm32_configure+0x59c>
 80077de: 6819         	ldr	r1, [r3]
 80077e0: 4b72         	ldr	r3, [pc, #0x1c8]        @ 0x80079ac <dma_stm32_configure+0x5a4>
 80077e2: 9302         	str	r3, [sp, #0x8]
 80077e4: 2300         	movs	r3, #0x0
 80077e6: 9301         	str	r3, [sp, #0x4]
 80077e8: 2300         	movs	r3, #0x0
 80077ea: 9300         	str	r3, [sp]
 80077ec: 2300         	movs	r3, #0x0
 80077ee: 2202         	movs	r2, #0x2
 80077f0: 2000         	movs	r0, #0x0
 80077f2: f00e fd56    	bl	0x80162a2 <z_log_msg_runtime_create> @ imm = #0xeaac
 80077f6: 2300         	movs	r3, #0x0
 80077f8: f8c7 30bc    	str.w	r3, [r7, #0xbc]
; 	if (config->head_block->dest_address == 0) {
 80077fc: 687b         	ldr	r3, [r7, #0x4]
 80077fe: 691b         	ldr	r3, [r3, #0x10]
 8007800: 685b         	ldr	r3, [r3, #0x4]
 8007802: 2b00         	cmp	r3, #0x0
 8007804: d11c         	bne	0x8007840 <dma_stm32_configure+0x438> @ imm = #0x38
; 		LOG_WRN("dest_buffer address is null.");
 8007806: 2303         	movs	r3, #0x3
 8007808: 2b01         	cmp	r3, #0x1
 800780a: d919         	bls	0x8007840 <dma_stm32_configure+0x438> @ imm = #0x32
 800780c: 2301         	movs	r3, #0x1
 800780e: f887 30bb    	strb.w	r3, [r7, #0xbb]
 8007812: f897 30bb    	ldrb.w	r3, [r7, #0xbb]
 8007816: f083 0301    	eor	r3, r3, #0x1
 800781a: b2db         	uxtb	r3, r3
 800781c: 2b00         	cmp	r3, #0x0
 800781e: d10f         	bne	0x8007840 <dma_stm32_configure+0x438> @ imm = #0x1e
 8007820: 4b60         	ldr	r3, [pc, #0x180]        @ 0x80079a4 <dma_stm32_configure+0x59c>
 8007822: 6819         	ldr	r1, [r3]
 8007824: 4b62         	ldr	r3, [pc, #0x188]        @ 0x80079b0 <dma_stm32_configure+0x5a8>
 8007826: 9302         	str	r3, [sp, #0x8]
 8007828: 2300         	movs	r3, #0x0
 800782a: 9301         	str	r3, [sp, #0x4]
 800782c: 2300         	movs	r3, #0x0
 800782e: 9300         	str	r3, [sp]
 8007830: 2300         	movs	r3, #0x0
 8007832: 2202         	movs	r2, #0x2
 8007834: 2000         	movs	r0, #0x0
 8007836: f00e fd34    	bl	0x80162a2 <z_log_msg_runtime_create> @ imm = #0xea68
 800783a: 2300         	movs	r3, #0x0
 800783c: f8c7 30b4    	str.w	r3, [r7, #0xb4]
; 	if (stream->direction == MEMORY_TO_PERIPHERAL) {
 8007840: f8d7 30d0    	ldr.w	r3, [r7, #0xd0]
 8007844: 681b         	ldr	r3, [r3]
 8007846: 2b01         	cmp	r3, #0x1
 8007848: d108         	bne	0x800785c <dma_stm32_configure+0x454> @ imm = #0x10
; 					config->head_block->source_address;
 800784a: 687b         	ldr	r3, [r7, #0x4]
 800784c: 691b         	ldr	r3, [r3, #0x10]
 800784e: 681b         	ldr	r3, [r3]
; 		DMA_InitStruct.MemoryOrM2MDstAddress =
 8007850: 617b         	str	r3, [r7, #0x14]
; 					config->head_block->dest_address;
 8007852: 687b         	ldr	r3, [r7, #0x4]
 8007854: 691b         	ldr	r3, [r3, #0x10]
 8007856: 685b         	ldr	r3, [r3, #0x4]
; 		DMA_InitStruct.PeriphOrM2MSrcAddress =
 8007858: 613b         	str	r3, [r7, #0x10]
 800785a: e007         	b	0x800786c <dma_stm32_configure+0x464> @ imm = #0xe
; 					config->head_block->source_address;
 800785c: 687b         	ldr	r3, [r7, #0x4]
 800785e: 691b         	ldr	r3, [r3, #0x10]
 8007860: 681b         	ldr	r3, [r3]
; 		DMA_InitStruct.PeriphOrM2MSrcAddress =
 8007862: 613b         	str	r3, [r7, #0x10]
; 					config->head_block->dest_address;
 8007864: 687b         	ldr	r3, [r7, #0x4]
 8007866: 691b         	ldr	r3, [r3, #0x10]
 8007868: 685b         	ldr	r3, [r3, #0x4]
; 		DMA_InitStruct.MemoryOrM2MDstAddress =
 800786a: 617b         	str	r3, [r7, #0x14]
; 	uint16_t memory_addr_adj = 0, periph_addr_adj = 0;
 800786c: 2300         	movs	r3, #0x0
 800786e: f8a7 30c6    	strh.w	r3, [r7, #0xc6]
 8007872: 2300         	movs	r3, #0x0
 8007874: f8a7 30c4    	strh.w	r3, [r7, #0xc4]
; 	ret = dma_stm32_get_priority(config->channel_priority,
 8007878: 687b         	ldr	r3, [r7, #0x4]
 800787a: 681b         	ldr	r3, [r3]
 800787c: f3c3 33c3    	ubfx	r3, r3, #0xf, #0x4
 8007880: b2db         	uxtb	r3, r3
 8007882: 461a         	mov	r2, r3
 8007884: f107 0310    	add.w	r3, r7, #0x10
 8007888: 3328         	adds	r3, #0x28
 800788a: 4619         	mov	r1, r3
 800788c: 4610         	mov	r0, r2
 800788e: f7ff fc9f    	bl	0x80071d0 <dma_stm32_get_priority> @ imm = #-0x6c2
 8007892: f8c7 00b0    	str.w	r0, [r7, #0xb0]
; 	if (ret < 0) {
 8007896: f8d7 30b0    	ldr.w	r3, [r7, #0xb0]
 800789a: 2b00         	cmp	r3, #0x0
 800789c: da02         	bge	0x80078a4 <dma_stm32_configure+0x49c> @ imm = #0x4
; 		return ret;
 800789e: f8d7 30b0    	ldr.w	r3, [r7, #0xb0]
 80078a2: e217         	b	0x8007cd4 <dma_stm32_configure+0x8cc> @ imm = #0x42e
; 	ret = dma_stm32_get_direction(config->channel_direction,
 80078a4: 687b         	ldr	r3, [r7, #0x4]
 80078a6: 785b         	ldrb	r3, [r3, #0x1]
 80078a8: f3c3 0302    	ubfx	r3, r3, #0x0, #0x3
 80078ac: b2db         	uxtb	r3, r3
 80078ae: 461a         	mov	r2, r3
 80078b0: f107 0310    	add.w	r3, r7, #0x10
 80078b4: 3308         	adds	r3, #0x8
 80078b6: 4619         	mov	r1, r3
 80078b8: 4610         	mov	r0, r2
 80078ba: f7ff fcd9    	bl	0x8007270 <dma_stm32_get_direction> @ imm = #-0x64e
 80078be: f8c7 00b0    	str.w	r0, [r7, #0xb0]
; 	if (ret < 0) {
 80078c2: f8d7 30b0    	ldr.w	r3, [r7, #0xb0]
 80078c6: 2b00         	cmp	r3, #0x0
 80078c8: da02         	bge	0x80078d0 <dma_stm32_configure+0x4c8> @ imm = #0x4
; 		return ret;
 80078ca: f8d7 30b0    	ldr.w	r3, [r7, #0xb0]
 80078ce: e201         	b	0x8007cd4 <dma_stm32_configure+0x8cc> @ imm = #0x402
; 	switch (config->channel_direction) {
 80078d0: 687b         	ldr	r3, [r7, #0x4]
 80078d2: 785b         	ldrb	r3, [r3, #0x1]
 80078d4: f3c3 0302    	ubfx	r3, r3, #0x0, #0x3
 80078d8: b2db         	uxtb	r3, r3
 80078da: 2b02         	cmp	r3, #0x2
 80078dc: d006         	beq	0x80078ec <dma_stm32_configure+0x4e4> @ imm = #0xc
 80078de: 2b02         	cmp	r3, #0x2
 80078e0: dc26         	bgt	0x8007930 <dma_stm32_configure+0x528> @ imm = #0x4c
 80078e2: 2b00         	cmp	r3, #0x0
 80078e4: d002         	beq	0x80078ec <dma_stm32_configure+0x4e4> @ imm = #0x4
 80078e6: 2b01         	cmp	r3, #0x1
 80078e8: d011         	beq	0x800790e <dma_stm32_configure+0x506> @ imm = #0x22
 80078ea: e021         	b	0x8007930 <dma_stm32_configure+0x528> @ imm = #0x42
; 		memory_addr_adj = config->head_block->dest_addr_adj;
 80078ec: 687b         	ldr	r3, [r7, #0x4]
 80078ee: 691b         	ldr	r3, [r3, #0x10]
 80078f0: 7f1b         	ldrb	r3, [r3, #0x1c]
 80078f2: f3c3 1301    	ubfx	r3, r3, #0x4, #0x2
 80078f6: b2db         	uxtb	r3, r3
 80078f8: f8a7 30c6    	strh.w	r3, [r7, #0xc6]
; 		periph_addr_adj = config->head_block->source_addr_adj;
 80078fc: 687b         	ldr	r3, [r7, #0x4]
 80078fe: 691b         	ldr	r3, [r3, #0x10]
 8007900: 7f1b         	ldrb	r3, [r3, #0x1c]
 8007902: f3c3 0381    	ubfx	r3, r3, #0x2, #0x2
 8007906: b2db         	uxtb	r3, r3
 8007908: f8a7 30c4    	strh.w	r3, [r7, #0xc4]
; 		break;
 800790c: e036         	b	0x800797c <dma_stm32_configure+0x574> @ imm = #0x6c
; 		memory_addr_adj = config->head_block->source_addr_adj;
 800790e: 687b         	ldr	r3, [r7, #0x4]
 8007910: 691b         	ldr	r3, [r3, #0x10]
 8007912: 7f1b         	ldrb	r3, [r3, #0x1c]
 8007914: f3c3 0381    	ubfx	r3, r3, #0x2, #0x2
 8007918: b2db         	uxtb	r3, r3
 800791a: f8a7 30c6    	strh.w	r3, [r7, #0xc6]
; 		periph_addr_adj = config->head_block->dest_addr_adj;
 800791e: 687b         	ldr	r3, [r7, #0x4]
 8007920: 691b         	ldr	r3, [r3, #0x10]
 8007922: 7f1b         	ldrb	r3, [r3, #0x1c]
 8007924: f3c3 1301    	ubfx	r3, r3, #0x4, #0x2
 8007928: b2db         	uxtb	r3, r3
 800792a: f8a7 30c4    	strh.w	r3, [r7, #0xc4]
; 		break;
 800792e: e025         	b	0x800797c <dma_stm32_configure+0x574> @ imm = #0x4a
; 		LOG_ERR("Channel direction error (%d).",
 8007930: 2303         	movs	r3, #0x3
 8007932: 2b00         	cmp	r3, #0x0
 8007934: d01f         	beq	0x8007976 <dma_stm32_configure+0x56e> @ imm = #0x3e
 8007936: 2301         	movs	r3, #0x1
 8007938: f887 308b    	strb.w	r3, [r7, #0x8b]
 800793c: f897 308b    	ldrb.w	r3, [r7, #0x8b]
 8007940: f083 0301    	eor	r3, r3, #0x1
 8007944: b2db         	uxtb	r3, r3
 8007946: 2b00         	cmp	r3, #0x0
 8007948: d115         	bne	0x8007976 <dma_stm32_configure+0x56e> @ imm = #0x2a
 800794a: 4b16         	ldr	r3, [pc, #0x58]         @ 0x80079a4 <dma_stm32_configure+0x59c>
 800794c: 6819         	ldr	r1, [r3]
 800794e: 687b         	ldr	r3, [r7, #0x4]
 8007950: 785b         	ldrb	r3, [r3, #0x1]
 8007952: f3c3 0302    	ubfx	r3, r3, #0x0, #0x3
 8007956: b2db         	uxtb	r3, r3
 8007958: 9303         	str	r3, [sp, #0xc]
 800795a: 4b16         	ldr	r3, [pc, #0x58]         @ 0x80079b4 <dma_stm32_configure+0x5ac>
 800795c: 9302         	str	r3, [sp, #0x8]
 800795e: 2300         	movs	r3, #0x0
 8007960: 9301         	str	r3, [sp, #0x4]
 8007962: 2300         	movs	r3, #0x0
 8007964: 9300         	str	r3, [sp]
 8007966: 2300         	movs	r3, #0x0
 8007968: 2201         	movs	r2, #0x1
 800796a: 2000         	movs	r0, #0x0
 800796c: f00e fc99    	bl	0x80162a2 <z_log_msg_runtime_create> @ imm = #0xe932
 8007970: 2300         	movs	r3, #0x0
 8007972: f8c7 3084    	str.w	r3, [r7, #0x84]
; 		return -EINVAL;
 8007976: f06f 0315    	mvn	r3, #0x15
 800797a: e1ab         	b	0x8007cd4 <dma_stm32_configure+0x8cc> @ imm = #0x356
; 	ret = dma_stm32_get_memory_increment(memory_addr_adj,
 800797c: f8b7 30c6    	ldrh.w	r3, [r7, #0xc6]
 8007980: b2da         	uxtb	r2, r3
 8007982: f107 0310    	add.w	r3, r7, #0x10
 8007986: 3314         	adds	r3, #0x14
 8007988: 4619         	mov	r1, r3
 800798a: 4610         	mov	r0, r2
 800798c: f7ff fcb4    	bl	0x80072f8 <dma_stm32_get_memory_increment> @ imm = #-0x698
 8007990: f8c7 00b0    	str.w	r0, [r7, #0xb0]
; 	if (ret < 0) {
 8007994: f8d7 30b0    	ldr.w	r3, [r7, #0xb0]
 8007998: 2b00         	cmp	r3, #0x0
 800799a: da0d         	bge	0x80079b8 <dma_stm32_configure+0x5b0> @ imm = #0x1a
; 		return ret;
 800799c: f8d7 30b0    	ldr.w	r3, [r7, #0xb0]
 80079a0: e198         	b	0x8007cd4 <dma_stm32_configure+0x8cc> @ imm = #0x330
 80079a2: bf00         	nop

080079a4 <$d>:
 80079a4: 00 05 00 20  	.word	0x20000500
 80079a8: d0 eb 01 08  	.word	0x0801ebd0
 80079ac: 08 ec 01 08  	.word	0x0801ec08
 80079b0: 28 ec 01 08  	.word	0x0801ec28
 80079b4: 48 ec 01 08  	.word	0x0801ec48

080079b8 <$t>:
; 	LOG_DBG("Channel (%d) memory inc (%x).",
 80079b8: 2303         	movs	r3, #0x3
 80079ba: 2b03         	cmp	r3, #0x3
 80079bc: d91f         	bls	0x80079fe <dma_stm32_configure+0x5f6> @ imm = #0x3e
 80079be: 2301         	movs	r3, #0x1
 80079c0: f887 30af    	strb.w	r3, [r7, #0xaf]
 80079c4: f897 30af    	ldrb.w	r3, [r7, #0xaf]
 80079c8: f083 0301    	eor	r3, r3, #0x1
 80079cc: b2db         	uxtb	r3, r3
 80079ce: 2b00         	cmp	r3, #0x0
 80079d0: d115         	bne	0x80079fe <dma_stm32_configure+0x5f6> @ imm = #0x2a
 80079d2: 4bae         	ldr	r3, [pc, #0x2b8]        @ 0x8007c8c <dma_stm32_configure+0x884>
 80079d4: 6819         	ldr	r1, [r3]
 80079d6: 6a7b         	ldr	r3, [r7, #0x24]
 80079d8: 9305         	str	r3, [sp, #0x14]
 80079da: 68bb         	ldr	r3, [r7, #0x8]
 80079dc: 9304         	str	r3, [sp, #0x10]
 80079de: 4bac         	ldr	r3, [pc, #0x2b0]        @ 0x8007c90 <dma_stm32_configure+0x888>
 80079e0: 9303         	str	r3, [sp, #0xc]
 80079e2: 4bac         	ldr	r3, [pc, #0x2b0]        @ 0x8007c94 <dma_stm32_configure+0x88c>
 80079e4: 9302         	str	r3, [sp, #0x8]
 80079e6: 2308         	movs	r3, #0x8
 80079e8: 9301         	str	r3, [sp, #0x4]
 80079ea: 2300         	movs	r3, #0x0
 80079ec: 9300         	str	r3, [sp]
 80079ee: 2300         	movs	r3, #0x0
 80079f0: 2204         	movs	r2, #0x4
 80079f2: 2000         	movs	r0, #0x0
 80079f4: f00e fc55    	bl	0x80162a2 <z_log_msg_runtime_create> @ imm = #0xe8aa
 80079f8: 2300         	movs	r3, #0x0
 80079fa: f8c7 30a8    	str.w	r3, [r7, #0xa8]
; 	ret = dma_stm32_get_periph_increment(periph_addr_adj,
 80079fe: f8b7 30c4    	ldrh.w	r3, [r7, #0xc4]
 8007a02: b2da         	uxtb	r2, r3
 8007a04: f107 0310    	add.w	r3, r7, #0x10
 8007a08: 3310         	adds	r3, #0x10
 8007a0a: 4619         	mov	r1, r3
 8007a0c: 4610         	mov	r0, r2
 8007a0e: f7ff fcb7    	bl	0x8007380 <dma_stm32_get_periph_increment> @ imm = #-0x692
 8007a12: f8c7 00b0    	str.w	r0, [r7, #0xb0]
; 	if (ret < 0) {
 8007a16: f8d7 30b0    	ldr.w	r3, [r7, #0xb0]
 8007a1a: 2b00         	cmp	r3, #0x0
 8007a1c: da02         	bge	0x8007a24 <dma_stm32_configure+0x61c> @ imm = #0x4
; 		return ret;
 8007a1e: f8d7 30b0    	ldr.w	r3, [r7, #0xb0]
 8007a22: e157         	b	0x8007cd4 <dma_stm32_configure+0x8cc> @ imm = #0x2ae
; 	LOG_DBG("Channel (%d) peripheral inc (%x).",
 8007a24: 2303         	movs	r3, #0x3
 8007a26: 2b03         	cmp	r3, #0x3
 8007a28: d91f         	bls	0x8007a6a <dma_stm32_configure+0x662> @ imm = #0x3e
 8007a2a: 2301         	movs	r3, #0x1
 8007a2c: f887 30a7    	strb.w	r3, [r7, #0xa7]
 8007a30: f897 30a7    	ldrb.w	r3, [r7, #0xa7]
 8007a34: f083 0301    	eor	r3, r3, #0x1
 8007a38: b2db         	uxtb	r3, r3
 8007a3a: 2b00         	cmp	r3, #0x0
 8007a3c: d115         	bne	0x8007a6a <dma_stm32_configure+0x662> @ imm = #0x2a
 8007a3e: 4b93         	ldr	r3, [pc, #0x24c]        @ 0x8007c8c <dma_stm32_configure+0x884>
 8007a40: 6819         	ldr	r1, [r3]
 8007a42: 6a3b         	ldr	r3, [r7, #0x20]
 8007a44: 9305         	str	r3, [sp, #0x14]
 8007a46: 68bb         	ldr	r3, [r7, #0x8]
 8007a48: 9304         	str	r3, [sp, #0x10]
 8007a4a: 4b91         	ldr	r3, [pc, #0x244]        @ 0x8007c90 <dma_stm32_configure+0x888>
 8007a4c: 9303         	str	r3, [sp, #0xc]
 8007a4e: 4b92         	ldr	r3, [pc, #0x248]        @ 0x8007c98 <dma_stm32_configure+0x890>
 8007a50: 9302         	str	r3, [sp, #0x8]
 8007a52: 2308         	movs	r3, #0x8
 8007a54: 9301         	str	r3, [sp, #0x4]
 8007a56: 2300         	movs	r3, #0x0
 8007a58: 9300         	str	r3, [sp]
 8007a5a: 2300         	movs	r3, #0x0
 8007a5c: 2204         	movs	r2, #0x4
 8007a5e: 2000         	movs	r0, #0x0
 8007a60: f00e fc1f    	bl	0x80162a2 <z_log_msg_runtime_create> @ imm = #0xe83e
 8007a64: 2300         	movs	r3, #0x0
 8007a66: f8c7 30a0    	str.w	r3, [r7, #0xa0]
; 	if (stream->cyclic) {
 8007a6a: f8d7 30d0    	ldr.w	r3, [r7, #0xd0]
 8007a6e: 7e1b         	ldrb	r3, [r3, #0x18]
 8007a70: 2b00         	cmp	r3, #0x0
 8007a72: d003         	beq	0x8007a7c <dma_stm32_configure+0x674> @ imm = #0x6
; 		DMA_InitStruct.Mode = LL_DMA_MODE_CIRCULAR;
 8007a74: f44f 7380    	mov.w	r3, #0x100
 8007a78: 61fb         	str	r3, [r7, #0x1c]
 8007a7a: e001         	b	0x8007a80 <dma_stm32_configure+0x678> @ imm = #0x2
; 		DMA_InitStruct.Mode = LL_DMA_MODE_NORMAL;
 8007a7c: 2300         	movs	r3, #0x0
 8007a7e: 61fb         	str	r3, [r7, #0x1c]
; 	stream->source_periph = (stream->direction == PERIPHERAL_TO_MEMORY);
 8007a80: f8d7 30d0    	ldr.w	r3, [r7, #0xd0]
 8007a84: 681b         	ldr	r3, [r3]
 8007a86: 2b02         	cmp	r3, #0x2
 8007a88: bf0c         	ite	eq
 8007a8a: 2301         	moveq	r3, #0x1
 8007a8c: 2300         	movne	r3, #0x0
 8007a8e: b2da         	uxtb	r2, r3
 8007a90: f8d7 30d0    	ldr.w	r3, [r7, #0xd0]
 8007a94: 711a         	strb	r2, [r3, #0x4]
; 	int index = find_lsb_set(config->source_data_size) - 1;
 8007a96: 687b         	ldr	r3, [r7, #0x4]
 8007a98: 889b         	ldrh	r3, [r3, #0x4]
 8007a9a: 64fb         	str	r3, [r7, #0x4c]
; 	return __builtin_ffs(op);
 8007a9c: 6cfb         	ldr	r3, [r7, #0x4c]
 8007a9e: fa93 f2a3    	rbit	r2, r3
 8007aa2: fab2 f282    	clz	r2, r2
 8007aa6: 2b00         	cmp	r3, #0x0
 8007aa8: d101         	bne	0x8007aae <dma_stm32_configure+0x6a6> @ imm = #0x2
 8007aaa: f04f 32ff    	mov.w	r2, #0xffffffff
 8007aae: 1c53         	adds	r3, r2, #0x1
; 	int index = find_lsb_set(config->source_data_size) - 1;
 8007ab0: 3b01         	subs	r3, #0x1
 8007ab2: f8c7 309c    	str.w	r3, [r7, #0x9c]
; 	DMA_InitStruct.PeriphOrM2MSrcDataSize = table_p_size[index];
 8007ab6: 4a79         	ldr	r2, [pc, #0x1e4]        @ 0x8007c9c <dma_stm32_configure+0x894>
 8007ab8: f8d7 309c    	ldr.w	r3, [r7, #0x9c]
 8007abc: f852 3023    	ldr.w	r3, [r2, r3, lsl #2]
 8007ac0: 62bb         	str	r3, [r7, #0x28]
; 	index = find_lsb_set(config->dest_data_size) - 1;
 8007ac2: 687b         	ldr	r3, [r7, #0x4]
 8007ac4: 88db         	ldrh	r3, [r3, #0x6]
 8007ac6: 653b         	str	r3, [r7, #0x50]
; 	return __builtin_ffs(op);
 8007ac8: 6d3b         	ldr	r3, [r7, #0x50]
 8007aca: fa93 f2a3    	rbit	r2, r3
 8007ace: fab2 f282    	clz	r2, r2
 8007ad2: 2b00         	cmp	r3, #0x0
 8007ad4: d101         	bne	0x8007ada <dma_stm32_configure+0x6d2> @ imm = #0x2
 8007ad6: f04f 32ff    	mov.w	r2, #0xffffffff
 8007ada: 1c53         	adds	r3, r2, #0x1
; 	index = find_lsb_set(config->dest_data_size) - 1;
 8007adc: 3b01         	subs	r3, #0x1
 8007ade: f8c7 309c    	str.w	r3, [r7, #0x9c]
; 	DMA_InitStruct.MemoryOrM2MDstDataSize = table_m_size[index];
 8007ae2: 4a6f         	ldr	r2, [pc, #0x1bc]        @ 0x8007ca0 <dma_stm32_configure+0x898>
 8007ae4: f8d7 309c    	ldr.w	r3, [r7, #0x9c]
 8007ae8: f852 3023    	ldr.w	r3, [r2, r3, lsl #2]
 8007aec: 62fb         	str	r3, [r7, #0x2c]
; 	DMA_InitStruct.MemBurst = stm32_dma_get_mburst(config,
 8007aee: f8d7 30d0    	ldr.w	r3, [r7, #0xd0]
 8007af2: 791b         	ldrb	r3, [r3, #0x4]
 8007af4: 4619         	mov	r1, r3
 8007af6: 6878         	ldr	r0, [r7, #0x4]
 8007af8: f000 fbc4    	bl	0x8008284 <stm32_dma_get_mburst> @ imm = #0x788
 8007afc: 4603         	mov	r3, r0
 8007afe: 647b         	str	r3, [r7, #0x44]
; 	DMA_InitStruct.PeriphBurst = stm32_dma_get_pburst(config,
 8007b00: f8d7 30d0    	ldr.w	r3, [r7, #0xd0]
 8007b04: 791b         	ldrb	r3, [r3, #0x4]
 8007b06: 4619         	mov	r1, r3
 8007b08: 6878         	ldr	r0, [r7, #0x4]
 8007b0a: f000 fc21    	bl	0x8008350 <stm32_dma_get_pburst> @ imm = #0x842
 8007b0e: 4603         	mov	r3, r0
 8007b10: 64bb         	str	r3, [r7, #0x48]
; 	if (config->channel_direction != MEMORY_TO_MEMORY) {
 8007b12: 687b         	ldr	r3, [r7, #0x4]
 8007b14: 785b         	ldrb	r3, [r3, #0x1]
 8007b16: f003 0307    	and	r3, r3, #0x7
 8007b1a: b2db         	uxtb	r3, r3
 8007b1c: 2b00         	cmp	r3, #0x0
 8007b1e: d023         	beq	0x8007b68 <dma_stm32_configure+0x760> @ imm = #0x46
; 		if (config->dma_slot >= 8) {
 8007b20: 687b         	ldr	r3, [r7, #0x4]
 8007b22: 781b         	ldrb	r3, [r3]
 8007b24: 2b07         	cmp	r3, #0x7
 8007b26: d943         	bls	0x8007bb0 <dma_stm32_configure+0x7a8> @ imm = #0x86
; 			LOG_ERR("dma slot error.");
 8007b28: 2303         	movs	r3, #0x3
 8007b2a: 2b00         	cmp	r3, #0x0
 8007b2c: d019         	beq	0x8007b62 <dma_stm32_configure+0x75a> @ imm = #0x32
 8007b2e: 2301         	movs	r3, #0x1
 8007b30: f887 3093    	strb.w	r3, [r7, #0x93]
 8007b34: f897 3093    	ldrb.w	r3, [r7, #0x93]
 8007b38: f083 0301    	eor	r3, r3, #0x1
 8007b3c: b2db         	uxtb	r3, r3
 8007b3e: 2b00         	cmp	r3, #0x0
 8007b40: d10f         	bne	0x8007b62 <dma_stm32_configure+0x75a> @ imm = #0x1e
 8007b42: 4b52         	ldr	r3, [pc, #0x148]        @ 0x8007c8c <dma_stm32_configure+0x884>
 8007b44: 6819         	ldr	r1, [r3]
 8007b46: 4b57         	ldr	r3, [pc, #0x15c]        @ 0x8007ca4 <dma_stm32_configure+0x89c>
 8007b48: 9302         	str	r3, [sp, #0x8]
 8007b4a: 2300         	movs	r3, #0x0
 8007b4c: 9301         	str	r3, [sp, #0x4]
 8007b4e: 2300         	movs	r3, #0x0
 8007b50: 9300         	str	r3, [sp]
 8007b52: 2300         	movs	r3, #0x0
 8007b54: 2201         	movs	r2, #0x1
 8007b56: 2000         	movs	r0, #0x0
 8007b58: f00e fba3    	bl	0x80162a2 <z_log_msg_runtime_create> @ imm = #0xe746
 8007b5c: 2300         	movs	r3, #0x0
 8007b5e: f8c7 308c    	str.w	r3, [r7, #0x8c]
; 			return -EINVAL;
 8007b62: f06f 0315    	mvn	r3, #0x15
 8007b66: e0b5         	b	0x8007cd4 <dma_stm32_configure+0x8cc> @ imm = #0x16a
; 		if (config->dma_slot >= 8) {
 8007b68: 687b         	ldr	r3, [r7, #0x4]
 8007b6a: 781b         	ldrb	r3, [r3]
 8007b6c: 2b07         	cmp	r3, #0x7
 8007b6e: d91f         	bls	0x8007bb0 <dma_stm32_configure+0x7a8> @ imm = #0x3e
; 			LOG_ERR("dma slot is too big, using 0 as default.");
 8007b70: 2303         	movs	r3, #0x3
 8007b72: 2b00         	cmp	r3, #0x0
 8007b74: d019         	beq	0x8007baa <dma_stm32_configure+0x7a2> @ imm = #0x32
 8007b76: 2301         	movs	r3, #0x1
 8007b78: f887 309b    	strb.w	r3, [r7, #0x9b]
 8007b7c: f897 309b    	ldrb.w	r3, [r7, #0x9b]
 8007b80: f083 0301    	eor	r3, r3, #0x1
 8007b84: b2db         	uxtb	r3, r3
 8007b86: 2b00         	cmp	r3, #0x0
 8007b88: d10f         	bne	0x8007baa <dma_stm32_configure+0x7a2> @ imm = #0x1e
 8007b8a: 4b40         	ldr	r3, [pc, #0x100]        @ 0x8007c8c <dma_stm32_configure+0x884>
 8007b8c: 6819         	ldr	r1, [r3]
 8007b8e: 4b46         	ldr	r3, [pc, #0x118]        @ 0x8007ca8 <dma_stm32_configure+0x8a0>
 8007b90: 9302         	str	r3, [sp, #0x8]
 8007b92: 2300         	movs	r3, #0x0
 8007b94: 9301         	str	r3, [sp, #0x4]
 8007b96: 2300         	movs	r3, #0x0
 8007b98: 9300         	str	r3, [sp]
 8007b9a: 2300         	movs	r3, #0x0
 8007b9c: 2201         	movs	r2, #0x1
 8007b9e: 2000         	movs	r0, #0x0
 8007ba0: f00e fb7f    	bl	0x80162a2 <z_log_msg_runtime_create> @ imm = #0xe6fe
 8007ba4: 2300         	movs	r3, #0x0
 8007ba6: f8c7 3094    	str.w	r3, [r7, #0x94]
; 			config->dma_slot = 0;
 8007baa: 687b         	ldr	r3, [r7, #0x4]
 8007bac: 2200         	movs	r2, #0x0
 8007bae: 701a         	strb	r2, [r3]
; 	DMA_InitStruct.Channel = dma_stm32_slot_to_channel(config->dma_slot);
 8007bb0: 687b         	ldr	r3, [r7, #0x4]
 8007bb2: 781b         	ldrb	r3, [r3]
 8007bb4: 4618         	mov	r0, r3
 8007bb6: f000 f9f1    	bl	0x8007f9c <dma_stm32_slot_to_channel> @ imm = #0x3e2
 8007bba: 4603         	mov	r3, r0
 8007bbc: 637b         	str	r3, [r7, #0x34]
; 					config->head_block->fifo_mode_control);
 8007bbe: 687b         	ldr	r3, [r7, #0x4]
 8007bc0: 691b         	ldr	r3, [r3, #0x10]
 8007bc2: 7f5b         	ldrb	r3, [r3, #0x1d]
 8007bc4: f3c3 0303    	ubfx	r3, r3, #0x0, #0x4
 8007bc8: b2db         	uxtb	r3, r3
; 	DMA_InitStruct.FIFOThreshold = stm32_dma_get_fifo_threshold(
 8007bca: 4618         	mov	r0, r3
 8007bcc: f000 fc26    	bl	0x800841c <stm32_dma_get_fifo_threshold> @ imm = #0x84c
 8007bd0: 4603         	mov	r3, r0
 8007bd2: 643b         	str	r3, [r7, #0x40]
; 	if (stm32_dma_check_fifo_mburst(&DMA_InitStruct)) {
 8007bd4: f107 0310    	add.w	r3, r7, #0x10
 8007bd8: 4618         	mov	r0, r3
 8007bda: f00f fc09    	bl	0x80173f0 <stm32_dma_check_fifo_mburst> @ imm = #0xf812
 8007bde: 4603         	mov	r3, r0
 8007be0: 2b00         	cmp	r3, #0x0
 8007be2: d002         	beq	0x8007bea <dma_stm32_configure+0x7e2> @ imm = #0x4
; 		DMA_InitStruct.FIFOMode = LL_DMA_FIFOMODE_ENABLE;
 8007be4: 2304         	movs	r3, #0x4
 8007be6: 63fb         	str	r3, [r7, #0x3c]
 8007be8: e001         	b	0x8007bee <dma_stm32_configure+0x7e6> @ imm = #0x2
; 		DMA_InitStruct.FIFOMode = LL_DMA_FIFOMODE_DISABLE;
 8007bea: 2300         	movs	r3, #0x0
 8007bec: 63fb         	str	r3, [r7, #0x3c]
; 	if (stream->source_periph) {
 8007bee: f8d7 30d0    	ldr.w	r3, [r7, #0xd0]
 8007bf2: 791b         	ldrb	r3, [r3, #0x4]
 8007bf4: 2b00         	cmp	r3, #0x0
 8007bf6: d008         	beq	0x8007c0a <dma_stm32_configure+0x802> @ imm = #0x10
; 		DMA_InitStruct.NbData = config->head_block->block_size /
 8007bf8: 687b         	ldr	r3, [r7, #0x4]
 8007bfa: 691b         	ldr	r3, [r3, #0x10]
 8007bfc: 695b         	ldr	r3, [r3, #0x14]
; 					config->source_data_size;
 8007bfe: 687a         	ldr	r2, [r7, #0x4]
 8007c00: 8892         	ldrh	r2, [r2, #0x4]
; 		DMA_InitStruct.NbData = config->head_block->block_size /
 8007c02: fbb3 f3f2    	udiv	r3, r3, r2
 8007c06: 633b         	str	r3, [r7, #0x30]
 8007c08: e007         	b	0x8007c1a <dma_stm32_configure+0x812> @ imm = #0xe
; 		DMA_InitStruct.NbData = config->head_block->block_size /
 8007c0a: 687b         	ldr	r3, [r7, #0x4]
 8007c0c: 691b         	ldr	r3, [r3, #0x10]
 8007c0e: 695b         	ldr	r3, [r3, #0x14]
; 					config->dest_data_size;
 8007c10: 687a         	ldr	r2, [r7, #0x4]
 8007c12: 88d2         	ldrh	r2, [r2, #0x6]
; 		DMA_InitStruct.NbData = config->head_block->block_size /
 8007c14: fbb3 f3f2    	udiv	r3, r3, r2
 8007c18: 633b         	str	r3, [r7, #0x30]
; 	LL_DMA_Init(dma, dma_stm32_id_to_stream(id), &DMA_InitStruct);
 8007c1a: 68b8         	ldr	r0, [r7, #0x8]
 8007c1c: f000 f9ae    	bl	0x8007f7c <dma_stm32_id_to_stream> @ imm = #0x35c
 8007c20: 4601         	mov	r1, r0
 8007c22: f107 0310    	add.w	r3, r7, #0x10
 8007c26: 461a         	mov	r2, r3
 8007c28: f8d7 00cc    	ldr.w	r0, [r7, #0xcc]
 8007c2c: f013 fee1    	bl	0x801b9f2 <LL_DMA_Init> @ imm = #0x13dc2
; 	LL_DMA_EnableIT_TC(dma, dma_stm32_id_to_stream(id));
 8007c30: 68b8         	ldr	r0, [r7, #0x8]
 8007c32: f000 f9a3    	bl	0x8007f7c <dma_stm32_id_to_stream> @ imm = #0x346
 8007c36: 4603         	mov	r3, r0
 8007c38: 4619         	mov	r1, r3
 8007c3a: f8d7 00cc    	ldr.w	r0, [r7, #0xcc]
 8007c3e: f7ff f983    	bl	0x8006f48 <LL_DMA_EnableIT_TC> @ imm = #-0xcfa
; 	if (stream->cyclic) {
 8007c42: f8d7 30d0    	ldr.w	r3, [r7, #0xd0]
 8007c46: 7e1b         	ldrb	r3, [r3, #0x18]
 8007c48: 2b00         	cmp	r3, #0x0
 8007c4a: d008         	beq	0x8007c5e <dma_stm32_configure+0x856> @ imm = #0x10
; 		LL_DMA_EnableIT_HT(dma, dma_stm32_id_to_stream(id));
 8007c4c: 68b8         	ldr	r0, [r7, #0x8]
 8007c4e: f000 f995    	bl	0x8007f7c <dma_stm32_id_to_stream> @ imm = #0x32a
 8007c52: 4603         	mov	r3, r0
 8007c54: 4619         	mov	r1, r3
 8007c56: f8d7 00cc    	ldr.w	r0, [r7, #0xcc]
 8007c5a: f7ff f957    	bl	0x8006f0c <LL_DMA_EnableIT_HT> @ imm = #-0xd52
; 	if (DMA_InitStruct.FIFOMode == LL_DMA_FIFOMODE_ENABLE) {
 8007c5e: 6bfb         	ldr	r3, [r7, #0x3c]
 8007c60: 2b04         	cmp	r3, #0x4
 8007c62: d123         	bne	0x8007cac <dma_stm32_configure+0x8a4> @ imm = #0x46
; 		LL_DMA_EnableFifoMode(dma, dma_stm32_id_to_stream(id));
 8007c64: 68b8         	ldr	r0, [r7, #0x8]
 8007c66: f000 f989    	bl	0x8007f7c <dma_stm32_id_to_stream> @ imm = #0x312
 8007c6a: 4603         	mov	r3, r0
 8007c6c: 4619         	mov	r1, r3
 8007c6e: f8d7 00cc    	ldr.w	r0, [r7, #0xcc]
 8007c72: f7ff f8fd    	bl	0x8006e70 <LL_DMA_EnableFifoMode> @ imm = #-0xe06
; 		LL_DMA_EnableIT_FE(dma, dma_stm32_id_to_stream(id));
 8007c76: 68b8         	ldr	r0, [r7, #0x8]
 8007c78: f000 f980    	bl	0x8007f7c <dma_stm32_id_to_stream> @ imm = #0x300
 8007c7c: 4603         	mov	r3, r0
 8007c7e: 4619         	mov	r1, r3
 8007c80: f8d7 00cc    	ldr.w	r0, [r7, #0xcc]
 8007c84: f7ff f97e    	bl	0x8006f84 <LL_DMA_EnableIT_FE> @ imm = #-0xd04
 8007c88: e022         	b	0x8007cd0 <dma_stm32_configure+0x8c8> @ imm = #0x44
 8007c8a: bf00         	nop

08007c8c <$d>:
 8007c8c: 00 05 00 20  	.word	0x20000500
 8007c90: ec ff 01 08  	.word	0x0801ffec
 8007c94: 68 ec 01 08  	.word	0x0801ec68
 8007c98: 8c ec 01 08  	.word	0x0801ec8c
 8007c9c: 80 ff 01 08  	.word	0x0801ff80
 8007ca0: 74 ff 01 08  	.word	0x0801ff74
 8007ca4: b4 ec 01 08  	.word	0x0801ecb4
 8007ca8: c4 ec 01 08  	.word	0x0801ecc4

08007cac <$t>:
; 		LL_DMA_DisableFifoMode(dma, dma_stm32_id_to_stream(id));
 8007cac: 68b8         	ldr	r0, [r7, #0x8]
 8007cae: f000 f965    	bl	0x8007f7c <dma_stm32_id_to_stream> @ imm = #0x2ca
 8007cb2: 4603         	mov	r3, r0
 8007cb4: 4619         	mov	r1, r3
 8007cb6: f8d7 00cc    	ldr.w	r0, [r7, #0xcc]
 8007cba: f7ff f8bb    	bl	0x8006e34 <LL_DMA_DisableFifoMode> @ imm = #-0xe8a
; 		LL_DMA_DisableIT_FE(dma, dma_stm32_id_to_stream(id));
 8007cbe: 68b8         	ldr	r0, [r7, #0x8]
 8007cc0: f000 f95c    	bl	0x8007f7c <dma_stm32_id_to_stream> @ imm = #0x2b8
 8007cc4: 4603         	mov	r3, r0
 8007cc6: 4619         	mov	r1, r3
 8007cc8: f8d7 00cc    	ldr.w	r0, [r7, #0xcc]
 8007ccc: f7ff f996    	bl	0x8006ffc <LL_DMA_DisableIT_FE> @ imm = #-0xcd4
; 	return ret;
 8007cd0: f8d7 30b0    	ldr.w	r3, [r7, #0xb0]
; }
 8007cd4: 4618         	mov	r0, r3
 8007cd6: 37e0         	adds	r7, #0xe0
 8007cd8: 46bd         	mov	sp, r7
 8007cda: bd80         	pop	{r7, pc}

08007cdc <dma_stm32_init>:
; {
 8007cdc: b580         	push	{r7, lr}
 8007cde: b08e         	sub	sp, #0x38
 8007ce0: af04         	add	r7, sp, #0x10
 8007ce2: 6078         	str	r0, [r7, #0x4]
; 	const struct dma_stm32_config *config = dev->config;
 8007ce4: 687b         	ldr	r3, [r7, #0x4]
 8007ce6: 685b         	ldr	r3, [r3, #0x4]
 8007ce8: 623b         	str	r3, [r7, #0x20]
; 	const struct device *const clk = DEVICE_DT_GET(STM32_CLOCK_CONTROL_NODE);
 8007cea: 4b3b         	ldr	r3, [pc, #0xec]         @ 0x8007dd8 <dma_stm32_init+0xfc>
 8007cec: 61fb         	str	r3, [r7, #0x1c]
; 	if (!device_is_ready(clk)) {
 8007cee: 69f8         	ldr	r0, [r7, #0x1c]
 8007cf0: f00e faab    	bl	0x801624a <device_is_ready> @ imm = #0xe556
 8007cf4: 4603         	mov	r3, r0
 8007cf6: f083 0301    	eor	r3, r3, #0x1
 8007cfa: b2db         	uxtb	r3, r3
 8007cfc: 2b00         	cmp	r3, #0x0
 8007cfe: d01c         	beq	0x8007d3a <dma_stm32_init+0x5e> @ imm = #0x38
; 		LOG_ERR("clock control device not ready");
 8007d00: 2303         	movs	r3, #0x3
 8007d02: 2b00         	cmp	r3, #0x0
 8007d04: d016         	beq	0x8007d34 <dma_stm32_init+0x58> @ imm = #0x2c
 8007d06: 2301         	movs	r3, #0x1
 8007d08: 74fb         	strb	r3, [r7, #0x13]
 8007d0a: 7cfb         	ldrb	r3, [r7, #0x13]
 8007d0c: f083 0301    	eor	r3, r3, #0x1
 8007d10: b2db         	uxtb	r3, r3
 8007d12: 2b00         	cmp	r3, #0x0
 8007d14: d10e         	bne	0x8007d34 <dma_stm32_init+0x58> @ imm = #0x1c
 8007d16: 4b31         	ldr	r3, [pc, #0xc4]         @ 0x8007ddc <dma_stm32_init+0x100>
 8007d18: 6819         	ldr	r1, [r3]
 8007d1a: 4b31         	ldr	r3, [pc, #0xc4]         @ 0x8007de0 <dma_stm32_init+0x104>
 8007d1c: 9302         	str	r3, [sp, #0x8]
 8007d1e: 2300         	movs	r3, #0x0
 8007d20: 9301         	str	r3, [sp, #0x4]
 8007d22: 2300         	movs	r3, #0x0
 8007d24: 9300         	str	r3, [sp]
 8007d26: 2300         	movs	r3, #0x0
 8007d28: 2201         	movs	r2, #0x1
 8007d2a: 2000         	movs	r0, #0x0
 8007d2c: f00e fab9    	bl	0x80162a2 <z_log_msg_runtime_create> @ imm = #0xe572
 8007d30: 2300         	movs	r3, #0x0
 8007d32: 60fb         	str	r3, [r7, #0xc]
; 		return -ENODEV;
 8007d34: f06f 0312    	mvn	r3, #0x12
 8007d38: e04a         	b	0x8007dd0 <dma_stm32_init+0xf4> @ imm = #0x94
; 		(clock_control_subsys_t) &config->pclken) != 0) {
 8007d3a: 6a3b         	ldr	r3, [r7, #0x20]
; 	if (clock_control_on(clk,
 8007d3c: 4619         	mov	r1, r3
 8007d3e: 69f8         	ldr	r0, [r7, #0x1c]
 8007d40: f00e fa9d    	bl	0x801627e <clock_control_on> @ imm = #0xe53a
 8007d44: 4603         	mov	r3, r0
 8007d46: 2b00         	cmp	r3, #0x0
 8007d48: d01c         	beq	0x8007d84 <dma_stm32_init+0xa8> @ imm = #0x38
; 		LOG_ERR("clock op failed\n");
 8007d4a: 2303         	movs	r3, #0x3
 8007d4c: 2b00         	cmp	r3, #0x0
 8007d4e: d016         	beq	0x8007d7e <dma_stm32_init+0xa2> @ imm = #0x2c
 8007d50: 2301         	movs	r3, #0x1
 8007d52: 76fb         	strb	r3, [r7, #0x1b]
 8007d54: 7efb         	ldrb	r3, [r7, #0x1b]
 8007d56: f083 0301    	eor	r3, r3, #0x1
 8007d5a: b2db         	uxtb	r3, r3
 8007d5c: 2b00         	cmp	r3, #0x0
 8007d5e: d10e         	bne	0x8007d7e <dma_stm32_init+0xa2> @ imm = #0x1c
 8007d60: 4b1e         	ldr	r3, [pc, #0x78]         @ 0x8007ddc <dma_stm32_init+0x100>
 8007d62: 6819         	ldr	r1, [r3]
 8007d64: 4b1f         	ldr	r3, [pc, #0x7c]         @ 0x8007de4 <dma_stm32_init+0x108>
 8007d66: 9302         	str	r3, [sp, #0x8]
 8007d68: 2300         	movs	r3, #0x0
 8007d6a: 9301         	str	r3, [sp, #0x4]
 8007d6c: 2300         	movs	r3, #0x0
 8007d6e: 9300         	str	r3, [sp]
 8007d70: 2300         	movs	r3, #0x0
 8007d72: 2201         	movs	r2, #0x1
 8007d74: 2000         	movs	r0, #0x0
 8007d76: f00e fa94    	bl	0x80162a2 <z_log_msg_runtime_create> @ imm = #0xe528
 8007d7a: 2300         	movs	r3, #0x0
 8007d7c: 617b         	str	r3, [r7, #0x14]
; 		return -EIO;
 8007d7e: f06f 0304    	mvn	r3, #0x4
 8007d82: e025         	b	0x8007dd0 <dma_stm32_init+0xf4> @ imm = #0x4a
; 	config->config_irq(dev);
 8007d84: 6a3b         	ldr	r3, [r7, #0x20]
 8007d86: 689b         	ldr	r3, [r3, #0x8]
 8007d88: 6878         	ldr	r0, [r7, #0x4]
 8007d8a: 4798         	blx	r3
; 	for (uint32_t i = 0; i < config->max_streams; i++) {
 8007d8c: 2300         	movs	r3, #0x0
 8007d8e: 627b         	str	r3, [r7, #0x24]
 8007d90: e00c         	b	0x8007dac <dma_stm32_init+0xd0> @ imm = #0x18
; 		config->streams[i].busy = false;
 8007d92: 6a3b         	ldr	r3, [r7, #0x20]
 8007d94: 6999         	ldr	r1, [r3, #0x18]
 8007d96: 6a7a         	ldr	r2, [r7, #0x24]
 8007d98: 4613         	mov	r3, r2
 8007d9a: 00db         	lsls	r3, r3, #0x3
 8007d9c: 1a9b         	subs	r3, r3, r2
 8007d9e: 009b         	lsls	r3, r3, #0x2
 8007da0: 440b         	add	r3, r1
 8007da2: 2200         	movs	r2, #0x0
 8007da4: 719a         	strb	r2, [r3, #0x6]
; 	for (uint32_t i = 0; i < config->max_streams; i++) {
 8007da6: 6a7b         	ldr	r3, [r7, #0x24]
 8007da8: 3301         	adds	r3, #0x1
 8007daa: 627b         	str	r3, [r7, #0x24]
 8007dac: 6a3b         	ldr	r3, [r7, #0x20]
 8007dae: 695b         	ldr	r3, [r3, #0x14]
 8007db0: 6a7a         	ldr	r2, [r7, #0x24]
 8007db2: 429a         	cmp	r2, r3
 8007db4: d3ed         	blo	0x8007d92 <dma_stm32_init+0xb6> @ imm = #-0x26
; 	((struct dma_stm32_data *)dev->data)->dma_ctx.magic = 0;
 8007db6: 687b         	ldr	r3, [r7, #0x4]
 8007db8: 691b         	ldr	r3, [r3, #0x10]
 8007dba: 2200         	movs	r2, #0x0
 8007dbc: 601a         	str	r2, [r3]
; 	((struct dma_stm32_data *)dev->data)->dma_ctx.dma_channels = 0;
 8007dbe: 687b         	ldr	r3, [r7, #0x4]
 8007dc0: 691b         	ldr	r3, [r3, #0x10]
 8007dc2: 2200         	movs	r2, #0x0
 8007dc4: 605a         	str	r2, [r3, #0x4]
; 	((struct dma_stm32_data *)dev->data)->dma_ctx.atomic = 0;
 8007dc6: 687b         	ldr	r3, [r7, #0x4]
 8007dc8: 691b         	ldr	r3, [r3, #0x10]
 8007dca: 2200         	movs	r2, #0x0
 8007dcc: 609a         	str	r2, [r3, #0x8]
; 	return 0;
 8007dce: 2300         	movs	r3, #0x0
; }
 8007dd0: 4618         	mov	r0, r3
 8007dd2: 3728         	adds	r7, #0x28
 8007dd4: 46bd         	mov	sp, r7
 8007dd6: bd80         	pop	{r7, pc}

08007dd8 <$d>:
 8007dd8: 28 dd 01 08  	.word	0x0801dd28
 8007ddc: 00 05 00 20  	.word	0x20000500
 8007de0: f0 ec 01 08  	.word	0x0801ecf0
 8007de4: 10 ed 01 08  	.word	0x0801ed10

08007de8 <LL_DMA_EnableStream>:
; {
 8007de8: b480         	push	{r7}
 8007dea: b083         	sub	sp, #0xc
 8007dec: af00         	add	r7, sp, #0x0
 8007dee: 6078         	str	r0, [r7, #0x4]
 8007df0: 6039         	str	r1, [r7]
;   SET_BIT(((DMA_Stream_TypeDef *)((uint32_t)((uint32_t)DMAx + STREAM_OFFSET_TAB[Stream])))->CR, DMA_SxCR_EN);
 8007df2: 4a0b         	ldr	r2, [pc, #0x2c]         @ 0x8007e20 <LL_DMA_EnableStream+0x38>
 8007df4: 683b         	ldr	r3, [r7]
 8007df6: 4413         	add	r3, r2
 8007df8: 781b         	ldrb	r3, [r3]
 8007dfa: 461a         	mov	r2, r3
 8007dfc: 687b         	ldr	r3, [r7, #0x4]
 8007dfe: 4413         	add	r3, r2
 8007e00: 681b         	ldr	r3, [r3]
 8007e02: 4907         	ldr	r1, [pc, #0x1c]         @ 0x8007e20 <LL_DMA_EnableStream+0x38>
 8007e04: 683a         	ldr	r2, [r7]
 8007e06: 440a         	add	r2, r1
 8007e08: 7812         	ldrb	r2, [r2]
 8007e0a: 4611         	mov	r1, r2
 8007e0c: 687a         	ldr	r2, [r7, #0x4]
 8007e0e: 440a         	add	r2, r1
 8007e10: f043 0301    	orr	r3, r3, #0x1
 8007e14: 6013         	str	r3, [r2]
; }
 8007e16: bf00         	nop
 8007e18: 370c         	adds	r7, #0xc
 8007e1a: 46bd         	mov	sp, r7
 8007e1c: bc80         	pop	{r7}
 8007e1e: 4770         	bx	lr

08007e20 <$d>:
 8007e20: 00 00 02 08  	.word	0x08020000

08007e24 <LL_DMA_DisableStream>:
; {
 8007e24: b480         	push	{r7}
 8007e26: b083         	sub	sp, #0xc
 8007e28: af00         	add	r7, sp, #0x0
 8007e2a: 6078         	str	r0, [r7, #0x4]
 8007e2c: 6039         	str	r1, [r7]
;   CLEAR_BIT(((DMA_Stream_TypeDef *)((uint32_t)((uint32_t)DMAx + STREAM_OFFSET_TAB[Stream])))->CR, DMA_SxCR_EN);
 8007e2e: 4a0b         	ldr	r2, [pc, #0x2c]         @ 0x8007e5c <LL_DMA_DisableStream+0x38>
 8007e30: 683b         	ldr	r3, [r7]
 8007e32: 4413         	add	r3, r2
 8007e34: 781b         	ldrb	r3, [r3]
 8007e36: 461a         	mov	r2, r3
 8007e38: 687b         	ldr	r3, [r7, #0x4]
 8007e3a: 4413         	add	r3, r2
 8007e3c: 681b         	ldr	r3, [r3]
 8007e3e: 4907         	ldr	r1, [pc, #0x1c]         @ 0x8007e5c <LL_DMA_DisableStream+0x38>
 8007e40: 683a         	ldr	r2, [r7]
 8007e42: 440a         	add	r2, r1
 8007e44: 7812         	ldrb	r2, [r2]
 8007e46: 4611         	mov	r1, r2
 8007e48: 687a         	ldr	r2, [r7, #0x4]
 8007e4a: 440a         	add	r2, r1
 8007e4c: f023 0301    	bic	r3, r3, #0x1
 8007e50: 6013         	str	r3, [r2]
; }
 8007e52: bf00         	nop
 8007e54: 370c         	adds	r7, #0xc
 8007e56: 46bd         	mov	sp, r7
 8007e58: bc80         	pop	{r7}
 8007e5a: 4770         	bx	lr

08007e5c <$d>:
 8007e5c: 00 00 02 08  	.word	0x08020000

08007e60 <LL_DMA_IsEnabledStream>:
; {
 8007e60: b480         	push	{r7}
 8007e62: b083         	sub	sp, #0xc
 8007e64: af00         	add	r7, sp, #0x0
 8007e66: 6078         	str	r0, [r7, #0x4]
 8007e68: 6039         	str	r1, [r7]
;   return (READ_BIT(((DMA_Stream_TypeDef*)((uint32_t)((uint32_t)DMAx + STREAM_OFFSET_TAB[Stream])))->CR, DMA_SxCR_EN) == (DMA_SxCR_EN));
 8007e6a: 4a0a         	ldr	r2, [pc, #0x28]         @ 0x8007e94 <LL_DMA_IsEnabledStream+0x34>
 8007e6c: 683b         	ldr	r3, [r7]
 8007e6e: 4413         	add	r3, r2
 8007e70: 781b         	ldrb	r3, [r3]
 8007e72: 461a         	mov	r2, r3
 8007e74: 687b         	ldr	r3, [r7, #0x4]
 8007e76: 4413         	add	r3, r2
 8007e78: 681b         	ldr	r3, [r3]
 8007e7a: f003 0301    	and	r3, r3, #0x1
 8007e7e: 2b01         	cmp	r3, #0x1
 8007e80: bf0c         	ite	eq
 8007e82: 2301         	moveq	r3, #0x1
 8007e84: 2300         	movne	r3, #0x0
 8007e86: b2db         	uxtb	r3, r3
; }
 8007e88: 4618         	mov	r0, r3
 8007e8a: 370c         	adds	r7, #0xc
 8007e8c: 46bd         	mov	sp, r7
 8007e8e: bc80         	pop	{r7}
 8007e90: 4770         	bx	lr
 8007e92: bf00         	nop

08007e94 <$d>:
 8007e94: 00 00 02 08  	.word	0x08020000

08007e98 <LL_DMA_DisableIT_FE>:
; {
 8007e98: b480         	push	{r7}
 8007e9a: b083         	sub	sp, #0xc
 8007e9c: af00         	add	r7, sp, #0x0
 8007e9e: 6078         	str	r0, [r7, #0x4]
 8007ea0: 6039         	str	r1, [r7]
;   CLEAR_BIT(((DMA_Stream_TypeDef *)((uint32_t)((uint32_t)DMAx + STREAM_OFFSET_TAB[Stream])))->FCR, DMA_SxFCR_FEIE);
 8007ea2: 4a0b         	ldr	r2, [pc, #0x2c]         @ 0x8007ed0 <LL_DMA_DisableIT_FE+0x38>
 8007ea4: 683b         	ldr	r3, [r7]
 8007ea6: 4413         	add	r3, r2
 8007ea8: 781b         	ldrb	r3, [r3]
 8007eaa: 461a         	mov	r2, r3
 8007eac: 687b         	ldr	r3, [r7, #0x4]
 8007eae: 4413         	add	r3, r2
 8007eb0: 695b         	ldr	r3, [r3, #0x14]
 8007eb2: 4907         	ldr	r1, [pc, #0x1c]         @ 0x8007ed0 <LL_DMA_DisableIT_FE+0x38>
 8007eb4: 683a         	ldr	r2, [r7]
 8007eb6: 440a         	add	r2, r1
 8007eb8: 7812         	ldrb	r2, [r2]
 8007eba: 4611         	mov	r1, r2
 8007ebc: 687a         	ldr	r2, [r7, #0x4]
 8007ebe: 440a         	add	r2, r1
 8007ec0: f023 0380    	bic	r3, r3, #0x80
 8007ec4: 6153         	str	r3, [r2, #0x14]
; }
 8007ec6: bf00         	nop
 8007ec8: 370c         	adds	r7, #0xc
 8007eca: 46bd         	mov	sp, r7
 8007ecc: bc80         	pop	{r7}
 8007ece: 4770         	bx	lr

08007ed0 <$d>:
 8007ed0: 00 00 02 08  	.word	0x08020000

08007ed4 <LL_DMA_IsEnabledIT_HT>:
; {
 8007ed4: b480         	push	{r7}
 8007ed6: b083         	sub	sp, #0xc
 8007ed8: af00         	add	r7, sp, #0x0
 8007eda: 6078         	str	r0, [r7, #0x4]
 8007edc: 6039         	str	r1, [r7]
;   return (READ_BIT(((DMA_Stream_TypeDef*)((uint32_t)((uint32_t)DMAx + STREAM_OFFSET_TAB[Stream])))->CR, DMA_SxCR_HTIE) == DMA_SxCR_HTIE);
 8007ede: 4a0a         	ldr	r2, [pc, #0x28]         @ 0x8007f08 <LL_DMA_IsEnabledIT_HT+0x34>
 8007ee0: 683b         	ldr	r3, [r7]
 8007ee2: 4413         	add	r3, r2
 8007ee4: 781b         	ldrb	r3, [r3]
 8007ee6: 461a         	mov	r2, r3
 8007ee8: 687b         	ldr	r3, [r7, #0x4]
 8007eea: 4413         	add	r3, r2
 8007eec: 681b         	ldr	r3, [r3]
 8007eee: f003 0308    	and	r3, r3, #0x8
 8007ef2: 2b08         	cmp	r3, #0x8
 8007ef4: bf0c         	ite	eq
 8007ef6: 2301         	moveq	r3, #0x1
 8007ef8: 2300         	movne	r3, #0x0
 8007efa: b2db         	uxtb	r3, r3
; }
 8007efc: 4618         	mov	r0, r3
 8007efe: 370c         	adds	r7, #0xc
 8007f00: 46bd         	mov	sp, r7
 8007f02: bc80         	pop	{r7}
 8007f04: 4770         	bx	lr
 8007f06: bf00         	nop

08007f08 <$d>:
 8007f08: 00 00 02 08  	.word	0x08020000

08007f0c <LL_DMA_IsEnabledIT_TC>:
; {
 8007f0c: b480         	push	{r7}
 8007f0e: b083         	sub	sp, #0xc
 8007f10: af00         	add	r7, sp, #0x0
 8007f12: 6078         	str	r0, [r7, #0x4]
 8007f14: 6039         	str	r1, [r7]
;   return (READ_BIT(((DMA_Stream_TypeDef*)((uint32_t)((uint32_t)DMAx + STREAM_OFFSET_TAB[Stream])))->CR, DMA_SxCR_TCIE) == DMA_SxCR_TCIE);
 8007f16: 4a0a         	ldr	r2, [pc, #0x28]         @ 0x8007f40 <LL_DMA_IsEnabledIT_TC+0x34>
 8007f18: 683b         	ldr	r3, [r7]
 8007f1a: 4413         	add	r3, r2
 8007f1c: 781b         	ldrb	r3, [r3]
 8007f1e: 461a         	mov	r2, r3
 8007f20: 687b         	ldr	r3, [r7, #0x4]
 8007f22: 4413         	add	r3, r2
 8007f24: 681b         	ldr	r3, [r3]
 8007f26: f003 0310    	and	r3, r3, #0x10
 8007f2a: 2b10         	cmp	r3, #0x10
 8007f2c: bf0c         	ite	eq
 8007f2e: 2301         	moveq	r3, #0x1
 8007f30: 2300         	movne	r3, #0x0
 8007f32: b2db         	uxtb	r3, r3
; }
 8007f34: 4618         	mov	r0, r3
 8007f36: 370c         	adds	r7, #0xc
 8007f38: 46bd         	mov	sp, r7
 8007f3a: bc80         	pop	{r7}
 8007f3c: 4770         	bx	lr
 8007f3e: bf00         	nop

08007f40 <$d>:
 8007f40: 00 00 02 08  	.word	0x08020000

08007f44 <LL_DMA_IsEnabledIT_FE>:
; {
 8007f44: b480         	push	{r7}
 8007f46: b083         	sub	sp, #0xc
 8007f48: af00         	add	r7, sp, #0x0
 8007f4a: 6078         	str	r0, [r7, #0x4]
 8007f4c: 6039         	str	r1, [r7]
;   return (READ_BIT(((DMA_Stream_TypeDef*)((uint32_t)((uint32_t)DMAx + STREAM_OFFSET_TAB[Stream])))->FCR, DMA_SxFCR_FEIE) == DMA_SxFCR_FEIE);
 8007f4e: 4a0a         	ldr	r2, [pc, #0x28]         @ 0x8007f78 <LL_DMA_IsEnabledIT_FE+0x34>
 8007f50: 683b         	ldr	r3, [r7]
 8007f52: 4413         	add	r3, r2
 8007f54: 781b         	ldrb	r3, [r3]
 8007f56: 461a         	mov	r2, r3
 8007f58: 687b         	ldr	r3, [r7, #0x4]
 8007f5a: 4413         	add	r3, r2
 8007f5c: 695b         	ldr	r3, [r3, #0x14]
 8007f5e: f003 0380    	and	r3, r3, #0x80
 8007f62: 2b80         	cmp	r3, #0x80
 8007f64: bf0c         	ite	eq
 8007f66: 2301         	moveq	r3, #0x1
 8007f68: 2300         	movne	r3, #0x0
 8007f6a: b2db         	uxtb	r3, r3
; }
 8007f6c: 4618         	mov	r0, r3
 8007f6e: 370c         	adds	r7, #0xc
 8007f70: 46bd         	mov	sp, r7
 8007f72: bc80         	pop	{r7}
 8007f74: 4770         	bx	lr
 8007f76: bf00         	nop

08007f78 <$d>:
 8007f78: 00 00 02 08  	.word	0x08020000

08007f7c <dma_stm32_id_to_stream>:
; {
 8007f7c: b480         	push	{r7}
 8007f7e: b083         	sub	sp, #0xc
 8007f80: af00         	add	r7, sp, #0x0
 8007f82: 6078         	str	r0, [r7, #0x4]
; 	return stream_nr[id];
 8007f84: 4a04         	ldr	r2, [pc, #0x10]         @ 0x8007f98 <dma_stm32_id_to_stream+0x1c>
 8007f86: 687b         	ldr	r3, [r7, #0x4]
 8007f88: f852 3023    	ldr.w	r3, [r2, r3, lsl #2]
; }
 8007f8c: 4618         	mov	r0, r3
 8007f8e: 370c         	adds	r7, #0xc
 8007f90: 46bd         	mov	sp, r7
 8007f92: bc80         	pop	{r7}
 8007f94: 4770         	bx	lr
 8007f96: bf00         	nop

08007f98 <$d>:
 8007f98: 08 00 02 08  	.word	0x08020008

08007f9c <dma_stm32_slot_to_channel>:
; {
 8007f9c: b480         	push	{r7}
 8007f9e: b083         	sub	sp, #0xc
 8007fa0: af00         	add	r7, sp, #0x0
 8007fa2: 6078         	str	r0, [r7, #0x4]
; 	return channel_nr[slot];
 8007fa4: 4a04         	ldr	r2, [pc, #0x10]         @ 0x8007fb8 <dma_stm32_slot_to_channel+0x1c>
 8007fa6: 687b         	ldr	r3, [r7, #0x4]
 8007fa8: f852 3023    	ldr.w	r3, [r2, r3, lsl #2]
; }
 8007fac: 4618         	mov	r0, r3
 8007fae: 370c         	adds	r7, #0xc
 8007fb0: 46bd         	mov	sp, r7
 8007fb2: bc80         	pop	{r7}
 8007fb4: 4770         	bx	lr
 8007fb6: bf00         	nop

08007fb8 <$d>:
 8007fb8: 28 00 02 08  	.word	0x08020028

08007fbc <dma_stm32_clear_ht>:
; {
 8007fbc: b580         	push	{r7, lr}
 8007fbe: b082         	sub	sp, #0x8
 8007fc0: af00         	add	r7, sp, #0x0
 8007fc2: 6078         	str	r0, [r7, #0x4]
 8007fc4: 6039         	str	r1, [r7]
; 	func[id](DMAx);
 8007fc6: 4a05         	ldr	r2, [pc, #0x14]         @ 0x8007fdc <dma_stm32_clear_ht+0x20>
 8007fc8: 683b         	ldr	r3, [r7]
 8007fca: f852 3023    	ldr.w	r3, [r2, r3, lsl #2]
 8007fce: 6878         	ldr	r0, [r7, #0x4]
 8007fd0: 4798         	blx	r3
; }
 8007fd2: bf00         	nop
 8007fd4: 3708         	adds	r7, #0x8
 8007fd6: 46bd         	mov	sp, r7
 8007fd8: bd80         	pop	{r7, pc}
 8007fda: bf00         	nop

08007fdc <$d>:
 8007fdc: 48 00 02 08  	.word	0x08020048

08007fe0 <dma_stm32_clear_tc>:
; {
 8007fe0: b580         	push	{r7, lr}
 8007fe2: b082         	sub	sp, #0x8
 8007fe4: af00         	add	r7, sp, #0x0
 8007fe6: 6078         	str	r0, [r7, #0x4]
 8007fe8: 6039         	str	r1, [r7]
; 	func[id](DMAx);
 8007fea: 4a05         	ldr	r2, [pc, #0x14]         @ 0x8008000 <dma_stm32_clear_tc+0x20>
 8007fec: 683b         	ldr	r3, [r7]
 8007fee: f852 3023    	ldr.w	r3, [r2, r3, lsl #2]
 8007ff2: 6878         	ldr	r0, [r7, #0x4]
 8007ff4: 4798         	blx	r3
; }
 8007ff6: bf00         	nop
 8007ff8: 3708         	adds	r7, #0x8
 8007ffa: 46bd         	mov	sp, r7
 8007ffc: bd80         	pop	{r7, pc}
 8007ffe: bf00         	nop

08008000 <$d>:
 8008000: 68 00 02 08  	.word	0x08020068

08008004 <dma_stm32_is_ht_active>:
; {
 8008004: b580         	push	{r7, lr}
 8008006: b082         	sub	sp, #0x8
 8008008: af00         	add	r7, sp, #0x0
 800800a: 6078         	str	r0, [r7, #0x4]
 800800c: 6039         	str	r1, [r7]
; 	return func[id](DMAx);
 800800e: 4a08         	ldr	r2, [pc, #0x20]         @ 0x8008030 <dma_stm32_is_ht_active+0x2c>
 8008010: 683b         	ldr	r3, [r7]
 8008012: f852 3023    	ldr.w	r3, [r2, r3, lsl #2]
 8008016: 6878         	ldr	r0, [r7, #0x4]
 8008018: 4798         	blx	r3
 800801a: 4603         	mov	r3, r0
 800801c: 2b00         	cmp	r3, #0x0
 800801e: bf14         	ite	ne
 8008020: 2301         	movne	r3, #0x1
 8008022: 2300         	moveq	r3, #0x0
 8008024: b2db         	uxtb	r3, r3
; }
 8008026: 4618         	mov	r0, r3
 8008028: 3708         	adds	r7, #0x8
 800802a: 46bd         	mov	sp, r7
 800802c: bd80         	pop	{r7, pc}
 800802e: bf00         	nop

08008030 <$d>:
 8008030: 88 00 02 08  	.word	0x08020088

08008034 <dma_stm32_is_tc_active>:
; {
 8008034: b580         	push	{r7, lr}
 8008036: b082         	sub	sp, #0x8
 8008038: af00         	add	r7, sp, #0x0
 800803a: 6078         	str	r0, [r7, #0x4]
 800803c: 6039         	str	r1, [r7]
; 	return func[id](DMAx);
 800803e: 4a08         	ldr	r2, [pc, #0x20]         @ 0x8008060 <dma_stm32_is_tc_active+0x2c>
 8008040: 683b         	ldr	r3, [r7]
 8008042: f852 3023    	ldr.w	r3, [r2, r3, lsl #2]
 8008046: 6878         	ldr	r0, [r7, #0x4]
 8008048: 4798         	blx	r3
 800804a: 4603         	mov	r3, r0
 800804c: 2b00         	cmp	r3, #0x0
 800804e: bf14         	ite	ne
 8008050: 2301         	movne	r3, #0x1
 8008052: 2300         	moveq	r3, #0x0
 8008054: b2db         	uxtb	r3, r3
; }
 8008056: 4618         	mov	r0, r3
 8008058: 3708         	adds	r7, #0x8
 800805a: 46bd         	mov	sp, r7
 800805c: bd80         	pop	{r7, pc}
 800805e: bf00         	nop

08008060 <$d>:
 8008060: a8 00 02 08  	.word	0x080200a8

08008064 <dma_stm32_clear_te>:
; {
 8008064: b580         	push	{r7, lr}
 8008066: b082         	sub	sp, #0x8
 8008068: af00         	add	r7, sp, #0x0
 800806a: 6078         	str	r0, [r7, #0x4]
 800806c: 6039         	str	r1, [r7]
; 	func[id](DMAx);
 800806e: 4a05         	ldr	r2, [pc, #0x14]         @ 0x8008084 <dma_stm32_clear_te+0x20>
 8008070: 683b         	ldr	r3, [r7]
 8008072: f852 3023    	ldr.w	r3, [r2, r3, lsl #2]
 8008076: 6878         	ldr	r0, [r7, #0x4]
 8008078: 4798         	blx	r3
; }
 800807a: bf00         	nop
 800807c: 3708         	adds	r7, #0x8
 800807e: 46bd         	mov	sp, r7
 8008080: bd80         	pop	{r7, pc}
 8008082: bf00         	nop

08008084 <$d>:
 8008084: c8 00 02 08  	.word	0x080200c8

08008088 <dma_stm32_clear_dme>:
; {
 8008088: b580         	push	{r7, lr}
 800808a: b082         	sub	sp, #0x8
 800808c: af00         	add	r7, sp, #0x0
 800808e: 6078         	str	r0, [r7, #0x4]
 8008090: 6039         	str	r1, [r7]
; 	func[id](DMAx);
 8008092: 4a05         	ldr	r2, [pc, #0x14]         @ 0x80080a8 <dma_stm32_clear_dme+0x20>
 8008094: 683b         	ldr	r3, [r7]
 8008096: f852 3023    	ldr.w	r3, [r2, r3, lsl #2]
 800809a: 6878         	ldr	r0, [r7, #0x4]
 800809c: 4798         	blx	r3
; }
 800809e: bf00         	nop
 80080a0: 3708         	adds	r7, #0x8
 80080a2: 46bd         	mov	sp, r7
 80080a4: bd80         	pop	{r7, pc}
 80080a6: bf00         	nop

080080a8 <$d>:
 80080a8: e8 00 02 08  	.word	0x080200e8

080080ac <dma_stm32_clear_fe>:
; {
 80080ac: b580         	push	{r7, lr}
 80080ae: b082         	sub	sp, #0x8
 80080b0: af00         	add	r7, sp, #0x0
 80080b2: 6078         	str	r0, [r7, #0x4]
 80080b4: 6039         	str	r1, [r7]
; 	func[id](DMAx);
 80080b6: 4a05         	ldr	r2, [pc, #0x14]         @ 0x80080cc <dma_stm32_clear_fe+0x20>
 80080b8: 683b         	ldr	r3, [r7]
 80080ba: f852 3023    	ldr.w	r3, [r2, r3, lsl #2]
 80080be: 6878         	ldr	r0, [r7, #0x4]
 80080c0: 4798         	blx	r3
; }
 80080c2: bf00         	nop
 80080c4: 3708         	adds	r7, #0x8
 80080c6: 46bd         	mov	sp, r7
 80080c8: bd80         	pop	{r7, pc}
 80080ca: bf00         	nop

080080cc <$d>:
 80080cc: 08 01 02 08  	.word	0x08020108

080080d0 <dma_stm32_is_te_active>:
; {
 80080d0: b580         	push	{r7, lr}
 80080d2: b082         	sub	sp, #0x8
 80080d4: af00         	add	r7, sp, #0x0
 80080d6: 6078         	str	r0, [r7, #0x4]
 80080d8: 6039         	str	r1, [r7]
; 	return func[id](DMAx);
 80080da: 4a08         	ldr	r2, [pc, #0x20]         @ 0x80080fc <dma_stm32_is_te_active+0x2c>
 80080dc: 683b         	ldr	r3, [r7]
 80080de: f852 3023    	ldr.w	r3, [r2, r3, lsl #2]
 80080e2: 6878         	ldr	r0, [r7, #0x4]
 80080e4: 4798         	blx	r3
 80080e6: 4603         	mov	r3, r0
 80080e8: 2b00         	cmp	r3, #0x0
 80080ea: bf14         	ite	ne
 80080ec: 2301         	movne	r3, #0x1
 80080ee: 2300         	moveq	r3, #0x0
 80080f0: b2db         	uxtb	r3, r3
; }
 80080f2: 4618         	mov	r0, r3
 80080f4: 3708         	adds	r7, #0x8
 80080f6: 46bd         	mov	sp, r7
 80080f8: bd80         	pop	{r7, pc}
 80080fa: bf00         	nop

080080fc <$d>:
 80080fc: 28 01 02 08  	.word	0x08020128

08008100 <dma_stm32_is_dme_active>:
; {
 8008100: b580         	push	{r7, lr}
 8008102: b082         	sub	sp, #0x8
 8008104: af00         	add	r7, sp, #0x0
 8008106: 6078         	str	r0, [r7, #0x4]
 8008108: 6039         	str	r1, [r7]
; 	return func[id](DMAx);
 800810a: 4a08         	ldr	r2, [pc, #0x20]         @ 0x800812c <dma_stm32_is_dme_active+0x2c>
 800810c: 683b         	ldr	r3, [r7]
 800810e: f852 3023    	ldr.w	r3, [r2, r3, lsl #2]
 8008112: 6878         	ldr	r0, [r7, #0x4]
 8008114: 4798         	blx	r3
 8008116: 4603         	mov	r3, r0
 8008118: 2b00         	cmp	r3, #0x0
 800811a: bf14         	ite	ne
 800811c: 2301         	movne	r3, #0x1
 800811e: 2300         	moveq	r3, #0x0
 8008120: b2db         	uxtb	r3, r3
; }
 8008122: 4618         	mov	r0, r3
 8008124: 3708         	adds	r7, #0x8
 8008126: 46bd         	mov	sp, r7
 8008128: bd80         	pop	{r7, pc}
 800812a: bf00         	nop

0800812c <$d>:
 800812c: 48 01 02 08  	.word	0x08020148

08008130 <dma_stm32_is_fe_active>:
; {
 8008130: b580         	push	{r7, lr}
 8008132: b082         	sub	sp, #0x8
 8008134: af00         	add	r7, sp, #0x0
 8008136: 6078         	str	r0, [r7, #0x4]
 8008138: 6039         	str	r1, [r7]
; 	return func[id](DMAx);
 800813a: 4a08         	ldr	r2, [pc, #0x20]         @ 0x800815c <dma_stm32_is_fe_active+0x2c>
 800813c: 683b         	ldr	r3, [r7]
 800813e: f852 3023    	ldr.w	r3, [r2, r3, lsl #2]
 8008142: 6878         	ldr	r0, [r7, #0x4]
 8008144: 4798         	blx	r3
 8008146: 4603         	mov	r3, r0
 8008148: 2b00         	cmp	r3, #0x0
 800814a: bf14         	ite	ne
 800814c: 2301         	movne	r3, #0x1
 800814e: 2300         	moveq	r3, #0x0
 8008150: b2db         	uxtb	r3, r3
; }
 8008152: 4618         	mov	r0, r3
 8008154: 3708         	adds	r7, #0x8
 8008156: 46bd         	mov	sp, r7
 8008158: bd80         	pop	{r7, pc}
 800815a: bf00         	nop

0800815c <$d>:
 800815c: 68 01 02 08  	.word	0x08020168

08008160 <stm32_dma_dump_stream_irq>:
; {
 8008160: b5f0         	push	{r4, r5, r6, r7, lr}
 8008162: b08f         	sub	sp, #0x3c
 8008164: af08         	add	r7, sp, #0x20
 8008166: 60f8         	str	r0, [r7, #0xc]
 8008168: 60b9         	str	r1, [r7, #0x8]
; 	LOG_INF("tc: %d, ht: %d, te: %d, dme: %d, fe: %d",
 800816a: 2303         	movs	r3, #0x3
 800816c: 2b02         	cmp	r3, #0x2
 800816e: d93c         	bls	0x80081ea <stm32_dma_dump_stream_irq+0x8a> @ imm = #0x78
 8008170: 2301         	movs	r3, #0x1
 8008172: 74fb         	strb	r3, [r7, #0x13]
 8008174: 7cfb         	ldrb	r3, [r7, #0x13]
 8008176: f083 0301    	eor	r3, r3, #0x1
 800817a: b2db         	uxtb	r3, r3
 800817c: 2b00         	cmp	r3, #0x0
 800817e: d134         	bne	0x80081ea <stm32_dma_dump_stream_irq+0x8a> @ imm = #0x68
 8008180: 4b1c         	ldr	r3, [pc, #0x70]         @ 0x80081f4 <stm32_dma_dump_stream_irq+0x94>
 8008182: 681c         	ldr	r4, [r3]
 8008184: 68b9         	ldr	r1, [r7, #0x8]
 8008186: 68f8         	ldr	r0, [r7, #0xc]
 8008188: f7ff ff54    	bl	0x8008034 <dma_stm32_is_tc_active> @ imm = #-0x158
 800818c: 4603         	mov	r3, r0
 800818e: 461d         	mov	r5, r3
 8008190: 68b9         	ldr	r1, [r7, #0x8]
 8008192: 68f8         	ldr	r0, [r7, #0xc]
 8008194: f7ff ff36    	bl	0x8008004 <dma_stm32_is_ht_active> @ imm = #-0x194
 8008198: 4603         	mov	r3, r0
 800819a: 461e         	mov	r6, r3
 800819c: 68b9         	ldr	r1, [r7, #0x8]
 800819e: 68f8         	ldr	r0, [r7, #0xc]
 80081a0: f7ff ff96    	bl	0x80080d0 <dma_stm32_is_te_active> @ imm = #-0xd4
 80081a4: 4603         	mov	r3, r0
 80081a6: 607b         	str	r3, [r7, #0x4]
 80081a8: 68b9         	ldr	r1, [r7, #0x8]
 80081aa: 68f8         	ldr	r0, [r7, #0xc]
 80081ac: f7ff ffa8    	bl	0x8008100 <dma_stm32_is_dme_active> @ imm = #-0xb0
 80081b0: 4603         	mov	r3, r0
 80081b2: 603b         	str	r3, [r7]
 80081b4: 68b9         	ldr	r1, [r7, #0x8]
 80081b6: 68f8         	ldr	r0, [r7, #0xc]
 80081b8: f7ff ffba    	bl	0x8008130 <dma_stm32_is_fe_active> @ imm = #-0x8c
 80081bc: 4603         	mov	r3, r0
 80081be: 9307         	str	r3, [sp, #0x1c]
 80081c0: 683a         	ldr	r2, [r7]
 80081c2: 9206         	str	r2, [sp, #0x18]
 80081c4: 687b         	ldr	r3, [r7, #0x4]
 80081c6: 9305         	str	r3, [sp, #0x14]
 80081c8: 9604         	str	r6, [sp, #0x10]
 80081ca: 9503         	str	r5, [sp, #0xc]
 80081cc: 4b0a         	ldr	r3, [pc, #0x28]         @ 0x80081f8 <stm32_dma_dump_stream_irq+0x98>
 80081ce: 9302         	str	r3, [sp, #0x8]
 80081d0: 2300         	movs	r3, #0x0
 80081d2: 9301         	str	r3, [sp, #0x4]
 80081d4: 2300         	movs	r3, #0x0
 80081d6: 9300         	str	r3, [sp]
 80081d8: 2300         	movs	r3, #0x0
 80081da: 2203         	movs	r2, #0x3
 80081dc: 4621         	mov	r1, r4
 80081de: 2000         	movs	r0, #0x0
 80081e0: f00f f83a    	bl	0x8017258 <z_log_msg_runtime_create> @ imm = #0xf074
 80081e4: 2300         	movs	r3, #0x0
 80081e6: 617b         	str	r3, [r7, #0x14]
; }
 80081e8: bf00         	nop
 80081ea: bf00         	nop
 80081ec: 371c         	adds	r7, #0x1c
 80081ee: 46bd         	mov	sp, r7
 80081f0: bdf0         	pop	{r4, r5, r6, r7, pc}
 80081f2: bf00         	nop

080081f4 <$d>:
 80081f4: 04 05 00 20  	.word	0x20000504
 80081f8: 54 ed 01 08  	.word	0x0801ed54

080081fc <stm32_dma_is_unexpected_irq_happened>:
; {
 80081fc: b580         	push	{r7, lr}
 80081fe: b088         	sub	sp, #0x20
 8008200: af04         	add	r7, sp, #0x10
 8008202: 6078         	str	r0, [r7, #0x4]
 8008204: 6039         	str	r1, [r7]
; 	if (LL_DMA_IsEnabledIT_FE(dma, dma_stm32_id_to_stream(id)) &&
 8008206: 6838         	ldr	r0, [r7]
 8008208: f7ff feb8    	bl	0x8007f7c <dma_stm32_id_to_stream> @ imm = #-0x290
 800820c: 4603         	mov	r3, r0
 800820e: 4619         	mov	r1, r3
 8008210: 6878         	ldr	r0, [r7, #0x4]
 8008212: f7ff fe97    	bl	0x8007f44 <LL_DMA_IsEnabledIT_FE> @ imm = #-0x2d2
 8008216: 4603         	mov	r3, r0
 8008218: 2b00         	cmp	r3, #0x0
 800821a: d02a         	beq	0x8008272 <stm32_dma_is_unexpected_irq_happened+0x76> @ imm = #0x54
; 	    dma_stm32_is_fe_active(dma, id)) {
 800821c: 6839         	ldr	r1, [r7]
 800821e: 6878         	ldr	r0, [r7, #0x4]
 8008220: f7ff ff86    	bl	0x8008130 <dma_stm32_is_fe_active> @ imm = #-0xf4
 8008224: 4603         	mov	r3, r0
; 	if (LL_DMA_IsEnabledIT_FE(dma, dma_stm32_id_to_stream(id)) &&
 8008226: 2b00         	cmp	r3, #0x0
 8008228: d023         	beq	0x8008272 <stm32_dma_is_unexpected_irq_happened+0x76> @ imm = #0x46
; 		LOG_ERR("FiFo error.");
 800822a: 2303         	movs	r3, #0x3
 800822c: 2b00         	cmp	r3, #0x0
 800822e: d016         	beq	0x800825e <stm32_dma_is_unexpected_irq_happened+0x62> @ imm = #0x2c
 8008230: 2301         	movs	r3, #0x1
 8008232: 73fb         	strb	r3, [r7, #0xf]
 8008234: 7bfb         	ldrb	r3, [r7, #0xf]
 8008236: f083 0301    	eor	r3, r3, #0x1
 800823a: b2db         	uxtb	r3, r3
 800823c: 2b00         	cmp	r3, #0x0
 800823e: d10e         	bne	0x800825e <stm32_dma_is_unexpected_irq_happened+0x62> @ imm = #0x1c
 8008240: 4b0e         	ldr	r3, [pc, #0x38]         @ 0x800827c <stm32_dma_is_unexpected_irq_happened+0x80>
 8008242: 6819         	ldr	r1, [r3]
 8008244: 4b0e         	ldr	r3, [pc, #0x38]         @ 0x8008280 <stm32_dma_is_unexpected_irq_happened+0x84>
 8008246: 9302         	str	r3, [sp, #0x8]
 8008248: 2300         	movs	r3, #0x0
 800824a: 9301         	str	r3, [sp, #0x4]
 800824c: 2300         	movs	r3, #0x0
 800824e: 9300         	str	r3, [sp]
 8008250: 2300         	movs	r3, #0x0
 8008252: 2201         	movs	r2, #0x1
 8008254: 2000         	movs	r0, #0x0
 8008256: f00e ffff    	bl	0x8017258 <z_log_msg_runtime_create> @ imm = #0xeffe
 800825a: 2300         	movs	r3, #0x0
 800825c: 60bb         	str	r3, [r7, #0x8]
; 		stm32_dma_dump_stream_irq(dma, id);
 800825e: 6839         	ldr	r1, [r7]
 8008260: 6878         	ldr	r0, [r7, #0x4]
 8008262: f7ff ff7d    	bl	0x8008160 <stm32_dma_dump_stream_irq> @ imm = #-0x106
; 		stm32_dma_clear_stream_irq(dma, id);
 8008266: 6839         	ldr	r1, [r7]
 8008268: 6878         	ldr	r0, [r7, #0x4]
 800826a: f00f f855    	bl	0x8017318 <stm32_dma_clear_stream_irq> @ imm = #0xf0aa
; 		return true;
 800826e: 2301         	movs	r3, #0x1
 8008270: e000         	b	0x8008274 <stm32_dma_is_unexpected_irq_happened+0x78> @ imm = #0x0
; 	return false;
 8008272: 2300         	movs	r3, #0x0
; }
 8008274: 4618         	mov	r0, r3
 8008276: 3710         	adds	r7, #0x10
 8008278: 46bd         	mov	sp, r7
 800827a: bd80         	pop	{r7, pc}

0800827c <$d>:
 800827c: 04 05 00 20  	.word	0x20000504
 8008280: 7c ed 01 08  	.word	0x0801ed7c

08008284 <stm32_dma_get_mburst>:
; {
 8008284: b580         	push	{r7, lr}
 8008286: b08a         	sub	sp, #0x28
 8008288: af04         	add	r7, sp, #0x10
 800828a: 6078         	str	r0, [r7, #0x4]
 800828c: 460b         	mov	r3, r1
 800828e: 70fb         	strb	r3, [r7, #0x3]
; 	if (source_periph) {
 8008290: 78fb         	ldrb	r3, [r7, #0x3]
 8008292: 2b00         	cmp	r3, #0x0
 8008294: d003         	beq	0x800829e <stm32_dma_get_mburst+0x1a> @ imm = #0x6
; 		memory_burst = config->dest_burst_length;
 8008296: 687b         	ldr	r3, [r7, #0x4]
 8008298: 895b         	ldrh	r3, [r3, #0xa]
 800829a: 617b         	str	r3, [r7, #0x14]
 800829c: e002         	b	0x80082a4 <stm32_dma_get_mburst+0x20> @ imm = #0x4
; 		memory_burst = config->source_burst_length;
 800829e: 687b         	ldr	r3, [r7, #0x4]
 80082a0: 891b         	ldrh	r3, [r3, #0x8]
 80082a2: 617b         	str	r3, [r7, #0x14]
; 	switch (memory_burst) {
 80082a4: 697b         	ldr	r3, [r7, #0x14]
 80082a6: 3b01         	subs	r3, #0x1
 80082a8: 2b0f         	cmp	r3, #0xf
 80082aa: d82e         	bhi	0x800830a <stm32_dma_get_mburst+0x86> @ imm = #0x5c
 80082ac: a201         	adr	r2, #4 <stm32_dma_get_mburst+0x2d>
 80082ae: f852 f023    	ldr.w	pc, [r2, r3, lsl #2]
 80082b2: bf00         	nop

080082b4 <$d>:
 80082b4: f5 82 00 08  	.word	0x080082f5
 80082b8: 0b 83 00 08  	.word	0x0800830b
 80082bc: 0b 83 00 08  	.word	0x0800830b
 80082c0: f9 82 00 08  	.word	0x080082f9
 80082c4: 0b 83 00 08  	.word	0x0800830b
 80082c8: 0b 83 00 08  	.word	0x0800830b
 80082cc: 0b 83 00 08  	.word	0x0800830b
 80082d0: ff 82 00 08  	.word	0x080082ff
 80082d4: 0b 83 00 08  	.word	0x0800830b
 80082d8: 0b 83 00 08  	.word	0x0800830b
 80082dc: 0b 83 00 08  	.word	0x0800830b
 80082e0: 0b 83 00 08  	.word	0x0800830b
 80082e4: 0b 83 00 08  	.word	0x0800830b
 80082e8: 0b 83 00 08  	.word	0x0800830b
 80082ec: 0b 83 00 08  	.word	0x0800830b
 80082f0: 05 83 00 08  	.word	0x08008305

080082f4 <$t>:
; 		return LL_DMA_MBURST_SINGLE;
 80082f4: 2300         	movs	r3, #0x0
 80082f6: e023         	b	0x8008340 <stm32_dma_get_mburst+0xbc> @ imm = #0x46
; 		return LL_DMA_MBURST_INC4;
 80082f8: f44f 0300    	mov.w	r3, #0x800000
 80082fc: e020         	b	0x8008340 <stm32_dma_get_mburst+0xbc> @ imm = #0x40
; 		return LL_DMA_MBURST_INC8;
 80082fe: f04f 7380    	mov.w	r3, #0x1000000
 8008302: e01d         	b	0x8008340 <stm32_dma_get_mburst+0xbc> @ imm = #0x3a
; 		return LL_DMA_MBURST_INC16;
 8008304: f04f 73c0    	mov.w	r3, #0x1800000
 8008308: e01a         	b	0x8008340 <stm32_dma_get_mburst+0xbc> @ imm = #0x34
; 		LOG_ERR("Memory burst size error,"
 800830a: 2303         	movs	r3, #0x3
 800830c: 2b00         	cmp	r3, #0x0
 800830e: d016         	beq	0x800833e <stm32_dma_get_mburst+0xba> @ imm = #0x2c
 8008310: 2301         	movs	r3, #0x1
 8008312: 74fb         	strb	r3, [r7, #0x13]
 8008314: 7cfb         	ldrb	r3, [r7, #0x13]
 8008316: f083 0301    	eor	r3, r3, #0x1
 800831a: b2db         	uxtb	r3, r3
 800831c: 2b00         	cmp	r3, #0x0
 800831e: d10e         	bne	0x800833e <stm32_dma_get_mburst+0xba> @ imm = #0x1c
 8008320: 4b09         	ldr	r3, [pc, #0x24]         @ 0x8008348 <stm32_dma_get_mburst+0xc4>
 8008322: 6819         	ldr	r1, [r3]
 8008324: 4b09         	ldr	r3, [pc, #0x24]         @ 0x800834c <stm32_dma_get_mburst+0xc8>
 8008326: 9302         	str	r3, [sp, #0x8]
 8008328: 2300         	movs	r3, #0x0
 800832a: 9301         	str	r3, [sp, #0x4]
 800832c: 2300         	movs	r3, #0x0
 800832e: 9300         	str	r3, [sp]
 8008330: 2300         	movs	r3, #0x0
 8008332: 2201         	movs	r2, #0x1
 8008334: 2000         	movs	r0, #0x0
 8008336: f00e ff8f    	bl	0x8017258 <z_log_msg_runtime_create> @ imm = #0xef1e
 800833a: 2300         	movs	r3, #0x0
 800833c: 60fb         	str	r3, [r7, #0xc]
; 		return LL_DMA_MBURST_SINGLE;
 800833e: 2300         	movs	r3, #0x0
; }
 8008340: 4618         	mov	r0, r3
 8008342: 3718         	adds	r7, #0x18
 8008344: 46bd         	mov	sp, r7
 8008346: bd80         	pop	{r7, pc}

08008348 <$d>:
 8008348: 04 05 00 20  	.word	0x20000504
 800834c: 88 ed 01 08  	.word	0x0801ed88

08008350 <stm32_dma_get_pburst>:
; {
 8008350: b580         	push	{r7, lr}
 8008352: b08a         	sub	sp, #0x28
 8008354: af04         	add	r7, sp, #0x10
 8008356: 6078         	str	r0, [r7, #0x4]
 8008358: 460b         	mov	r3, r1
 800835a: 70fb         	strb	r3, [r7, #0x3]
; 	if (source_periph) {
 800835c: 78fb         	ldrb	r3, [r7, #0x3]
 800835e: 2b00         	cmp	r3, #0x0
 8008360: d003         	beq	0x800836a <stm32_dma_get_pburst+0x1a> @ imm = #0x6
; 		periph_burst = config->source_burst_length;
 8008362: 687b         	ldr	r3, [r7, #0x4]
 8008364: 891b         	ldrh	r3, [r3, #0x8]
 8008366: 617b         	str	r3, [r7, #0x14]
 8008368: e002         	b	0x8008370 <stm32_dma_get_pburst+0x20> @ imm = #0x4
; 		periph_burst = config->dest_burst_length;
 800836a: 687b         	ldr	r3, [r7, #0x4]
 800836c: 895b         	ldrh	r3, [r3, #0xa]
 800836e: 617b         	str	r3, [r7, #0x14]
; 	switch (periph_burst) {
 8008370: 697b         	ldr	r3, [r7, #0x14]
 8008372: 3b01         	subs	r3, #0x1
 8008374: 2b0f         	cmp	r3, #0xf
 8008376: d82e         	bhi	0x80083d6 <stm32_dma_get_pburst+0x86> @ imm = #0x5c
 8008378: a201         	adr	r2, #4 <stm32_dma_get_pburst+0x2d>
 800837a: f852 f023    	ldr.w	pc, [r2, r3, lsl #2]
 800837e: bf00         	nop

08008380 <$d>:
 8008380: c1 83 00 08  	.word	0x080083c1
 8008384: d7 83 00 08  	.word	0x080083d7
 8008388: d7 83 00 08  	.word	0x080083d7
 800838c: c5 83 00 08  	.word	0x080083c5
 8008390: d7 83 00 08  	.word	0x080083d7
 8008394: d7 83 00 08  	.word	0x080083d7
 8008398: d7 83 00 08  	.word	0x080083d7
 800839c: cb 83 00 08  	.word	0x080083cb
 80083a0: d7 83 00 08  	.word	0x080083d7
 80083a4: d7 83 00 08  	.word	0x080083d7
 80083a8: d7 83 00 08  	.word	0x080083d7
 80083ac: d7 83 00 08  	.word	0x080083d7
 80083b0: d7 83 00 08  	.word	0x080083d7
 80083b4: d7 83 00 08  	.word	0x080083d7
 80083b8: d7 83 00 08  	.word	0x080083d7
 80083bc: d1 83 00 08  	.word	0x080083d1

080083c0 <$t>:
; 		return LL_DMA_PBURST_SINGLE;
 80083c0: 2300         	movs	r3, #0x0
 80083c2: e023         	b	0x800840c <stm32_dma_get_pburst+0xbc> @ imm = #0x46
; 		return LL_DMA_PBURST_INC4;
 80083c4: f44f 1300    	mov.w	r3, #0x200000
 80083c8: e020         	b	0x800840c <stm32_dma_get_pburst+0xbc> @ imm = #0x40
; 		return LL_DMA_PBURST_INC8;
 80083ca: f44f 0380    	mov.w	r3, #0x400000
 80083ce: e01d         	b	0x800840c <stm32_dma_get_pburst+0xbc> @ imm = #0x3a
; 		return LL_DMA_PBURST_INC16;
 80083d0: f44f 03c0    	mov.w	r3, #0x600000
 80083d4: e01a         	b	0x800840c <stm32_dma_get_pburst+0xbc> @ imm = #0x34
; 		LOG_ERR("Peripheral burst size error,"
 80083d6: 2303         	movs	r3, #0x3
 80083d8: 2b00         	cmp	r3, #0x0
 80083da: d016         	beq	0x800840a <stm32_dma_get_pburst+0xba> @ imm = #0x2c
 80083dc: 2301         	movs	r3, #0x1
 80083de: 74fb         	strb	r3, [r7, #0x13]
 80083e0: 7cfb         	ldrb	r3, [r7, #0x13]
 80083e2: f083 0301    	eor	r3, r3, #0x1
 80083e6: b2db         	uxtb	r3, r3
 80083e8: 2b00         	cmp	r3, #0x0
 80083ea: d10e         	bne	0x800840a <stm32_dma_get_pburst+0xba> @ imm = #0x1c
 80083ec: 4b09         	ldr	r3, [pc, #0x24]         @ 0x8008414 <stm32_dma_get_pburst+0xc4>
 80083ee: 6819         	ldr	r1, [r3]
 80083f0: 4b09         	ldr	r3, [pc, #0x24]         @ 0x8008418 <stm32_dma_get_pburst+0xc8>
 80083f2: 9302         	str	r3, [sp, #0x8]
 80083f4: 2300         	movs	r3, #0x0
 80083f6: 9301         	str	r3, [sp, #0x4]
 80083f8: 2300         	movs	r3, #0x0
 80083fa: 9300         	str	r3, [sp]
 80083fc: 2300         	movs	r3, #0x0
 80083fe: 2201         	movs	r2, #0x1
 8008400: 2000         	movs	r0, #0x0
 8008402: f00e ff29    	bl	0x8017258 <z_log_msg_runtime_create> @ imm = #0xee52
 8008406: 2300         	movs	r3, #0x0
 8008408: 60fb         	str	r3, [r7, #0xc]
; 		return LL_DMA_PBURST_SINGLE;
 800840a: 2300         	movs	r3, #0x0
; }
 800840c: 4618         	mov	r0, r3
 800840e: 3718         	adds	r7, #0x18
 8008410: 46bd         	mov	sp, r7
 8008412: bd80         	pop	{r7, pc}

08008414 <$d>:
 8008414: 04 05 00 20  	.word	0x20000504
 8008418: c0 ed 01 08  	.word	0x0801edc0

0800841c <stm32_dma_get_fifo_threshold>:
; {
 800841c: b580         	push	{r7, lr}
 800841e: b088         	sub	sp, #0x20
 8008420: af04         	add	r7, sp, #0x10
 8008422: 4603         	mov	r3, r0
 8008424: 80fb         	strh	r3, [r7, #0x6]
; 	switch (fifo_mode_control) {
 8008426: 88fb         	ldrh	r3, [r7, #0x6]
 8008428: 2b03         	cmp	r3, #0x3
 800842a: d813         	bhi	0x8008454 <stm32_dma_get_fifo_threshold+0x38> @ imm = #0x26
 800842c: a201         	adr	r2, #4 <stm32_dma_get_fifo_threshold+0x15>
 800842e: f852 f023    	ldr.w	pc, [r2, r3, lsl #2]
 8008432: bf00         	nop

08008434 <$d>:
 8008434: 45 84 00 08  	.word	0x08008445
 8008438: 49 84 00 08  	.word	0x08008449
 800843c: 4d 84 00 08  	.word	0x0800844d
 8008440: 51 84 00 08  	.word	0x08008451

08008444 <$t>:
; 		return LL_DMA_FIFOTHRESHOLD_1_4;
 8008444: 2300         	movs	r3, #0x0
 8008446: e020         	b	0x800848a <stm32_dma_get_fifo_threshold+0x6e> @ imm = #0x40
; 		return LL_DMA_FIFOTHRESHOLD_1_2;
 8008448: 2301         	movs	r3, #0x1
 800844a: e01e         	b	0x800848a <stm32_dma_get_fifo_threshold+0x6e> @ imm = #0x3c
; 		return LL_DMA_FIFOTHRESHOLD_3_4;
 800844c: 2302         	movs	r3, #0x2
 800844e: e01c         	b	0x800848a <stm32_dma_get_fifo_threshold+0x6e> @ imm = #0x38
; 		return LL_DMA_FIFOTHRESHOLD_FULL;
 8008450: 2303         	movs	r3, #0x3
 8008452: e01a         	b	0x800848a <stm32_dma_get_fifo_threshold+0x6e> @ imm = #0x34
; 		LOG_WRN("FIFO threshold parameter error, reset to 1/4");
 8008454: 2303         	movs	r3, #0x3
 8008456: 2b01         	cmp	r3, #0x1
 8008458: d916         	bls	0x8008488 <stm32_dma_get_fifo_threshold+0x6c> @ imm = #0x2c
 800845a: 2301         	movs	r3, #0x1
 800845c: 73fb         	strb	r3, [r7, #0xf]
 800845e: 7bfb         	ldrb	r3, [r7, #0xf]
 8008460: f083 0301    	eor	r3, r3, #0x1
 8008464: b2db         	uxtb	r3, r3
 8008466: 2b00         	cmp	r3, #0x0
 8008468: d10e         	bne	0x8008488 <stm32_dma_get_fifo_threshold+0x6c> @ imm = #0x1c
 800846a: 4b0a         	ldr	r3, [pc, #0x28]         @ 0x8008494 <stm32_dma_get_fifo_threshold+0x78>
 800846c: 6819         	ldr	r1, [r3]
 800846e: 4b0a         	ldr	r3, [pc, #0x28]         @ 0x8008498 <stm32_dma_get_fifo_threshold+0x7c>
 8008470: 9302         	str	r3, [sp, #0x8]
 8008472: 2300         	movs	r3, #0x0
 8008474: 9301         	str	r3, [sp, #0x4]
 8008476: 2300         	movs	r3, #0x0
 8008478: 9300         	str	r3, [sp]
 800847a: 2300         	movs	r3, #0x0
 800847c: 2202         	movs	r2, #0x2
 800847e: 2000         	movs	r0, #0x0
 8008480: f00e feea    	bl	0x8017258 <z_log_msg_runtime_create> @ imm = #0xedd4
 8008484: 2300         	movs	r3, #0x0
 8008486: 60bb         	str	r3, [r7, #0x8]
; 		return LL_DMA_FIFOTHRESHOLD_1_4;
 8008488: 2300         	movs	r3, #0x0
; }
 800848a: 4618         	mov	r0, r3
 800848c: 3710         	adds	r7, #0x10
 800848e: 46bd         	mov	sp, r7
 8008490: bd80         	pop	{r7, pc}
 8008492: bf00         	nop

08008494 <$d>:
 8008494: 04 05 00 20  	.word	0x20000504
 8008498: fc ed 01 08  	.word	0x0801edfc

0800849c <gpio_stm32_clock_request>:
; {
 800849c: b580         	push	{r7, lr}
 800849e: b086         	sub	sp, #0x18
 80084a0: af00         	add	r7, sp, #0x0
 80084a2: 6078         	str	r0, [r7, #0x4]
 80084a4: 460b         	mov	r3, r1
 80084a6: 70fb         	strb	r3, [r7, #0x3]
; 	const struct gpio_stm32_config *cfg = dev->config;
 80084a8: 687b         	ldr	r3, [r7, #0x4]
 80084aa: 685b         	ldr	r3, [r3, #0x4]
 80084ac: 613b         	str	r3, [r7, #0x10]
; 	const struct device *const clk = DEVICE_DT_GET(STM32_CLOCK_CONTROL_NODE);
 80084ae: 4b0c         	ldr	r3, [pc, #0x30]         @ 0x80084e0 <gpio_stm32_clock_request+0x44>
 80084b0: 60fb         	str	r3, [r7, #0xc]
; 	if (on) {
 80084b2: 78fb         	ldrb	r3, [r7, #0x3]
 80084b4: 2b00         	cmp	r3, #0x0
 80084b6: d007         	beq	0x80084c8 <gpio_stm32_clock_request+0x2c> @ imm = #0xe
; 					(clock_control_subsys_t)&cfg->pclken);
 80084b8: 693b         	ldr	r3, [r7, #0x10]
 80084ba: 330c         	adds	r3, #0xc
; 		ret = clock_control_on(clk,
 80084bc: 4619         	mov	r1, r3
 80084be: 68f8         	ldr	r0, [r7, #0xc]
 80084c0: f00f fa7b    	bl	0x80179ba <clock_control_on> @ imm = #0xf4f6
 80084c4: 6178         	str	r0, [r7, #0x14]
 80084c6: e006         	b	0x80084d6 <gpio_stm32_clock_request+0x3a> @ imm = #0xc
; 					(clock_control_subsys_t)&cfg->pclken);
 80084c8: 693b         	ldr	r3, [r7, #0x10]
 80084ca: 330c         	adds	r3, #0xc
; 		ret = clock_control_off(clk,
 80084cc: 4619         	mov	r1, r3
 80084ce: 68f8         	ldr	r0, [r7, #0xc]
 80084d0: f00f fa85    	bl	0x80179de <clock_control_off> @ imm = #0xf50a
 80084d4: 6178         	str	r0, [r7, #0x14]
; 	return ret;
 80084d6: 697b         	ldr	r3, [r7, #0x14]
; }
 80084d8: 4618         	mov	r0, r3
 80084da: 3718         	adds	r7, #0x18
 80084dc: 46bd         	mov	sp, r7
 80084de: bd80         	pop	{r7, pc}

080084e0 <$d>:
 80084e0: 28 dd 01 08  	.word	0x0801dd28

080084e4 <gpio_stm32_pin_interrupt_configure>:
; {
 80084e4: b580         	push	{r7, lr}
 80084e6: b08a         	sub	sp, #0x28
 80084e8: af00         	add	r7, sp, #0x0
 80084ea: 60f8         	str	r0, [r7, #0xc]
 80084ec: 607a         	str	r2, [r7, #0x4]
 80084ee: 603b         	str	r3, [r7]
 80084f0: 460b         	mov	r3, r1
 80084f2: 72fb         	strb	r3, [r7, #0xb]
; 	const struct gpio_stm32_config *cfg = dev->config;
 80084f4: 68fb         	ldr	r3, [r7, #0xc]
 80084f6: 685b         	ldr	r3, [r3, #0x4]
 80084f8: 61fb         	str	r3, [r7, #0x1c]
; 	struct gpio_stm32_data *data = dev->data;
 80084fa: 68fb         	ldr	r3, [r7, #0xc]
 80084fc: 691b         	ldr	r3, [r3, #0x10]
 80084fe: 61bb         	str	r3, [r7, #0x18]
; 	const stm32_gpio_irq_line_t irq_line = stm32_gpio_intc_get_pin_irq_line(cfg->port, pin);
 8008500: 69fb         	ldr	r3, [r7, #0x1c]
 8008502: 689b         	ldr	r3, [r3, #0x8]
 8008504: 461a         	mov	r2, r3
 8008506: 7afb         	ldrb	r3, [r7, #0xb]
 8008508: 4619         	mov	r1, r3
 800850a: 4610         	mov	r0, r2
 800850c: f00d fc93    	bl	0x8015e36 <stm32_gpio_intc_get_pin_irq_line> @ imm = #0xd926
 8008510: 6178         	str	r0, [r7, #0x14]
; 	uint32_t irq_trigger = 0;
 8008512: 2300         	movs	r3, #0x0
 8008514: 627b         	str	r3, [r7, #0x24]
; 	int err = 0;
 8008516: 2300         	movs	r3, #0x0
 8008518: 623b         	str	r3, [r7, #0x20]
; 	if (mode == GPIO_INT_MODE_DISABLED) {
 800851a: 687b         	ldr	r3, [r7, #0x4]
 800851c: f5b3 1f00    	cmp.w	r3, #0x200000
 8008520: d108         	bne	0x8008534 <gpio_stm32_pin_interrupt_configure+0x50> @ imm = #0x10
; 		gpio_stm32_disable_pin_irqs(cfg->port, pin);
 8008522: 69fb         	ldr	r3, [r7, #0x1c]
 8008524: 689b         	ldr	r3, [r3, #0x8]
 8008526: 461a         	mov	r2, r3
 8008528: 7afb         	ldrb	r3, [r7, #0xb]
 800852a: 4619         	mov	r1, r3
 800852c: 4610         	mov	r0, r2
 800852e: f00f fbc6    	bl	0x8017cbe <gpio_stm32_disable_pin_irqs> @ imm = #0xf78c
; 		goto exit;
 8008532: e040         	b	0x80085b6 <gpio_stm32_pin_interrupt_configure+0xd2> @ imm = #0x80
; 	if (mode == GPIO_INT_MODE_LEVEL) {
 8008534: 687b         	ldr	r3, [r7, #0x4]
 8008536: f5b3 0f80    	cmp.w	r3, #0x400000
 800853a: d103         	bne	0x8008544 <gpio_stm32_pin_interrupt_configure+0x60> @ imm = #0x6
; 			err = -ENOTSUP;
 800853c: f06f 0385    	mvn	r3, #0x85
 8008540: 623b         	str	r3, [r7, #0x20]
; 			goto exit;
 8008542: e038         	b	0x80085b6 <gpio_stm32_pin_interrupt_configure+0xd2> @ imm = #0x70
; 		switch (trig) {
 8008544: 683b         	ldr	r3, [r7]
 8008546: f1b3 6fc0    	cmp.w	r3, #0x6000000
 800854a: d012         	beq	0x8008572 <gpio_stm32_pin_interrupt_configure+0x8e> @ imm = #0x24
 800854c: 683b         	ldr	r3, [r7]
 800854e: f1b3 6fc0    	cmp.w	r3, #0x6000000
 8008552: d811         	bhi	0x8008578 <gpio_stm32_pin_interrupt_configure+0x94> @ imm = #0x22
 8008554: 683b         	ldr	r3, [r7]
 8008556: f1b3 7f00    	cmp.w	r3, #0x2000000
 800855a: d004         	beq	0x8008566 <gpio_stm32_pin_interrupt_configure+0x82> @ imm = #0x8
 800855c: 683b         	ldr	r3, [r7]
 800855e: f1b3 6f80    	cmp.w	r3, #0x4000000
 8008562: d003         	beq	0x800856c <gpio_stm32_pin_interrupt_configure+0x88> @ imm = #0x6
 8008564: e008         	b	0x8008578 <gpio_stm32_pin_interrupt_configure+0x94> @ imm = #0x10
; 			irq_trigger = STM32_GPIO_IRQ_TRIG_FALLING;
 8008566: 2302         	movs	r3, #0x2
 8008568: 627b         	str	r3, [r7, #0x24]
; 			break;
 800856a: e009         	b	0x8008580 <gpio_stm32_pin_interrupt_configure+0x9c> @ imm = #0x12
; 			irq_trigger = STM32_GPIO_IRQ_TRIG_RISING;
 800856c: 2301         	movs	r3, #0x1
 800856e: 627b         	str	r3, [r7, #0x24]
; 			break;
 8008570: e006         	b	0x8008580 <gpio_stm32_pin_interrupt_configure+0x9c> @ imm = #0xc
; 			irq_trigger = STM32_GPIO_IRQ_TRIG_BOTH;
 8008572: 2303         	movs	r3, #0x3
 8008574: 627b         	str	r3, [r7, #0x24]
; 			break;
 8008576: e003         	b	0x8008580 <gpio_stm32_pin_interrupt_configure+0x9c> @ imm = #0x6
; 			err = -EINVAL;
 8008578: f06f 0315    	mvn	r3, #0x15
 800857c: 623b         	str	r3, [r7, #0x20]
; 			goto exit;
 800857e: e01a         	b	0x80085b6 <gpio_stm32_pin_interrupt_configure+0xd2> @ imm = #0x34
; 	if (stm32_gpio_intc_set_irq_callback(irq_line, gpio_stm32_isr, data) != 0) {
 8008580: 69ba         	ldr	r2, [r7, #0x18]
 8008582: 490f         	ldr	r1, [pc, #0x3c]         @ 0x80085c0 <gpio_stm32_pin_interrupt_configure+0xdc>
 8008584: 6978         	ldr	r0, [r7, #0x14]
 8008586: f7fe f86f    	bl	0x8006668 <stm32_gpio_intc_set_irq_callback> @ imm = #-0x1f22
 800858a: 4603         	mov	r3, r0
 800858c: 2b00         	cmp	r3, #0x0
 800858e: d003         	beq	0x8008598 <gpio_stm32_pin_interrupt_configure+0xb4> @ imm = #0x6
; 		err = -EBUSY;
 8008590: f06f 030f    	mvn	r3, #0xf
 8008594: 623b         	str	r3, [r7, #0x20]
; 		goto exit;
 8008596: e00e         	b	0x80085b6 <gpio_stm32_pin_interrupt_configure+0xd2> @ imm = #0x1c
; 	stm32_exti_set_line_src_port(pin, cfg->port);
 8008598: 69fb         	ldr	r3, [r7, #0x1c]
 800859a: 689b         	ldr	r3, [r3, #0x8]
 800859c: 461a         	mov	r2, r3
 800859e: 7afb         	ldrb	r3, [r7, #0xb]
 80085a0: 4611         	mov	r1, r2
 80085a2: 4618         	mov	r0, r3
 80085a4: f00d fc61    	bl	0x8015e6a <stm32_exti_set_line_src_port> @ imm = #0xd8c2
; 	stm32_gpio_intc_select_line_trigger(irq_line, irq_trigger);
 80085a8: 6a79         	ldr	r1, [r7, #0x24]
 80085aa: 6978         	ldr	r0, [r7, #0x14]
 80085ac: f7fe f820    	bl	0x80065f0 <stm32_gpio_intc_select_line_trigger> @ imm = #-0x1fc0
; 	stm32_gpio_intc_enable_line(irq_line);
 80085b0: 6978         	ldr	r0, [r7, #0x14]
 80085b2: f7fe f801    	bl	0x80065b8 <stm32_gpio_intc_enable_line> @ imm = #-0x1ffe
; 	return err;
 80085b6: 6a3b         	ldr	r3, [r7, #0x20]
; }
 80085b8: 4618         	mov	r0, r3
 80085ba: 3728         	adds	r7, #0x28
 80085bc: 46bd         	mov	sp, r7
 80085be: bd80         	pop	{r7, pc}

080085c0 <$d>:
 80085c0: 83 7b 01 08  	.word	0x08017b83

080085c4 <gpio_stm32_init>:
; {
 80085c4: b580         	push	{r7, lr}
 80085c6: b084         	sub	sp, #0x10
 80085c8: af00         	add	r7, sp, #0x0
 80085ca: 6078         	str	r0, [r7, #0x4]
; 	struct gpio_stm32_data *data = dev->data;
 80085cc: 687b         	ldr	r3, [r7, #0x4]
 80085ce: 691b         	ldr	r3, [r3, #0x10]
 80085d0: 60fb         	str	r3, [r7, #0xc]
; 	data->dev = dev;
 80085d2: 68fb         	ldr	r3, [r7, #0xc]
 80085d4: 687a         	ldr	r2, [r7, #0x4]
 80085d6: 605a         	str	r2, [r3, #0x4]
; 	if (!device_is_ready(DEVICE_DT_GET(STM32_CLOCK_CONTROL_NODE))) {
 80085d8: 480e         	ldr	r0, [pc, #0x38]         @ 0x8008614 <gpio_stm32_init+0x50>
 80085da: f00f f86c    	bl	0x80176b6 <device_is_ready> @ imm = #0xf0d8
 80085de: 4603         	mov	r3, r0
 80085e0: f083 0301    	eor	r3, r3, #0x1
 80085e4: b2db         	uxtb	r3, r3
 80085e6: 2b00         	cmp	r3, #0x0
 80085e8: d002         	beq	0x80085f0 <gpio_stm32_init+0x2c> @ imm = #0x4
; 		return -ENODEV;
 80085ea: f06f 0312    	mvn	r3, #0x12
 80085ee: e00d         	b	0x800860c <gpio_stm32_init+0x48> @ imm = #0x1a
; 	ret = gpio_stm32_clock_request(dev, !IS_ENABLED(CONFIG_PM_DEVICE_RUNTIME));
 80085f0: 2101         	movs	r1, #0x1
 80085f2: 6878         	ldr	r0, [r7, #0x4]
 80085f4: f7ff ff52    	bl	0x800849c <gpio_stm32_clock_request> @ imm = #-0x15c
 80085f8: 60b8         	str	r0, [r7, #0x8]
; 	if (ret < 0) {
 80085fa: 68bb         	ldr	r3, [r7, #0x8]
 80085fc: 2b00         	cmp	r3, #0x0
 80085fe: da01         	bge	0x8008604 <gpio_stm32_init+0x40> @ imm = #0x2
; 		return ret;
 8008600: 68bb         	ldr	r3, [r7, #0x8]
 8008602: e003         	b	0x800860c <gpio_stm32_init+0x48> @ imm = #0x6
; 	(void)pm_device_runtime_enable(dev);
 8008604: 6878         	ldr	r0, [r7, #0x4]
 8008606: f00f f9fc    	bl	0x8017a02 <pm_device_runtime_enable> @ imm = #0xf3f8
; 	return 0;
 800860a: 2300         	movs	r3, #0x0
; }
 800860c: 4618         	mov	r0, r3
 800860e: 3710         	adds	r7, #0x10
 8008610: 46bd         	mov	sp, r7
 8008612: bd80         	pop	{r7, pc}

08008614 <$d>:
 8008614: 28 dd 01 08  	.word	0x0801dd28

08008618 <stm32_pin_configure>:
; {
 8008618: b580         	push	{r7, lr}
 800861a: b086         	sub	sp, #0x18
 800861c: af00         	add	r7, sp, #0x0
 800861e: 60f8         	str	r0, [r7, #0xc]
 8008620: 60b9         	str	r1, [r7, #0x8]
 8008622: 607a         	str	r2, [r7, #0x4]
; 	if (STM32_PORT(pin) >= gpio_ports_cnt) {
 8008624: 68fb         	ldr	r3, [r7, #0xc]
 8008626: 091b         	lsrs	r3, r3, #0x4
 8008628: 2210         	movs	r2, #0x10
 800862a: 4293         	cmp	r3, r2
 800862c: d302         	blo	0x8008634 <stm32_pin_configure+0x1c> @ imm = #0x4
; 		return -EINVAL;
 800862e: f06f 0315    	mvn	r3, #0x15
 8008632: e01f         	b	0x8008674 <stm32_pin_configure+0x5c> @ imm = #0x3e
; 	port_device = gpio_ports[STM32_PORT(pin)];
 8008634: 68fb         	ldr	r3, [r7, #0xc]
 8008636: 091b         	lsrs	r3, r3, #0x4
 8008638: 4a10         	ldr	r2, [pc, #0x40]         @ 0x800867c <stm32_pin_configure+0x64>
 800863a: f852 3023    	ldr.w	r3, [r2, r3, lsl #2]
 800863e: 617b         	str	r3, [r7, #0x14]
; 	if ((port_device == NULL) || (!device_is_ready(port_device))) {
 8008640: 697b         	ldr	r3, [r7, #0x14]
 8008642: 2b00         	cmp	r3, #0x0
 8008644: d008         	beq	0x8008658 <stm32_pin_configure+0x40> @ imm = #0x10
 8008646: 6978         	ldr	r0, [r7, #0x14]
 8008648: f00f fd48    	bl	0x80180dc <device_is_ready> @ imm = #0xfa90
 800864c: 4603         	mov	r3, r0
 800864e: f083 0301    	eor	r3, r3, #0x1
 8008652: b2db         	uxtb	r3, r3
 8008654: 2b00         	cmp	r3, #0x0
 8008656: d002         	beq	0x800865e <stm32_pin_configure+0x46> @ imm = #0x4
; 		return -ENODEV;
 8008658: f06f 0312    	mvn	r3, #0x12
 800865c: e00a         	b	0x8008674 <stm32_pin_configure+0x5c> @ imm = #0x14
; 	return gpio_stm32_configure(port_device, STM32_PIN(pin), pin_cgf, pin_func);
 800865e: 68fb         	ldr	r3, [r7, #0xc]
 8008660: b2db         	uxtb	r3, r3
 8008662: f003 030f    	and	r3, r3, #0xf
 8008666: b2d9         	uxtb	r1, r3
 8008668: 687b         	ldr	r3, [r7, #0x4]
 800866a: 68ba         	ldr	r2, [r7, #0x8]
 800866c: 6978         	ldr	r0, [r7, #0x14]
 800866e: f00f fc2a    	bl	0x8017ec6 <gpio_stm32_configure> @ imm = #0xf854
 8008672: 4603         	mov	r3, r0
; }
 8008674: 4618         	mov	r0, r3
 8008676: 3718         	adds	r7, #0x18
 8008678: 46bd         	mov	sp, r7
 800867a: bd80         	pop	{r7, pc}

0800867c <$d>:
 800867c: 3c 02 02 08  	.word	0x0802023c

08008680 <bmi08x_bus_init_spi>:
; {
 8008680: b580         	push	{r7, lr}
 8008682: b08a         	sub	sp, #0x28
 8008684: af04         	add	r7, sp, #0x10
 8008686: 6078         	str	r0, [r7, #0x4]
; 	ret = bmi08x_accel_byte_read(dev, 0x7F, &val);
 8008688: f107 030b    	add.w	r3, r7, #0xb
 800868c: 461a         	mov	r2, r3
 800868e: 217f         	movs	r1, #0x7f
 8008690: 6878         	ldr	r0, [r7, #0x4]
 8008692: f010 f80f    	bl	0x80186b4 <bmi08x_accel_byte_read> @ imm = #0x1001e
 8008696: 6178         	str	r0, [r7, #0x14]
; 	if (ret < 0) {
 8008698: 697b         	ldr	r3, [r7, #0x14]
 800869a: 2b00         	cmp	r3, #0x0
 800869c: da1b         	bge	0x80086d6 <bmi08x_bus_init_spi+0x56> @ imm = #0x36
; 		LOG_ERR("Cannot read from 0x7F..");
 800869e: 2303         	movs	r3, #0x3
 80086a0: 2b00         	cmp	r3, #0x0
 80086a2: d016         	beq	0x80086d2 <bmi08x_bus_init_spi+0x52> @ imm = #0x2c
 80086a4: 2301         	movs	r3, #0x1
 80086a6: 74fb         	strb	r3, [r7, #0x13]
 80086a8: 7cfb         	ldrb	r3, [r7, #0x13]
 80086aa: f083 0301    	eor	r3, r3, #0x1
 80086ae: b2db         	uxtb	r3, r3
 80086b0: 2b00         	cmp	r3, #0x0
 80086b2: d10e         	bne	0x80086d2 <bmi08x_bus_init_spi+0x52> @ imm = #0x1c
 80086b4: 4b0c         	ldr	r3, [pc, #0x30]         @ 0x80086e8 <bmi08x_bus_init_spi+0x68>
 80086b6: 6819         	ldr	r1, [r3]
 80086b8: 4b0c         	ldr	r3, [pc, #0x30]         @ 0x80086ec <bmi08x_bus_init_spi+0x6c>
 80086ba: 9302         	str	r3, [sp, #0x8]
 80086bc: 2300         	movs	r3, #0x0
 80086be: 9301         	str	r3, [sp, #0x4]
 80086c0: 2300         	movs	r3, #0x0
 80086c2: 9300         	str	r3, [sp]
 80086c4: 2300         	movs	r3, #0x0
 80086c6: 2201         	movs	r2, #0x1
 80086c8: 2000         	movs	r0, #0x0
 80086ca: f00f fe66    	bl	0x801839a <z_log_msg_runtime_create> @ imm = #0xfccc
 80086ce: 2300         	movs	r3, #0x0
 80086d0: 60fb         	str	r3, [r7, #0xc]
; 		return ret;
 80086d2: 697b         	ldr	r3, [r7, #0x14]
 80086d4: e003         	b	0x80086de <bmi08x_bus_init_spi+0x5e> @ imm = #0x6
; 	k_usleep(100);
 80086d6: 2064         	movs	r0, #0x64
 80086d8: f00f fe41    	bl	0x801835e <k_usleep>    @ imm = #0xfc82
; 	return ret;
 80086dc: 697b         	ldr	r3, [r7, #0x14]
; }
 80086de: 4618         	mov	r0, r3
 80086e0: 3718         	adds	r7, #0x18
 80086e2: 46bd         	mov	sp, r7
 80086e4: bd80         	pop	{r7, pc}
 80086e6: bf00         	nop

080086e8 <$d>:
 80086e8: 08 05 00 20  	.word	0x20000508
 80086ec: e8 ee 01 08  	.word	0x0801eee8

080086f0 <bmi08x_acc_range_set>:
; {
 80086f0: e92d 4fb0    	push.w	{r4, r5, r7, r8, r9, r10, r11, lr}
 80086f4: b086         	sub	sp, #0x18
 80086f6: af00         	add	r7, sp, #0x0
 80086f8: 6078         	str	r0, [r7, #0x4]
 80086fa: 6039         	str	r1, [r7]
; 	struct bmi08x_accel_data *data = dev->data;
 80086fc: 687b         	ldr	r3, [r7, #0x4]
 80086fe: 691b         	ldr	r3, [r3, #0x10]
 8008700: 613b         	str	r3, [r7, #0x10]
; 	int32_t reg_val = -1;
 8008702: f04f 33ff    	mov.w	r3, #0xffffffff
 8008706: 617b         	str	r3, [r7, #0x14]
; 	if (data->accel_chip_id == BMI085_ACCEL_CHIP_ID) {
 8008708: 693b         	ldr	r3, [r7, #0x10]
 800870a: f893 3700    	ldrb.w	r3, [r3, #0x700]
 800870e: 2b1f         	cmp	r3, #0x1f
 8008710: d108         	bne	0x8008724 <bmi08x_acc_range_set+0x34> @ imm = #0x10
; 		reg_val = bmi08x_range_to_reg_val(range, bmi085_acc_range_map,
 8008712: 683b         	ldr	r3, [r7]
 8008714: b29b         	uxth	r3, r3
 8008716: 2204         	movs	r2, #0x4
 8008718: 492b         	ldr	r1, [pc, #0xac]         @ 0x80087c8 <bmi08x_acc_range_set+0xd8>
 800871a: 4618         	mov	r0, r3
 800871c: f010 fb3d    	bl	0x8018d9a <bmi08x_range_to_reg_val> @ imm = #0x1067a
 8008720: 6178         	str	r0, [r7, #0x14]
 8008722: e010         	b	0x8008746 <bmi08x_acc_range_set+0x56> @ imm = #0x20
; 	} else if (data->accel_chip_id == BMI088_ACCEL_CHIP_ID) {
 8008724: 693b         	ldr	r3, [r7, #0x10]
 8008726: f893 3700    	ldrb.w	r3, [r3, #0x700]
 800872a: 2b1e         	cmp	r3, #0x1e
 800872c: d108         	bne	0x8008740 <bmi08x_acc_range_set+0x50> @ imm = #0x10
; 		reg_val = bmi08x_range_to_reg_val(range, bmi088_acc_range_map,
 800872e: 683b         	ldr	r3, [r7]
 8008730: b29b         	uxth	r3, r3
 8008732: 2204         	movs	r2, #0x4
 8008734: 4925         	ldr	r1, [pc, #0x94]         @ 0x80087cc <bmi08x_acc_range_set+0xdc>
 8008736: 4618         	mov	r0, r3
 8008738: f010 fb2f    	bl	0x8018d9a <bmi08x_range_to_reg_val> @ imm = #0x1065e
 800873c: 6178         	str	r0, [r7, #0x14]
 800873e: e002         	b	0x8008746 <bmi08x_acc_range_set+0x56> @ imm = #0x4
; 		return -ENODEV;
 8008740: f06f 0312    	mvn	r3, #0x12
 8008744: e03b         	b	0x80087be <bmi08x_acc_range_set+0xce> @ imm = #0x76
; 	if (reg_val < 0) {
 8008746: 697b         	ldr	r3, [r7, #0x14]
 8008748: 2b00         	cmp	r3, #0x0
 800874a: da01         	bge	0x8008750 <bmi08x_acc_range_set+0x60> @ imm = #0x2
; 		return reg_val;
 800874c: 697b         	ldr	r3, [r7, #0x14]
 800874e: e036         	b	0x80087be <bmi08x_acc_range_set+0xce> @ imm = #0x6c
; 	ret = bmi08x_accel_byte_write(dev, BMI08X_REG_ACCEL_RANGE, reg_val & 0xff);
 8008750: 697b         	ldr	r3, [r7, #0x14]
 8008752: b2db         	uxtb	r3, r3
 8008754: 461a         	mov	r2, r3
 8008756: 2141         	movs	r1, #0x41
 8008758: 6878         	ldr	r0, [r7, #0x4]
 800875a: f00f ffe3    	bl	0x8018724 <bmi08x_accel_byte_write> @ imm = #0xffc6
 800875e: 60f8         	str	r0, [r7, #0xc]
; 	if (ret < 0) {
 8008760: 68fb         	ldr	r3, [r7, #0xc]
 8008762: 2b00         	cmp	r3, #0x0
 8008764: da01         	bge	0x800876a <bmi08x_acc_range_set+0x7a> @ imm = #0x2
; 		return ret;
 8008766: 68fb         	ldr	r3, [r7, #0xc]
 8008768: e029         	b	0x80087be <bmi08x_acc_range_set+0xce> @ imm = #0x52
; 	data->scale = BMI08X_ACC_SCALE(range);
 800876a: 683b         	ldr	r3, [r7]
 800876c: 17da         	asrs	r2, r3, #0x1f
 800876e: 4698         	mov	r8, r3
 8008770: 4691         	mov	r9, r2
 8008772: 4b17         	ldr	r3, [pc, #0x5c]         @ 0x80087d0 <bmi08x_acc_range_set+0xe0>
 8008774: fb03 f209    	mul	r2, r3, r9
 8008778: 2300         	movs	r3, #0x0
 800877a: fb03 f308    	mul	r3, r3, r8
 800877e: 4413         	add	r3, r2
 8008780: 4a13         	ldr	r2, [pc, #0x4c]         @ 0x80087d0 <bmi08x_acc_range_set+0xe0>
 8008782: fba8 4502    	umull	r4, r5, r8, r2
 8008786: 442b         	add	r3, r5
 8008788: 461d         	mov	r5, r3
 800878a: 4622         	mov	r2, r4
 800878c: 462b         	mov	r3, r5
 800878e: 2b00         	cmp	r3, #0x0
 8008790: da07         	bge	0x80087a2 <bmi08x_acc_range_set+0xb2> @ imm = #0xe
 8008792: f64f 71ff    	movw	r1, #0xffff
 8008796: eb12 0a01    	adds.w	r10, r2, r1
 800879a: f143 0b00    	adc	r11, r3, #0x0
 800879e: 4652         	mov	r2, r10
 80087a0: 465b         	mov	r3, r11
 80087a2: f04f 0000    	mov.w	r0, #0x0
 80087a6: f04f 0100    	mov.w	r1, #0x0
 80087aa: 0c10         	lsrs	r0, r2, #0x10
 80087ac: ea40 4003    	orr.w	r0, r0, r3, lsl #16
 80087b0: 1419         	asrs	r1, r3, #0x10
 80087b2: 4602         	mov	r2, r0
 80087b4: 460b         	mov	r3, r1
 80087b6: b292         	uxth	r2, r2
 80087b8: 693b         	ldr	r3, [r7, #0x10]
 80087ba: 825a         	strh	r2, [r3, #0x12]
; 	return ret;
 80087bc: 68fb         	ldr	r3, [r7, #0xc]
; }
 80087be: 4618         	mov	r0, r3
 80087c0: 3718         	adds	r7, #0x18
 80087c2: 46bd         	mov	sp, r7
 80087c4: e8bd 8fb0    	pop.w	{r4, r5, r7, r8, r9, r10, r11, pc}

080087c8 <$d>:
 80087c8: 8c 02 02 08  	.word	0x0802028c
 80087cc: 9c 02 02 08  	.word	0x0802029c
 80087d0: 74 46 2b 01  	.word	0x012b4674

080087d4 <bmi08x_acc_config>:
; {
 80087d4: b580         	push	{r7, lr}
 80087d6: b08a         	sub	sp, #0x28
 80087d8: af04         	add	r7, sp, #0x10
 80087da: 60f8         	str	r0, [r7, #0xc]
 80087dc: 607b         	str	r3, [r7, #0x4]
 80087de: 460b         	mov	r3, r1
 80087e0: 817b         	strh	r3, [r7, #0xa]
 80087e2: 4613         	mov	r3, r2
 80087e4: 813b         	strh	r3, [r7, #0x8]
; 	switch (attr) {
 80087e6: 893b         	ldrh	r3, [r7, #0x8]
 80087e8: 2b00         	cmp	r3, #0x0
 80087ea: d00b         	beq	0x8008804 <bmi08x_acc_config+0x30> @ imm = #0x16
 80087ec: 2b07         	cmp	r3, #0x7
 80087ee: d11b         	bne	0x8008828 <bmi08x_acc_config+0x54> @ imm = #0x36
; 		return bmi08x_acc_range_set(dev, sensor_ms2_to_g(val));
 80087f0: 6878         	ldr	r0, [r7, #0x4]
 80087f2: f7f8 f985    	bl	0x8000b00 <sensor_ms2_to_g> @ imm = #-0x7cf6
 80087f6: 4603         	mov	r3, r0
 80087f8: 4619         	mov	r1, r3
 80087fa: 68f8         	ldr	r0, [r7, #0xc]
 80087fc: f7ff ff78    	bl	0x80086f0 <bmi08x_acc_range_set> @ imm = #-0x110
 8008800: 4603         	mov	r3, r0
 8008802: e02f         	b	0x8008864 <bmi08x_acc_config+0x90> @ imm = #0x5e
; 		return bmi08x_acc_odr_set(dev, val->val1, val->val2 / 1000);
 8008804: 687b         	ldr	r3, [r7, #0x4]
 8008806: 681b         	ldr	r3, [r3]
 8008808: b299         	uxth	r1, r3
 800880a: 687b         	ldr	r3, [r7, #0x4]
 800880c: 685b         	ldr	r3, [r3, #0x4]
 800880e: 4a17         	ldr	r2, [pc, #0x5c]         @ 0x800886c <bmi08x_acc_config+0x98>
 8008810: fb82 0203    	smull	r0, r2, r2, r3
 8008814: 1192         	asrs	r2, r2, #0x6
 8008816: 17db         	asrs	r3, r3, #0x1f
 8008818: 1ad3         	subs	r3, r2, r3
 800881a: b29b         	uxth	r3, r3
 800881c: 461a         	mov	r2, r3
 800881e: 68f8         	ldr	r0, [r7, #0xc]
 8008820: f00f ffd0    	bl	0x80187c4 <bmi08x_acc_odr_set> @ imm = #0xffa0
 8008824: 4603         	mov	r3, r0
 8008826: e01d         	b	0x8008864 <bmi08x_acc_config+0x90> @ imm = #0x3a
; 		LOG_DBG("Accel attribute not supported.");
 8008828: 2303         	movs	r3, #0x3
 800882a: 2b03         	cmp	r3, #0x3
 800882c: d918         	bls	0x8008860 <bmi08x_acc_config+0x8c> @ imm = #0x30
 800882e: 2301         	movs	r3, #0x1
 8008830: 75fb         	strb	r3, [r7, #0x17]
 8008832: 7dfb         	ldrb	r3, [r7, #0x17]
 8008834: f083 0301    	eor	r3, r3, #0x1
 8008838: b2db         	uxtb	r3, r3
 800883a: 2b00         	cmp	r3, #0x0
 800883c: d110         	bne	0x8008860 <bmi08x_acc_config+0x8c> @ imm = #0x20
 800883e: 4b0c         	ldr	r3, [pc, #0x30]         @ 0x8008870 <bmi08x_acc_config+0x9c>
 8008840: 6819         	ldr	r1, [r3]
 8008842: 4b0c         	ldr	r3, [pc, #0x30]         @ 0x8008874 <bmi08x_acc_config+0xa0>
 8008844: 9303         	str	r3, [sp, #0xc]
 8008846: 4b0c         	ldr	r3, [pc, #0x30]         @ 0x8008878 <bmi08x_acc_config+0xa4>
 8008848: 9302         	str	r3, [sp, #0x8]
 800884a: 2308         	movs	r3, #0x8
 800884c: 9301         	str	r3, [sp, #0x4]
 800884e: 2300         	movs	r3, #0x0
 8008850: 9300         	str	r3, [sp]
 8008852: 2300         	movs	r3, #0x0
 8008854: 2204         	movs	r2, #0x4
 8008856: 2000         	movs	r0, #0x0
 8008858: f00f fd9f    	bl	0x801839a <z_log_msg_runtime_create> @ imm = #0xfb3e
 800885c: 2300         	movs	r3, #0x0
 800885e: 613b         	str	r3, [r7, #0x10]
; 		return -ENOTSUP;
 8008860: f06f 0385    	mvn	r3, #0x85
; }
 8008864: 4618         	mov	r0, r3
 8008866: 3718         	adds	r7, #0x18
 8008868: 46bd         	mov	sp, r7
 800886a: bd80         	pop	{r7, pc}

0800886c <$d>:
 800886c: d3 4d 62 10  	.word	0x10624dd3
 8008870: 08 05 00 20  	.word	0x20000508
 8008874: d8 02 02 08  	.word	0x080202d8
 8008878: 00 ef 01 08  	.word	0x0801ef00

0800887c <bmi08x_attr_set>:
; {
 800887c: b580         	push	{r7, lr}
 800887e: b08a         	sub	sp, #0x28
 8008880: af04         	add	r7, sp, #0x10
 8008882: 60f8         	str	r0, [r7, #0xc]
 8008884: 607b         	str	r3, [r7, #0x4]
 8008886: 460b         	mov	r3, r1
 8008888: 817b         	strh	r3, [r7, #0xa]
 800888a: 4613         	mov	r3, r2
 800888c: 813b         	strh	r3, [r7, #0x8]
; 	switch (chan) {
 800888e: 897b         	ldrh	r3, [r7, #0xa]
 8008890: 2b03         	cmp	r3, #0x3
 8008892: d807         	bhi	0x80088a4 <bmi08x_attr_set+0x28> @ imm = #0xe
; 		return bmi08x_acc_config(dev, chan, attr, val);
 8008894: 893a         	ldrh	r2, [r7, #0x8]
 8008896: 8979         	ldrh	r1, [r7, #0xa]
 8008898: 687b         	ldr	r3, [r7, #0x4]
 800889a: 68f8         	ldr	r0, [r7, #0xc]
 800889c: f7ff ff9a    	bl	0x80087d4 <bmi08x_acc_config> @ imm = #-0xcc
 80088a0: 4603         	mov	r3, r0
 80088a2: e01d         	b	0x80088e0 <bmi08x_attr_set+0x64> @ imm = #0x3a
; 		LOG_DBG("attr_set() not supported on this channel.");
 80088a4: 2303         	movs	r3, #0x3
 80088a6: 2b03         	cmp	r3, #0x3
 80088a8: d918         	bls	0x80088dc <bmi08x_attr_set+0x60> @ imm = #0x30
 80088aa: 2301         	movs	r3, #0x1
 80088ac: 75fb         	strb	r3, [r7, #0x17]
 80088ae: 7dfb         	ldrb	r3, [r7, #0x17]
 80088b0: f083 0301    	eor	r3, r3, #0x1
 80088b4: b2db         	uxtb	r3, r3
 80088b6: 2b00         	cmp	r3, #0x0
 80088b8: d110         	bne	0x80088dc <bmi08x_attr_set+0x60> @ imm = #0x20
 80088ba: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x80088e8 <bmi08x_attr_set+0x6c>
 80088bc: 6819         	ldr	r1, [r3]
 80088be: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x80088ec <bmi08x_attr_set+0x70>
 80088c0: 9303         	str	r3, [sp, #0xc]
 80088c2: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x80088f0 <bmi08x_attr_set+0x74>
 80088c4: 9302         	str	r3, [sp, #0x8]
 80088c6: 2308         	movs	r3, #0x8
 80088c8: 9301         	str	r3, [sp, #0x4]
 80088ca: 2300         	movs	r3, #0x0
 80088cc: 9300         	str	r3, [sp]
 80088ce: 2300         	movs	r3, #0x0
 80088d0: 2204         	movs	r2, #0x4
 80088d2: 2000         	movs	r0, #0x0
 80088d4: f00f fd61    	bl	0x801839a <z_log_msg_runtime_create> @ imm = #0xfac2
 80088d8: 2300         	movs	r3, #0x0
 80088da: 613b         	str	r3, [r7, #0x10]
; 		return -ENOTSUP;
 80088dc: f06f 0385    	mvn	r3, #0x85
; }
 80088e0: 4618         	mov	r0, r3
 80088e2: 3718         	adds	r7, #0x18
 80088e4: 46bd         	mov	sp, r7
 80088e6: bd80         	pop	{r7, pc}

080088e8 <$d>:
 80088e8: 08 05 00 20  	.word	0x20000508
 80088ec: ec 02 02 08  	.word	0x080202ec
 80088f0: 24 ef 01 08  	.word	0x0801ef24

080088f4 <bmi08x_sample_fetch>:
; {
 80088f4: b580         	push	{r7, lr}
 80088f6: b08c         	sub	sp, #0x30
 80088f8: af04         	add	r7, sp, #0x10
 80088fa: 6078         	str	r0, [r7, #0x4]
 80088fc: 460b         	mov	r3, r1
 80088fe: 807b         	strh	r3, [r7, #0x2]
; 	struct bmi08x_accel_data *data = dev->data;
 8008900: 687b         	ldr	r3, [r7, #0x4]
 8008902: 691b         	ldr	r3, [r3, #0x10]
 8008904: 61bb         	str	r3, [r7, #0x18]
; 	if (chan != SENSOR_CHAN_ALL && chan != SENSOR_CHAN_ACCEL_XYZ) {
 8008906: 887b         	ldrh	r3, [r7, #0x2]
 8008908: 2b3c         	cmp	r3, #0x3c
 800890a: d021         	beq	0x8008950 <bmi08x_sample_fetch+0x5c> @ imm = #0x42
 800890c: 887b         	ldrh	r3, [r7, #0x2]
 800890e: 2b03         	cmp	r3, #0x3
 8008910: d01e         	beq	0x8008950 <bmi08x_sample_fetch+0x5c> @ imm = #0x3c
; 		LOG_DBG("Unsupported sensor channel");
 8008912: 2303         	movs	r3, #0x3
 8008914: 2b03         	cmp	r3, #0x3
 8008916: d918         	bls	0x800894a <bmi08x_sample_fetch+0x56> @ imm = #0x30
 8008918: 2301         	movs	r3, #0x1
 800891a: 75fb         	strb	r3, [r7, #0x17]
 800891c: 7dfb         	ldrb	r3, [r7, #0x17]
 800891e: f083 0301    	eor	r3, r3, #0x1
 8008922: b2db         	uxtb	r3, r3
 8008924: 2b00         	cmp	r3, #0x0
 8008926: d110         	bne	0x800894a <bmi08x_sample_fetch+0x56> @ imm = #0x20
 8008928: 4b22         	ldr	r3, [pc, #0x88]         @ 0x80089b4 <bmi08x_sample_fetch+0xc0>
 800892a: 6819         	ldr	r1, [r3]
 800892c: 4b22         	ldr	r3, [pc, #0x88]         @ 0x80089b8 <bmi08x_sample_fetch+0xc4>
 800892e: 9303         	str	r3, [sp, #0xc]
 8008930: 4b22         	ldr	r3, [pc, #0x88]         @ 0x80089bc <bmi08x_sample_fetch+0xc8>
 8008932: 9302         	str	r3, [sp, #0x8]
 8008934: 2308         	movs	r3, #0x8
 8008936: 9301         	str	r3, [sp, #0x4]
 8008938: 2300         	movs	r3, #0x0
 800893a: 9300         	str	r3, [sp]
 800893c: 2300         	movs	r3, #0x0
 800893e: 2204         	movs	r2, #0x4
 8008940: 2000         	movs	r0, #0x0
 8008942: f00f fd2a    	bl	0x801839a <z_log_msg_runtime_create> @ imm = #0xfa54
 8008946: 2300         	movs	r3, #0x0
 8008948: 613b         	str	r3, [r7, #0x10]
; 		return -ENOTSUP;
 800894a: f06f 0385    	mvn	r3, #0x85
 800894e: e02d         	b	0x80089ac <bmi08x_sample_fetch+0xb8> @ imm = #0x5a
; 	pm_device_busy_set(dev);
 8008950: 6878         	ldr	r0, [r7, #0x4]
 8008952: f00f fd10    	bl	0x8018376 <pm_device_busy_set> @ imm = #0xfa20
; 	ret = bmi08x_accel_read(dev, BMI08X_REG_ACCEL_X_LSB, (uint8_t *)data->acc_sample,
 8008956: 69bb         	ldr	r3, [r7, #0x18]
 8008958: f103 020c    	add.w	r2, r3, #0xc
 800895c: 2306         	movs	r3, #0x6
 800895e: 2112         	movs	r1, #0x12
 8008960: 6878         	ldr	r0, [r7, #0x4]
 8008962: f00f fe8d    	bl	0x8018680 <bmi08x_accel_read> @ imm = #0xfd1a
 8008966: 60f8         	str	r0, [r7, #0xc]
; 	if (ret < 0) {
 8008968: 68fb         	ldr	r3, [r7, #0xc]
 800896a: 2b00         	cmp	r3, #0x0
 800896c: da04         	bge	0x8008978 <bmi08x_sample_fetch+0x84> @ imm = #0x8
; 		pm_device_busy_clear(dev);
 800896e: 6878         	ldr	r0, [r7, #0x4]
 8008970: f00f fd0a    	bl	0x8018388 <pm_device_busy_clear> @ imm = #0xfa14
; 		return ret;
 8008974: 68fb         	ldr	r3, [r7, #0xc]
 8008976: e019         	b	0x80089ac <bmi08x_sample_fetch+0xb8> @ imm = #0x32
; 	for (i = 0; i < ARRAY_SIZE(data->acc_sample); i++) {
 8008978: 2300         	movs	r3, #0x0
 800897a: 61fb         	str	r3, [r7, #0x1c]
 800897c: e00f         	b	0x800899e <bmi08x_sample_fetch+0xaa> @ imm = #0x1e
; 		data->acc_sample[i] = sys_le16_to_cpu(data->acc_sample[i]);
 800897e: 69ba         	ldr	r2, [r7, #0x18]
 8008980: 69fb         	ldr	r3, [r7, #0x1c]
 8008982: 3304         	adds	r3, #0x4
 8008984: 005b         	lsls	r3, r3, #0x1
 8008986: 4413         	add	r3, r2
 8008988: 8899         	ldrh	r1, [r3, #0x4]
 800898a: 69ba         	ldr	r2, [r7, #0x18]
 800898c: 69fb         	ldr	r3, [r7, #0x1c]
 800898e: 3304         	adds	r3, #0x4
 8008990: 005b         	lsls	r3, r3, #0x1
 8008992: 4413         	add	r3, r2
 8008994: 460a         	mov	r2, r1
 8008996: 809a         	strh	r2, [r3, #0x4]
; 	for (i = 0; i < ARRAY_SIZE(data->acc_sample); i++) {
 8008998: 69fb         	ldr	r3, [r7, #0x1c]
 800899a: 3301         	adds	r3, #0x1
 800899c: 61fb         	str	r3, [r7, #0x1c]
 800899e: 69fb         	ldr	r3, [r7, #0x1c]
 80089a0: 2b02         	cmp	r3, #0x2
 80089a2: d9ec         	bls	0x800897e <bmi08x_sample_fetch+0x8a> @ imm = #-0x28
; 	pm_device_busy_clear(dev);
 80089a4: 6878         	ldr	r0, [r7, #0x4]
 80089a6: f00f fcef    	bl	0x8018388 <pm_device_busy_clear> @ imm = #0xf9de
; 	return ret;
 80089aa: 68fb         	ldr	r3, [r7, #0xc]
; }
 80089ac: 4618         	mov	r0, r3
 80089ae: 3720         	adds	r7, #0x20
 80089b0: 46bd         	mov	sp, r7
 80089b2: bd80         	pop	{r7, pc}

080089b4 <$d>:
 80089b4: 08 05 00 20  	.word	0x20000508
 80089b8: fc 02 02 08  	.word	0x080202fc
 80089bc: 54 ef 01 08  	.word	0x0801ef54

080089c0 <bmi08x_to_fixed_point>:
; {
 80089c0: b480         	push	{r7}
 80089c2: b085         	sub	sp, #0x14
 80089c4: af00         	add	r7, sp, #0x0
 80089c6: 4603         	mov	r3, r0
 80089c8: 603a         	str	r2, [r7]
 80089ca: 80fb         	strh	r3, [r7, #0x6]
 80089cc: 460b         	mov	r3, r1
 80089ce: 80bb         	strh	r3, [r7, #0x4]
; 	converted_val = raw_val * scale;
 80089d0: f9b7 3006    	ldrsh.w	r3, [r7, #0x6]
 80089d4: 88ba         	ldrh	r2, [r7, #0x4]
 80089d6: fb02 f303    	mul	r3, r2, r3
 80089da: 60fb         	str	r3, [r7, #0xc]
; 	val->val1 = converted_val / 1000000;
 80089dc: 68fb         	ldr	r3, [r7, #0xc]
 80089de: 4a0d         	ldr	r2, [pc, #0x34]         @ 0x8008a14 <bmi08x_to_fixed_point+0x54>
 80089e0: fb82 1203    	smull	r1, r2, r2, r3
 80089e4: 1492         	asrs	r2, r2, #0x12
 80089e6: 17db         	asrs	r3, r3, #0x1f
 80089e8: 1ad2         	subs	r2, r2, r3
 80089ea: 683b         	ldr	r3, [r7]
 80089ec: 601a         	str	r2, [r3]
; 	val->val2 = converted_val % 1000000;
 80089ee: 68fa         	ldr	r2, [r7, #0xc]
 80089f0: 4b08         	ldr	r3, [pc, #0x20]         @ 0x8008a14 <bmi08x_to_fixed_point+0x54>
 80089f2: fb83 1302    	smull	r1, r3, r3, r2
 80089f6: 1499         	asrs	r1, r3, #0x12
 80089f8: 17d3         	asrs	r3, r2, #0x1f
 80089fa: 1acb         	subs	r3, r1, r3
 80089fc: 4906         	ldr	r1, [pc, #0x18]         @ 0x8008a18 <bmi08x_to_fixed_point+0x58>
 80089fe: fb01 f303    	mul	r3, r1, r3
 8008a02: 1ad3         	subs	r3, r2, r3
 8008a04: 683a         	ldr	r2, [r7]
 8008a06: 6053         	str	r3, [r2, #0x4]
; }
 8008a08: bf00         	nop
 8008a0a: 3714         	adds	r7, #0x14
 8008a0c: 46bd         	mov	sp, r7
 8008a0e: bc80         	pop	{r7}
 8008a10: 4770         	bx	lr
 8008a12: bf00         	nop

08008a14 <$d>:
 8008a14: 83 de 1b 43  	.word	0x431bde83
 8008a18: 40 42 0f 00  	.word	0x000f4240

08008a1c <bmi08x_temp_channel_get>:
; {
 8008a1c: e92d 43b0    	push.w	{r4, r5, r7, r8, r9, lr}
 8008a20: b090         	sub	sp, #0x40
 8008a22: af04         	add	r7, sp, #0x10
 8008a24: 6078         	str	r0, [r7, #0x4]
 8008a26: 6039         	str	r1, [r7]
; 	uint16_t temp_raw = 0U;
 8008a28: 2300         	movs	r3, #0x0
 8008a2a: 817b         	strh	r3, [r7, #0xa]
; 	int32_t temp_micro = 0;
 8008a2c: 2300         	movs	r3, #0x0
 8008a2e: 62bb         	str	r3, [r7, #0x28]
; 	int16_t temp_int11 = 0;
 8008a30: 2300         	movs	r3, #0x0
 8008a32: 85fb         	strh	r3, [r7, #0x2e]
; 	ret = bmi08x_accel_word_read(dev, BMI08X_REG_TEMP_MSB, &temp_raw);
 8008a34: f107 030a    	add.w	r3, r7, #0xa
 8008a38: 461a         	mov	r2, r3
 8008a3a: 2122         	movs	r1, #0x22
 8008a3c: 6878         	ldr	r0, [r7, #0x4]
 8008a3e: f00f fe50    	bl	0x80186e2 <bmi08x_accel_word_read> @ imm = #0xfca0
 8008a42: 6278         	str	r0, [r7, #0x24]
; 	if (!ret) {
 8008a44: 6a7b         	ldr	r3, [r7, #0x24]
 8008a46: 2b00         	cmp	r3, #0x0
 8008a48: d109         	bne	0x8008a5e <bmi08x_temp_channel_get+0x42> @ imm = #0x12
; 		temp_int11 = (temp_raw & 0xFF) << 3;
 8008a4a: 897b         	ldrh	r3, [r7, #0xa]
 8008a4c: 00db         	lsls	r3, r3, #0x3
 8008a4e: b21b         	sxth	r3, r3
 8008a50: f403 63ff    	and	r3, r3, #0x7f8
 8008a54: 85fb         	strh	r3, [r7, #0x2e]
; 	if (temp_raw == 0x80) {
 8008a56: 897b         	ldrh	r3, [r7, #0xa]
 8008a58: 2b80         	cmp	r3, #0x80
 8008a5a: d13d         	bne	0x8008ad8 <bmi08x_temp_channel_get+0xbc> @ imm = #0x7a
 8008a5c: e01f         	b	0x8008a9e <bmi08x_temp_channel_get+0x82> @ imm = #0x3e
; 		LOG_ERR("Error reading BMI08X_REG_TEMP_MSB. (err %d)", ret);
 8008a5e: 2303         	movs	r3, #0x3
 8008a60: 2b00         	cmp	r3, #0x0
 8008a62: d01a         	beq	0x8008a9a <bmi08x_temp_channel_get+0x7e> @ imm = #0x34
 8008a64: 2301         	movs	r3, #0x1
 8008a66: f887 3023    	strb.w	r3, [r7, #0x23]
 8008a6a: f897 3023    	ldrb.w	r3, [r7, #0x23]
 8008a6e: f083 0301    	eor	r3, r3, #0x1
 8008a72: b2db         	uxtb	r3, r3
 8008a74: 2b00         	cmp	r3, #0x0
 8008a76: d110         	bne	0x8008a9a <bmi08x_temp_channel_get+0x7e> @ imm = #0x20
 8008a78: 4b4c         	ldr	r3, [pc, #0x130]        @ 0x8008bac <bmi08x_temp_channel_get+0x190>
 8008a7a: 6819         	ldr	r1, [r3]
 8008a7c: 6a7b         	ldr	r3, [r7, #0x24]
 8008a7e: 9303         	str	r3, [sp, #0xc]
 8008a80: 4b4b         	ldr	r3, [pc, #0x12c]        @ 0x8008bb0 <bmi08x_temp_channel_get+0x194>
 8008a82: 9302         	str	r3, [sp, #0x8]
 8008a84: 2300         	movs	r3, #0x0
 8008a86: 9301         	str	r3, [sp, #0x4]
 8008a88: 2300         	movs	r3, #0x0
 8008a8a: 9300         	str	r3, [sp]
 8008a8c: 2300         	movs	r3, #0x0
 8008a8e: 2201         	movs	r2, #0x1
 8008a90: 2000         	movs	r0, #0x0
 8008a92: f00f fc82    	bl	0x801839a <z_log_msg_runtime_create> @ imm = #0xf904
 8008a96: 2300         	movs	r3, #0x0
 8008a98: 61fb         	str	r3, [r7, #0x1c]
; 		return ret;
 8008a9a: 6a7b         	ldr	r3, [r7, #0x24]
 8008a9c: e080         	b	0x8008ba0 <bmi08x_temp_channel_get+0x184> @ imm = #0x100
; 		LOG_ERR("BMI08X returned invalid temperature.");
 8008a9e: 2303         	movs	r3, #0x3
 8008aa0: 2b00         	cmp	r3, #0x0
 8008aa2: d016         	beq	0x8008ad2 <bmi08x_temp_channel_get+0xb6> @ imm = #0x2c
 8008aa4: 2301         	movs	r3, #0x1
 8008aa6: 74fb         	strb	r3, [r7, #0x13]
 8008aa8: 7cfb         	ldrb	r3, [r7, #0x13]
 8008aaa: f083 0301    	eor	r3, r3, #0x1
 8008aae: b2db         	uxtb	r3, r3
 8008ab0: 2b00         	cmp	r3, #0x0
 8008ab2: d10e         	bne	0x8008ad2 <bmi08x_temp_channel_get+0xb6> @ imm = #0x1c
 8008ab4: 4b3d         	ldr	r3, [pc, #0xf4]         @ 0x8008bac <bmi08x_temp_channel_get+0x190>
 8008ab6: 6819         	ldr	r1, [r3]
 8008ab8: 4b3e         	ldr	r3, [pc, #0xf8]         @ 0x8008bb4 <bmi08x_temp_channel_get+0x198>
 8008aba: 9302         	str	r3, [sp, #0x8]
 8008abc: 2300         	movs	r3, #0x0
 8008abe: 9301         	str	r3, [sp, #0x4]
 8008ac0: 2300         	movs	r3, #0x0
 8008ac2: 9300         	str	r3, [sp]
 8008ac4: 2300         	movs	r3, #0x0
 8008ac6: 2201         	movs	r2, #0x1
 8008ac8: 2000         	movs	r0, #0x0
 8008aca: f00f fc66    	bl	0x801839a <z_log_msg_runtime_create> @ imm = #0xf8cc
 8008ace: 2300         	movs	r3, #0x0
 8008ad0: 60fb         	str	r3, [r7, #0xc]
; 		return -ENODATA;
 8008ad2: f06f 033c    	mvn	r3, #0x3c
 8008ad6: e063         	b	0x8008ba0 <bmi08x_temp_channel_get+0x184> @ imm = #0xc6
; 	ret = bmi08x_accel_word_read(dev, BMI08X_REG_TEMP_LSB, &temp_raw);
 8008ad8: f107 030a    	add.w	r3, r7, #0xa
 8008adc: 461a         	mov	r2, r3
 8008ade: 2123         	movs	r1, #0x23
 8008ae0: 6878         	ldr	r0, [r7, #0x4]
 8008ae2: f00f fdfe    	bl	0x80186e2 <bmi08x_accel_word_read> @ imm = #0xfbfc
 8008ae6: 6278         	str	r0, [r7, #0x24]
; 	if (!ret) {
 8008ae8: 6a7b         	ldr	r3, [r7, #0x24]
 8008aea: 2b00         	cmp	r3, #0x0
 8008aec: d10e         	bne	0x8008b0c <bmi08x_temp_channel_get+0xf0> @ imm = #0x1c
; 		temp_int11 |= (temp_raw & 0xE0) >> 5;
 8008aee: 897b         	ldrh	r3, [r7, #0xa]
 8008af0: 115b         	asrs	r3, r3, #0x5
 8008af2: b21b         	sxth	r3, r3
 8008af4: f003 0307    	and	r3, r3, #0x7
 8008af8: b21a         	sxth	r2, r3
 8008afa: 8dfb         	ldrh	r3, [r7, #0x2e]
 8008afc: 4313         	orrs	r3, r2
 8008afe: 85fb         	strh	r3, [r7, #0x2e]
; 	if (temp_int11 > 1023) {
 8008b00: f9b7 302e    	ldrsh.w	r3, [r7, #0x2e]
 8008b04: f5b3 6f80    	cmp.w	r3, #0x400
 8008b08: db23         	blt	0x8008b52 <bmi08x_temp_channel_get+0x136> @ imm = #0x46
 8008b0a: e01d         	b	0x8008b48 <bmi08x_temp_channel_get+0x12c> @ imm = #0x3a
; 		LOG_ERR("Error reading BMI08X_REG_TEMP_LSB. (err %d)", ret);
 8008b0c: 2303         	movs	r3, #0x3
 8008b0e: 2b00         	cmp	r3, #0x0
 8008b10: d018         	beq	0x8008b44 <bmi08x_temp_channel_get+0x128> @ imm = #0x30
 8008b12: 2301         	movs	r3, #0x1
 8008b14: 76fb         	strb	r3, [r7, #0x1b]
 8008b16: 7efb         	ldrb	r3, [r7, #0x1b]
 8008b18: f083 0301    	eor	r3, r3, #0x1
 8008b1c: b2db         	uxtb	r3, r3
 8008b1e: 2b00         	cmp	r3, #0x0
 8008b20: d110         	bne	0x8008b44 <bmi08x_temp_channel_get+0x128> @ imm = #0x20
 8008b22: 4b22         	ldr	r3, [pc, #0x88]         @ 0x8008bac <bmi08x_temp_channel_get+0x190>
 8008b24: 6819         	ldr	r1, [r3]
 8008b26: 6a7b         	ldr	r3, [r7, #0x24]
 8008b28: 9303         	str	r3, [sp, #0xc]
 8008b2a: 4b23         	ldr	r3, [pc, #0x8c]         @ 0x8008bb8 <bmi08x_temp_channel_get+0x19c>
 8008b2c: 9302         	str	r3, [sp, #0x8]
 8008b2e: 2300         	movs	r3, #0x0
 8008b30: 9301         	str	r3, [sp, #0x4]
 8008b32: 2300         	movs	r3, #0x0
 8008b34: 9300         	str	r3, [sp]
 8008b36: 2300         	movs	r3, #0x0
 8008b38: 2201         	movs	r2, #0x1
 8008b3a: 2000         	movs	r0, #0x0
 8008b3c: f00f fc2d    	bl	0x801839a <z_log_msg_runtime_create> @ imm = #0xf85a
 8008b40: 2300         	movs	r3, #0x0
 8008b42: 617b         	str	r3, [r7, #0x14]
; 		return ret;
 8008b44: 6a7b         	ldr	r3, [r7, #0x24]
 8008b46: e02b         	b	0x8008ba0 <bmi08x_temp_channel_get+0x184> @ imm = #0x56
; 		temp_int11 -= 2048;
 8008b48: 8dfb         	ldrh	r3, [r7, #0x2e]
 8008b4a: f5a3 6300    	sub.w	r3, r3, #0x800
 8008b4e: b29b         	uxth	r3, r3
 8008b50: 85fb         	strh	r3, [r7, #0x2e]
; 	temp_micro = temp_int11 * 125 + 23 * 1000000;
 8008b52: f9b7 202e    	ldrsh.w	r2, [r7, #0x2e]
 8008b56: 4613         	mov	r3, r2
 8008b58: 015b         	lsls	r3, r3, #0x5
 8008b5a: 1a9b         	subs	r3, r3, r2
 8008b5c: 009b         	lsls	r3, r3, #0x2
 8008b5e: 441a         	add	r2, r3
 8008b60: 4b16         	ldr	r3, [pc, #0x58]         @ 0x8008bbc <bmi08x_temp_channel_get+0x1a0>
 8008b62: 4413         	add	r3, r2
 8008b64: 62bb         	str	r3, [r7, #0x28]
; 	val->val1 = temp_micro / 1000000ULL;
 8008b66: 6abb         	ldr	r3, [r7, #0x28]
 8008b68: 17da         	asrs	r2, r3, #0x1f
 8008b6a: 4698         	mov	r8, r3
 8008b6c: 4691         	mov	r9, r2
 8008b6e: 4a14         	ldr	r2, [pc, #0x50]         @ 0x8008bc0 <bmi08x_temp_channel_get+0x1a4>
 8008b70: f04f 0300    	mov.w	r3, #0x0
 8008b74: 4640         	mov	r0, r8
 8008b76: 4649         	mov	r1, r9
 8008b78: f7f7 fe50    	bl	0x800081c <__aeabi_uldivmod> @ imm = #-0x8360
 8008b7c: 4602         	mov	r2, r0
 8008b7e: 460b         	mov	r3, r1
 8008b80: 683b         	ldr	r3, [r7]
 8008b82: 601a         	str	r2, [r3]
; 	val->val2 = temp_micro % 1000000ULL;
 8008b84: 6abb         	ldr	r3, [r7, #0x28]
 8008b86: 17da         	asrs	r2, r3, #0x1f
 8008b88: 461c         	mov	r4, r3
 8008b8a: 4615         	mov	r5, r2
 8008b8c: 4a0c         	ldr	r2, [pc, #0x30]         @ 0x8008bc0 <bmi08x_temp_channel_get+0x1a4>
 8008b8e: f04f 0300    	mov.w	r3, #0x0
 8008b92: 4620         	mov	r0, r4
 8008b94: 4629         	mov	r1, r5
 8008b96: f7f7 fe41    	bl	0x800081c <__aeabi_uldivmod> @ imm = #-0x837e
 8008b9a: 683b         	ldr	r3, [r7]
 8008b9c: 605a         	str	r2, [r3, #0x4]
; 	return ret;
 8008b9e: 6a7b         	ldr	r3, [r7, #0x24]
; }
 8008ba0: 4618         	mov	r0, r3
 8008ba2: 3730         	adds	r7, #0x30
 8008ba4: 46bd         	mov	sp, r7
 8008ba6: e8bd 83b0    	pop.w	{r4, r5, r7, r8, r9, pc}
 8008baa: bf00         	nop

08008bac <$d>:
 8008bac: 08 05 00 20  	.word	0x20000508
 8008bb0: 74 ef 01 08  	.word	0x0801ef74
 8008bb4: a0 ef 01 08  	.word	0x0801efa0
 8008bb8: c8 ef 01 08  	.word	0x0801efc8
 8008bbc: c0 f3 5e 01  	.word	0x015ef3c0
 8008bc0: 40 42 0f 00  	.word	0x000f4240

08008bc4 <bmi08x_channel_get>:
; {
 8008bc4: b580         	push	{r7, lr}
 8008bc6: b08a         	sub	sp, #0x28
 8008bc8: af04         	add	r7, sp, #0x10
 8008bca: 60f8         	str	r0, [r7, #0xc]
 8008bcc: 460b         	mov	r3, r1
 8008bce: 607a         	str	r2, [r7, #0x4]
 8008bd0: 817b         	strh	r3, [r7, #0xa]
; 	switch ((int16_t)chan) {
 8008bd2: f9b7 300a    	ldrsh.w	r3, [r7, #0xa]
 8008bd6: 2b03         	cmp	r3, #0x3
 8008bd8: dc02         	bgt	0x8008be0 <bmi08x_channel_get+0x1c> @ imm = #0x4
 8008bda: 2b00         	cmp	r3, #0x0
 8008bdc: da03         	bge	0x8008be6 <bmi08x_channel_get+0x22> @ imm = #0x6
 8008bde: e010         	b	0x8008c02 <bmi08x_channel_get+0x3e> @ imm = #0x20
 8008be0: 2b0c         	cmp	r3, #0xc
 8008be2: d008         	beq	0x8008bf6 <bmi08x_channel_get+0x32> @ imm = #0x10
 8008be4: e00d         	b	0x8008c02 <bmi08x_channel_get+0x3e> @ imm = #0x1a
; 		bmi08x_acc_channel_get(dev, chan, val);
 8008be6: 897b         	ldrh	r3, [r7, #0xa]
 8008be8: 687a         	ldr	r2, [r7, #0x4]
 8008bea: 4619         	mov	r1, r3
 8008bec: 68f8         	ldr	r0, [r7, #0xc]
 8008bee: f00f fe4f    	bl	0x8018890 <bmi08x_acc_channel_get> @ imm = #0xfc9e
; 		return 0;
 8008bf2: 2300         	movs	r3, #0x0
 8008bf4: e023         	b	0x8008c3e <bmi08x_channel_get+0x7a> @ imm = #0x46
; 		return bmi08x_temp_channel_get(dev, val);
 8008bf6: 6879         	ldr	r1, [r7, #0x4]
 8008bf8: 68f8         	ldr	r0, [r7, #0xc]
 8008bfa: f7ff ff0f    	bl	0x8008a1c <bmi08x_temp_channel_get> @ imm = #-0x1e2
 8008bfe: 4603         	mov	r3, r0
 8008c00: e01d         	b	0x8008c3e <bmi08x_channel_get+0x7a> @ imm = #0x3a
; 		LOG_DBG("Channel not supported.");
 8008c02: 2303         	movs	r3, #0x3
 8008c04: 2b03         	cmp	r3, #0x3
 8008c06: d918         	bls	0x8008c3a <bmi08x_channel_get+0x76> @ imm = #0x30
 8008c08: 2301         	movs	r3, #0x1
 8008c0a: 75fb         	strb	r3, [r7, #0x17]
 8008c0c: 7dfb         	ldrb	r3, [r7, #0x17]
 8008c0e: f083 0301    	eor	r3, r3, #0x1
 8008c12: b2db         	uxtb	r3, r3
 8008c14: 2b00         	cmp	r3, #0x0
 8008c16: d110         	bne	0x8008c3a <bmi08x_channel_get+0x76> @ imm = #0x20
 8008c18: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x8008c48 <bmi08x_channel_get+0x84>
 8008c1a: 6819         	ldr	r1, [r3]
 8008c1c: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x8008c4c <bmi08x_channel_get+0x88>
 8008c1e: 9303         	str	r3, [sp, #0xc]
 8008c20: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x8008c50 <bmi08x_channel_get+0x8c>
 8008c22: 9302         	str	r3, [sp, #0x8]
 8008c24: 2308         	movs	r3, #0x8
 8008c26: 9301         	str	r3, [sp, #0x4]
 8008c28: 2300         	movs	r3, #0x0
 8008c2a: 9300         	str	r3, [sp]
 8008c2c: 2300         	movs	r3, #0x0
 8008c2e: 2204         	movs	r2, #0x4
 8008c30: 2000         	movs	r0, #0x0
 8008c32: f00f fbb2    	bl	0x801839a <z_log_msg_runtime_create> @ imm = #0xf764
 8008c36: 2300         	movs	r3, #0x0
 8008c38: 613b         	str	r3, [r7, #0x10]
; 		return -ENOTSUP;
 8008c3a: f06f 0385    	mvn	r3, #0x85
; }
 8008c3e: 4618         	mov	r0, r3
 8008c40: 3718         	adds	r7, #0x18
 8008c42: 46bd         	mov	sp, r7
 8008c44: bd80         	pop	{r7, pc}
 8008c46: bf00         	nop

08008c48 <$d>:
 8008c48: 08 05 00 20  	.word	0x20000508
 8008c4c: 10 03 02 08  	.word	0x08020310
 8008c50: f4 ef 01 08  	.word	0x0801eff4

08008c54 <bmi08x_accel_init>:
; {
 8008c54: b580         	push	{r7, lr}
 8008c56: b09e         	sub	sp, #0x78
 8008c58: af04         	add	r7, sp, #0x10
 8008c5a: 6078         	str	r0, [r7, #0x4]
; 	const struct bmi08x_accel_config *config = dev->config;
 8008c5c: 687b         	ldr	r3, [r7, #0x4]
 8008c5e: 685b         	ldr	r3, [r3, #0x4]
 8008c60: 65fb         	str	r3, [r7, #0x5c]
; 	struct bmi08x_accel_data *data = dev->data;
 8008c62: 687b         	ldr	r3, [r7, #0x4]
 8008c64: 691b         	ldr	r3, [r3, #0x10]
 8008c66: 65bb         	str	r3, [r7, #0x58]
; 	uint8_t val = 0U;
 8008c68: 2300         	movs	r3, #0x0
 8008c6a: 72fb         	strb	r3, [r7, #0xb]
; 	ret = bmi08x_bus_check(dev);
 8008c6c: 6878         	ldr	r0, [r7, #0x4]
 8008c6e: f00f fcc2    	bl	0x80185f6 <bmi08x_bus_check> @ imm = #0xf984
 8008c72: 6678         	str	r0, [r7, #0x64]
; 	if (ret < 0) {
 8008c74: 6e7b         	ldr	r3, [r7, #0x64]
 8008c76: 2b00         	cmp	r3, #0x0
 8008c78: da1e         	bge	0x8008cb8 <bmi08x_accel_init+0x64> @ imm = #0x3c
; 		LOG_ERR("Bus not ready for '%s'", dev->name);
 8008c7a: 2303         	movs	r3, #0x3
 8008c7c: 2b00         	cmp	r3, #0x0
 8008c7e: d019         	beq	0x8008cb4 <bmi08x_accel_init+0x60> @ imm = #0x32
 8008c80: 2301         	movs	r3, #0x1
 8008c82: 74fb         	strb	r3, [r7, #0x13]
 8008c84: 7cfb         	ldrb	r3, [r7, #0x13]
 8008c86: f083 0301    	eor	r3, r3, #0x1
 8008c8a: b2db         	uxtb	r3, r3
 8008c8c: 2b00         	cmp	r3, #0x0
 8008c8e: d111         	bne	0x8008cb4 <bmi08x_accel_init+0x60> @ imm = #0x22
 8008c90: 4b9a         	ldr	r3, [pc, #0x268]        @ 0x8008efc <bmi08x_accel_init+0x2a8>
 8008c92: 6819         	ldr	r1, [r3]
 8008c94: 687b         	ldr	r3, [r7, #0x4]
 8008c96: 681b         	ldr	r3, [r3]
 8008c98: 9303         	str	r3, [sp, #0xc]
 8008c9a: 4b99         	ldr	r3, [pc, #0x264]        @ 0x8008f00 <bmi08x_accel_init+0x2ac>
 8008c9c: 9302         	str	r3, [sp, #0x8]
 8008c9e: 2300         	movs	r3, #0x0
 8008ca0: 9301         	str	r3, [sp, #0x4]
 8008ca2: 2300         	movs	r3, #0x0
 8008ca4: 9300         	str	r3, [sp]
 8008ca6: 2300         	movs	r3, #0x0
 8008ca8: 2201         	movs	r2, #0x1
 8008caa: 2000         	movs	r0, #0x0
 8008cac: f00f fb75    	bl	0x801839a <z_log_msg_runtime_create> @ imm = #0xf6ea
 8008cb0: 2300         	movs	r3, #0x0
 8008cb2: 60fb         	str	r3, [r7, #0xc]
; 		return ret;
 8008cb4: 6e7b         	ldr	r3, [r7, #0x64]
 8008cb6: e185         	b	0x8008fc4 <bmi08x_accel_init+0x370> @ imm = #0x30a
; 	ret = bmi08x_accel_byte_write(dev, BMI08X_REG_ACCEL_SOFTRESET, BMI08X_SOFT_RESET_CMD);
 8008cb8: 22b6         	movs	r2, #0xb6
 8008cba: 217e         	movs	r1, #0x7e
 8008cbc: 6878         	ldr	r0, [r7, #0x4]
 8008cbe: f00f fd31    	bl	0x8018724 <bmi08x_accel_byte_write> @ imm = #0xfa62
 8008cc2: 6678         	str	r0, [r7, #0x64]
; 	if (ret < 0) {
 8008cc4: 6e7b         	ldr	r3, [r7, #0x64]
 8008cc6: 2b00         	cmp	r3, #0x0
 8008cc8: da1b         	bge	0x8008d02 <bmi08x_accel_init+0xae> @ imm = #0x36
; 		LOG_ERR("Cannot reboot chip.");
 8008cca: 2303         	movs	r3, #0x3
 8008ccc: 2b00         	cmp	r3, #0x0
 8008cce: d016         	beq	0x8008cfe <bmi08x_accel_init+0xaa> @ imm = #0x2c
 8008cd0: 2301         	movs	r3, #0x1
 8008cd2: 76fb         	strb	r3, [r7, #0x1b]
 8008cd4: 7efb         	ldrb	r3, [r7, #0x1b]
 8008cd6: f083 0301    	eor	r3, r3, #0x1
 8008cda: b2db         	uxtb	r3, r3
 8008cdc: 2b00         	cmp	r3, #0x0
 8008cde: d10e         	bne	0x8008cfe <bmi08x_accel_init+0xaa> @ imm = #0x1c
 8008ce0: 4b86         	ldr	r3, [pc, #0x218]        @ 0x8008efc <bmi08x_accel_init+0x2a8>
 8008ce2: 6819         	ldr	r1, [r3]
 8008ce4: 4b87         	ldr	r3, [pc, #0x21c]        @ 0x8008f04 <bmi08x_accel_init+0x2b0>
 8008ce6: 9302         	str	r3, [sp, #0x8]
 8008ce8: 2300         	movs	r3, #0x0
 8008cea: 9301         	str	r3, [sp, #0x4]
 8008cec: 2300         	movs	r3, #0x0
 8008cee: 9300         	str	r3, [sp]
 8008cf0: 2300         	movs	r3, #0x0
 8008cf2: 2201         	movs	r2, #0x1
 8008cf4: 2000         	movs	r0, #0x0
 8008cf6: f00f fb50    	bl	0x801839a <z_log_msg_runtime_create> @ imm = #0xf6a0
 8008cfa: 2300         	movs	r3, #0x0
 8008cfc: 617b         	str	r3, [r7, #0x14]
; 		return ret;
 8008cfe: 6e7b         	ldr	r3, [r7, #0x64]
 8008d00: e160         	b	0x8008fc4 <bmi08x_accel_init+0x370> @ imm = #0x2c0
; 	k_msleep(BMI08X_ACCEL_SOFTRESET_DELAY_MS);
 8008d02: 2001         	movs	r0, #0x1
 8008d04: f00f faf1    	bl	0x80182ea <k_msleep>    @ imm = #0xf5e2
; 	ret = bmi08x_bus_init(dev);
 8008d08: 6878         	ldr	r0, [r7, #0x4]
 8008d0a: f00f fc86    	bl	0x801861a <bmi08x_bus_init> @ imm = #0xf90c
 8008d0e: 6678         	str	r0, [r7, #0x64]
; 	if (ret < 0) {
 8008d10: 6e7b         	ldr	r3, [r7, #0x64]
 8008d12: 2b00         	cmp	r3, #0x0
 8008d14: da20         	bge	0x8008d58 <bmi08x_accel_init+0x104> @ imm = #0x40
; 		LOG_ERR("Can't initialize bus for %s", dev->name);
 8008d16: 2303         	movs	r3, #0x3
 8008d18: 2b00         	cmp	r3, #0x0
 8008d1a: d01b         	beq	0x8008d54 <bmi08x_accel_init+0x100> @ imm = #0x36
 8008d1c: 2301         	movs	r3, #0x1
 8008d1e: f887 3023    	strb.w	r3, [r7, #0x23]
 8008d22: f897 3023    	ldrb.w	r3, [r7, #0x23]
 8008d26: f083 0301    	eor	r3, r3, #0x1
 8008d2a: b2db         	uxtb	r3, r3
 8008d2c: 2b00         	cmp	r3, #0x0
 8008d2e: d111         	bne	0x8008d54 <bmi08x_accel_init+0x100> @ imm = #0x22
 8008d30: 4b72         	ldr	r3, [pc, #0x1c8]        @ 0x8008efc <bmi08x_accel_init+0x2a8>
 8008d32: 6819         	ldr	r1, [r3]
 8008d34: 687b         	ldr	r3, [r7, #0x4]
 8008d36: 681b         	ldr	r3, [r3]
 8008d38: 9303         	str	r3, [sp, #0xc]
 8008d3a: 4b73         	ldr	r3, [pc, #0x1cc]        @ 0x8008f08 <bmi08x_accel_init+0x2b4>
 8008d3c: 9302         	str	r3, [sp, #0x8]
 8008d3e: 2300         	movs	r3, #0x0
 8008d40: 9301         	str	r3, [sp, #0x4]
 8008d42: 2300         	movs	r3, #0x0
 8008d44: 9300         	str	r3, [sp]
 8008d46: 2300         	movs	r3, #0x0
 8008d48: 2201         	movs	r2, #0x1
 8008d4a: 2000         	movs	r0, #0x0
 8008d4c: f00f fb25    	bl	0x801839a <z_log_msg_runtime_create> @ imm = #0xf64a
 8008d50: 2300         	movs	r3, #0x0
 8008d52: 61fb         	str	r3, [r7, #0x1c]
; 		return ret;
 8008d54: 6e7b         	ldr	r3, [r7, #0x64]
 8008d56: e135         	b	0x8008fc4 <bmi08x_accel_init+0x370> @ imm = #0x26a
; 	ret = bmi08x_accel_byte_read(dev, BMI08X_REG_ACCEL_CHIP_ID, &val);
 8008d58: f107 030b    	add.w	r3, r7, #0xb
 8008d5c: 461a         	mov	r2, r3
 8008d5e: 2100         	movs	r1, #0x0
 8008d60: 6878         	ldr	r0, [r7, #0x4]
 8008d62: f00f fca7    	bl	0x80186b4 <bmi08x_accel_byte_read> @ imm = #0xf94e
 8008d66: 6678         	str	r0, [r7, #0x64]
; 	if (ret < 0) {
 8008d68: 6e7b         	ldr	r3, [r7, #0x64]
 8008d6a: 2b00         	cmp	r3, #0x0
 8008d6c: da1d         	bge	0x8008daa <bmi08x_accel_init+0x156> @ imm = #0x3a
; 		LOG_ERR("Failed to read chip id.");
 8008d6e: 2303         	movs	r3, #0x3
 8008d70: 2b00         	cmp	r3, #0x0
 8008d72: d018         	beq	0x8008da6 <bmi08x_accel_init+0x152> @ imm = #0x30
 8008d74: 2301         	movs	r3, #0x1
 8008d76: f887 302b    	strb.w	r3, [r7, #0x2b]
 8008d7a: f897 302b    	ldrb.w	r3, [r7, #0x2b]
 8008d7e: f083 0301    	eor	r3, r3, #0x1
 8008d82: b2db         	uxtb	r3, r3
 8008d84: 2b00         	cmp	r3, #0x0
 8008d86: d10e         	bne	0x8008da6 <bmi08x_accel_init+0x152> @ imm = #0x1c
 8008d88: 4b5c         	ldr	r3, [pc, #0x170]        @ 0x8008efc <bmi08x_accel_init+0x2a8>
 8008d8a: 6819         	ldr	r1, [r3]
 8008d8c: 4b5f         	ldr	r3, [pc, #0x17c]        @ 0x8008f0c <bmi08x_accel_init+0x2b8>
 8008d8e: 9302         	str	r3, [sp, #0x8]
 8008d90: 2300         	movs	r3, #0x0
 8008d92: 9301         	str	r3, [sp, #0x4]
 8008d94: 2300         	movs	r3, #0x0
 8008d96: 9300         	str	r3, [sp]
 8008d98: 2300         	movs	r3, #0x0
 8008d9a: 2201         	movs	r2, #0x1
 8008d9c: 2000         	movs	r0, #0x0
 8008d9e: f00f fafc    	bl	0x801839a <z_log_msg_runtime_create> @ imm = #0xf5f8
 8008da2: 2300         	movs	r3, #0x0
 8008da4: 627b         	str	r3, [r7, #0x24]
; 		return ret;
 8008da6: 6e7b         	ldr	r3, [r7, #0x64]
 8008da8: e10c         	b	0x8008fc4 <bmi08x_accel_init+0x370> @ imm = #0x218
; 	if ((val != BMI085_ACCEL_CHIP_ID) && (val != BMI088_ACCEL_CHIP_ID)) {
 8008daa: 7afb         	ldrb	r3, [r7, #0xb]
 8008dac: 2b1f         	cmp	r3, #0x1f
 8008dae: d023         	beq	0x8008df8 <bmi08x_accel_init+0x1a4> @ imm = #0x46
 8008db0: 7afb         	ldrb	r3, [r7, #0xb]
 8008db2: 2b1e         	cmp	r3, #0x1e
 8008db4: d020         	beq	0x8008df8 <bmi08x_accel_init+0x1a4> @ imm = #0x40
; 		LOG_ERR("Unsupported chip detected (0x%02x)!", val);
 8008db6: 2303         	movs	r3, #0x3
 8008db8: 2b00         	cmp	r3, #0x0
 8008dba: d01a         	beq	0x8008df2 <bmi08x_accel_init+0x19e> @ imm = #0x34
 8008dbc: 2301         	movs	r3, #0x1
 8008dbe: f887 3063    	strb.w	r3, [r7, #0x63]
 8008dc2: f897 3063    	ldrb.w	r3, [r7, #0x63]
 8008dc6: f083 0301    	eor	r3, r3, #0x1
 8008dca: b2db         	uxtb	r3, r3
 8008dcc: 2b00         	cmp	r3, #0x0
 8008dce: d110         	bne	0x8008df2 <bmi08x_accel_init+0x19e> @ imm = #0x20
 8008dd0: 4b4a         	ldr	r3, [pc, #0x128]        @ 0x8008efc <bmi08x_accel_init+0x2a8>
 8008dd2: 6819         	ldr	r1, [r3]
 8008dd4: 7afb         	ldrb	r3, [r7, #0xb]
 8008dd6: 9303         	str	r3, [sp, #0xc]
 8008dd8: 4b4d         	ldr	r3, [pc, #0x134]        @ 0x8008f10 <bmi08x_accel_init+0x2bc>
 8008dda: 9302         	str	r3, [sp, #0x8]
 8008ddc: 2300         	movs	r3, #0x0
 8008dde: 9301         	str	r3, [sp, #0x4]
 8008de0: 2300         	movs	r3, #0x0
 8008de2: 9300         	str	r3, [sp]
 8008de4: 2300         	movs	r3, #0x0
 8008de6: 2201         	movs	r2, #0x1
 8008de8: 2000         	movs	r0, #0x0
 8008dea: f00f fad6    	bl	0x801839a <z_log_msg_runtime_create> @ imm = #0xf5ac
 8008dee: 2300         	movs	r3, #0x0
 8008df0: 657b         	str	r3, [r7, #0x54]
; 		return -ENODEV;
 8008df2: f06f 0312    	mvn	r3, #0x12
 8008df6: e0e5         	b	0x8008fc4 <bmi08x_accel_init+0x370> @ imm = #0x1ca
; 	data->accel_chip_id = val;
 8008df8: 7afa         	ldrb	r2, [r7, #0xb]
 8008dfa: 6dbb         	ldr	r3, [r7, #0x58]
 8008dfc: f883 2700    	strb.w	r2, [r3, #0x700]
; 	ret = bmi08x_accel_byte_write(dev, BMI08X_REG_ACCEL_PWR_CONF, BMI08X_ACCEL_PM_ACTIVE);
 8008e00: 2200         	movs	r2, #0x0
 8008e02: 217c         	movs	r1, #0x7c
 8008e04: 6878         	ldr	r0, [r7, #0x4]
 8008e06: f00f fc8d    	bl	0x8018724 <bmi08x_accel_byte_write> @ imm = #0xf91a
 8008e0a: 6678         	str	r0, [r7, #0x64]
; 	if (ret < 0) {
 8008e0c: 6e7b         	ldr	r3, [r7, #0x64]
 8008e0e: 2b00         	cmp	r3, #0x0
 8008e10: da1d         	bge	0x8008e4e <bmi08x_accel_init+0x1fa> @ imm = #0x3a
; 		LOG_ERR("Failed to set conf power mode");
 8008e12: 2303         	movs	r3, #0x3
 8008e14: 2b00         	cmp	r3, #0x0
 8008e16: d018         	beq	0x8008e4a <bmi08x_accel_init+0x1f6> @ imm = #0x30
 8008e18: 2301         	movs	r3, #0x1
 8008e1a: f887 3033    	strb.w	r3, [r7, #0x33]
 8008e1e: f897 3033    	ldrb.w	r3, [r7, #0x33]
 8008e22: f083 0301    	eor	r3, r3, #0x1
 8008e26: b2db         	uxtb	r3, r3
 8008e28: 2b00         	cmp	r3, #0x0
 8008e2a: d10e         	bne	0x8008e4a <bmi08x_accel_init+0x1f6> @ imm = #0x1c
 8008e2c: 4b33         	ldr	r3, [pc, #0xcc]         @ 0x8008efc <bmi08x_accel_init+0x2a8>
 8008e2e: 6819         	ldr	r1, [r3]
 8008e30: 4b38         	ldr	r3, [pc, #0xe0]         @ 0x8008f14 <bmi08x_accel_init+0x2c0>
 8008e32: 9302         	str	r3, [sp, #0x8]
 8008e34: 2300         	movs	r3, #0x0
 8008e36: 9301         	str	r3, [sp, #0x4]
 8008e38: 2300         	movs	r3, #0x0
 8008e3a: 9300         	str	r3, [sp]
 8008e3c: 2300         	movs	r3, #0x0
 8008e3e: 2201         	movs	r2, #0x1
 8008e40: 2000         	movs	r0, #0x0
 8008e42: f00f faaa    	bl	0x801839a <z_log_msg_runtime_create> @ imm = #0xf554
 8008e46: 2300         	movs	r3, #0x0
 8008e48: 62fb         	str	r3, [r7, #0x2c]
; 		return ret;
 8008e4a: 6e7b         	ldr	r3, [r7, #0x64]
 8008e4c: e0ba         	b	0x8008fc4 <bmi08x_accel_init+0x370> @ imm = #0x174
; 	k_msleep(BMI08X_POWER_CONFIG_DELAY);
 8008e4e: 2005         	movs	r0, #0x5
 8008e50: f00f fa4b    	bl	0x80182ea <k_msleep>    @ imm = #0xf496
; 	ret = bmi08x_accel_byte_write(dev, BMI08X_REG_ACCEL_PWR_CTRL, BMI08X_ACCEL_POWER_ENABLE);
 8008e54: 2204         	movs	r2, #0x4
 8008e56: 217d         	movs	r1, #0x7d
 8008e58: 6878         	ldr	r0, [r7, #0x4]
 8008e5a: f00f fc63    	bl	0x8018724 <bmi08x_accel_byte_write> @ imm = #0xf8c6
 8008e5e: 6678         	str	r0, [r7, #0x64]
; 	if (ret < 0) {
 8008e60: 6e7b         	ldr	r3, [r7, #0x64]
 8008e62: 2b00         	cmp	r3, #0x0
 8008e64: da1d         	bge	0x8008ea2 <bmi08x_accel_init+0x24e> @ imm = #0x3a
; 		LOG_ERR("Failed to set ctrl power mode");
 8008e66: 2303         	movs	r3, #0x3
 8008e68: 2b00         	cmp	r3, #0x0
 8008e6a: d018         	beq	0x8008e9e <bmi08x_accel_init+0x24a> @ imm = #0x30
 8008e6c: 2301         	movs	r3, #0x1
 8008e6e: f887 303b    	strb.w	r3, [r7, #0x3b]
 8008e72: f897 303b    	ldrb.w	r3, [r7, #0x3b]
 8008e76: f083 0301    	eor	r3, r3, #0x1
 8008e7a: b2db         	uxtb	r3, r3
 8008e7c: 2b00         	cmp	r3, #0x0
 8008e7e: d10e         	bne	0x8008e9e <bmi08x_accel_init+0x24a> @ imm = #0x1c
 8008e80: 4b1e         	ldr	r3, [pc, #0x78]         @ 0x8008efc <bmi08x_accel_init+0x2a8>
 8008e82: 6819         	ldr	r1, [r3]
 8008e84: 4b24         	ldr	r3, [pc, #0x90]         @ 0x8008f18 <bmi08x_accel_init+0x2c4>
 8008e86: 9302         	str	r3, [sp, #0x8]
 8008e88: 2300         	movs	r3, #0x0
 8008e8a: 9301         	str	r3, [sp, #0x4]
 8008e8c: 2300         	movs	r3, #0x0
 8008e8e: 9300         	str	r3, [sp]
 8008e90: 2300         	movs	r3, #0x0
 8008e92: 2201         	movs	r2, #0x1
 8008e94: 2000         	movs	r0, #0x0
 8008e96: f00f fa80    	bl	0x801839a <z_log_msg_runtime_create> @ imm = #0xf500
 8008e9a: 2300         	movs	r3, #0x0
 8008e9c: 637b         	str	r3, [r7, #0x34]
; 		return ret;
 8008e9e: 6e7b         	ldr	r3, [r7, #0x64]
 8008ea0: e090         	b	0x8008fc4 <bmi08x_accel_init+0x370> @ imm = #0x120
; 	k_msleep(BMI08X_POWER_CONFIG_DELAY);
 8008ea2: 2005         	movs	r0, #0x5
 8008ea4: f00f fa21    	bl	0x80182ea <k_msleep>    @ imm = #0xf442
; 	ret = bmi08x_acc_range_set(dev, config->accel_fs);
 8008ea8: 6dfb         	ldr	r3, [r7, #0x5c]
 8008eaa: f893 3029    	ldrb.w	r3, [r3, #0x29]
 8008eae: 4619         	mov	r1, r3
 8008eb0: 6878         	ldr	r0, [r7, #0x4]
 8008eb2: f7ff fc1d    	bl	0x80086f0 <bmi08x_acc_range_set> @ imm = #-0x7c6
 8008eb6: 6678         	str	r0, [r7, #0x64]
; 	if (ret < 0) {
 8008eb8: 6e7b         	ldr	r3, [r7, #0x64]
 8008eba: 2b00         	cmp	r3, #0x0
 8008ebc: da30         	bge	0x8008f20 <bmi08x_accel_init+0x2cc> @ imm = #0x60
; 		LOG_ERR("Cannot set default range for accelerometer.");
 8008ebe: 2303         	movs	r3, #0x3
 8008ec0: 2b00         	cmp	r3, #0x0
 8008ec2: d018         	beq	0x8008ef6 <bmi08x_accel_init+0x2a2> @ imm = #0x30
 8008ec4: 2301         	movs	r3, #0x1
 8008ec6: f887 3043    	strb.w	r3, [r7, #0x43]
 8008eca: f897 3043    	ldrb.w	r3, [r7, #0x43]
 8008ece: f083 0301    	eor	r3, r3, #0x1
 8008ed2: b2db         	uxtb	r3, r3
 8008ed4: 2b00         	cmp	r3, #0x0
 8008ed6: d10e         	bne	0x8008ef6 <bmi08x_accel_init+0x2a2> @ imm = #0x1c
 8008ed8: 4b08         	ldr	r3, [pc, #0x20]         @ 0x8008efc <bmi08x_accel_init+0x2a8>
 8008eda: 6819         	ldr	r1, [r3]
 8008edc: 4b0f         	ldr	r3, [pc, #0x3c]         @ 0x8008f1c <bmi08x_accel_init+0x2c8>
 8008ede: 9302         	str	r3, [sp, #0x8]
 8008ee0: 2300         	movs	r3, #0x0
 8008ee2: 9301         	str	r3, [sp, #0x4]
 8008ee4: 2300         	movs	r3, #0x0
 8008ee6: 9300         	str	r3, [sp]
 8008ee8: 2300         	movs	r3, #0x0
 8008eea: 2201         	movs	r2, #0x1
 8008eec: 2000         	movs	r0, #0x0
 8008eee: f00f fa54    	bl	0x801839a <z_log_msg_runtime_create> @ imm = #0xf4a8
 8008ef2: 2300         	movs	r3, #0x0
 8008ef4: 63fb         	str	r3, [r7, #0x3c]
; 		return ret;
 8008ef6: 6e7b         	ldr	r3, [r7, #0x64]
 8008ef8: e064         	b	0x8008fc4 <bmi08x_accel_init+0x370> @ imm = #0xc8
 8008efa: bf00         	nop

08008efc <$d>:
 8008efc: 08 05 00 20  	.word	0x20000508
 8008f00: 10 f0 01 08  	.word	0x0801f010
 8008f04: 28 f0 01 08  	.word	0x0801f028
 8008f08: 3c f0 01 08  	.word	0x0801f03c
 8008f0c: 58 f0 01 08  	.word	0x0801f058
 8008f10: 70 f0 01 08  	.word	0x0801f070
 8008f14: 94 f0 01 08  	.word	0x0801f094
 8008f18: b4 f0 01 08  	.word	0x0801f0b4
 8008f1c: d4 f0 01 08  	.word	0x0801f0d4

08008f20 <$t>:
; 					    config->accel_hz);
 8008f20: 6dfb         	ldr	r3, [r7, #0x5c]
 8008f22: f893 3028    	ldrb.w	r3, [r3, #0x28]
; 	ret = bmi08x_accel_reg_field_update(dev, BMI08X_REG_ACCEL_CONF, 0, BMI08X_ACCEL_ODR_MASK,
 8008f26: 9300         	str	r3, [sp]
 8008f28: 230f         	movs	r3, #0xf
 8008f2a: 2200         	movs	r2, #0x0
 8008f2c: 2140         	movs	r1, #0x40
 8008f2e: 6878         	ldr	r0, [r7, #0x4]
 8008f30: f00f fc10    	bl	0x8018754 <bmi08x_accel_reg_field_update> @ imm = #0xf820
 8008f34: 6678         	str	r0, [r7, #0x64]
; 	if (ret < 0) {
 8008f36: 6e7b         	ldr	r3, [r7, #0x64]
 8008f38: 2b00         	cmp	r3, #0x0
 8008f3a: da1d         	bge	0x8008f78 <bmi08x_accel_init+0x324> @ imm = #0x3a
; 		LOG_ERR("Failed to set accel's default ODR.");
 8008f3c: 2303         	movs	r3, #0x3
 8008f3e: 2b00         	cmp	r3, #0x0
 8008f40: d018         	beq	0x8008f74 <bmi08x_accel_init+0x320> @ imm = #0x30
 8008f42: 2301         	movs	r3, #0x1
 8008f44: f887 304b    	strb.w	r3, [r7, #0x4b]
 8008f48: f897 304b    	ldrb.w	r3, [r7, #0x4b]
 8008f4c: f083 0301    	eor	r3, r3, #0x1
 8008f50: b2db         	uxtb	r3, r3
 8008f52: 2b00         	cmp	r3, #0x0
 8008f54: d10e         	bne	0x8008f74 <bmi08x_accel_init+0x320> @ imm = #0x1c
 8008f56: 4b1d         	ldr	r3, [pc, #0x74]         @ 0x8008fcc <bmi08x_accel_init+0x378>
 8008f58: 6819         	ldr	r1, [r3]
 8008f5a: 4b1d         	ldr	r3, [pc, #0x74]         @ 0x8008fd0 <bmi08x_accel_init+0x37c>
 8008f5c: 9302         	str	r3, [sp, #0x8]
 8008f5e: 2300         	movs	r3, #0x0
 8008f60: 9301         	str	r3, [sp, #0x4]
 8008f62: 2300         	movs	r3, #0x0
 8008f64: 9300         	str	r3, [sp]
 8008f66: 2300         	movs	r3, #0x0
 8008f68: 2201         	movs	r2, #0x1
 8008f6a: 2000         	movs	r0, #0x0
 8008f6c: f00f fa15    	bl	0x801839a <z_log_msg_runtime_create> @ imm = #0xf42a
 8008f70: 2300         	movs	r3, #0x0
 8008f72: 647b         	str	r3, [r7, #0x44]
; 		return ret;
 8008f74: 6e7b         	ldr	r3, [r7, #0x64]
 8008f76: e025         	b	0x8008fc4 <bmi08x_accel_init+0x370> @ imm = #0x4a
; 	ret = bmi08x_acc_trigger_mode_init(dev);
 8008f78: 6878         	ldr	r0, [r7, #0x4]
 8008f7a: f000 fc63    	bl	0x8009844 <bmi08x_acc_trigger_mode_init> @ imm = #0x8c6
 8008f7e: 6678         	str	r0, [r7, #0x64]
; 	if (ret < 0) {
 8008f80: 6e7b         	ldr	r3, [r7, #0x64]
 8008f82: 2b00         	cmp	r3, #0x0
 8008f84: da1d         	bge	0x8008fc2 <bmi08x_accel_init+0x36e> @ imm = #0x3a
; 		LOG_ERR("Cannot set up trigger mode.");
 8008f86: 2303         	movs	r3, #0x3
 8008f88: 2b00         	cmp	r3, #0x0
 8008f8a: d018         	beq	0x8008fbe <bmi08x_accel_init+0x36a> @ imm = #0x30
 8008f8c: 2301         	movs	r3, #0x1
 8008f8e: f887 3053    	strb.w	r3, [r7, #0x53]
 8008f92: f897 3053    	ldrb.w	r3, [r7, #0x53]
 8008f96: f083 0301    	eor	r3, r3, #0x1
 8008f9a: b2db         	uxtb	r3, r3
 8008f9c: 2b00         	cmp	r3, #0x0
 8008f9e: d10e         	bne	0x8008fbe <bmi08x_accel_init+0x36a> @ imm = #0x1c
 8008fa0: 4b0a         	ldr	r3, [pc, #0x28]         @ 0x8008fcc <bmi08x_accel_init+0x378>
 8008fa2: 6819         	ldr	r1, [r3]
 8008fa4: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x8008fd4 <bmi08x_accel_init+0x380>
 8008fa6: 9302         	str	r3, [sp, #0x8]
 8008fa8: 2300         	movs	r3, #0x0
 8008faa: 9301         	str	r3, [sp, #0x4]
 8008fac: 2300         	movs	r3, #0x0
 8008fae: 9300         	str	r3, [sp]
 8008fb0: 2300         	movs	r3, #0x0
 8008fb2: 2201         	movs	r2, #0x1
 8008fb4: 2000         	movs	r0, #0x0
 8008fb6: f00f f9f0    	bl	0x801839a <z_log_msg_runtime_create> @ imm = #0xf3e0
 8008fba: 2300         	movs	r3, #0x0
 8008fbc: 64fb         	str	r3, [r7, #0x4c]
; 		return ret;
 8008fbe: 6e7b         	ldr	r3, [r7, #0x64]
 8008fc0: e000         	b	0x8008fc4 <bmi08x_accel_init+0x370> @ imm = #0x0
; 	return ret;
 8008fc2: 6e7b         	ldr	r3, [r7, #0x64]
; }
 8008fc4: 4618         	mov	r0, r3
 8008fc6: 3768         	adds	r7, #0x68
 8008fc8: 46bd         	mov	sp, r7
 8008fca: bd80         	pop	{r7, pc}

08008fcc <$d>:
 8008fcc: 08 05 00 20  	.word	0x20000508
 8008fd0: 00 f1 01 08  	.word	0x0801f100
 8008fd4: 24 f1 01 08  	.word	0x0801f124

08008fd8 <bmi08x_gyr_range_set>:
; {
 8008fd8: e92d 4fb0    	push.w	{r4, r5, r7, r8, r9, r10, r11, lr}
 8008fdc: b08c         	sub	sp, #0x30
 8008fde: af00         	add	r7, sp, #0x0
 8008fe0: 61f8         	str	r0, [r7, #0x1c]
 8008fe2: 460b         	mov	r3, r1
 8008fe4: 837b         	strh	r3, [r7, #0x1a]
; 	struct bmi08x_gyro_data *bmi08x = dev->data;
 8008fe6: 69fb         	ldr	r3, [r7, #0x1c]
 8008fe8: 691b         	ldr	r3, [r3, #0x10]
 8008fea: 62fb         	str	r3, [r7, #0x2c]
; 		bmi08x_range_to_reg_val(range, bmi08x_gyr_range_map, BMI08X_GYR_RANGE_MAP_SIZE);
 8008fec: 8b7b         	ldrh	r3, [r7, #0x1a]
 8008fee: 2205         	movs	r2, #0x5
 8008ff0: 493e         	ldr	r1, [pc, #0xf8]         @ 0x80090ec <bmi08x_gyr_range_set+0x114>
 8008ff2: 4618         	mov	r0, r3
 8008ff4: f00f fed1    	bl	0x8018d9a <bmi08x_range_to_reg_val> @ imm = #0xfda2
 8008ff8: 62b8         	str	r0, [r7, #0x28]
; 	if (reg_val < 0) {
 8008ffa: 6abb         	ldr	r3, [r7, #0x28]
 8008ffc: 2b00         	cmp	r3, #0x0
 8008ffe: da01         	bge	0x8009004 <bmi08x_gyr_range_set+0x2c> @ imm = #0x2
; 		return reg_val;
 8009000: 6abb         	ldr	r3, [r7, #0x28]
 8009002: e06d         	b	0x80090e0 <bmi08x_gyr_range_set+0x108> @ imm = #0xda
; 	ret = bmi08x_gyro_byte_write(dev, BMI08X_REG_GYRO_RANGE, reg_val);
 8009004: 6abb         	ldr	r3, [r7, #0x28]
 8009006: b2db         	uxtb	r3, r3
 8009008: 461a         	mov	r2, r3
 800900a: 210f         	movs	r1, #0xf
 800900c: 69f8         	ldr	r0, [r7, #0x1c]
 800900e: f00f fe28    	bl	0x8018c62 <bmi08x_gyro_byte_write> @ imm = #0xfc50
 8009012: 6278         	str	r0, [r7, #0x24]
; 	if (ret < 0) {
 8009014: 6a7b         	ldr	r3, [r7, #0x24]
 8009016: 2b00         	cmp	r3, #0x0
 8009018: da01         	bge	0x800901e <bmi08x_gyr_range_set+0x46> @ imm = #0x2
; 		return ret;
 800901a: 6a7b         	ldr	r3, [r7, #0x24]
 800901c: e060         	b	0x80090e0 <bmi08x_gyr_range_set+0x108> @ imm = #0xc0
; 	bmi08x->scale = BMI08X_GYR_SCALE(range);
 800901e: 8b7b         	ldrh	r3, [r7, #0x1a]
 8009020: 2200         	movs	r2, #0x0
 8009022: 461c         	mov	r4, r3
 8009024: 4615         	mov	r5, r2
 8009026: 4622         	mov	r2, r4
 8009028: 462b         	mov	r3, r5
 800902a: 1891         	adds	r1, r2, r2
 800902c: 60b9         	str	r1, [r7, #0x8]
 800902e: 415b         	adcs	r3, r3
 8009030: 60fb         	str	r3, [r7, #0xc]
 8009032: e9d7 2302    	ldrd	r2, r3, [r7, #8]
 8009036: 1911         	adds	r1, r2, r4
 8009038: 6139         	str	r1, [r7, #0x10]
 800903a: 416b         	adcs	r3, r5
 800903c: 617b         	str	r3, [r7, #0x14]
 800903e: f04f 0200    	mov.w	r2, #0x0
 8009042: f04f 0300    	mov.w	r3, #0x0
 8009046: 6979         	ldr	r1, [r7, #0x14]
 8009048: 020b         	lsls	r3, r1, #0x8
 800904a: e9d7 0104    	ldrd	r0, r1, [r7, #16]
 800904e: 4684         	mov	r12, r0
 8009050: ea43 631c    	orr.w	r3, r3, r12, lsr #24
 8009054: 4601         	mov	r1, r0
 8009056: 020a         	lsls	r2, r1, #0x8
 8009058: 4611         	mov	r1, r2
 800905a: ebb1 0a04    	subs.w	r10, r1, r4
 800905e: eb63 0b05    	sbc.w	r11, r3, r5
 8009062: f04f 0200    	mov.w	r2, #0x0
 8009066: f04f 0300    	mov.w	r3, #0x0
 800906a: ea4f 13cb    	lsl.w	r3, r11, #0x7
 800906e: ea43 635a    	orr.w	r3, r3, r10, lsr #25
 8009072: ea4f 12ca    	lsl.w	r2, r10, #0x7
 8009076: 4692         	mov	r10, r2
 8009078: 469b         	mov	r11, r3
 800907a: ebba 0804    	subs.w	r8, r10, r4
 800907e: eb6b 0905    	sbc.w	r9, r11, r5
 8009082: f04f 0200    	mov.w	r2, #0x0
 8009086: f04f 0300    	mov.w	r3, #0x0
 800908a: ea4f 0389    	lsl.w	r3, r9, #0x2
 800908e: ea43 7398    	orr.w	r3, r3, r8, lsr #30
 8009092: ea4f 0288    	lsl.w	r2, r8, #0x2
 8009096: 4690         	mov	r8, r2
 8009098: 4699         	mov	r9, r3
 800909a: ebb8 0304    	subs.w	r3, r8, r4
 800909e: 603b         	str	r3, [r7]
 80090a0: eb69 0305    	sbc.w	r3, r9, r5
 80090a4: 607b         	str	r3, [r7, #0x4]
 80090a6: f04f 0200    	mov.w	r2, #0x0
 80090aa: f04f 0300    	mov.w	r3, #0x0
 80090ae: e9d7 4500    	ldrd	r4, r5, [r7]
 80090b2: 4629         	mov	r1, r5
 80090b4: 010b         	lsls	r3, r1, #0x4
 80090b6: 4620         	mov	r0, r4
 80090b8: 4629         	mov	r1, r5
 80090ba: 4604         	mov	r4, r0
 80090bc: ea43 7314    	orr.w	r3, r3, r4, lsr #28
 80090c0: 4601         	mov	r1, r0
 80090c2: 010a         	lsls	r2, r1, #0x4
 80090c4: 4610         	mov	r0, r2
 80090c6: 4619         	mov	r1, r3
 80090c8: f44f 0234    	mov.w	r2, #0xb40000
 80090cc: f04f 0300    	mov.w	r3, #0x0
 80090d0: f7f7 fb54    	bl	0x800077c <__aeabi_ldivmod> @ imm = #-0x8958
 80090d4: 4602         	mov	r2, r0
 80090d6: 460b         	mov	r3, r1
 80090d8: b292         	uxth	r2, r2
 80090da: 6afb         	ldr	r3, [r7, #0x2c]
 80090dc: 825a         	strh	r2, [r3, #0x12]
; 	return ret;
 80090de: 6a7b         	ldr	r3, [r7, #0x24]
; }
 80090e0: 4618         	mov	r0, r3
 80090e2: 3730         	adds	r7, #0x30
 80090e4: 46bd         	mov	sp, r7
 80090e6: e8bd 8fb0    	pop.w	{r4, r5, r7, r8, r9, r10, r11, pc}
 80090ea: bf00         	nop

080090ec <$d>:
 80090ec: 2c 03 02 08  	.word	0x0802032c

080090f0 <bmi08x_gyr_config>:
; {
 80090f0: b580         	push	{r7, lr}
 80090f2: b08a         	sub	sp, #0x28
 80090f4: af04         	add	r7, sp, #0x10
 80090f6: 60f8         	str	r0, [r7, #0xc]
 80090f8: 607b         	str	r3, [r7, #0x4]
 80090fa: 460b         	mov	r3, r1
 80090fc: 817b         	strh	r3, [r7, #0xa]
 80090fe: 4613         	mov	r3, r2
 8009100: 813b         	strh	r3, [r7, #0x8]
; 	switch (attr) {
 8009102: 893b         	ldrh	r3, [r7, #0x8]
 8009104: 2b00         	cmp	r3, #0x0
 8009106: d00c         	beq	0x8009122 <bmi08x_gyr_config+0x32> @ imm = #0x18
 8009108: 2b07         	cmp	r3, #0x7
 800910a: d11c         	bne	0x8009146 <bmi08x_gyr_config+0x56> @ imm = #0x38
; 		return bmi08x_gyr_range_set(dev, sensor_rad_to_degrees(val));
 800910c: 6878         	ldr	r0, [r7, #0x4]
 800910e: f7f7 fd87    	bl	0x8000c20 <sensor_rad_to_degrees> @ imm = #-0x84f2
 8009112: 4603         	mov	r3, r0
 8009114: b29b         	uxth	r3, r3
 8009116: 4619         	mov	r1, r3
 8009118: 68f8         	ldr	r0, [r7, #0xc]
 800911a: f7ff ff5d    	bl	0x8008fd8 <bmi08x_gyr_range_set> @ imm = #-0x146
 800911e: 4603         	mov	r3, r0
 8009120: e02f         	b	0x8009182 <bmi08x_gyr_config+0x92> @ imm = #0x5e
; 		return bmi08x_gyr_odr_set(dev, val->val1, val->val2 / 1000);
 8009122: 687b         	ldr	r3, [r7, #0x4]
 8009124: 681b         	ldr	r3, [r3]
 8009126: b299         	uxth	r1, r3
 8009128: 687b         	ldr	r3, [r7, #0x4]
 800912a: 685b         	ldr	r3, [r3, #0x4]
 800912c: 4a17         	ldr	r2, [pc, #0x5c]         @ 0x800918c <bmi08x_gyr_config+0x9c>
 800912e: fb82 0203    	smull	r0, r2, r2, r3
 8009132: 1192         	asrs	r2, r2, #0x6
 8009134: 17db         	asrs	r3, r3, #0x1f
 8009136: 1ad3         	subs	r3, r2, r3
 8009138: b29b         	uxth	r3, r3
 800913a: 461a         	mov	r2, r3
 800913c: 68f8         	ldr	r0, [r7, #0xc]
 800913e: f00f fda8    	bl	0x8018c92 <bmi08x_gyr_odr_set> @ imm = #0xfb50
 8009142: 4603         	mov	r3, r0
 8009144: e01d         	b	0x8009182 <bmi08x_gyr_config+0x92> @ imm = #0x3a
; 		LOG_DBG("Gyro attribute not supported.");
 8009146: 2303         	movs	r3, #0x3
 8009148: 2b03         	cmp	r3, #0x3
 800914a: d918         	bls	0x800917e <bmi08x_gyr_config+0x8e> @ imm = #0x30
 800914c: 2301         	movs	r3, #0x1
 800914e: 75fb         	strb	r3, [r7, #0x17]
 8009150: 7dfb         	ldrb	r3, [r7, #0x17]
 8009152: f083 0301    	eor	r3, r3, #0x1
 8009156: b2db         	uxtb	r3, r3
 8009158: 2b00         	cmp	r3, #0x0
 800915a: d110         	bne	0x800917e <bmi08x_gyr_config+0x8e> @ imm = #0x20
 800915c: 4b0c         	ldr	r3, [pc, #0x30]         @ 0x8009190 <bmi08x_gyr_config+0xa0>
 800915e: 6819         	ldr	r1, [r3]
 8009160: 4b0c         	ldr	r3, [pc, #0x30]         @ 0x8009194 <bmi08x_gyr_config+0xa4>
 8009162: 9303         	str	r3, [sp, #0xc]
 8009164: 4b0c         	ldr	r3, [pc, #0x30]         @ 0x8009198 <bmi08x_gyr_config+0xa8>
 8009166: 9302         	str	r3, [sp, #0x8]
 8009168: 2308         	movs	r3, #0x8
 800916a: 9301         	str	r3, [sp, #0x4]
 800916c: 2300         	movs	r3, #0x0
 800916e: 9300         	str	r3, [sp]
 8009170: 2300         	movs	r3, #0x0
 8009172: 2204         	movs	r2, #0x4
 8009174: 2000         	movs	r0, #0x0
 8009176: f00f fbe8    	bl	0x801894a <z_log_msg_runtime_create> @ imm = #0xf7d0
 800917a: 2300         	movs	r3, #0x0
 800917c: 613b         	str	r3, [r7, #0x10]
; 		return -ENOTSUP;
 800917e: f06f 0385    	mvn	r3, #0x85
; }
 8009182: 4618         	mov	r0, r3
 8009184: 3718         	adds	r7, #0x18
 8009186: 46bd         	mov	sp, r7
 8009188: bd80         	pop	{r7, pc}
 800918a: bf00         	nop

0800918c <$d>:
 800918c: d3 4d 62 10  	.word	0x10624dd3
 8009190: 0c 05 00 20  	.word	0x2000050c
 8009194: 6c 03 02 08  	.word	0x0802036c
 8009198: 5c f1 01 08  	.word	0x0801f15c

0800919c <bmi08x_attr_set>:
; {
 800919c: b580         	push	{r7, lr}
 800919e: b08a         	sub	sp, #0x28
 80091a0: af04         	add	r7, sp, #0x10
 80091a2: 60f8         	str	r0, [r7, #0xc]
 80091a4: 607b         	str	r3, [r7, #0x4]
 80091a6: 460b         	mov	r3, r1
 80091a8: 817b         	strh	r3, [r7, #0xa]
 80091aa: 4613         	mov	r3, r2
 80091ac: 813b         	strh	r3, [r7, #0x8]
; 	switch (chan) {
 80091ae: 897b         	ldrh	r3, [r7, #0xa]
 80091b0: 3b04         	subs	r3, #0x4
 80091b2: 2b03         	cmp	r3, #0x3
 80091b4: d807         	bhi	0x80091c6 <bmi08x_attr_set+0x2a> @ imm = #0xe
; 		return bmi08x_gyr_config(dev, chan, attr, val);
 80091b6: 893a         	ldrh	r2, [r7, #0x8]
 80091b8: 8979         	ldrh	r1, [r7, #0xa]
 80091ba: 687b         	ldr	r3, [r7, #0x4]
 80091bc: 68f8         	ldr	r0, [r7, #0xc]
 80091be: f7ff ff97    	bl	0x80090f0 <bmi08x_gyr_config> @ imm = #-0xd2
 80091c2: 4603         	mov	r3, r0
 80091c4: e01d         	b	0x8009202 <bmi08x_attr_set+0x66> @ imm = #0x3a
; 		LOG_DBG("attr_set() not supported on this channel.");
 80091c6: 2303         	movs	r3, #0x3
 80091c8: 2b03         	cmp	r3, #0x3
 80091ca: d918         	bls	0x80091fe <bmi08x_attr_set+0x62> @ imm = #0x30
 80091cc: 2301         	movs	r3, #0x1
 80091ce: 75fb         	strb	r3, [r7, #0x17]
 80091d0: 7dfb         	ldrb	r3, [r7, #0x17]
 80091d2: f083 0301    	eor	r3, r3, #0x1
 80091d6: b2db         	uxtb	r3, r3
 80091d8: 2b00         	cmp	r3, #0x0
 80091da: d110         	bne	0x80091fe <bmi08x_attr_set+0x62> @ imm = #0x20
 80091dc: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x800920c <bmi08x_attr_set+0x70>
 80091de: 6819         	ldr	r1, [r3]
 80091e0: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x8009210 <bmi08x_attr_set+0x74>
 80091e2: 9303         	str	r3, [sp, #0xc]
 80091e4: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x8009214 <bmi08x_attr_set+0x78>
 80091e6: 9302         	str	r3, [sp, #0x8]
 80091e8: 2308         	movs	r3, #0x8
 80091ea: 9301         	str	r3, [sp, #0x4]
 80091ec: 2300         	movs	r3, #0x0
 80091ee: 9300         	str	r3, [sp]
 80091f0: 2300         	movs	r3, #0x0
 80091f2: 2204         	movs	r2, #0x4
 80091f4: 2000         	movs	r0, #0x0
 80091f6: f00f fba8    	bl	0x801894a <z_log_msg_runtime_create> @ imm = #0xf750
 80091fa: 2300         	movs	r3, #0x0
 80091fc: 613b         	str	r3, [r7, #0x10]
; 		return -ENOTSUP;
 80091fe: f06f 0385    	mvn	r3, #0x85
; }
 8009202: 4618         	mov	r0, r3
 8009204: 3718         	adds	r7, #0x18
 8009206: 46bd         	mov	sp, r7
 8009208: bd80         	pop	{r7, pc}
 800920a: bf00         	nop

0800920c <$d>:
 800920c: 0c 05 00 20  	.word	0x2000050c
 8009210: 80 03 02 08  	.word	0x08020380
 8009214: 80 f1 01 08  	.word	0x0801f180

08009218 <bmi08x_sample_fetch>:
; {
 8009218: b580         	push	{r7, lr}
 800921a: b08c         	sub	sp, #0x30
 800921c: af04         	add	r7, sp, #0x10
 800921e: 6078         	str	r0, [r7, #0x4]
 8009220: 460b         	mov	r3, r1
 8009222: 807b         	strh	r3, [r7, #0x2]
; 	struct bmi08x_gyro_data *bmi08x = dev->data;
 8009224: 687b         	ldr	r3, [r7, #0x4]
 8009226: 691b         	ldr	r3, [r3, #0x10]
 8009228: 61bb         	str	r3, [r7, #0x18]
; 	if (chan != SENSOR_CHAN_ALL && chan != SENSOR_CHAN_GYRO_XYZ) {
 800922a: 887b         	ldrh	r3, [r7, #0x2]
 800922c: 2b3c         	cmp	r3, #0x3c
 800922e: d021         	beq	0x8009274 <bmi08x_sample_fetch+0x5c> @ imm = #0x42
 8009230: 887b         	ldrh	r3, [r7, #0x2]
 8009232: 2b07         	cmp	r3, #0x7
 8009234: d01e         	beq	0x8009274 <bmi08x_sample_fetch+0x5c> @ imm = #0x3c
; 		LOG_DBG("Unsupported sensor channel");
 8009236: 2303         	movs	r3, #0x3
 8009238: 2b03         	cmp	r3, #0x3
 800923a: d918         	bls	0x800926e <bmi08x_sample_fetch+0x56> @ imm = #0x30
 800923c: 2301         	movs	r3, #0x1
 800923e: 75fb         	strb	r3, [r7, #0x17]
 8009240: 7dfb         	ldrb	r3, [r7, #0x17]
 8009242: f083 0301    	eor	r3, r3, #0x1
 8009246: b2db         	uxtb	r3, r3
 8009248: 2b00         	cmp	r3, #0x0
 800924a: d110         	bne	0x800926e <bmi08x_sample_fetch+0x56> @ imm = #0x20
 800924c: 4b1e         	ldr	r3, [pc, #0x78]         @ 0x80092c8 <bmi08x_sample_fetch+0xb0>
 800924e: 6819         	ldr	r1, [r3]
 8009250: 4b1e         	ldr	r3, [pc, #0x78]         @ 0x80092cc <bmi08x_sample_fetch+0xb4>
 8009252: 9303         	str	r3, [sp, #0xc]
 8009254: 4b1e         	ldr	r3, [pc, #0x78]         @ 0x80092d0 <bmi08x_sample_fetch+0xb8>
 8009256: 9302         	str	r3, [sp, #0x8]
 8009258: 2308         	movs	r3, #0x8
 800925a: 9301         	str	r3, [sp, #0x4]
 800925c: 2300         	movs	r3, #0x0
 800925e: 9300         	str	r3, [sp]
 8009260: 2300         	movs	r3, #0x0
 8009262: 2204         	movs	r2, #0x4
 8009264: 2000         	movs	r0, #0x0
 8009266: f00f fb70    	bl	0x801894a <z_log_msg_runtime_create> @ imm = #0xf6e0
 800926a: 2300         	movs	r3, #0x0
 800926c: 613b         	str	r3, [r7, #0x10]
; 		return -ENOTSUP;
 800926e: f06f 0385    	mvn	r3, #0x85
 8009272: e024         	b	0x80092be <bmi08x_sample_fetch+0xa6> @ imm = #0x48
; 	ret = bmi08x_gyro_read(dev, BMI08X_REG_GYRO_X_LSB, (uint8_t *)bmi08x->gyr_sample,
 8009274: 69bb         	ldr	r3, [r7, #0x18]
 8009276: f103 020c    	add.w	r2, r3, #0xc
 800927a: 2306         	movs	r3, #0x6
 800927c: 2102         	movs	r1, #0x2
 800927e: 6878         	ldr	r0, [r7, #0x4]
 8009280: f00f fcbe    	bl	0x8018c00 <bmi08x_gyro_read> @ imm = #0xf97c
 8009284: 60f8         	str	r0, [r7, #0xc]
; 	if (ret < 0) {
 8009286: 68fb         	ldr	r3, [r7, #0xc]
 8009288: 2b00         	cmp	r3, #0x0
 800928a: da01         	bge	0x8009290 <bmi08x_sample_fetch+0x78> @ imm = #0x2
; 		return ret;
 800928c: 68fb         	ldr	r3, [r7, #0xc]
 800928e: e016         	b	0x80092be <bmi08x_sample_fetch+0xa6> @ imm = #0x2c
; 	for (i = 0; i < ARRAY_SIZE(bmi08x->gyr_sample); i++) {
 8009290: 2300         	movs	r3, #0x0
 8009292: 61fb         	str	r3, [r7, #0x1c]
 8009294: e00f         	b	0x80092b6 <bmi08x_sample_fetch+0x9e> @ imm = #0x1e
; 		bmi08x->gyr_sample[i] = sys_le16_to_cpu(bmi08x->gyr_sample[i]);
 8009296: 69ba         	ldr	r2, [r7, #0x18]
 8009298: 69fb         	ldr	r3, [r7, #0x1c]
 800929a: 3304         	adds	r3, #0x4
 800929c: 005b         	lsls	r3, r3, #0x1
 800929e: 4413         	add	r3, r2
 80092a0: 8899         	ldrh	r1, [r3, #0x4]
 80092a2: 69ba         	ldr	r2, [r7, #0x18]
 80092a4: 69fb         	ldr	r3, [r7, #0x1c]
 80092a6: 3304         	adds	r3, #0x4
 80092a8: 005b         	lsls	r3, r3, #0x1
 80092aa: 4413         	add	r3, r2
 80092ac: 460a         	mov	r2, r1
 80092ae: 809a         	strh	r2, [r3, #0x4]
; 	for (i = 0; i < ARRAY_SIZE(bmi08x->gyr_sample); i++) {
 80092b0: 69fb         	ldr	r3, [r7, #0x1c]
 80092b2: 3301         	adds	r3, #0x1
 80092b4: 61fb         	str	r3, [r7, #0x1c]
 80092b6: 69fb         	ldr	r3, [r7, #0x1c]
 80092b8: 2b02         	cmp	r3, #0x2
 80092ba: d9ec         	bls	0x8009296 <bmi08x_sample_fetch+0x7e> @ imm = #-0x28
; 	return ret;
 80092bc: 68fb         	ldr	r3, [r7, #0xc]
; }
 80092be: 4618         	mov	r0, r3
 80092c0: 3720         	adds	r7, #0x20
 80092c2: 46bd         	mov	sp, r7
 80092c4: bd80         	pop	{r7, pc}
 80092c6: bf00         	nop

080092c8 <$d>:
 80092c8: 0c 05 00 20  	.word	0x2000050c
 80092cc: 90 03 02 08  	.word	0x08020390
 80092d0: b0 f1 01 08  	.word	0x0801f1b0

080092d4 <bmi08x_to_fixed_point>:
; {
 80092d4: b480         	push	{r7}
 80092d6: b085         	sub	sp, #0x14
 80092d8: af00         	add	r7, sp, #0x0
 80092da: 4603         	mov	r3, r0
 80092dc: 603a         	str	r2, [r7]
 80092de: 80fb         	strh	r3, [r7, #0x6]
 80092e0: 460b         	mov	r3, r1
 80092e2: 80bb         	strh	r3, [r7, #0x4]
; 	converted_val = raw_val * scale;
 80092e4: f9b7 3006    	ldrsh.w	r3, [r7, #0x6]
 80092e8: 88ba         	ldrh	r2, [r7, #0x4]
 80092ea: fb02 f303    	mul	r3, r2, r3
 80092ee: 60fb         	str	r3, [r7, #0xc]
; 	val->val1 = converted_val / 1000000;
 80092f0: 68fb         	ldr	r3, [r7, #0xc]
 80092f2: 4a0d         	ldr	r2, [pc, #0x34]         @ 0x8009328 <bmi08x_to_fixed_point+0x54>
 80092f4: fb82 1203    	smull	r1, r2, r2, r3
 80092f8: 1492         	asrs	r2, r2, #0x12
 80092fa: 17db         	asrs	r3, r3, #0x1f
 80092fc: 1ad2         	subs	r2, r2, r3
 80092fe: 683b         	ldr	r3, [r7]
 8009300: 601a         	str	r2, [r3]
; 	val->val2 = converted_val % 1000000;
 8009302: 68fa         	ldr	r2, [r7, #0xc]
 8009304: 4b08         	ldr	r3, [pc, #0x20]         @ 0x8009328 <bmi08x_to_fixed_point+0x54>
 8009306: fb83 1302    	smull	r1, r3, r3, r2
 800930a: 1499         	asrs	r1, r3, #0x12
 800930c: 17d3         	asrs	r3, r2, #0x1f
 800930e: 1acb         	subs	r3, r1, r3
 8009310: 4906         	ldr	r1, [pc, #0x18]         @ 0x800932c <bmi08x_to_fixed_point+0x58>
 8009312: fb01 f303    	mul	r3, r1, r3
 8009316: 1ad3         	subs	r3, r2, r3
 8009318: 683a         	ldr	r2, [r7]
 800931a: 6053         	str	r3, [r2, #0x4]
; }
 800931c: bf00         	nop
 800931e: 3714         	adds	r7, #0x14
 8009320: 46bd         	mov	sp, r7
 8009322: bc80         	pop	{r7}
 8009324: 4770         	bx	lr
 8009326: bf00         	nop

08009328 <$d>:
 8009328: 83 de 1b 43  	.word	0x431bde83
 800932c: 40 42 0f 00  	.word	0x000f4240

08009330 <bmi08x_channel_get>:
; {
 8009330: b580         	push	{r7, lr}
 8009332: b08a         	sub	sp, #0x28
 8009334: af04         	add	r7, sp, #0x10
 8009336: 60f8         	str	r0, [r7, #0xc]
 8009338: 460b         	mov	r3, r1
 800933a: 607a         	str	r2, [r7, #0x4]
 800933c: 817b         	strh	r3, [r7, #0xa]
; 	switch ((int16_t)chan) {
 800933e: f9b7 300a    	ldrsh.w	r3, [r7, #0xa]
 8009342: 3b04         	subs	r3, #0x4
 8009344: 2b03         	cmp	r3, #0x3
 8009346: d807         	bhi	0x8009358 <bmi08x_channel_get+0x28> @ imm = #0xe
; 		bmi08x_gyr_channel_get(dev, chan, val);
 8009348: 897b         	ldrh	r3, [r7, #0xa]
 800934a: 687a         	ldr	r2, [r7, #0x4]
 800934c: 4619         	mov	r1, r3
 800934e: 68f8         	ldr	r0, [r7, #0xc]
 8009350: f00f fd0c    	bl	0x8018d6c <bmi08x_gyr_channel_get> @ imm = #0xfa18
; 		return 0;
 8009354: 2300         	movs	r3, #0x0
 8009356: e01d         	b	0x8009394 <bmi08x_channel_get+0x64> @ imm = #0x3a
; 		LOG_DBG("Channel not supported.");
 8009358: 2303         	movs	r3, #0x3
 800935a: 2b03         	cmp	r3, #0x3
 800935c: d918         	bls	0x8009390 <bmi08x_channel_get+0x60> @ imm = #0x30
 800935e: 2301         	movs	r3, #0x1
 8009360: 75fb         	strb	r3, [r7, #0x17]
 8009362: 7dfb         	ldrb	r3, [r7, #0x17]
 8009364: f083 0301    	eor	r3, r3, #0x1
 8009368: b2db         	uxtb	r3, r3
 800936a: 2b00         	cmp	r3, #0x0
 800936c: d110         	bne	0x8009390 <bmi08x_channel_get+0x60> @ imm = #0x20
 800936e: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x800939c <bmi08x_channel_get+0x6c>
 8009370: 6819         	ldr	r1, [r3]
 8009372: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x80093a0 <bmi08x_channel_get+0x70>
 8009374: 9303         	str	r3, [sp, #0xc]
 8009376: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x80093a4 <bmi08x_channel_get+0x74>
 8009378: 9302         	str	r3, [sp, #0x8]
 800937a: 2308         	movs	r3, #0x8
 800937c: 9301         	str	r3, [sp, #0x4]
 800937e: 2300         	movs	r3, #0x0
 8009380: 9300         	str	r3, [sp]
 8009382: 2300         	movs	r3, #0x0
 8009384: 2204         	movs	r2, #0x4
 8009386: 2000         	movs	r0, #0x0
 8009388: f00f fadf    	bl	0x801894a <z_log_msg_runtime_create> @ imm = #0xf5be
 800938c: 2300         	movs	r3, #0x0
 800938e: 613b         	str	r3, [r7, #0x10]
; 		return -ENOTSUP;
 8009390: f06f 0385    	mvn	r3, #0x85
; }
 8009394: 4618         	mov	r0, r3
 8009396: 3718         	adds	r7, #0x18
 8009398: 46bd         	mov	sp, r7
 800939a: bd80         	pop	{r7, pc}

0800939c <$d>:
 800939c: 0c 05 00 20  	.word	0x2000050c
 80093a0: a4 03 02 08  	.word	0x080203a4
 80093a4: d0 f1 01 08  	.word	0x0801f1d0

080093a8 <bmi08x_gyro_init>:
; {
 80093a8: b580         	push	{r7, lr}
 80093aa: b09e         	sub	sp, #0x78
 80093ac: af04         	add	r7, sp, #0x10
 80093ae: 6078         	str	r0, [r7, #0x4]
; 	const struct bmi08x_gyro_config *config = dev->config;
 80093b0: 687b         	ldr	r3, [r7, #0x4]
 80093b2: 685b         	ldr	r3, [r3, #0x4]
 80093b4: 663b         	str	r3, [r7, #0x60]
; 	uint8_t val = 0U;
 80093b6: 2300         	movs	r3, #0x0
 80093b8: 73fb         	strb	r3, [r7, #0xf]
; 	ret = bmi08x_bus_check(dev);
 80093ba: 6878         	ldr	r0, [r7, #0x4]
 80093bc: f00f fbf3    	bl	0x8018ba6 <bmi08x_bus_check> @ imm = #0xf7e6
 80093c0: 6678         	str	r0, [r7, #0x64]
; 	if (ret < 0) {
 80093c2: 6e7b         	ldr	r3, [r7, #0x64]
 80093c4: 2b00         	cmp	r3, #0x0
 80093c6: da1e         	bge	0x8009406 <bmi08x_gyro_init+0x5e> @ imm = #0x3c
; 		LOG_ERR("Bus not ready for '%s'", dev->name);
 80093c8: 2303         	movs	r3, #0x3
 80093ca: 2b00         	cmp	r3, #0x0
 80093cc: d019         	beq	0x8009402 <bmi08x_gyro_init+0x5a> @ imm = #0x32
 80093ce: 2301         	movs	r3, #0x1
 80093d0: 75fb         	strb	r3, [r7, #0x17]
 80093d2: 7dfb         	ldrb	r3, [r7, #0x17]
 80093d4: f083 0301    	eor	r3, r3, #0x1
 80093d8: b2db         	uxtb	r3, r3
 80093da: 2b00         	cmp	r3, #0x0
 80093dc: d111         	bne	0x8009402 <bmi08x_gyro_init+0x5a> @ imm = #0x22
 80093de: 4ba8         	ldr	r3, [pc, #0x2a0]        @ 0x8009680 <bmi08x_gyro_init+0x2d8>
 80093e0: 6819         	ldr	r1, [r3]
 80093e2: 687b         	ldr	r3, [r7, #0x4]
 80093e4: 681b         	ldr	r3, [r3]
 80093e6: 9303         	str	r3, [sp, #0xc]
 80093e8: 4ba6         	ldr	r3, [pc, #0x298]        @ 0x8009684 <bmi08x_gyro_init+0x2dc>
 80093ea: 9302         	str	r3, [sp, #0x8]
 80093ec: 2300         	movs	r3, #0x0
 80093ee: 9301         	str	r3, [sp, #0x4]
 80093f0: 2300         	movs	r3, #0x0
 80093f2: 9300         	str	r3, [sp]
 80093f4: 2300         	movs	r3, #0x0
 80093f6: 2201         	movs	r2, #0x1
 80093f8: 2000         	movs	r0, #0x0
 80093fa: f00f faa6    	bl	0x801894a <z_log_msg_runtime_create> @ imm = #0xf54c
 80093fe: 2300         	movs	r3, #0x0
 8009400: 613b         	str	r3, [r7, #0x10]
; 		return ret;
 8009402: 6e7b         	ldr	r3, [r7, #0x64]
 8009404: e179         	b	0x80096fa <bmi08x_gyro_init+0x352> @ imm = #0x2f2
; 	ret = bmi08x_gyro_byte_write(dev, BMI08X_REG_GYRO_SOFTRESET, BMI08X_SOFT_RESET_CMD);
 8009406: 22b6         	movs	r2, #0xb6
 8009408: 2114         	movs	r1, #0x14
 800940a: 6878         	ldr	r0, [r7, #0x4]
 800940c: f00f fc29    	bl	0x8018c62 <bmi08x_gyro_byte_write> @ imm = #0xf852
 8009410: 6678         	str	r0, [r7, #0x64]
; 	if (ret < 0) {
 8009412: 6e7b         	ldr	r3, [r7, #0x64]
 8009414: 2b00         	cmp	r3, #0x0
 8009416: da1b         	bge	0x8009450 <bmi08x_gyro_init+0xa8> @ imm = #0x36
; 		LOG_ERR("Cannot reboot chip.");
 8009418: 2303         	movs	r3, #0x3
 800941a: 2b00         	cmp	r3, #0x0
 800941c: d016         	beq	0x800944c <bmi08x_gyro_init+0xa4> @ imm = #0x2c
 800941e: 2301         	movs	r3, #0x1
 8009420: 77fb         	strb	r3, [r7, #0x1f]
 8009422: 7ffb         	ldrb	r3, [r7, #0x1f]
 8009424: f083 0301    	eor	r3, r3, #0x1
 8009428: b2db         	uxtb	r3, r3
 800942a: 2b00         	cmp	r3, #0x0
 800942c: d10e         	bne	0x800944c <bmi08x_gyro_init+0xa4> @ imm = #0x1c
 800942e: 4b94         	ldr	r3, [pc, #0x250]        @ 0x8009680 <bmi08x_gyro_init+0x2d8>
 8009430: 6819         	ldr	r1, [r3]
 8009432: 4b95         	ldr	r3, [pc, #0x254]        @ 0x8009688 <bmi08x_gyro_init+0x2e0>
 8009434: 9302         	str	r3, [sp, #0x8]
 8009436: 2300         	movs	r3, #0x0
 8009438: 9301         	str	r3, [sp, #0x4]
 800943a: 2300         	movs	r3, #0x0
 800943c: 9300         	str	r3, [sp]
 800943e: 2300         	movs	r3, #0x0
 8009440: 2201         	movs	r2, #0x1
 8009442: 2000         	movs	r0, #0x0
 8009444: f00f fa81    	bl	0x801894a <z_log_msg_runtime_create> @ imm = #0xf502
 8009448: 2300         	movs	r3, #0x0
 800944a: 61bb         	str	r3, [r7, #0x18]
; 		return ret;
 800944c: 6e7b         	ldr	r3, [r7, #0x64]
 800944e: e154         	b	0x80096fa <bmi08x_gyro_init+0x352> @ imm = #0x2a8
; 	k_msleep(BMI08X_GYRO_SOFTRESET_DELAY);
 8009450: 201e         	movs	r0, #0x1e
 8009452: f00f fa40    	bl	0x80188d6 <k_msleep>    @ imm = #0xf480
; 	ret = bmi08x_gyro_byte_read(dev, BMI08X_REG_GYRO_CHIP_ID, &val);
 8009456: f107 030f    	add.w	r3, r7, #0xf
 800945a: 461a         	mov	r2, r3
 800945c: 2100         	movs	r1, #0x0
 800945e: 6878         	ldr	r0, [r7, #0x4]
 8009460: f00f fbe8    	bl	0x8018c34 <bmi08x_gyro_byte_read> @ imm = #0xf7d0
 8009464: 6678         	str	r0, [r7, #0x64]
; 	if (ret < 0) {
 8009466: 6e7b         	ldr	r3, [r7, #0x64]
 8009468: 2b00         	cmp	r3, #0x0
 800946a: da1d         	bge	0x80094a8 <bmi08x_gyro_init+0x100> @ imm = #0x3a
; 		LOG_ERR("Failed to read chip id.");
 800946c: 2303         	movs	r3, #0x3
 800946e: 2b00         	cmp	r3, #0x0
 8009470: d018         	beq	0x80094a4 <bmi08x_gyro_init+0xfc> @ imm = #0x30
 8009472: 2301         	movs	r3, #0x1
 8009474: f887 3027    	strb.w	r3, [r7, #0x27]
 8009478: f897 3027    	ldrb.w	r3, [r7, #0x27]
 800947c: f083 0301    	eor	r3, r3, #0x1
 8009480: b2db         	uxtb	r3, r3
 8009482: 2b00         	cmp	r3, #0x0
 8009484: d10e         	bne	0x80094a4 <bmi08x_gyro_init+0xfc> @ imm = #0x1c
 8009486: 4b7e         	ldr	r3, [pc, #0x1f8]        @ 0x8009680 <bmi08x_gyro_init+0x2d8>
 8009488: 6819         	ldr	r1, [r3]
 800948a: 4b80         	ldr	r3, [pc, #0x200]        @ 0x800968c <bmi08x_gyro_init+0x2e4>
 800948c: 9302         	str	r3, [sp, #0x8]
 800948e: 2300         	movs	r3, #0x0
 8009490: 9301         	str	r3, [sp, #0x4]
 8009492: 2300         	movs	r3, #0x0
 8009494: 9300         	str	r3, [sp]
 8009496: 2300         	movs	r3, #0x0
 8009498: 2201         	movs	r2, #0x1
 800949a: 2000         	movs	r0, #0x0
 800949c: f00f fa55    	bl	0x801894a <z_log_msg_runtime_create> @ imm = #0xf4aa
 80094a0: 2300         	movs	r3, #0x0
 80094a2: 623b         	str	r3, [r7, #0x20]
; 		return ret;
 80094a4: 6e7b         	ldr	r3, [r7, #0x64]
 80094a6: e128         	b	0x80096fa <bmi08x_gyro_init+0x352> @ imm = #0x250
; 	if (val != BMI08X_GYRO_CHIP_ID) {
 80094a8: 7bfb         	ldrb	r3, [r7, #0xf]
 80094aa: 2b0f         	cmp	r3, #0xf
 80094ac: d020         	beq	0x80094f0 <bmi08x_gyro_init+0x148> @ imm = #0x40
; 		LOG_ERR("Unsupported chip detected (0x%02x)!", val);
 80094ae: 2303         	movs	r3, #0x3
 80094b0: 2b00         	cmp	r3, #0x0
 80094b2: d01a         	beq	0x80094ea <bmi08x_gyro_init+0x142> @ imm = #0x34
 80094b4: 2301         	movs	r3, #0x1
 80094b6: f887 302f    	strb.w	r3, [r7, #0x2f]
 80094ba: f897 302f    	ldrb.w	r3, [r7, #0x2f]
 80094be: f083 0301    	eor	r3, r3, #0x1
 80094c2: b2db         	uxtb	r3, r3
 80094c4: 2b00         	cmp	r3, #0x0
 80094c6: d110         	bne	0x80094ea <bmi08x_gyro_init+0x142> @ imm = #0x20
 80094c8: 4b6d         	ldr	r3, [pc, #0x1b4]        @ 0x8009680 <bmi08x_gyro_init+0x2d8>
 80094ca: 6819         	ldr	r1, [r3]
 80094cc: 7bfb         	ldrb	r3, [r7, #0xf]
 80094ce: 9303         	str	r3, [sp, #0xc]
 80094d0: 4b6f         	ldr	r3, [pc, #0x1bc]        @ 0x8009690 <bmi08x_gyro_init+0x2e8>
 80094d2: 9302         	str	r3, [sp, #0x8]
 80094d4: 2300         	movs	r3, #0x0
 80094d6: 9301         	str	r3, [sp, #0x4]
 80094d8: 2300         	movs	r3, #0x0
 80094da: 9300         	str	r3, [sp]
 80094dc: 2300         	movs	r3, #0x0
 80094de: 2201         	movs	r2, #0x1
 80094e0: 2000         	movs	r0, #0x0
 80094e2: f00f fa32    	bl	0x801894a <z_log_msg_runtime_create> @ imm = #0xf464
 80094e6: 2300         	movs	r3, #0x0
 80094e8: 62bb         	str	r3, [r7, #0x28]
; 		return -ENODEV;
 80094ea: f06f 0312    	mvn	r3, #0x12
 80094ee: e104         	b	0x80096fa <bmi08x_gyro_init+0x352> @ imm = #0x208
; 	ret = bmi08x_gyr_range_set(dev, config->gyro_fs);
 80094f0: 6e3b         	ldr	r3, [r7, #0x60]
 80094f2: 8d1b         	ldrh	r3, [r3, #0x28]
 80094f4: 4619         	mov	r1, r3
 80094f6: 6878         	ldr	r0, [r7, #0x4]
 80094f8: f7ff fd6e    	bl	0x8008fd8 <bmi08x_gyr_range_set> @ imm = #-0x524
 80094fc: 6678         	str	r0, [r7, #0x64]
; 	if (ret < 0) {
 80094fe: 6e7b         	ldr	r3, [r7, #0x64]
 8009500: 2b00         	cmp	r3, #0x0
 8009502: da1d         	bge	0x8009540 <bmi08x_gyro_init+0x198> @ imm = #0x3a
; 		LOG_ERR("Cannot set default range for gyroscope.");
 8009504: 2303         	movs	r3, #0x3
 8009506: 2b00         	cmp	r3, #0x0
 8009508: d018         	beq	0x800953c <bmi08x_gyro_init+0x194> @ imm = #0x30
 800950a: 2301         	movs	r3, #0x1
 800950c: f887 3037    	strb.w	r3, [r7, #0x37]
 8009510: f897 3037    	ldrb.w	r3, [r7, #0x37]
 8009514: f083 0301    	eor	r3, r3, #0x1
 8009518: b2db         	uxtb	r3, r3
 800951a: 2b00         	cmp	r3, #0x0
 800951c: d10e         	bne	0x800953c <bmi08x_gyro_init+0x194> @ imm = #0x1c
 800951e: 4b58         	ldr	r3, [pc, #0x160]        @ 0x8009680 <bmi08x_gyro_init+0x2d8>
 8009520: 6819         	ldr	r1, [r3]
 8009522: 4b5c         	ldr	r3, [pc, #0x170]        @ 0x8009694 <bmi08x_gyro_init+0x2ec>
 8009524: 9302         	str	r3, [sp, #0x8]
 8009526: 2300         	movs	r3, #0x0
 8009528: 9301         	str	r3, [sp, #0x4]
 800952a: 2300         	movs	r3, #0x0
 800952c: 9300         	str	r3, [sp]
 800952e: 2300         	movs	r3, #0x0
 8009530: 2201         	movs	r2, #0x1
 8009532: 2000         	movs	r0, #0x0
 8009534: f00f fa09    	bl	0x801894a <z_log_msg_runtime_create> @ imm = #0xf412
 8009538: 2300         	movs	r3, #0x0
 800953a: 633b         	str	r3, [r7, #0x30]
; 		return ret;
 800953c: 6e7b         	ldr	r3, [r7, #0x64]
 800953e: e0dc         	b	0x80096fa <bmi08x_gyro_init+0x352> @ imm = #0x1b8
; 	ret = bmi08x_gyro_byte_write(dev, BMI08X_REG_GYRO_BANDWIDTH, config->gyro_hz);
 8009540: 6e3b         	ldr	r3, [r7, #0x60]
 8009542: f893 3026    	ldrb.w	r3, [r3, #0x26]
 8009546: 461a         	mov	r2, r3
 8009548: 2110         	movs	r1, #0x10
 800954a: 6878         	ldr	r0, [r7, #0x4]
 800954c: f00f fb89    	bl	0x8018c62 <bmi08x_gyro_byte_write> @ imm = #0xf712
 8009550: 6678         	str	r0, [r7, #0x64]
; 	if (ret < 0) {
 8009552: 6e7b         	ldr	r3, [r7, #0x64]
 8009554: 2b00         	cmp	r3, #0x0
 8009556: da1d         	bge	0x8009594 <bmi08x_gyro_init+0x1ec> @ imm = #0x3a
; 		LOG_ERR("Failed to set gyro's default ODR.");
 8009558: 2303         	movs	r3, #0x3
 800955a: 2b00         	cmp	r3, #0x0
 800955c: d018         	beq	0x8009590 <bmi08x_gyro_init+0x1e8> @ imm = #0x30
 800955e: 2301         	movs	r3, #0x1
 8009560: f887 303f    	strb.w	r3, [r7, #0x3f]
 8009564: f897 303f    	ldrb.w	r3, [r7, #0x3f]
 8009568: f083 0301    	eor	r3, r3, #0x1
 800956c: b2db         	uxtb	r3, r3
 800956e: 2b00         	cmp	r3, #0x0
 8009570: d10e         	bne	0x8009590 <bmi08x_gyro_init+0x1e8> @ imm = #0x1c
 8009572: 4b43         	ldr	r3, [pc, #0x10c]        @ 0x8009680 <bmi08x_gyro_init+0x2d8>
 8009574: 6819         	ldr	r1, [r3]
 8009576: 4b48         	ldr	r3, [pc, #0x120]        @ 0x8009698 <bmi08x_gyro_init+0x2f0>
 8009578: 9302         	str	r3, [sp, #0x8]
 800957a: 2300         	movs	r3, #0x0
 800957c: 9301         	str	r3, [sp, #0x4]
 800957e: 2300         	movs	r3, #0x0
 8009580: 9300         	str	r3, [sp]
 8009582: 2300         	movs	r3, #0x0
 8009584: 2201         	movs	r2, #0x1
 8009586: 2000         	movs	r0, #0x0
 8009588: f00f f9df    	bl	0x801894a <z_log_msg_runtime_create> @ imm = #0xf3be
 800958c: 2300         	movs	r3, #0x0
 800958e: 63bb         	str	r3, [r7, #0x38]
; 		return ret;
 8009590: 6e7b         	ldr	r3, [r7, #0x64]
 8009592: e0b2         	b	0x80096fa <bmi08x_gyro_init+0x352> @ imm = #0x164
; 	ret = bmi08x_gyr_trigger_mode_init(dev);
 8009594: 6878         	ldr	r0, [r7, #0x4]
 8009596: f000 faed    	bl	0x8009b74 <bmi08x_gyr_trigger_mode_init> @ imm = #0x5da
 800959a: 6678         	str	r0, [r7, #0x64]
; 	if (ret < 0) {
 800959c: 6e7b         	ldr	r3, [r7, #0x64]
 800959e: 2b00         	cmp	r3, #0x0
 80095a0: da1d         	bge	0x80095de <bmi08x_gyro_init+0x236> @ imm = #0x3a
; 		LOG_ERR("Cannot set up trigger mode.");
 80095a2: 2303         	movs	r3, #0x3
 80095a4: 2b00         	cmp	r3, #0x0
 80095a6: d018         	beq	0x80095da <bmi08x_gyro_init+0x232> @ imm = #0x30
 80095a8: 2301         	movs	r3, #0x1
 80095aa: f887 3047    	strb.w	r3, [r7, #0x47]
 80095ae: f897 3047    	ldrb.w	r3, [r7, #0x47]
 80095b2: f083 0301    	eor	r3, r3, #0x1
 80095b6: b2db         	uxtb	r3, r3
 80095b8: 2b00         	cmp	r3, #0x0
 80095ba: d10e         	bne	0x80095da <bmi08x_gyro_init+0x232> @ imm = #0x1c
 80095bc: 4b30         	ldr	r3, [pc, #0xc0]         @ 0x8009680 <bmi08x_gyro_init+0x2d8>
 80095be: 6819         	ldr	r1, [r3]
 80095c0: 4b36         	ldr	r3, [pc, #0xd8]         @ 0x800969c <bmi08x_gyro_init+0x2f4>
 80095c2: 9302         	str	r3, [sp, #0x8]
 80095c4: 2300         	movs	r3, #0x0
 80095c6: 9301         	str	r3, [sp, #0x4]
 80095c8: 2300         	movs	r3, #0x0
 80095ca: 9300         	str	r3, [sp]
 80095cc: 2300         	movs	r3, #0x0
 80095ce: 2201         	movs	r2, #0x1
 80095d0: 2000         	movs	r0, #0x0
 80095d2: f00f f9ba    	bl	0x801894a <z_log_msg_runtime_create> @ imm = #0xf374
 80095d6: 2300         	movs	r3, #0x0
 80095d8: 643b         	str	r3, [r7, #0x40]
; 		return ret;
 80095da: 6e7b         	ldr	r3, [r7, #0x64]
 80095dc: e08d         	b	0x80096fa <bmi08x_gyro_init+0x352> @ imm = #0x11a
; 	ret = bmi08x_gyro_byte_write(dev, BMI08X_REG_GYRO_INT_CTRL, 0x80);
 80095de: 2280         	movs	r2, #0x80
 80095e0: 2115         	movs	r1, #0x15
 80095e2: 6878         	ldr	r0, [r7, #0x4]
 80095e4: f00f fb3d    	bl	0x8018c62 <bmi08x_gyro_byte_write> @ imm = #0xf67a
 80095e8: 6678         	str	r0, [r7, #0x64]
; 	if (ret < 0) {
 80095ea: 6e7b         	ldr	r3, [r7, #0x64]
 80095ec: 2b00         	cmp	r3, #0x0
 80095ee: da1d         	bge	0x800962c <bmi08x_gyro_init+0x284> @ imm = #0x3a
; 		LOG_ERR("Failed to map interrupts.");
 80095f0: 2303         	movs	r3, #0x3
 80095f2: 2b00         	cmp	r3, #0x0
 80095f4: d018         	beq	0x8009628 <bmi08x_gyro_init+0x280> @ imm = #0x30
 80095f6: 2301         	movs	r3, #0x1
 80095f8: f887 304f    	strb.w	r3, [r7, #0x4f]
 80095fc: f897 304f    	ldrb.w	r3, [r7, #0x4f]
 8009600: f083 0301    	eor	r3, r3, #0x1
 8009604: b2db         	uxtb	r3, r3
 8009606: 2b00         	cmp	r3, #0x0
 8009608: d10e         	bne	0x8009628 <bmi08x_gyro_init+0x280> @ imm = #0x1c
 800960a: 4b1d         	ldr	r3, [pc, #0x74]         @ 0x8009680 <bmi08x_gyro_init+0x2d8>
 800960c: 6819         	ldr	r1, [r3]
 800960e: 4b24         	ldr	r3, [pc, #0x90]         @ 0x80096a0 <bmi08x_gyro_init+0x2f8>
 8009610: 9302         	str	r3, [sp, #0x8]
 8009612: 2300         	movs	r3, #0x0
 8009614: 9301         	str	r3, [sp, #0x4]
 8009616: 2300         	movs	r3, #0x0
 8009618: 9300         	str	r3, [sp]
 800961a: 2300         	movs	r3, #0x0
 800961c: 2201         	movs	r2, #0x1
 800961e: 2000         	movs	r0, #0x0
 8009620: f00f f993    	bl	0x801894a <z_log_msg_runtime_create> @ imm = #0xf326
 8009624: 2300         	movs	r3, #0x0
 8009626: 64bb         	str	r3, [r7, #0x48]
; 		return ret;
 8009628: 6e7b         	ldr	r3, [r7, #0x64]
 800962a: e066         	b	0x80096fa <bmi08x_gyro_init+0x352> @ imm = #0xcc
; 				     config->int3_4_conf_io);
 800962c: 6e3b         	ldr	r3, [r7, #0x60]
 800962e: f893 3025    	ldrb.w	r3, [r3, #0x25]
; 	ret = bmi08x_gyro_byte_write(dev, BMI08X_REG_GYRO_INT3_INT4_IO_CONF,
 8009632: 461a         	mov	r2, r3
 8009634: 2116         	movs	r1, #0x16
 8009636: 6878         	ldr	r0, [r7, #0x4]
 8009638: f00f fb13    	bl	0x8018c62 <bmi08x_gyro_byte_write> @ imm = #0xf626
 800963c: 6678         	str	r0, [r7, #0x64]
; 	if (ret < 0) {
 800963e: 6e7b         	ldr	r3, [r7, #0x64]
 8009640: 2b00         	cmp	r3, #0x0
 8009642: da2f         	bge	0x80096a4 <bmi08x_gyro_init+0x2fc> @ imm = #0x5e
; 		LOG_ERR("Failed to map interrupts.");
 8009644: 2303         	movs	r3, #0x3
 8009646: 2b00         	cmp	r3, #0x0
 8009648: d018         	beq	0x800967c <bmi08x_gyro_init+0x2d4> @ imm = #0x30
 800964a: 2301         	movs	r3, #0x1
 800964c: f887 3057    	strb.w	r3, [r7, #0x57]
 8009650: f897 3057    	ldrb.w	r3, [r7, #0x57]
 8009654: f083 0301    	eor	r3, r3, #0x1
 8009658: b2db         	uxtb	r3, r3
 800965a: 2b00         	cmp	r3, #0x0
 800965c: d10e         	bne	0x800967c <bmi08x_gyro_init+0x2d4> @ imm = #0x1c
 800965e: 4b08         	ldr	r3, [pc, #0x20]         @ 0x8009680 <bmi08x_gyro_init+0x2d8>
 8009660: 6819         	ldr	r1, [r3]
 8009662: 4b0f         	ldr	r3, [pc, #0x3c]         @ 0x80096a0 <bmi08x_gyro_init+0x2f8>
 8009664: 9302         	str	r3, [sp, #0x8]
 8009666: 2300         	movs	r3, #0x0
 8009668: 9301         	str	r3, [sp, #0x4]
 800966a: 2300         	movs	r3, #0x0
 800966c: 9300         	str	r3, [sp]
 800966e: 2300         	movs	r3, #0x0
 8009670: 2201         	movs	r2, #0x1
 8009672: 2000         	movs	r0, #0x0
 8009674: f00f f969    	bl	0x801894a <z_log_msg_runtime_create> @ imm = #0xf2d2
 8009678: 2300         	movs	r3, #0x0
 800967a: 653b         	str	r3, [r7, #0x50]
; 		return ret;
 800967c: 6e7b         	ldr	r3, [r7, #0x64]
 800967e: e03c         	b	0x80096fa <bmi08x_gyro_init+0x352> @ imm = #0x78

08009680 <$d>:
 8009680: 0c 05 00 20  	.word	0x2000050c
 8009684: ec f1 01 08  	.word	0x0801f1ec
 8009688: 04 f2 01 08  	.word	0x0801f204
 800968c: 18 f2 01 08  	.word	0x0801f218
 8009690: 30 f2 01 08  	.word	0x0801f230
 8009694: 54 f2 01 08  	.word	0x0801f254
 8009698: 7c f2 01 08  	.word	0x0801f27c
 800969c: a0 f2 01 08  	.word	0x0801f2a0
 80096a0: bc f2 01 08  	.word	0x0801f2bc

080096a4 <$t>:
; 	ret = bmi08x_gyro_byte_write(dev, BMI08X_REG_GYRO_INT3_INT4_IO_MAP, config->int3_4_map);
 80096a4: 6e3b         	ldr	r3, [r7, #0x60]
 80096a6: f893 3024    	ldrb.w	r3, [r3, #0x24]
 80096aa: 461a         	mov	r2, r3
 80096ac: 2118         	movs	r1, #0x18
 80096ae: 6878         	ldr	r0, [r7, #0x4]
 80096b0: f00f fad7    	bl	0x8018c62 <bmi08x_gyro_byte_write> @ imm = #0xf5ae
 80096b4: 6678         	str	r0, [r7, #0x64]
; 	if (ret < 0) {
 80096b6: 6e7b         	ldr	r3, [r7, #0x64]
 80096b8: 2b00         	cmp	r3, #0x0
 80096ba: da1d         	bge	0x80096f8 <bmi08x_gyro_init+0x350> @ imm = #0x3a
; 		LOG_ERR("Failed to map interrupts.");
 80096bc: 2303         	movs	r3, #0x3
 80096be: 2b00         	cmp	r3, #0x0
 80096c0: d018         	beq	0x80096f4 <bmi08x_gyro_init+0x34c> @ imm = #0x30
 80096c2: 2301         	movs	r3, #0x1
 80096c4: f887 305f    	strb.w	r3, [r7, #0x5f]
 80096c8: f897 305f    	ldrb.w	r3, [r7, #0x5f]
 80096cc: f083 0301    	eor	r3, r3, #0x1
 80096d0: b2db         	uxtb	r3, r3
 80096d2: 2b00         	cmp	r3, #0x0
 80096d4: d10e         	bne	0x80096f4 <bmi08x_gyro_init+0x34c> @ imm = #0x1c
 80096d6: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x8009704 <bmi08x_gyro_init+0x35c>
 80096d8: 6819         	ldr	r1, [r3]
 80096da: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x8009708 <bmi08x_gyro_init+0x360>
 80096dc: 9302         	str	r3, [sp, #0x8]
 80096de: 2300         	movs	r3, #0x0
 80096e0: 9301         	str	r3, [sp, #0x4]
 80096e2: 2300         	movs	r3, #0x0
 80096e4: 9300         	str	r3, [sp]
 80096e6: 2300         	movs	r3, #0x0
 80096e8: 2201         	movs	r2, #0x1
 80096ea: 2000         	movs	r0, #0x0
 80096ec: f00f f92d    	bl	0x801894a <z_log_msg_runtime_create> @ imm = #0xf25a
 80096f0: 2300         	movs	r3, #0x0
 80096f2: 65bb         	str	r3, [r7, #0x58]
; 		return ret;
 80096f4: 6e7b         	ldr	r3, [r7, #0x64]
 80096f6: e000         	b	0x80096fa <bmi08x_gyro_init+0x352> @ imm = #0x0
; 	return ret;
 80096f8: 6e7b         	ldr	r3, [r7, #0x64]
; }
 80096fa: 4618         	mov	r0, r3
 80096fc: 3768         	adds	r7, #0x68
 80096fe: 46bd         	mov	sp, r7
 8009700: bd80         	pop	{r7, pc}
 8009702: bf00         	nop

08009704 <$d>:
 8009704: 0c 05 00 20  	.word	0x2000050c
 8009708: bc f2 01 08  	.word	0x0801f2bc

0800970c <bmi08x_freq_to_odr_val>:
; {
 800970c: b480         	push	{r7}
 800970e: b085         	sub	sp, #0x14
 8009710: af00         	add	r7, sp, #0x0
 8009712: 4603         	mov	r3, r0
 8009714: 460a         	mov	r2, r1
 8009716: 80fb         	strh	r3, [r7, #0x6]
 8009718: 4613         	mov	r3, r2
 800971a: 80bb         	strh	r3, [r7, #0x4]
; 	if (freq_int == 0U && freq_milli == 0U) {
 800971c: 88fb         	ldrh	r3, [r7, #0x6]
 800971e: 2b00         	cmp	r3, #0x0
 8009720: d105         	bne	0x800972e <bmi08x_freq_to_odr_val+0x22> @ imm = #0xa
 8009722: 88bb         	ldrh	r3, [r7, #0x4]
 8009724: 2b00         	cmp	r3, #0x0
 8009726: d102         	bne	0x800972e <bmi08x_freq_to_odr_val+0x22> @ imm = #0x4
; 		return -EINVAL;
 8009728: f06f 0315    	mvn	r3, #0x15
 800972c: e022         	b	0x8009774 <bmi08x_freq_to_odr_val+0x68> @ imm = #0x44
; 	for (i = 0; i < ARRAY_SIZE(bmi08x_odr_map); i++) {
 800972e: 2300         	movs	r3, #0x0
 8009730: 60fb         	str	r3, [r7, #0xc]
 8009732: e01a         	b	0x800976a <bmi08x_freq_to_odr_val+0x5e> @ imm = #0x34
; 		if (freq_int < bmi08x_odr_map[i].freq_int ||
 8009734: 4a12         	ldr	r2, [pc, #0x48]         @ 0x8009780 <bmi08x_freq_to_odr_val+0x74>
 8009736: 68fb         	ldr	r3, [r7, #0xc]
 8009738: f832 3023    	ldrh.w	r3, [r2, r3, lsl #2]
 800973c: 88fa         	ldrh	r2, [r7, #0x6]
 800973e: 429a         	cmp	r2, r3
 8009740: d30e         	blo	0x8009760 <bmi08x_freq_to_odr_val+0x54> @ imm = #0x1c
; 		    (freq_int == bmi08x_odr_map[i].freq_int &&
 8009742: 4a0f         	ldr	r2, [pc, #0x3c]         @ 0x8009780 <bmi08x_freq_to_odr_val+0x74>
 8009744: 68fb         	ldr	r3, [r7, #0xc]
 8009746: f832 3023    	ldrh.w	r3, [r2, r3, lsl #2]
; 		if (freq_int < bmi08x_odr_map[i].freq_int ||
 800974a: 88fa         	ldrh	r2, [r7, #0x6]
 800974c: 429a         	cmp	r2, r3
 800974e: d109         	bne	0x8009764 <bmi08x_freq_to_odr_val+0x58> @ imm = #0x12
; 		     freq_milli <= bmi08x_odr_map[i].freq_milli)) {
 8009750: 4a0b         	ldr	r2, [pc, #0x2c]         @ 0x8009780 <bmi08x_freq_to_odr_val+0x74>
 8009752: 68fb         	ldr	r3, [r7, #0xc]
 8009754: 009b         	lsls	r3, r3, #0x2
 8009756: 4413         	add	r3, r2
 8009758: 885b         	ldrh	r3, [r3, #0x2]
; 		    (freq_int == bmi08x_odr_map[i].freq_int &&
 800975a: 88ba         	ldrh	r2, [r7, #0x4]
 800975c: 429a         	cmp	r2, r3
 800975e: d801         	bhi	0x8009764 <bmi08x_freq_to_odr_val+0x58> @ imm = #0x2
; 			return i;
 8009760: 68fb         	ldr	r3, [r7, #0xc]
 8009762: e007         	b	0x8009774 <bmi08x_freq_to_odr_val+0x68> @ imm = #0xe
; 	for (i = 0; i < ARRAY_SIZE(bmi08x_odr_map); i++) {
 8009764: 68fb         	ldr	r3, [r7, #0xc]
 8009766: 3301         	adds	r3, #0x1
 8009768: 60fb         	str	r3, [r7, #0xc]
 800976a: 68fb         	ldr	r3, [r7, #0xc]
 800976c: 2b0d         	cmp	r3, #0xd
 800976e: d9e1         	bls	0x8009734 <bmi08x_freq_to_odr_val+0x28> @ imm = #-0x3e
; 	return -EINVAL;
 8009770: f06f 0315    	mvn	r3, #0x15
; }
 8009774: 4618         	mov	r0, r3
 8009776: 3714         	adds	r7, #0x14
 8009778: 46bd         	mov	sp, r7
 800977a: bc80         	pop	{r7}
 800977c: 4770         	bx	lr
 800977e: bf00         	nop

08009780 <$d>:
 8009780: b8 03 02 08  	.word	0x080203b8

08009784 <z_impl_gpio_pin_interrupt_configure>:
; {
 8009784: b590         	push	{r4, r7, lr}
 8009786: b08b         	sub	sp, #0x2c
 8009788: af00         	add	r7, sp, #0x0
 800978a: 60f8         	str	r0, [r7, #0xc]
 800978c: 460b         	mov	r3, r1
 800978e: 607a         	str	r2, [r7, #0x4]
 8009790: 72fb         	strb	r3, [r7, #0xb]
; 	const struct gpio_driver_api *api =
 8009792: 68fb         	ldr	r3, [r7, #0xc]
 8009794: 689b         	ldr	r3, [r3, #0x8]
 8009796: 627b         	str	r3, [r7, #0x24]
; 	__unused const struct gpio_driver_config *const cfg =
 8009798: 68fb         	ldr	r3, [r7, #0xc]
 800979a: 685b         	ldr	r3, [r3, #0x4]
 800979c: 623b         	str	r3, [r7, #0x20]
; 	const struct gpio_driver_data *const data =
 800979e: 68fb         	ldr	r3, [r7, #0xc]
 80097a0: 691b         	ldr	r3, [r3, #0x10]
 80097a2: 61fb         	str	r3, [r7, #0x1c]
; 	if (api->pin_interrupt_configure == NULL) {
 80097a4: 6a7b         	ldr	r3, [r7, #0x24]
 80097a6: 699b         	ldr	r3, [r3, #0x18]
 80097a8: 2b00         	cmp	r3, #0x0
 80097aa: d102         	bne	0x80097b2 <z_impl_gpio_pin_interrupt_configure+0x2e> @ imm = #0x4
; 		return -ENOSYS;
 80097ac: f06f 0357    	mvn	r3, #0x57
 80097b0: e021         	b	0x80097f6 <z_impl_gpio_pin_interrupt_configure+0x72> @ imm = #0x42
; 	if (((flags & GPIO_INT_LEVELS_LOGICAL) != 0) &&
 80097b2: 687b         	ldr	r3, [r7, #0x4]
 80097b4: f403 0300    	and	r3, r3, #0x800000
 80097b8: 2b00         	cmp	r3, #0x0
 80097ba: d00c         	beq	0x80097d6 <z_impl_gpio_pin_interrupt_configure+0x52> @ imm = #0x18
; 	    ((data->invert & (gpio_port_pins_t)BIT(pin)) != 0)) {
 80097bc: 69fb         	ldr	r3, [r7, #0x1c]
 80097be: 681a         	ldr	r2, [r3]
 80097c0: 7afb         	ldrb	r3, [r7, #0xb]
 80097c2: 2101         	movs	r1, #0x1
 80097c4: fa01 f303    	lsl.w	r3, r1, r3
 80097c8: 4013         	ands	r3, r2
; 	if (((flags & GPIO_INT_LEVELS_LOGICAL) != 0) &&
 80097ca: 2b00         	cmp	r3, #0x0
 80097cc: d003         	beq	0x80097d6 <z_impl_gpio_pin_interrupt_configure+0x52> @ imm = #0x6
; 		flags ^= (GPIO_INT_LOW_0 | GPIO_INT_HIGH_1);
 80097ce: 687b         	ldr	r3, [r7, #0x4]
 80097d0: f083 63c0    	eor	r3, r3, #0x6000000
 80097d4: 607b         	str	r3, [r7, #0x4]
; 	trig = (enum gpio_int_trig)(flags & (GPIO_INT_LOW_0 | GPIO_INT_HIGH_1 | GPIO_INT_WAKEUP));
 80097d6: 687a         	ldr	r2, [r7, #0x4]
 80097d8: 4b09         	ldr	r3, [pc, #0x24]         @ 0x8009800 <z_impl_gpio_pin_interrupt_configure+0x7c>
 80097da: 4013         	ands	r3, r2
 80097dc: 61bb         	str	r3, [r7, #0x18]
; 	mode = (enum gpio_int_mode)(flags & (GPIO_INT_EDGE | GPIO_INT_DISABLE | GPIO_INT_ENABLE));
 80097de: 687b         	ldr	r3, [r7, #0x4]
 80097e0: f003 73b0    	and	r3, r3, #0x1600000
 80097e4: 617b         	str	r3, [r7, #0x14]
; 	return api->pin_interrupt_configure(port, pin, mode, trig);
 80097e6: 6a7b         	ldr	r3, [r7, #0x24]
 80097e8: 699c         	ldr	r4, [r3, #0x18]
 80097ea: 7af9         	ldrb	r1, [r7, #0xb]
 80097ec: 69bb         	ldr	r3, [r7, #0x18]
 80097ee: 697a         	ldr	r2, [r7, #0x14]
 80097f0: 68f8         	ldr	r0, [r7, #0xc]
 80097f2: 47a0         	blx	r4
 80097f4: 4603         	mov	r3, r0
; }
 80097f6: 4618         	mov	r0, r3
 80097f8: 372c         	adds	r7, #0x2c
 80097fa: 46bd         	mov	sp, r7
 80097fc: bd90         	pop	{r4, r7, pc}
 80097fe: bf00         	nop

08009800 <$d>:
 8009800: 40 00 00 06  	.word	0x06000040

08009804 <bmi08x_acc_thread_main>:
; {
 8009804: b580         	push	{r7, lr}
 8009806: b086         	sub	sp, #0x18
 8009808: af00         	add	r7, sp, #0x0
 800980a: 60f8         	str	r0, [r7, #0xc]
 800980c: 60b9         	str	r1, [r7, #0x8]
 800980e: 607a         	str	r2, [r7, #0x4]
; 	k_thread_name_set(NULL, "bmi08x_acc_trig");
 8009810: 490b         	ldr	r1, [pc, #0x2c]         @ 0x8009840 <bmi08x_acc_thread_main+0x3c>
 8009812: 2000         	movs	r0, #0x0
 8009814: f00f fbe4    	bl	0x8018fe0 <k_thread_name_set> @ imm = #0xf7c8
; 	const struct device *dev = (const struct device *)arg1;
 8009818: 68fb         	ldr	r3, [r7, #0xc]
 800981a: 617b         	str	r3, [r7, #0x14]
; 	struct bmi08x_accel_data *data = dev->data;
 800981c: 697b         	ldr	r3, [r7, #0x14]
 800981e: 691b         	ldr	r3, [r3, #0x10]
 8009820: 613b         	str	r3, [r7, #0x10]
; 		k_sem_take(&data->sem, K_FOREVER);
 8009822: 693b         	ldr	r3, [r7, #0x10]
 8009824: f503 61dd    	add.w	r1, r3, #0x6e8
 8009828: f04f 32ff    	mov.w	r2, #0xffffffff
 800982c: f04f 33ff    	mov.w	r3, #0xffffffff
 8009830: 4608         	mov	r0, r1
 8009832: f00f fbf3    	bl	0x801901c <k_sem_take>  @ imm = #0xf7e6
; 		bmi08x_handle_interrupts_acc((void *)dev);
 8009836: 6978         	ldr	r0, [r7, #0x14]
 8009838: f00f fc42    	bl	0x80190c0 <bmi08x_handle_interrupts_acc> @ imm = #0xf884
; 	while (1) {
 800983c: bf00         	nop
 800983e: e7f0         	b	0x8009822 <bmi08x_acc_thread_main+0x1e> @ imm = #-0x20

08009840 <$d>:
 8009840: e8 f2 01 08  	.word	0x0801f2e8

08009844 <bmi08x_acc_trigger_mode_init>:
; {
 8009844: b5b0         	push	{r4, r5, r7, lr}
 8009846: b098         	sub	sp, #0x60
 8009848: af08         	add	r7, sp, #0x20
 800984a: 6078         	str	r0, [r7, #0x4]
; 	struct bmi08x_accel_data *data = dev->data;
 800984c: 687b         	ldr	r3, [r7, #0x4]
 800984e: 691b         	ldr	r3, [r3, #0x10]
 8009850: 63fb         	str	r3, [r7, #0x3c]
; 	const struct bmi08x_accel_config *cfg = dev->config;
 8009852: 687b         	ldr	r3, [r7, #0x4]
 8009854: 685b         	ldr	r3, [r3, #0x4]
 8009856: 63bb         	str	r3, [r7, #0x38]
; 	int ret = 0;
 8009858: 2300         	movs	r3, #0x0
 800985a: 637b         	str	r3, [r7, #0x34]
; 	if (!gpio_is_ready_dt(&cfg->int_gpio)) {
 800985c: 6bbb         	ldr	r3, [r7, #0x38]
 800985e: 331c         	adds	r3, #0x1c
 8009860: 4618         	mov	r0, r3
 8009862: f00f facd    	bl	0x8018e00 <gpio_is_ready_dt> @ imm = #0xf59a
 8009866: 4603         	mov	r3, r0
 8009868: f083 0301    	eor	r3, r3, #0x1
 800986c: b2db         	uxtb	r3, r3
 800986e: 2b00         	cmp	r3, #0x0
 8009870: d01c         	beq	0x80098ac <bmi08x_acc_trigger_mode_init+0x68> @ imm = #0x38
; 		LOG_ERR("GPIO device not ready");
 8009872: 2303         	movs	r3, #0x3
 8009874: 2b00         	cmp	r3, #0x0
 8009876: d016         	beq	0x80098a6 <bmi08x_acc_trigger_mode_init+0x62> @ imm = #0x2c
 8009878: 2301         	movs	r3, #0x1
 800987a: 74fb         	strb	r3, [r7, #0x13]
 800987c: 7cfb         	ldrb	r3, [r7, #0x13]
 800987e: f083 0301    	eor	r3, r3, #0x1
 8009882: b2db         	uxtb	r3, r3
 8009884: 2b00         	cmp	r3, #0x0
 8009886: d10e         	bne	0x80098a6 <bmi08x_acc_trigger_mode_init+0x62> @ imm = #0x1c
 8009888: 4b84         	ldr	r3, [pc, #0x210]        @ 0x8009a9c <bmi08x_acc_trigger_mode_init+0x258>
 800988a: 6819         	ldr	r1, [r3]
 800988c: 4b84         	ldr	r3, [pc, #0x210]        @ 0x8009aa0 <bmi08x_acc_trigger_mode_init+0x25c>
 800988e: 9302         	str	r3, [sp, #0x8]
 8009890: 2300         	movs	r3, #0x0
 8009892: 9301         	str	r3, [sp, #0x4]
 8009894: 2300         	movs	r3, #0x0
 8009896: 9300         	str	r3, [sp]
 8009898: 2300         	movs	r3, #0x0
 800989a: 2201         	movs	r2, #0x1
 800989c: 2000         	movs	r0, #0x0
 800989e: f00f fbd8    	bl	0x8019052 <z_log_msg_runtime_create> @ imm = #0xf7b0
 80098a2: 2300         	movs	r3, #0x0
 80098a4: 60fb         	str	r3, [r7, #0xc]
; 		return -ENODEV;
 80098a6: f06f 0312    	mvn	r3, #0x12
 80098aa: e0f2         	b	0x8009a92 <bmi08x_acc_trigger_mode_init+0x24e> @ imm = #0x1e4
; 	k_sem_init(&data->sem, 0, K_SEM_MAX_LIMIT);
 80098ac: 6bfb         	ldr	r3, [r7, #0x3c]
 80098ae: f503 63dd    	add.w	r3, r3, #0x6e8
 80098b2: f04f 32ff    	mov.w	r2, #0xffffffff
 80098b6: 2100         	movs	r1, #0x0
 80098b8: 4618         	mov	r0, r3
 80098ba: f00f fb9f    	bl	0x8018ffc <k_sem_init>  @ imm = #0xf73e
; 	k_thread_create(&data->thread, data->thread_stack,
 80098be: 6bfb         	ldr	r3, [r7, #0x3c]
 80098c0: f503 64c3    	add.w	r4, r3, #0x618
 80098c4: 6bfb         	ldr	r3, [r7, #0x3c]
 80098c6: f103 0518    	add.w	r5, r3, #0x18
; 			NULL, NULL, K_PRIO_COOP(CONFIG_BMI08X_ACCEL_THREAD_PRIORITY), 0, K_NO_WAIT);
 80098ca: f04f 0000    	mov.w	r0, #0x0
 80098ce: f04f 0100    	mov.w	r1, #0x0
; 	k_thread_create(&data->thread, data->thread_stack,
 80098d2: e9cd 0106    	strd	r0, r1, [sp, #24]
 80098d6: 2300         	movs	r3, #0x0
 80098d8: 9304         	str	r3, [sp, #0x10]
 80098da: f06f 0305    	mvn	r3, #0x5
 80098de: 9303         	str	r3, [sp, #0xc]
 80098e0: 2300         	movs	r3, #0x0
 80098e2: 9302         	str	r3, [sp, #0x8]
 80098e4: 2300         	movs	r3, #0x0
 80098e6: 9301         	str	r3, [sp, #0x4]
 80098e8: 687b         	ldr	r3, [r7, #0x4]
 80098ea: 9300         	str	r3, [sp]
 80098ec: 4b6d         	ldr	r3, [pc, #0x1b4]        @ 0x8009aa4 <bmi08x_acc_trigger_mode_init+0x260>
 80098ee: f44f 62c0    	mov.w	r2, #0x600
 80098f2: 4629         	mov	r1, r5
 80098f4: 4620         	mov	r0, r4
 80098f6: f00f fb53    	bl	0x8018fa0 <k_thread_create> @ imm = #0xf6a6
; 		uint8_t map_data = ((cfg->int2_map << BMI08X_ACCEL_INT2_DRDY_POS) |
 80098fa: 6bbb         	ldr	r3, [r7, #0x38]
 80098fc: f893 3025    	ldrb.w	r3, [r3, #0x25]
 8009900: 019b         	lsls	r3, r3, #0x6
 8009902: b25a         	sxtb	r2, r3
; 				    (cfg->int1_map << BMI08X_ACCEL_INT1_DRDY_POS));
 8009904: 6bbb         	ldr	r3, [r7, #0x38]
 8009906: f893 3024    	ldrb.w	r3, [r3, #0x24]
 800990a: 009b         	lsls	r3, r3, #0x2
; 		uint8_t map_data = ((cfg->int2_map << BMI08X_ACCEL_INT2_DRDY_POS) |
 800990c: b25b         	sxtb	r3, r3
 800990e: 4313         	orrs	r3, r2
 8009910: b25b         	sxtb	r3, r3
 8009912: f887 3033    	strb.w	r3, [r7, #0x33]
; 		ret = bmi08x_accel_byte_write(dev, BMI08X_REG_ACCEL_INT1_INT2_MAP_DATA, map_data);
 8009916: f897 3033    	ldrb.w	r3, [r7, #0x33]
 800991a: 461a         	mov	r2, r3
 800991c: 2158         	movs	r1, #0x58
 800991e: 6878         	ldr	r0, [r7, #0x4]
 8009920: f00e ff00    	bl	0x8018724 <bmi08x_accel_byte_write> @ imm = #0xee00
 8009924: 6378         	str	r0, [r7, #0x34]
; 		if (ret < 0) {
 8009926: 6b7b         	ldr	r3, [r7, #0x34]
 8009928: 2b00         	cmp	r3, #0x0
 800992a: da1b         	bge	0x8009964 <bmi08x_acc_trigger_mode_init+0x120> @ imm = #0x36
; 			LOG_ERR("Failed to map interrupts.");
 800992c: 2303         	movs	r3, #0x3
 800992e: 2b00         	cmp	r3, #0x0
 8009930: d016         	beq	0x8009960 <bmi08x_acc_trigger_mode_init+0x11c> @ imm = #0x2c
 8009932: 2301         	movs	r3, #0x1
 8009934: 76fb         	strb	r3, [r7, #0x1b]
 8009936: 7efb         	ldrb	r3, [r7, #0x1b]
 8009938: f083 0301    	eor	r3, r3, #0x1
 800993c: b2db         	uxtb	r3, r3
 800993e: 2b00         	cmp	r3, #0x0
 8009940: d10e         	bne	0x8009960 <bmi08x_acc_trigger_mode_init+0x11c> @ imm = #0x1c
 8009942: 4b56         	ldr	r3, [pc, #0x158]        @ 0x8009a9c <bmi08x_acc_trigger_mode_init+0x258>
 8009944: 6819         	ldr	r1, [r3]
 8009946: 4b58         	ldr	r3, [pc, #0x160]        @ 0x8009aa8 <bmi08x_acc_trigger_mode_init+0x264>
 8009948: 9302         	str	r3, [sp, #0x8]
 800994a: 2300         	movs	r3, #0x0
 800994c: 9301         	str	r3, [sp, #0x4]
 800994e: 2300         	movs	r3, #0x0
 8009950: 9300         	str	r3, [sp]
 8009952: 2300         	movs	r3, #0x0
 8009954: 2201         	movs	r2, #0x1
 8009956: 2000         	movs	r0, #0x0
 8009958: f00f fb7b    	bl	0x8019052 <z_log_msg_runtime_create> @ imm = #0xf6f6
 800995c: 2300         	movs	r3, #0x0
 800995e: 617b         	str	r3, [r7, #0x14]
; 			return ret;
 8009960: 6b7b         	ldr	r3, [r7, #0x34]
 8009962: e096         	b	0x8009a92 <bmi08x_acc_trigger_mode_init+0x24e> @ imm = #0x12c
; 	ret = bmi08x_accel_byte_write(dev, BMI08X_REG_ACCEL_INT1_IO_CONF, cfg->int1_conf_io);
 8009964: 6bbb         	ldr	r3, [r7, #0x38]
 8009966: f893 3026    	ldrb.w	r3, [r3, #0x26]
 800996a: 461a         	mov	r2, r3
 800996c: 2153         	movs	r1, #0x53
 800996e: 6878         	ldr	r0, [r7, #0x4]
 8009970: f00e fed8    	bl	0x8018724 <bmi08x_accel_byte_write> @ imm = #0xedb0
 8009974: 6378         	str	r0, [r7, #0x34]
; 	if (ret < 0) {
 8009976: 6b7b         	ldr	r3, [r7, #0x34]
 8009978: 2b00         	cmp	r3, #0x0
 800997a: da1d         	bge	0x80099b8 <bmi08x_acc_trigger_mode_init+0x174> @ imm = #0x3a
; 		LOG_ERR("Failed to map interrupts.");
 800997c: 2303         	movs	r3, #0x3
 800997e: 2b00         	cmp	r3, #0x0
 8009980: d018         	beq	0x80099b4 <bmi08x_acc_trigger_mode_init+0x170> @ imm = #0x30
 8009982: 2301         	movs	r3, #0x1
 8009984: f887 3023    	strb.w	r3, [r7, #0x23]
 8009988: f897 3023    	ldrb.w	r3, [r7, #0x23]
 800998c: f083 0301    	eor	r3, r3, #0x1
 8009990: b2db         	uxtb	r3, r3
 8009992: 2b00         	cmp	r3, #0x0
 8009994: d10e         	bne	0x80099b4 <bmi08x_acc_trigger_mode_init+0x170> @ imm = #0x1c
 8009996: 4b41         	ldr	r3, [pc, #0x104]        @ 0x8009a9c <bmi08x_acc_trigger_mode_init+0x258>
 8009998: 6819         	ldr	r1, [r3]
 800999a: 4b43         	ldr	r3, [pc, #0x10c]        @ 0x8009aa8 <bmi08x_acc_trigger_mode_init+0x264>
 800999c: 9302         	str	r3, [sp, #0x8]
 800999e: 2300         	movs	r3, #0x0
 80099a0: 9301         	str	r3, [sp, #0x4]
 80099a2: 2300         	movs	r3, #0x0
 80099a4: 9300         	str	r3, [sp]
 80099a6: 2300         	movs	r3, #0x0
 80099a8: 2201         	movs	r2, #0x1
 80099aa: 2000         	movs	r0, #0x0
 80099ac: f00f fb51    	bl	0x8019052 <z_log_msg_runtime_create> @ imm = #0xf6a2
 80099b0: 2300         	movs	r3, #0x0
 80099b2: 61fb         	str	r3, [r7, #0x1c]
; 		return ret;
 80099b4: 6b7b         	ldr	r3, [r7, #0x34]
 80099b6: e06c         	b	0x8009a92 <bmi08x_acc_trigger_mode_init+0x24e> @ imm = #0xd8
; 	ret = bmi08x_accel_byte_write(dev, BMI08X_REG_ACCEL_INT2_IO_CONF, cfg->int2_conf_io);
 80099b8: 6bbb         	ldr	r3, [r7, #0x38]
 80099ba: f893 3027    	ldrb.w	r3, [r3, #0x27]
 80099be: 461a         	mov	r2, r3
 80099c0: 2154         	movs	r1, #0x54
 80099c2: 6878         	ldr	r0, [r7, #0x4]
 80099c4: f00e feae    	bl	0x8018724 <bmi08x_accel_byte_write> @ imm = #0xed5c
 80099c8: 6378         	str	r0, [r7, #0x34]
; 	if (ret < 0) {
 80099ca: 6b7b         	ldr	r3, [r7, #0x34]
 80099cc: 2b00         	cmp	r3, #0x0
 80099ce: da1d         	bge	0x8009a0c <bmi08x_acc_trigger_mode_init+0x1c8> @ imm = #0x3a
; 		LOG_ERR("Failed to map interrupts.");
 80099d0: 2303         	movs	r3, #0x3
 80099d2: 2b00         	cmp	r3, #0x0
 80099d4: d018         	beq	0x8009a08 <bmi08x_acc_trigger_mode_init+0x1c4> @ imm = #0x30
 80099d6: 2301         	movs	r3, #0x1
 80099d8: f887 302b    	strb.w	r3, [r7, #0x2b]
 80099dc: f897 302b    	ldrb.w	r3, [r7, #0x2b]
 80099e0: f083 0301    	eor	r3, r3, #0x1
 80099e4: b2db         	uxtb	r3, r3
 80099e6: 2b00         	cmp	r3, #0x0
 80099e8: d10e         	bne	0x8009a08 <bmi08x_acc_trigger_mode_init+0x1c4> @ imm = #0x1c
 80099ea: 4b2c         	ldr	r3, [pc, #0xb0]         @ 0x8009a9c <bmi08x_acc_trigger_mode_init+0x258>
 80099ec: 6819         	ldr	r1, [r3]
 80099ee: 4b2e         	ldr	r3, [pc, #0xb8]         @ 0x8009aa8 <bmi08x_acc_trigger_mode_init+0x264>
 80099f0: 9302         	str	r3, [sp, #0x8]
 80099f2: 2300         	movs	r3, #0x0
 80099f4: 9301         	str	r3, [sp, #0x4]
 80099f6: 2300         	movs	r3, #0x0
 80099f8: 9300         	str	r3, [sp]
 80099fa: 2300         	movs	r3, #0x0
 80099fc: 2201         	movs	r2, #0x1
 80099fe: 2000         	movs	r0, #0x0
 8009a00: f00f fb27    	bl	0x8019052 <z_log_msg_runtime_create> @ imm = #0xf64e
 8009a04: 2300         	movs	r3, #0x0
 8009a06: 627b         	str	r3, [r7, #0x24]
; 		return ret;
 8009a08: 6b7b         	ldr	r3, [r7, #0x34]
 8009a0a: e042         	b	0x8009a92 <bmi08x_acc_trigger_mode_init+0x24e> @ imm = #0x84
; 	gpio_pin_configure_dt(&cfg->int_gpio, GPIO_INPUT);
 8009a0c: 6bbb         	ldr	r3, [r7, #0x38]
 8009a0e: 331c         	adds	r3, #0x1c
 8009a10: f44f 3180    	mov.w	r1, #0x10000
 8009a14: 4618         	mov	r0, r3
 8009a16: f00f fa5e    	bl	0x8018ed6 <gpio_pin_configure_dt> @ imm = #0xf4bc
; 	gpio_init_callback(&data->gpio_cb, bmi08x_acc_gpio_callback, BIT(cfg->int_gpio.pin));
 8009a1a: 6bf8         	ldr	r0, [r7, #0x3c]
 8009a1c: 6bbb         	ldr	r3, [r7, #0x38]
 8009a1e: f893 3020    	ldrb.w	r3, [r3, #0x20]
 8009a22: 461a         	mov	r2, r3
 8009a24: 2301         	movs	r3, #0x1
 8009a26: 4093         	lsls	r3, r2
 8009a28: 461a         	mov	r2, r3
 8009a2a: 4920         	ldr	r1, [pc, #0x80]         @ 0x8009aac <bmi08x_acc_trigger_mode_init+0x268>
 8009a2c: f00f fa69    	bl	0x8018f02 <gpio_init_callback> @ imm = #0xf4d2
; 	ret = gpio_add_callback(cfg->int_gpio.port, &data->gpio_cb);
 8009a30: 6bbb         	ldr	r3, [r7, #0x38]
 8009a32: 69db         	ldr	r3, [r3, #0x1c]
 8009a34: 6bfa         	ldr	r2, [r7, #0x3c]
 8009a36: 4611         	mov	r1, r2
 8009a38: 4618         	mov	r0, r3
 8009a3a: f00f fa73    	bl	0x8018f24 <gpio_add_callback> @ imm = #0xf4e6
 8009a3e: 6378         	str	r0, [r7, #0x34]
; 	if (ret < 0) {
 8009a40: 6b7b         	ldr	r3, [r7, #0x34]
 8009a42: 2b00         	cmp	r3, #0x0
 8009a44: da1d         	bge	0x8009a82 <bmi08x_acc_trigger_mode_init+0x23e> @ imm = #0x3a
; 		LOG_ERR("Failed to set gpio callback.");
 8009a46: 2303         	movs	r3, #0x3
 8009a48: 2b00         	cmp	r3, #0x0
 8009a4a: d018         	beq	0x8009a7e <bmi08x_acc_trigger_mode_init+0x23a> @ imm = #0x30
 8009a4c: 2301         	movs	r3, #0x1
 8009a4e: f887 3032    	strb.w	r3, [r7, #0x32]
 8009a52: f897 3032    	ldrb.w	r3, [r7, #0x32]
 8009a56: f083 0301    	eor	r3, r3, #0x1
 8009a5a: b2db         	uxtb	r3, r3
 8009a5c: 2b00         	cmp	r3, #0x0
 8009a5e: d10e         	bne	0x8009a7e <bmi08x_acc_trigger_mode_init+0x23a> @ imm = #0x1c
 8009a60: 4b0e         	ldr	r3, [pc, #0x38]         @ 0x8009a9c <bmi08x_acc_trigger_mode_init+0x258>
 8009a62: 6819         	ldr	r1, [r3]
 8009a64: 4b12         	ldr	r3, [pc, #0x48]         @ 0x8009ab0 <bmi08x_acc_trigger_mode_init+0x26c>
 8009a66: 9302         	str	r3, [sp, #0x8]
 8009a68: 2300         	movs	r3, #0x0
 8009a6a: 9301         	str	r3, [sp, #0x4]
 8009a6c: 2300         	movs	r3, #0x0
 8009a6e: 9300         	str	r3, [sp]
 8009a70: 2300         	movs	r3, #0x0
 8009a72: 2201         	movs	r2, #0x1
 8009a74: 2000         	movs	r0, #0x0
 8009a76: f00f faec    	bl	0x8019052 <z_log_msg_runtime_create> @ imm = #0xf5d8
 8009a7a: 2300         	movs	r3, #0x0
 8009a7c: 62fb         	str	r3, [r7, #0x2c]
; 		return ret;
 8009a7e: 6b7b         	ldr	r3, [r7, #0x34]
 8009a80: e007         	b	0x8009a92 <bmi08x_acc_trigger_mode_init+0x24e> @ imm = #0xe
; 	gpio_pin_interrupt_configure_dt(&cfg->int_gpio, GPIO_INT_EDGE_TO_ACTIVE);
 8009a82: 6bbb         	ldr	r3, [r7, #0x38]
 8009a84: 331c         	adds	r3, #0x1c
 8009a86: f04f 61b8    	mov.w	r1, #0x5c00000
 8009a8a: 4618         	mov	r0, r3
 8009a8c: f00f f9c6    	bl	0x8018e1c <gpio_pin_interrupt_configure_dt> @ imm = #0xf38c
; 	return ret;
 8009a90: 6b7b         	ldr	r3, [r7, #0x34]
; }
 8009a92: 4618         	mov	r0, r3
 8009a94: 3740         	adds	r7, #0x40
 8009a96: 46bd         	mov	sp, r7
 8009a98: bdb0         	pop	{r4, r5, r7, pc}
 8009a9a: bf00         	nop

08009a9c <$d>:
 8009a9c: 10 05 00 20  	.word	0x20000510
 8009aa0: f8 f2 01 08  	.word	0x0801f2f8
 8009aa4: 05 98 00 08  	.word	0x08009805
 8009aa8: 10 f3 01 08  	.word	0x0801f310
 8009aac: db 90 01 08  	.word	0x080190db
 8009ab0: 2c f3 01 08  	.word	0x0801f32c

08009ab4 <z_impl_gpio_pin_interrupt_configure>:
; {
 8009ab4: b590         	push	{r4, r7, lr}
 8009ab6: b08b         	sub	sp, #0x2c
 8009ab8: af00         	add	r7, sp, #0x0
 8009aba: 60f8         	str	r0, [r7, #0xc]
 8009abc: 460b         	mov	r3, r1
 8009abe: 607a         	str	r2, [r7, #0x4]
 8009ac0: 72fb         	strb	r3, [r7, #0xb]
; 	const struct gpio_driver_api *api =
 8009ac2: 68fb         	ldr	r3, [r7, #0xc]
 8009ac4: 689b         	ldr	r3, [r3, #0x8]
 8009ac6: 627b         	str	r3, [r7, #0x24]
; 	__unused const struct gpio_driver_config *const cfg =
 8009ac8: 68fb         	ldr	r3, [r7, #0xc]
 8009aca: 685b         	ldr	r3, [r3, #0x4]
 8009acc: 623b         	str	r3, [r7, #0x20]
; 	const struct gpio_driver_data *const data =
 8009ace: 68fb         	ldr	r3, [r7, #0xc]
 8009ad0: 691b         	ldr	r3, [r3, #0x10]
 8009ad2: 61fb         	str	r3, [r7, #0x1c]
; 	if (api->pin_interrupt_configure == NULL) {
 8009ad4: 6a7b         	ldr	r3, [r7, #0x24]
 8009ad6: 699b         	ldr	r3, [r3, #0x18]
 8009ad8: 2b00         	cmp	r3, #0x0
 8009ada: d102         	bne	0x8009ae2 <z_impl_gpio_pin_interrupt_configure+0x2e> @ imm = #0x4
; 		return -ENOSYS;
 8009adc: f06f 0357    	mvn	r3, #0x57
 8009ae0: e021         	b	0x8009b26 <z_impl_gpio_pin_interrupt_configure+0x72> @ imm = #0x42
; 	if (((flags & GPIO_INT_LEVELS_LOGICAL) != 0) &&
 8009ae2: 687b         	ldr	r3, [r7, #0x4]
 8009ae4: f403 0300    	and	r3, r3, #0x800000
 8009ae8: 2b00         	cmp	r3, #0x0
 8009aea: d00c         	beq	0x8009b06 <z_impl_gpio_pin_interrupt_configure+0x52> @ imm = #0x18
; 	    ((data->invert & (gpio_port_pins_t)BIT(pin)) != 0)) {
 8009aec: 69fb         	ldr	r3, [r7, #0x1c]
 8009aee: 681a         	ldr	r2, [r3]
 8009af0: 7afb         	ldrb	r3, [r7, #0xb]
 8009af2: 2101         	movs	r1, #0x1
 8009af4: fa01 f303    	lsl.w	r3, r1, r3
 8009af8: 4013         	ands	r3, r2
; 	if (((flags & GPIO_INT_LEVELS_LOGICAL) != 0) &&
 8009afa: 2b00         	cmp	r3, #0x0
 8009afc: d003         	beq	0x8009b06 <z_impl_gpio_pin_interrupt_configure+0x52> @ imm = #0x6
; 		flags ^= (GPIO_INT_LOW_0 | GPIO_INT_HIGH_1);
 8009afe: 687b         	ldr	r3, [r7, #0x4]
 8009b00: f083 63c0    	eor	r3, r3, #0x6000000
 8009b04: 607b         	str	r3, [r7, #0x4]
; 	trig = (enum gpio_int_trig)(flags & (GPIO_INT_LOW_0 | GPIO_INT_HIGH_1 | GPIO_INT_WAKEUP));
 8009b06: 687a         	ldr	r2, [r7, #0x4]
 8009b08: 4b09         	ldr	r3, [pc, #0x24]         @ 0x8009b30 <z_impl_gpio_pin_interrupt_configure+0x7c>
 8009b0a: 4013         	ands	r3, r2
 8009b0c: 61bb         	str	r3, [r7, #0x18]
; 	mode = (enum gpio_int_mode)(flags & (GPIO_INT_EDGE | GPIO_INT_DISABLE | GPIO_INT_ENABLE));
 8009b0e: 687b         	ldr	r3, [r7, #0x4]
 8009b10: f003 73b0    	and	r3, r3, #0x1600000
 8009b14: 617b         	str	r3, [r7, #0x14]
; 	return api->pin_interrupt_configure(port, pin, mode, trig);
 8009b16: 6a7b         	ldr	r3, [r7, #0x24]
 8009b18: 699c         	ldr	r4, [r3, #0x18]
 8009b1a: 7af9         	ldrb	r1, [r7, #0xb]
 8009b1c: 69bb         	ldr	r3, [r7, #0x18]
 8009b1e: 697a         	ldr	r2, [r7, #0x14]
 8009b20: 68f8         	ldr	r0, [r7, #0xc]
 8009b22: 47a0         	blx	r4
 8009b24: 4603         	mov	r3, r0
; }
 8009b26: 4618         	mov	r0, r3
 8009b28: 372c         	adds	r7, #0x2c
 8009b2a: 46bd         	mov	sp, r7
 8009b2c: bd90         	pop	{r4, r7, pc}
 8009b2e: bf00         	nop

08009b30 <$d>:
 8009b30: 40 00 00 06  	.word	0x06000040

08009b34 <bmi08x_gyr_thread_main>:
; {
 8009b34: b580         	push	{r7, lr}
 8009b36: b086         	sub	sp, #0x18
 8009b38: af00         	add	r7, sp, #0x0
 8009b3a: 60f8         	str	r0, [r7, #0xc]
 8009b3c: 60b9         	str	r1, [r7, #0x8]
 8009b3e: 607a         	str	r2, [r7, #0x4]
; 	k_thread_name_set(NULL, "bmi08x_gyr_trig");
 8009b40: 490b         	ldr	r1, [pc, #0x2c]         @ 0x8009b70 <bmi08x_gyr_thread_main+0x3c>
 8009b42: 2000         	movs	r0, #0x0
 8009b44: f00f fbf9    	bl	0x801933a <k_thread_name_set> @ imm = #0xf7f2
; 	const struct device *dev = (const struct device *)arg1;
 8009b48: 68fb         	ldr	r3, [r7, #0xc]
 8009b4a: 617b         	str	r3, [r7, #0x14]
; 	struct bmi08x_gyro_data *data = dev->data;
 8009b4c: 697b         	ldr	r3, [r7, #0x14]
 8009b4e: 691b         	ldr	r3, [r3, #0x10]
 8009b50: 613b         	str	r3, [r7, #0x10]
; 		k_sem_take(&data->sem, K_FOREVER);
 8009b52: 693b         	ldr	r3, [r7, #0x10]
 8009b54: f503 61dd    	add.w	r1, r3, #0x6e8
 8009b58: f04f 32ff    	mov.w	r2, #0xffffffff
 8009b5c: f04f 33ff    	mov.w	r3, #0xffffffff
 8009b60: 4608         	mov	r0, r1
 8009b62: f00f fc08    	bl	0x8019376 <k_sem_take>  @ imm = #0xf810
; 		bmi08x_handle_interrupts_gyr((void *)dev);
 8009b66: 6978         	ldr	r0, [r7, #0x14]
 8009b68: f00f fc57    	bl	0x801941a <bmi08x_handle_interrupts_gyr> @ imm = #0xf8ae
; 	while (1) {
 8009b6c: bf00         	nop
 8009b6e: e7f0         	b	0x8009b52 <bmi08x_gyr_thread_main+0x1e> @ imm = #-0x20

08009b70 <$d>:
 8009b70: 4c f3 01 08  	.word	0x0801f34c

08009b74 <bmi08x_gyr_trigger_mode_init>:
; {
 8009b74: b5b0         	push	{r4, r5, r7, lr}
 8009b76: b092         	sub	sp, #0x48
 8009b78: af08         	add	r7, sp, #0x20
 8009b7a: 6078         	str	r0, [r7, #0x4]
; 	struct bmi08x_gyro_data *data = dev->data;
 8009b7c: 687b         	ldr	r3, [r7, #0x4]
 8009b7e: 691b         	ldr	r3, [r3, #0x10]
 8009b80: 627b         	str	r3, [r7, #0x24]
; 	const struct bmi08x_gyro_config *cfg = dev->config;
 8009b82: 687b         	ldr	r3, [r7, #0x4]
 8009b84: 685b         	ldr	r3, [r3, #0x4]
 8009b86: 623b         	str	r3, [r7, #0x20]
; 	if (!gpio_is_ready_dt(&cfg->int_gpio)) {
 8009b88: 6a3b         	ldr	r3, [r7, #0x20]
 8009b8a: 331c         	adds	r3, #0x1c
 8009b8c: 4618         	mov	r0, r3
 8009b8e: f00f fae4    	bl	0x801915a <gpio_is_ready_dt> @ imm = #0xf5c8
 8009b92: 4603         	mov	r3, r0
 8009b94: f083 0301    	eor	r3, r3, #0x1
 8009b98: b2db         	uxtb	r3, r3
 8009b9a: 2b00         	cmp	r3, #0x0
 8009b9c: d01c         	beq	0x8009bd8 <bmi08x_gyr_trigger_mode_init+0x64> @ imm = #0x38
; 		LOG_ERR("GPIO device not ready");
 8009b9e: 2303         	movs	r3, #0x3
 8009ba0: 2b00         	cmp	r3, #0x0
 8009ba2: d016         	beq	0x8009bd2 <bmi08x_gyr_trigger_mode_init+0x5e> @ imm = #0x2c
 8009ba4: 2301         	movs	r3, #0x1
 8009ba6: 74fb         	strb	r3, [r7, #0x13]
 8009ba8: 7cfb         	ldrb	r3, [r7, #0x13]
 8009baa: f083 0301    	eor	r3, r3, #0x1
 8009bae: b2db         	uxtb	r3, r3
 8009bb0: 2b00         	cmp	r3, #0x0
 8009bb2: d10e         	bne	0x8009bd2 <bmi08x_gyr_trigger_mode_init+0x5e> @ imm = #0x1c
 8009bb4: 4b3e         	ldr	r3, [pc, #0xf8]         @ 0x8009cb0 <bmi08x_gyr_trigger_mode_init+0x13c>
 8009bb6: 6819         	ldr	r1, [r3]
 8009bb8: 4b3e         	ldr	r3, [pc, #0xf8]         @ 0x8009cb4 <bmi08x_gyr_trigger_mode_init+0x140>
 8009bba: 9302         	str	r3, [sp, #0x8]
 8009bbc: 2300         	movs	r3, #0x0
 8009bbe: 9301         	str	r3, [sp, #0x4]
 8009bc0: 2300         	movs	r3, #0x0
 8009bc2: 9300         	str	r3, [sp]
 8009bc4: 2300         	movs	r3, #0x0
 8009bc6: 2201         	movs	r2, #0x1
 8009bc8: 2000         	movs	r0, #0x0
 8009bca: f00f fbef    	bl	0x80193ac <z_log_msg_runtime_create> @ imm = #0xf7de
 8009bce: 2300         	movs	r3, #0x0
 8009bd0: 60fb         	str	r3, [r7, #0xc]
; 		return -ENODEV;
 8009bd2: f06f 0312    	mvn	r3, #0x12
 8009bd6: e067         	b	0x8009ca8 <bmi08x_gyr_trigger_mode_init+0x134> @ imm = #0xce
; 	k_sem_init(&data->sem, 0, K_SEM_MAX_LIMIT);
 8009bd8: 6a7b         	ldr	r3, [r7, #0x24]
 8009bda: f503 63dd    	add.w	r3, r3, #0x6e8
 8009bde: f04f 32ff    	mov.w	r2, #0xffffffff
 8009be2: 2100         	movs	r1, #0x0
 8009be4: 4618         	mov	r0, r3
 8009be6: f00f fbb6    	bl	0x8019356 <k_sem_init>  @ imm = #0xf76c
; 	k_thread_create(&data->thread, data->thread_stack,
 8009bea: 6a7b         	ldr	r3, [r7, #0x24]
 8009bec: f503 64c3    	add.w	r4, r3, #0x618
 8009bf0: 6a7b         	ldr	r3, [r7, #0x24]
 8009bf2: f103 0518    	add.w	r5, r3, #0x18
; 			NULL, NULL, K_PRIO_COOP(CONFIG_BMI08X_GYRO_THREAD_PRIORITY), 0, K_NO_WAIT);
 8009bf6: f04f 0000    	mov.w	r0, #0x0
 8009bfa: f04f 0100    	mov.w	r1, #0x0
; 	k_thread_create(&data->thread, data->thread_stack,
 8009bfe: e9cd 0106    	strd	r0, r1, [sp, #24]
 8009c02: 2300         	movs	r3, #0x0
 8009c04: 9304         	str	r3, [sp, #0x10]
 8009c06: f06f 0305    	mvn	r3, #0x5
 8009c0a: 9303         	str	r3, [sp, #0xc]
 8009c0c: 2300         	movs	r3, #0x0
 8009c0e: 9302         	str	r3, [sp, #0x8]
 8009c10: 2300         	movs	r3, #0x0
 8009c12: 9301         	str	r3, [sp, #0x4]
 8009c14: 687b         	ldr	r3, [r7, #0x4]
 8009c16: 9300         	str	r3, [sp]
 8009c18: 4b27         	ldr	r3, [pc, #0x9c]         @ 0x8009cb8 <bmi08x_gyr_trigger_mode_init+0x144>
 8009c1a: f44f 62c0    	mov.w	r2, #0x600
 8009c1e: 4629         	mov	r1, r5
 8009c20: 4620         	mov	r0, r4
 8009c22: f00f fb6a    	bl	0x80192fa <k_thread_create> @ imm = #0xf6d4
; 	gpio_pin_configure_dt(&cfg->int_gpio, GPIO_INPUT);
 8009c26: 6a3b         	ldr	r3, [r7, #0x20]
 8009c28: 331c         	adds	r3, #0x1c
 8009c2a: f44f 3180    	mov.w	r1, #0x10000
 8009c2e: 4618         	mov	r0, r3
 8009c30: f00f fafe    	bl	0x8019230 <gpio_pin_configure_dt> @ imm = #0xf5fc
; 	gpio_init_callback(&data->gpio_cb, bmi08x_gyr_gpio_callback, BIT(cfg->int_gpio.pin));
 8009c34: 6a78         	ldr	r0, [r7, #0x24]
 8009c36: 6a3b         	ldr	r3, [r7, #0x20]
 8009c38: f893 3020    	ldrb.w	r3, [r3, #0x20]
 8009c3c: 461a         	mov	r2, r3
 8009c3e: 2301         	movs	r3, #0x1
 8009c40: 4093         	lsls	r3, r2
 8009c42: 461a         	mov	r2, r3
 8009c44: 491d         	ldr	r1, [pc, #0x74]         @ 0x8009cbc <bmi08x_gyr_trigger_mode_init+0x148>
 8009c46: f00f fb09    	bl	0x801925c <gpio_init_callback> @ imm = #0xf612
; 	ret = gpio_add_callback(cfg->int_gpio.port, &data->gpio_cb);
 8009c4a: 6a3b         	ldr	r3, [r7, #0x20]
 8009c4c: 69db         	ldr	r3, [r3, #0x1c]
 8009c4e: 6a7a         	ldr	r2, [r7, #0x24]
 8009c50: 4611         	mov	r1, r2
 8009c52: 4618         	mov	r0, r3
 8009c54: f00f fb13    	bl	0x801927e <gpio_add_callback> @ imm = #0xf626
 8009c58: 61f8         	str	r0, [r7, #0x1c]
; 	if (ret < 0) {
 8009c5a: 69fb         	ldr	r3, [r7, #0x1c]
 8009c5c: 2b00         	cmp	r3, #0x0
 8009c5e: da1b         	bge	0x8009c98 <bmi08x_gyr_trigger_mode_init+0x124> @ imm = #0x36
; 		LOG_ERR("Failed to set gpio callback.");
 8009c60: 2303         	movs	r3, #0x3
 8009c62: 2b00         	cmp	r3, #0x0
 8009c64: d016         	beq	0x8009c94 <bmi08x_gyr_trigger_mode_init+0x120> @ imm = #0x2c
 8009c66: 2301         	movs	r3, #0x1
 8009c68: 76fb         	strb	r3, [r7, #0x1b]
 8009c6a: 7efb         	ldrb	r3, [r7, #0x1b]
 8009c6c: f083 0301    	eor	r3, r3, #0x1
 8009c70: b2db         	uxtb	r3, r3
 8009c72: 2b00         	cmp	r3, #0x0
 8009c74: d10e         	bne	0x8009c94 <bmi08x_gyr_trigger_mode_init+0x120> @ imm = #0x1c
 8009c76: 4b0e         	ldr	r3, [pc, #0x38]         @ 0x8009cb0 <bmi08x_gyr_trigger_mode_init+0x13c>
 8009c78: 6819         	ldr	r1, [r3]
 8009c7a: 4b11         	ldr	r3, [pc, #0x44]         @ 0x8009cc0 <bmi08x_gyr_trigger_mode_init+0x14c>
 8009c7c: 9302         	str	r3, [sp, #0x8]
 8009c7e: 2300         	movs	r3, #0x0
 8009c80: 9301         	str	r3, [sp, #0x4]
 8009c82: 2300         	movs	r3, #0x0
 8009c84: 9300         	str	r3, [sp]
 8009c86: 2300         	movs	r3, #0x0
 8009c88: 2201         	movs	r2, #0x1
 8009c8a: 2000         	movs	r0, #0x0
 8009c8c: f00f fb8e    	bl	0x80193ac <z_log_msg_runtime_create> @ imm = #0xf71c
 8009c90: 2300         	movs	r3, #0x0
 8009c92: 617b         	str	r3, [r7, #0x14]
; 		return ret;
 8009c94: 69fb         	ldr	r3, [r7, #0x1c]
 8009c96: e007         	b	0x8009ca8 <bmi08x_gyr_trigger_mode_init+0x134> @ imm = #0xe
; 	gpio_pin_interrupt_configure_dt(&cfg->int_gpio, GPIO_INT_EDGE_TO_ACTIVE);
 8009c98: 6a3b         	ldr	r3, [r7, #0x20]
 8009c9a: 331c         	adds	r3, #0x1c
 8009c9c: f04f 61b8    	mov.w	r1, #0x5c00000
 8009ca0: 4618         	mov	r0, r3
 8009ca2: f00f fa68    	bl	0x8019176 <gpio_pin_interrupt_configure_dt> @ imm = #0xf4d0
; 	return ret;
 8009ca6: 69fb         	ldr	r3, [r7, #0x1c]
; }
 8009ca8: 4618         	mov	r0, r3
 8009caa: 3728         	adds	r7, #0x28
 8009cac: 46bd         	mov	sp, r7
 8009cae: bdb0         	pop	{r4, r5, r7, pc}

08009cb0 <$d>:
 8009cb0: 14 05 00 20  	.word	0x20000514
 8009cb4: 5c f3 01 08  	.word	0x0801f35c
 8009cb8: 35 9b 00 08  	.word	0x08009b35
 8009cbc: 35 94 01 08  	.word	0x08019435
 8009cc0: 74 f3 01 08  	.word	0x0801f374

08009cc4 <LL_USART_SetBaudRate>:
; {
 8009cc4: e92d 4fb0    	push.w	{r4, r5, r7, r8, r9, r10, r11, lr}
 8009cc8: b0c0         	sub	sp, #0x100
 8009cca: af00         	add	r7, sp, #0x0
 8009ccc: f8c7 00fc    	str.w	r0, [r7, #0xfc]
 8009cd0: f8c7 10f8    	str.w	r1, [r7, #0xf8]
 8009cd4: f8c7 20f4    	str.w	r2, [r7, #0xf4]
 8009cd8: f8c7 30f0    	str.w	r3, [r7, #0xf0]
;   if (OverSampling == LL_USART_OVERSAMPLING_8)
 8009cdc: f8d7 30f4    	ldr.w	r3, [r7, #0xf4]
 8009ce0: f5b3 4f00    	cmp.w	r3, #0x8000
 8009ce4: f040 810e    	bne.w	0x8009f04 <LL_USART_SetBaudRate+0x240> @ imm = #0x21c
;     USARTx->BRR = (uint16_t)(__LL_USART_DIV_SAMPLING8(PeriphClk, BaudRate));
 8009ce8: f8d7 30f8    	ldr.w	r3, [r7, #0xf8]
 8009cec: 2200         	movs	r2, #0x0
 8009cee: f8c7 30e8    	str.w	r3, [r7, #0xe8]
 8009cf2: f8c7 20ec    	str.w	r2, [r7, #0xec]
 8009cf6: e9d7 453a    	ldrd	r4, r5, [r7, #232]
 8009cfa: 4622         	mov	r2, r4
 8009cfc: 462b         	mov	r3, r5
 8009cfe: 1891         	adds	r1, r2, r2
 8009d00: 6639         	str	r1, [r7, #0x60]
 8009d02: 415b         	adcs	r3, r3
 8009d04: 667b         	str	r3, [r7, #0x64]
 8009d06: e9d7 2318    	ldrd	r2, r3, [r7, #96]
 8009d0a: 4620         	mov	r0, r4
 8009d0c: 4629         	mov	r1, r5
 8009d0e: 4604         	mov	r4, r0
 8009d10: eb12 0804    	adds.w	r8, r2, r4
 8009d14: 460c         	mov	r4, r1
 8009d16: eb43 0904    	adc.w	r9, r3, r4
 8009d1a: f04f 0200    	mov.w	r2, #0x0
 8009d1e: f04f 0300    	mov.w	r3, #0x0
 8009d22: ea4f 03c9    	lsl.w	r3, r9, #0x3
 8009d26: ea43 7358    	orr.w	r3, r3, r8, lsr #29
 8009d2a: ea4f 02c8    	lsl.w	r2, r8, #0x3
 8009d2e: 4690         	mov	r8, r2
 8009d30: 4699         	mov	r9, r3
 8009d32: 4603         	mov	r3, r0
 8009d34: eb18 0303    	adds.w	r3, r8, r3
 8009d38: f8c7 30e0    	str.w	r3, [r7, #0xe0]
 8009d3c: 460b         	mov	r3, r1
 8009d3e: eb49 0303    	adc.w	r3, r9, r3
 8009d42: f8c7 30e4    	str.w	r3, [r7, #0xe4]
 8009d46: f8d7 30f0    	ldr.w	r3, [r7, #0xf0]
 8009d4a: 2200         	movs	r2, #0x0
 8009d4c: 469a         	mov	r10, r3
 8009d4e: 4693         	mov	r11, r2
 8009d50: eb1a 030a    	adds.w	r3, r10, r10
 8009d54: 65bb         	str	r3, [r7, #0x58]
 8009d56: eb4b 030b    	adc.w	r3, r11, r11
 8009d5a: 65fb         	str	r3, [r7, #0x5c]
 8009d5c: e9d7 2316    	ldrd	r2, r3, [r7, #88]
 8009d60: e9d7 0138    	ldrd	r0, r1, [r7, #224]
 8009d64: f7f6 fd5a    	bl	0x800081c <__aeabi_uldivmod> @ imm = #-0x954c
 8009d68: 4602         	mov	r2, r0
 8009d6a: 460b         	mov	r3, r1
 8009d6c: 4b64         	ldr	r3, [pc, #0x190]        @ 0x8009f00 <LL_USART_SetBaudRate+0x23c>
 8009d6e: fba3 2302    	umull	r2, r3, r3, r2
 8009d72: 095b         	lsrs	r3, r3, #0x5
 8009d74: b29b         	uxth	r3, r3
 8009d76: 011b         	lsls	r3, r3, #0x4
 8009d78: b29c         	uxth	r4, r3
 8009d7a: f8d7 30f8    	ldr.w	r3, [r7, #0xf8]
 8009d7e: 2200         	movs	r2, #0x0
 8009d80: f8c7 30d8    	str.w	r3, [r7, #0xd8]
 8009d84: f8c7 20dc    	str.w	r2, [r7, #0xdc]
 8009d88: e9d7 8936    	ldrd	r8, r9, [r7, #216]
 8009d8c: 4642         	mov	r2, r8
 8009d8e: 464b         	mov	r3, r9
 8009d90: 1891         	adds	r1, r2, r2
 8009d92: 6539         	str	r1, [r7, #0x50]
 8009d94: 415b         	adcs	r3, r3
 8009d96: 657b         	str	r3, [r7, #0x54]
 8009d98: e9d7 2314    	ldrd	r2, r3, [r7, #80]
 8009d9c: 4641         	mov	r1, r8
 8009d9e: 1851         	adds	r1, r2, r1
 8009da0: 64b9         	str	r1, [r7, #0x48]
 8009da2: 4649         	mov	r1, r9
 8009da4: 414b         	adcs	r3, r1
 8009da6: 64fb         	str	r3, [r7, #0x4c]
 8009da8: f04f 0200    	mov.w	r2, #0x0
 8009dac: f04f 0300    	mov.w	r3, #0x0
 8009db0: e9d7 ab12    	ldrd	r10, r11, [r7, #72]
 8009db4: 4659         	mov	r1, r11
 8009db6: 00cb         	lsls	r3, r1, #0x3
 8009db8: 4655         	mov	r5, r10
 8009dba: ea43 7355    	orr.w	r3, r3, r5, lsr #29
 8009dbe: 4651         	mov	r1, r10
 8009dc0: 00ca         	lsls	r2, r1, #0x3
 8009dc2: 4610         	mov	r0, r2
 8009dc4: 4619         	mov	r1, r3
 8009dc6: 4603         	mov	r3, r0
 8009dc8: 4642         	mov	r2, r8
 8009dca: 189b         	adds	r3, r3, r2
 8009dcc: f8c7 30d0    	str.w	r3, [r7, #0xd0]
 8009dd0: 464b         	mov	r3, r9
 8009dd2: 460a         	mov	r2, r1
 8009dd4: eb42 0303    	adc.w	r3, r2, r3
 8009dd8: f8c7 30d4    	str.w	r3, [r7, #0xd4]
 8009ddc: f8d7 30f0    	ldr.w	r3, [r7, #0xf0]
 8009de0: 2200         	movs	r2, #0x0
 8009de2: f8c7 30c8    	str.w	r3, [r7, #0xc8]
 8009de6: f8c7 20cc    	str.w	r2, [r7, #0xcc]
 8009dea: e9d7 1232    	ldrd	r1, r2, [r7, #200]
 8009dee: 460b         	mov	r3, r1
 8009df0: 18db         	adds	r3, r3, r3
 8009df2: 643b         	str	r3, [r7, #0x40]
 8009df4: 4613         	mov	r3, r2
 8009df6: eb42 0303    	adc.w	r3, r2, r3
 8009dfa: 647b         	str	r3, [r7, #0x44]
 8009dfc: e9d7 2310    	ldrd	r2, r3, [r7, #64]
 8009e00: e9d7 0134    	ldrd	r0, r1, [r7, #208]
 8009e04: f7f6 fd0a    	bl	0x800081c <__aeabi_uldivmod> @ imm = #-0x95ec
 8009e08: 4602         	mov	r2, r0
 8009e0a: 460b         	mov	r3, r1
 8009e0c: 4611         	mov	r1, r2
 8009e0e: 4b3c         	ldr	r3, [pc, #0xf0]         @ 0x8009f00 <LL_USART_SetBaudRate+0x23c>
 8009e10: fba3 2301    	umull	r2, r3, r3, r1
 8009e14: 095b         	lsrs	r3, r3, #0x5
 8009e16: 2264         	movs	r2, #0x64
 8009e18: fb02 f303    	mul	r3, r2, r3
 8009e1c: 1acb         	subs	r3, r1, r3
 8009e1e: 00db         	lsls	r3, r3, #0x3
 8009e20: f103 0232    	add.w	r2, r3, #0x32
 8009e24: 4b36         	ldr	r3, [pc, #0xd8]         @ 0x8009f00 <LL_USART_SetBaudRate+0x23c>
 8009e26: fba3 2302    	umull	r2, r3, r3, r2
 8009e2a: 095b         	lsrs	r3, r3, #0x5
 8009e2c: b29b         	uxth	r3, r3
 8009e2e: 005b         	lsls	r3, r3, #0x1
 8009e30: b29b         	uxth	r3, r3
 8009e32: f403 73f8    	and	r3, r3, #0x1f0
 8009e36: b29b         	uxth	r3, r3
 8009e38: 4423         	add	r3, r4
 8009e3a: b29c         	uxth	r4, r3
 8009e3c: f8d7 30f8    	ldr.w	r3, [r7, #0xf8]
 8009e40: 2200         	movs	r2, #0x0
 8009e42: f8c7 30c0    	str.w	r3, [r7, #0xc0]
 8009e46: f8c7 20c4    	str.w	r2, [r7, #0xc4]
 8009e4a: e9d7 8930    	ldrd	r8, r9, [r7, #192]
 8009e4e: 4642         	mov	r2, r8
 8009e50: 464b         	mov	r3, r9
 8009e52: 1891         	adds	r1, r2, r2
 8009e54: 63b9         	str	r1, [r7, #0x38]
 8009e56: 415b         	adcs	r3, r3
 8009e58: 63fb         	str	r3, [r7, #0x3c]
 8009e5a: e9d7 230e    	ldrd	r2, r3, [r7, #56]
 8009e5e: 4641         	mov	r1, r8
 8009e60: 1851         	adds	r1, r2, r1
 8009e62: 6339         	str	r1, [r7, #0x30]
 8009e64: 4649         	mov	r1, r9
 8009e66: 414b         	adcs	r3, r1
 8009e68: 637b         	str	r3, [r7, #0x34]
 8009e6a: f04f 0200    	mov.w	r2, #0x0
 8009e6e: f04f 0300    	mov.w	r3, #0x0
 8009e72: e9d7 ab0c    	ldrd	r10, r11, [r7, #48]
 8009e76: 4659         	mov	r1, r11
 8009e78: 00cb         	lsls	r3, r1, #0x3
 8009e7a: 4655         	mov	r5, r10
 8009e7c: ea43 7355    	orr.w	r3, r3, r5, lsr #29
 8009e80: 4651         	mov	r1, r10
 8009e82: 00ca         	lsls	r2, r1, #0x3
 8009e84: 4610         	mov	r0, r2
 8009e86: 4619         	mov	r1, r3
 8009e88: 4603         	mov	r3, r0
 8009e8a: 4642         	mov	r2, r8
 8009e8c: 189b         	adds	r3, r3, r2
 8009e8e: f8c7 30b8    	str.w	r3, [r7, #0xb8]
 8009e92: 464b         	mov	r3, r9
 8009e94: 460a         	mov	r2, r1
 8009e96: eb42 0303    	adc.w	r3, r2, r3
 8009e9a: f8c7 30bc    	str.w	r3, [r7, #0xbc]
 8009e9e: f8d7 30f0    	ldr.w	r3, [r7, #0xf0]
 8009ea2: 2200         	movs	r2, #0x0
 8009ea4: f8c7 30b0    	str.w	r3, [r7, #0xb0]
 8009ea8: f8c7 20b4    	str.w	r2, [r7, #0xb4]
 8009eac: e9d7 122c    	ldrd	r1, r2, [r7, #176]
 8009eb0: 460b         	mov	r3, r1
 8009eb2: 18db         	adds	r3, r3, r3
 8009eb4: 62bb         	str	r3, [r7, #0x28]
 8009eb6: 4613         	mov	r3, r2
 8009eb8: eb42 0303    	adc.w	r3, r2, r3
 8009ebc: 62fb         	str	r3, [r7, #0x2c]
 8009ebe: e9d7 230a    	ldrd	r2, r3, [r7, #40]
 8009ec2: e9d7 012e    	ldrd	r0, r1, [r7, #184]
 8009ec6: f7f6 fca9    	bl	0x800081c <__aeabi_uldivmod> @ imm = #-0x96ae
 8009eca: 4602         	mov	r2, r0
 8009ecc: 460b         	mov	r3, r1
 8009ece: 4b0c         	ldr	r3, [pc, #0x30]         @ 0x8009f00 <LL_USART_SetBaudRate+0x23c>
 8009ed0: fba3 1302    	umull	r1, r3, r3, r2
 8009ed4: 095b         	lsrs	r3, r3, #0x5
 8009ed6: 2164         	movs	r1, #0x64
 8009ed8: fb01 f303    	mul	r3, r1, r3
 8009edc: 1ad3         	subs	r3, r2, r3
 8009ede: 00db         	lsls	r3, r3, #0x3
 8009ee0: 3332         	adds	r3, #0x32
 8009ee2: 4a07         	ldr	r2, [pc, #0x1c]         @ 0x8009f00 <LL_USART_SetBaudRate+0x23c>
 8009ee4: fba2 2303    	umull	r2, r3, r2, r3
 8009ee8: 095b         	lsrs	r3, r3, #0x5
 8009eea: b29b         	uxth	r3, r3
 8009eec: f003 0307    	and	r3, r3, #0x7
 8009ef0: b29b         	uxth	r3, r3
 8009ef2: 4423         	add	r3, r4
 8009ef4: b29b         	uxth	r3, r3
 8009ef6: 461a         	mov	r2, r3
 8009ef8: f8d7 30fc    	ldr.w	r3, [r7, #0xfc]
 8009efc: 609a         	str	r2, [r3, #0x8]
; }
 8009efe: e10c         	b	0x800a11a <LL_USART_SetBaudRate+0x456> @ imm = #0x218

08009f00 <$d>:
 8009f00: 1f 85 eb 51  	.word	0x51eb851f

08009f04 <$t>:
;     USARTx->BRR = (uint16_t)(__LL_USART_DIV_SAMPLING16(PeriphClk, BaudRate));
 8009f04: f8d7 30f8    	ldr.w	r3, [r7, #0xf8]
 8009f08: 2200         	movs	r2, #0x0
 8009f0a: f8c7 30a8    	str.w	r3, [r7, #0xa8]
 8009f0e: f8c7 20ac    	str.w	r2, [r7, #0xac]
 8009f12: e9d7 892a    	ldrd	r8, r9, [r7, #168]
 8009f16: 4642         	mov	r2, r8
 8009f18: 464b         	mov	r3, r9
 8009f1a: 1891         	adds	r1, r2, r2
 8009f1c: 6239         	str	r1, [r7, #0x20]
 8009f1e: 415b         	adcs	r3, r3
 8009f20: 627b         	str	r3, [r7, #0x24]
 8009f22: e9d7 2308    	ldrd	r2, r3, [r7, #32]
 8009f26: 4641         	mov	r1, r8
 8009f28: 1854         	adds	r4, r2, r1
 8009f2a: 46cc         	mov	r12, r9
 8009f2c: eb43 050c    	adc.w	r5, r3, r12
 8009f30: f04f 0200    	mov.w	r2, #0x0
 8009f34: f04f 0300    	mov.w	r3, #0x0
 8009f38: 00eb         	lsls	r3, r5, #0x3
 8009f3a: ea43 7354    	orr.w	r3, r3, r4, lsr #29
 8009f3e: 00e2         	lsls	r2, r4, #0x3
 8009f40: 4614         	mov	r4, r2
 8009f42: 461d         	mov	r5, r3
 8009f44: 4640         	mov	r0, r8
 8009f46: 4649         	mov	r1, r9
 8009f48: 4603         	mov	r3, r0
 8009f4a: 18e3         	adds	r3, r4, r3
 8009f4c: f8c7 30a0    	str.w	r3, [r7, #0xa0]
 8009f50: 460b         	mov	r3, r1
 8009f52: eb45 0303    	adc.w	r3, r5, r3
 8009f56: f8c7 30a4    	str.w	r3, [r7, #0xa4]
 8009f5a: f8d7 30f0    	ldr.w	r3, [r7, #0xf0]
 8009f5e: 2200         	movs	r2, #0x0
 8009f60: f8c7 3098    	str.w	r3, [r7, #0x98]
 8009f64: f8c7 209c    	str.w	r2, [r7, #0x9c]
 8009f68: f04f 0200    	mov.w	r2, #0x0
 8009f6c: f04f 0300    	mov.w	r3, #0x0
 8009f70: e9d7 4526    	ldrd	r4, r5, [r7, #152]
 8009f74: 4629         	mov	r1, r5
 8009f76: 008b         	lsls	r3, r1, #0x2
 8009f78: 4620         	mov	r0, r4
 8009f7a: 4629         	mov	r1, r5
 8009f7c: 4604         	mov	r4, r0
 8009f7e: ea43 7394    	orr.w	r3, r3, r4, lsr #30
 8009f82: 4601         	mov	r1, r0
 8009f84: 008a         	lsls	r2, r1, #0x2
 8009f86: e9d7 0128    	ldrd	r0, r1, [r7, #160]
 8009f8a: f7f6 fc47    	bl	0x800081c <__aeabi_uldivmod> @ imm = #-0x9772
 8009f8e: 4602         	mov	r2, r0
 8009f90: 460b         	mov	r3, r1
 8009f92: 4b65         	ldr	r3, [pc, #0x194]        @ 0x800a128 <LL_USART_SetBaudRate+0x464>
 8009f94: fba3 2302    	umull	r2, r3, r3, r2
 8009f98: 095b         	lsrs	r3, r3, #0x5
 8009f9a: b29b         	uxth	r3, r3
 8009f9c: 011b         	lsls	r3, r3, #0x4
 8009f9e: b29c         	uxth	r4, r3
 8009fa0: f8d7 30f8    	ldr.w	r3, [r7, #0xf8]
 8009fa4: 2200         	movs	r2, #0x0
 8009fa6: f8c7 3090    	str.w	r3, [r7, #0x90]
 8009faa: f8c7 2094    	str.w	r2, [r7, #0x94]
 8009fae: e9d7 8924    	ldrd	r8, r9, [r7, #144]
 8009fb2: 4642         	mov	r2, r8
 8009fb4: 464b         	mov	r3, r9
 8009fb6: 1891         	adds	r1, r2, r2
 8009fb8: 61b9         	str	r1, [r7, #0x18]
 8009fba: 415b         	adcs	r3, r3
 8009fbc: 61fb         	str	r3, [r7, #0x1c]
 8009fbe: e9d7 2306    	ldrd	r2, r3, [r7, #24]
 8009fc2: 4641         	mov	r1, r8
 8009fc4: 1851         	adds	r1, r2, r1
 8009fc6: 6139         	str	r1, [r7, #0x10]
 8009fc8: 4649         	mov	r1, r9
 8009fca: 414b         	adcs	r3, r1
 8009fcc: 617b         	str	r3, [r7, #0x14]
 8009fce: f04f 0200    	mov.w	r2, #0x0
 8009fd2: f04f 0300    	mov.w	r3, #0x0
 8009fd6: e9d7 ab04    	ldrd	r10, r11, [r7, #16]
 8009fda: 4659         	mov	r1, r11
 8009fdc: 00cb         	lsls	r3, r1, #0x3
 8009fde: 4655         	mov	r5, r10
 8009fe0: ea43 7355    	orr.w	r3, r3, r5, lsr #29
 8009fe4: 4651         	mov	r1, r10
 8009fe6: 00ca         	lsls	r2, r1, #0x3
 8009fe8: 4610         	mov	r0, r2
 8009fea: 4619         	mov	r1, r3
 8009fec: 4603         	mov	r3, r0
 8009fee: 4642         	mov	r2, r8
 8009ff0: 189b         	adds	r3, r3, r2
 8009ff2: f8c7 3088    	str.w	r3, [r7, #0x88]
 8009ff6: 464b         	mov	r3, r9
 8009ff8: 460a         	mov	r2, r1
 8009ffa: eb42 0303    	adc.w	r3, r2, r3
 8009ffe: f8c7 308c    	str.w	r3, [r7, #0x8c]
 800a002: f8d7 30f0    	ldr.w	r3, [r7, #0xf0]
 800a006: 2200         	movs	r2, #0x0
 800a008: f8c7 3080    	str.w	r3, [r7, #0x80]
 800a00c: f8c7 2084    	str.w	r2, [r7, #0x84]
 800a010: f04f 0200    	mov.w	r2, #0x0
 800a014: f04f 0300    	mov.w	r3, #0x0
 800a018: e9d7 8920    	ldrd	r8, r9, [r7, #128]
 800a01c: 4649         	mov	r1, r9
 800a01e: 008b         	lsls	r3, r1, #0x2
 800a020: 4645         	mov	r5, r8
 800a022: ea43 7395    	orr.w	r3, r3, r5, lsr #30
 800a026: 4641         	mov	r1, r8
 800a028: 008a         	lsls	r2, r1, #0x2
 800a02a: e9d7 0122    	ldrd	r0, r1, [r7, #136]
 800a02e: f7f6 fbf5    	bl	0x800081c <__aeabi_uldivmod> @ imm = #-0x9816
 800a032: 4602         	mov	r2, r0
 800a034: 460b         	mov	r3, r1
 800a036: 4611         	mov	r1, r2
 800a038: 4b3b         	ldr	r3, [pc, #0xec]         @ 0x800a128 <LL_USART_SetBaudRate+0x464>
 800a03a: fba3 2301    	umull	r2, r3, r3, r1
 800a03e: 095b         	lsrs	r3, r3, #0x5
 800a040: 2264         	movs	r2, #0x64
 800a042: fb02 f303    	mul	r3, r2, r3
 800a046: 1acb         	subs	r3, r1, r3
 800a048: 011b         	lsls	r3, r3, #0x4
 800a04a: 3332         	adds	r3, #0x32
 800a04c: 4a36         	ldr	r2, [pc, #0xd8]         @ 0x800a128 <LL_USART_SetBaudRate+0x464>
 800a04e: fba2 2303    	umull	r2, r3, r2, r3
 800a052: 095b         	lsrs	r3, r3, #0x5
 800a054: b29b         	uxth	r3, r3
 800a056: f003 03f0    	and	r3, r3, #0xf0
 800a05a: b29b         	uxth	r3, r3
 800a05c: 4423         	add	r3, r4
 800a05e: b29c         	uxth	r4, r3
 800a060: f8d7 30f8    	ldr.w	r3, [r7, #0xf8]
 800a064: 2200         	movs	r2, #0x0
 800a066: 67bb         	str	r3, [r7, #0x78]
 800a068: 67fa         	str	r2, [r7, #0x7c]
 800a06a: e9d7 891e    	ldrd	r8, r9, [r7, #120]
 800a06e: 4642         	mov	r2, r8
 800a070: 464b         	mov	r3, r9
 800a072: 1891         	adds	r1, r2, r2
 800a074: 60b9         	str	r1, [r7, #0x8]
 800a076: 415b         	adcs	r3, r3
 800a078: 60fb         	str	r3, [r7, #0xc]
 800a07a: e9d7 2302    	ldrd	r2, r3, [r7, #8]
 800a07e: 4641         	mov	r1, r8
 800a080: 1851         	adds	r1, r2, r1
 800a082: 6039         	str	r1, [r7]
 800a084: 4649         	mov	r1, r9
 800a086: 414b         	adcs	r3, r1
 800a088: 607b         	str	r3, [r7, #0x4]
 800a08a: f04f 0200    	mov.w	r2, #0x0
 800a08e: f04f 0300    	mov.w	r3, #0x0
 800a092: e9d7 ab00    	ldrd	r10, r11, [r7]
 800a096: 4659         	mov	r1, r11
 800a098: 00cb         	lsls	r3, r1, #0x3
 800a09a: 4655         	mov	r5, r10
 800a09c: ea43 7355    	orr.w	r3, r3, r5, lsr #29
 800a0a0: 4651         	mov	r1, r10
 800a0a2: 00ca         	lsls	r2, r1, #0x3
 800a0a4: 4610         	mov	r0, r2
 800a0a6: 4619         	mov	r1, r3
 800a0a8: 4603         	mov	r3, r0
 800a0aa: 4642         	mov	r2, r8
 800a0ac: 189b         	adds	r3, r3, r2
 800a0ae: 673b         	str	r3, [r7, #0x70]
 800a0b0: 464b         	mov	r3, r9
 800a0b2: 460a         	mov	r2, r1
 800a0b4: eb42 0303    	adc.w	r3, r2, r3
 800a0b8: 677b         	str	r3, [r7, #0x74]
 800a0ba: f8d7 30f0    	ldr.w	r3, [r7, #0xf0]
 800a0be: 2200         	movs	r2, #0x0
 800a0c0: 66bb         	str	r3, [r7, #0x68]
 800a0c2: 66fa         	str	r2, [r7, #0x6c]
 800a0c4: f04f 0200    	mov.w	r2, #0x0
 800a0c8: f04f 0300    	mov.w	r3, #0x0
 800a0cc: e9d7 891a    	ldrd	r8, r9, [r7, #104]
 800a0d0: 4649         	mov	r1, r9
 800a0d2: 008b         	lsls	r3, r1, #0x2
 800a0d4: 4645         	mov	r5, r8
 800a0d6: ea43 7395    	orr.w	r3, r3, r5, lsr #30
 800a0da: 4641         	mov	r1, r8
 800a0dc: 008a         	lsls	r2, r1, #0x2
 800a0de: e9d7 011c    	ldrd	r0, r1, [r7, #112]
 800a0e2: f7f6 fb9b    	bl	0x800081c <__aeabi_uldivmod> @ imm = #-0x98ca
 800a0e6: 4602         	mov	r2, r0
 800a0e8: 460b         	mov	r3, r1
 800a0ea: 4b0f         	ldr	r3, [pc, #0x3c]         @ 0x800a128 <LL_USART_SetBaudRate+0x464>
 800a0ec: fba3 1302    	umull	r1, r3, r3, r2
 800a0f0: 095b         	lsrs	r3, r3, #0x5
 800a0f2: 2164         	movs	r1, #0x64
 800a0f4: fb01 f303    	mul	r3, r1, r3
 800a0f8: 1ad3         	subs	r3, r2, r3
 800a0fa: 011b         	lsls	r3, r3, #0x4
 800a0fc: 3332         	adds	r3, #0x32
 800a0fe: 4a0a         	ldr	r2, [pc, #0x28]         @ 0x800a128 <LL_USART_SetBaudRate+0x464>
 800a100: fba2 2303    	umull	r2, r3, r2, r3
 800a104: 095b         	lsrs	r3, r3, #0x5
 800a106: b29b         	uxth	r3, r3
 800a108: f003 030f    	and	r3, r3, #0xf
 800a10c: b29b         	uxth	r3, r3
 800a10e: 4423         	add	r3, r4
 800a110: b29b         	uxth	r3, r3
 800a112: 461a         	mov	r2, r3
 800a114: f8d7 30fc    	ldr.w	r3, [r7, #0xfc]
 800a118: 609a         	str	r2, [r3, #0x8]
; }
 800a11a: bf00         	nop
 800a11c: f507 7780    	add.w	r7, r7, #0x100
 800a120: 46bd         	mov	sp, r7
 800a122: e8bd 8fb0    	pop.w	{r4, r5, r7, r8, r9, r10, r11, pc}
 800a126: bf00         	nop

0800a128 <$d>:
 800a128: 1f 85 eb 51  	.word	0x51eb851f

0800a12c <uart_stm32_set_baudrate>:
; {
 800a12c: b580         	push	{r7, lr}
 800a12e: b08c         	sub	sp, #0x30
 800a130: af04         	add	r7, sp, #0x10
 800a132: 6078         	str	r0, [r7, #0x4]
 800a134: 6039         	str	r1, [r7]
; 	const struct uart_stm32_config *config = dev->config;
 800a136: 687b         	ldr	r3, [r7, #0x4]
 800a138: 685b         	ldr	r3, [r3, #0x4]
 800a13a: 61bb         	str	r3, [r7, #0x18]
; 	USART_TypeDef *usart = config->usart;
 800a13c: 69bb         	ldr	r3, [r7, #0x18]
 800a13e: 681b         	ldr	r3, [r3]
 800a140: 617b         	str	r3, [r7, #0x14]
; 	struct uart_stm32_data *data = dev->data;
 800a142: 687b         	ldr	r3, [r7, #0x4]
 800a144: 691b         	ldr	r3, [r3, #0x10]
 800a146: 61fb         	str	r3, [r7, #0x1c]
; 		if (clock_control_get_rate(data->clock,
 800a148: 69fb         	ldr	r3, [r7, #0x1c]
 800a14a: 6818         	ldr	r0, [r3]
; 					   (clock_control_subsys_t)&config->pclken[0],
 800a14c: 69bb         	ldr	r3, [r7, #0x18]
 800a14e: 68db         	ldr	r3, [r3, #0xc]
; 		if (clock_control_get_rate(data->clock,
 800a150: f107 0208    	add.w	r2, r7, #0x8
 800a154: 4619         	mov	r1, r3
 800a156: f00f f9c9    	bl	0x80194ec <clock_control_get_rate> @ imm = #0xf392
 800a15a: 4603         	mov	r3, r0
 800a15c: 2b00         	cmp	r3, #0x0
 800a15e: da1a         	bge	0x800a196 <uart_stm32_set_baudrate+0x6a> @ imm = #0x34
; 			LOG_ERR("Failed call clock_control_get_rate(pclken[0])");
 800a160: 2303         	movs	r3, #0x3
 800a162: 2b00         	cmp	r3, #0x0
 800a164: d021         	beq	0x800a1aa <uart_stm32_set_baudrate+0x7e> @ imm = #0x42
 800a166: 2301         	movs	r3, #0x1
 800a168: 74fb         	strb	r3, [r7, #0x13]
 800a16a: 7cfb         	ldrb	r3, [r7, #0x13]
 800a16c: f083 0301    	eor	r3, r3, #0x1
 800a170: b2db         	uxtb	r3, r3
 800a172: 2b00         	cmp	r3, #0x0
 800a174: d119         	bne	0x800a1aa <uart_stm32_set_baudrate+0x7e> @ imm = #0x32
 800a176: 4b0e         	ldr	r3, [pc, #0x38]         @ 0x800a1b0 <uart_stm32_set_baudrate+0x84>
 800a178: 6819         	ldr	r1, [r3]
 800a17a: 4b0e         	ldr	r3, [pc, #0x38]         @ 0x800a1b4 <uart_stm32_set_baudrate+0x88>
 800a17c: 9302         	str	r3, [sp, #0x8]
 800a17e: 2300         	movs	r3, #0x0
 800a180: 9301         	str	r3, [sp, #0x4]
 800a182: 2300         	movs	r3, #0x0
 800a184: 9300         	str	r3, [sp]
 800a186: 2300         	movs	r3, #0x0
 800a188: 2201         	movs	r2, #0x1
 800a18a: 2000         	movs	r0, #0x0
 800a18c: f00f ff10    	bl	0x8019fb0 <z_log_msg_runtime_create> @ imm = #0xfe20
 800a190: 2300         	movs	r3, #0x0
 800a192: 60fb         	str	r3, [r7, #0xc]
; 			return;
 800a194: e009         	b	0x800a1aa <uart_stm32_set_baudrate+0x7e> @ imm = #0x12
; 		LL_USART_SetOverSampling(usart,
 800a196: 2100         	movs	r1, #0x0
 800a198: 6978         	ldr	r0, [r7, #0x14]
 800a19a: f00f fb3a    	bl	0x8019812 <LL_USART_SetOverSampling> @ imm = #0xf674
; 		LL_USART_SetBaudRate(usart,
 800a19e: 68b9         	ldr	r1, [r7, #0x8]
 800a1a0: 683b         	ldr	r3, [r7]
 800a1a2: 2200         	movs	r2, #0x0
 800a1a4: 6978         	ldr	r0, [r7, #0x14]
 800a1a6: f7ff fd8d    	bl	0x8009cc4 <LL_USART_SetBaudRate> @ imm = #-0x4e6
; }
 800a1aa: 3720         	adds	r7, #0x20
 800a1ac: 46bd         	mov	sp, r7
 800a1ae: bd80         	pop	{r7, pc}

0800a1b0 <$d>:
 800a1b0: 18 05 00 20  	.word	0x20000518
 800a1b4: a0 f3 01 08  	.word	0x0801f3a0

0800a1b8 <uart_stm32_configure>:
; {
 800a1b8: b580         	push	{r7, lr}
 800a1ba: b08a         	sub	sp, #0x28
 800a1bc: af00         	add	r7, sp, #0x0
 800a1be: 6078         	str	r0, [r7, #0x4]
 800a1c0: 6039         	str	r1, [r7]
; 	const struct uart_stm32_config *config = dev->config;
 800a1c2: 687b         	ldr	r3, [r7, #0x4]
 800a1c4: 685b         	ldr	r3, [r3, #0x4]
 800a1c6: 627b         	str	r3, [r7, #0x24]
; 	USART_TypeDef *usart = config->usart;
 800a1c8: 6a7b         	ldr	r3, [r7, #0x24]
 800a1ca: 681b         	ldr	r3, [r3]
 800a1cc: 623b         	str	r3, [r7, #0x20]
; 	struct uart_stm32_data *data = dev->data;
 800a1ce: 687b         	ldr	r3, [r7, #0x4]
 800a1d0: 691b         	ldr	r3, [r3, #0x10]
 800a1d2: 61fb         	str	r3, [r7, #0x1c]
; 	struct uart_config *uart_cfg = data->uart_cfg;
 800a1d4: 69fb         	ldr	r3, [r7, #0x1c]
 800a1d6: 685b         	ldr	r3, [r3, #0x4]
 800a1d8: 61bb         	str	r3, [r7, #0x18]
; 	const uint32_t parity = uart_stm32_cfg2ll_parity(cfg->parity);
 800a1da: 683b         	ldr	r3, [r7]
 800a1dc: 791b         	ldrb	r3, [r3, #0x4]
 800a1de: 4618         	mov	r0, r3
 800a1e0: f00f ff90    	bl	0x801a104 <uart_stm32_cfg2ll_parity> @ imm = #0xff20
 800a1e4: 6178         	str	r0, [r7, #0x14]
; 	const uint32_t stopbits = uart_stm32_cfg2ll_stopbits(config, cfg->stop_bits);
 800a1e6: 683b         	ldr	r3, [r7]
 800a1e8: 795b         	ldrb	r3, [r3, #0x5]
 800a1ea: 4619         	mov	r1, r3
 800a1ec: 6a78         	ldr	r0, [r7, #0x24]
 800a1ee: f00f ffb6    	bl	0x801a15e <uart_stm32_cfg2ll_stopbits> @ imm = #0xff6c
 800a1f2: 6138         	str	r0, [r7, #0x10]
; 	const uint32_t databits = uart_stm32_cfg2ll_databits(cfg->data_bits,
 800a1f4: 683b         	ldr	r3, [r7]
 800a1f6: 799a         	ldrb	r2, [r3, #0x6]
; 							     cfg->parity);
 800a1f8: 683b         	ldr	r3, [r7]
 800a1fa: 791b         	ldrb	r3, [r3, #0x4]
; 	const uint32_t databits = uart_stm32_cfg2ll_databits(cfg->data_bits,
 800a1fc: 4619         	mov	r1, r3
 800a1fe: 4610         	mov	r0, r2
 800a200: f00f ffeb    	bl	0x801a1da <uart_stm32_cfg2ll_databits> @ imm = #0xffd6
 800a204: 60f8         	str	r0, [r7, #0xc]
; 	if ((cfg->parity == UART_CFG_PARITY_MARK) ||
 800a206: 683b         	ldr	r3, [r7]
 800a208: 791b         	ldrb	r3, [r3, #0x4]
 800a20a: 2b03         	cmp	r3, #0x3
 800a20c: d003         	beq	0x800a216 <uart_stm32_configure+0x5e> @ imm = #0x6
; 	    (cfg->parity == UART_CFG_PARITY_SPACE)) {
 800a20e: 683b         	ldr	r3, [r7]
 800a210: 791b         	ldrb	r3, [r3, #0x4]
; 	if ((cfg->parity == UART_CFG_PARITY_MARK) ||
 800a212: 2b04         	cmp	r3, #0x4
 800a214: d102         	bne	0x800a21c <uart_stm32_configure+0x64> @ imm = #0x4
; 		return -ENOTSUP;
 800a216: f06f 0385    	mvn	r3, #0x85
 800a21a: e04f         	b	0x800a2bc <uart_stm32_configure+0x104> @ imm = #0x9e
; 	if ((cfg->parity != UART_CFG_PARITY_NONE) &&
 800a21c: 683b         	ldr	r3, [r7]
 800a21e: 791b         	ldrb	r3, [r3, #0x4]
 800a220: 2b00         	cmp	r3, #0x0
 800a222: d006         	beq	0x800a232 <uart_stm32_configure+0x7a> @ imm = #0xc
; 	    (cfg->data_bits == UART_CFG_DATA_BITS_9)) {
 800a224: 683b         	ldr	r3, [r7]
 800a226: 799b         	ldrb	r3, [r3, #0x6]
; 	if ((cfg->parity != UART_CFG_PARITY_NONE) &&
 800a228: 2b04         	cmp	r3, #0x4
 800a22a: d102         	bne	0x800a232 <uart_stm32_configure+0x7a> @ imm = #0x4
; 		return -ENOTSUP;
 800a22c: f06f 0385    	mvn	r3, #0x85
 800a230: e044         	b	0x800a2bc <uart_stm32_configure+0x104> @ imm = #0x88
; 	if (uart_stm32_ll2cfg_stopbits(stopbits) != cfg->stop_bits) {
 800a232: 6938         	ldr	r0, [r7, #0x10]
 800a234: f00f ffb2    	bl	0x801a19c <uart_stm32_ll2cfg_stopbits> @ imm = #0xff64
 800a238: 4603         	mov	r3, r0
 800a23a: 461a         	mov	r2, r3
 800a23c: 683b         	ldr	r3, [r7]
 800a23e: 795b         	ldrb	r3, [r3, #0x5]
 800a240: 429a         	cmp	r2, r3
 800a242: d002         	beq	0x800a24a <uart_stm32_configure+0x92> @ imm = #0x4
; 		return -ENOTSUP;
 800a244: f06f 0385    	mvn	r3, #0x85
 800a248: e038         	b	0x800a2bc <uart_stm32_configure+0x104> @ imm = #0x70
; 	if (uart_stm32_ll2cfg_databits(databits, parity) != cfg->data_bits) {
 800a24a: 6979         	ldr	r1, [r7, #0x14]
 800a24c: 68f8         	ldr	r0, [r7, #0xc]
 800a24e: f00f ffde    	bl	0x801a20e <uart_stm32_ll2cfg_databits> @ imm = #0xffbc
 800a252: 4603         	mov	r3, r0
 800a254: 461a         	mov	r2, r3
 800a256: 683b         	ldr	r3, [r7]
 800a258: 799b         	ldrb	r3, [r3, #0x6]
 800a25a: 429a         	cmp	r2, r3
 800a25c: d002         	beq	0x800a264 <uart_stm32_configure+0xac> @ imm = #0x4
; 		return -ENOTSUP;
 800a25e: f06f 0385    	mvn	r3, #0x85
 800a262: e02b         	b	0x800a2bc <uart_stm32_configure+0x104> @ imm = #0x56
; 	if (!(cfg->flow_ctrl == UART_CFG_FLOW_CTRL_NONE
 800a264: 683b         	ldr	r3, [r7]
 800a266: 79db         	ldrb	r3, [r3, #0x7]
 800a268: 2b00         	cmp	r3, #0x0
 800a26a: d016         	beq	0x800a29a <uart_stm32_configure+0xe2> @ imm = #0x2c
; 		|| (cfg->flow_ctrl == UART_CFG_FLOW_CTRL_RTS_CTS &&
 800a26c: 683b         	ldr	r3, [r7]
 800a26e: 79db         	ldrb	r3, [r3, #0x7]
; 	if (!(cfg->flow_ctrl == UART_CFG_FLOW_CTRL_NONE
 800a270: 2b01         	cmp	r3, #0x1
 800a272: d10f         	bne	0x800a294 <uart_stm32_configure+0xdc> @ imm = #0x1e
; 		|| (cfg->flow_ctrl == UART_CFG_FLOW_CTRL_RTS_CTS &&
 800a274: 6a3b         	ldr	r3, [r7, #0x20]
 800a276: 4a13         	ldr	r2, [pc, #0x4c]         @ 0x800a2c4 <uart_stm32_configure+0x10c>
 800a278: 4293         	cmp	r3, r2
 800a27a: d00e         	beq	0x800a29a <uart_stm32_configure+0xe2> @ imm = #0x1c
; 			IS_UART_HWFLOW_INSTANCE(usart))
 800a27c: 6a3b         	ldr	r3, [r7, #0x20]
 800a27e: 4a12         	ldr	r2, [pc, #0x48]         @ 0x800a2c8 <uart_stm32_configure+0x110>
 800a280: 4293         	cmp	r3, r2
 800a282: d00a         	beq	0x800a29a <uart_stm32_configure+0xe2> @ imm = #0x14
 800a284: 6a3b         	ldr	r3, [r7, #0x20]
 800a286: 4a11         	ldr	r2, [pc, #0x44]         @ 0x800a2cc <uart_stm32_configure+0x114>
 800a288: 4293         	cmp	r3, r2
 800a28a: d006         	beq	0x800a29a <uart_stm32_configure+0xe2> @ imm = #0xc
 800a28c: 6a3b         	ldr	r3, [r7, #0x20]
 800a28e: 4a10         	ldr	r2, [pc, #0x40]         @ 0x800a2d0 <uart_stm32_configure+0x118>
 800a290: 4293         	cmp	r3, r2
 800a292: d002         	beq	0x800a29a <uart_stm32_configure+0xe2> @ imm = #0x4
; 		return -ENOTSUP;
 800a294: f06f 0385    	mvn	r3, #0x85
 800a298: e010         	b	0x800a2bc <uart_stm32_configure+0x104> @ imm = #0x20
; 	LL_USART_Disable(usart);
 800a29a: 6a38         	ldr	r0, [r7, #0x20]
 800a29c: f00f fa47    	bl	0x801972e <LL_USART_Disable> @ imm = #0xf48e
; 	uart_stm32_parameters_set(dev, cfg);
 800a2a0: 6839         	ldr	r1, [r7]
 800a2a2: 6878         	ldr	r0, [r7, #0x4]
 800a2a4: f00f fff4    	bl	0x801a290 <uart_stm32_parameters_set> @ imm = #0xffe8
; 	LL_USART_Enable(usart);
 800a2a8: 6a38         	ldr	r0, [r7, #0x20]
 800a2aa: f00f fa31    	bl	0x8019710 <LL_USART_Enable> @ imm = #0xf462
; 	*uart_cfg = *cfg;
 800a2ae: 69bb         	ldr	r3, [r7, #0x18]
 800a2b0: 683a         	ldr	r2, [r7]
 800a2b2: e892 0003    	ldm.w	r2, {r0, r1}
 800a2b6: e883 0003    	stm.w	r3, {r0, r1}
; 	return 0;
 800a2ba: 2300         	movs	r3, #0x0
; };
 800a2bc: 4618         	mov	r0, r3
 800a2be: 3728         	adds	r7, #0x28
 800a2c0: 46bd         	mov	sp, r7
 800a2c2: bd80         	pop	{r7, pc}

0800a2c4 <$d>:
 800a2c4: 00 10 01 40  	.word	0x40011000
 800a2c8: 00 44 00 40  	.word	0x40004400
 800a2cc: 00 48 00 40  	.word	0x40004800
 800a2d0: 00 14 01 40  	.word	0x40011400

0800a2d4 <uart_stm32_poll_in>:
; {
 800a2d4: b580         	push	{r7, lr}
 800a2d6: b082         	sub	sp, #0x8
 800a2d8: af00         	add	r7, sp, #0x0
 800a2da: 6078         	str	r0, [r7, #0x4]
 800a2dc: 6039         	str	r1, [r7]
; 	return uart_stm32_poll_in_visitor(dev, (void *)c, poll_in_u8);
 800a2de: 4a05         	ldr	r2, [pc, #0x14]         @ 0x800a2f4 <uart_stm32_poll_in+0x20>
 800a2e0: 6839         	ldr	r1, [r7]
 800a2e2: 6878         	ldr	r0, [r7, #0x4]
 800a2e4: f010 f899    	bl	0x801a41a <uart_stm32_poll_in_visitor> @ imm = #0x10132
 800a2e8: 4603         	mov	r3, r0
; }
 800a2ea: 4618         	mov	r0, r3
 800a2ec: 3708         	adds	r7, #0x8
 800a2ee: 46bd         	mov	sp, r7
 800a2f0: bd80         	pop	{r7, pc}
 800a2f2: bf00         	nop

0800a2f4 <$d>:
 800a2f4: 01 a5 01 08  	.word	0x0801a501

0800a2f8 <uart_stm32_poll_out>:
; {
 800a2f8: b580         	push	{r7, lr}
 800a2fa: b082         	sub	sp, #0x8
 800a2fc: af00         	add	r7, sp, #0x0
 800a2fe: 6078         	str	r0, [r7, #0x4]
 800a300: 460b         	mov	r3, r1
 800a302: 70fb         	strb	r3, [r7, #0x3]
; 	uart_stm32_poll_out_visitor(dev, c, poll_out_u8);
 800a304: 78fb         	ldrb	r3, [r7, #0x3]
 800a306: b29b         	uxth	r3, r3
 800a308: 4a04         	ldr	r2, [pc, #0x10]         @ 0x800a31c <uart_stm32_poll_out+0x24>
 800a30a: 4619         	mov	r1, r3
 800a30c: 6878         	ldr	r0, [r7, #0x4]
 800a30e: f010 f8ab    	bl	0x801a468 <uart_stm32_poll_out_visitor> @ imm = #0x10156
; }
 800a312: bf00         	nop
 800a314: 3708         	adds	r7, #0x8
 800a316: 46bd         	mov	sp, r7
 800a318: bd80         	pop	{r7, pc}
 800a31a: bf00         	nop

0800a31c <$d>:
 800a31c: 21 a5 01 08  	.word	0x0801a521

0800a320 <__uart_stm32_get_clock>:
; {
 800a320: b480         	push	{r7}
 800a322: b085         	sub	sp, #0x14
 800a324: af00         	add	r7, sp, #0x0
 800a326: 6078         	str	r0, [r7, #0x4]
; 	struct uart_stm32_data *data = dev->data;
 800a328: 687b         	ldr	r3, [r7, #0x4]
 800a32a: 691b         	ldr	r3, [r3, #0x10]
 800a32c: 60fb         	str	r3, [r7, #0xc]
; 	const struct device *const clk = DEVICE_DT_GET(STM32_CLOCK_CONTROL_NODE);
 800a32e: 4b05         	ldr	r3, [pc, #0x14]         @ 0x800a344 <__uart_stm32_get_clock+0x24>
 800a330: 60bb         	str	r3, [r7, #0x8]
; 	data->clock = clk;
 800a332: 68fb         	ldr	r3, [r7, #0xc]
 800a334: 68ba         	ldr	r2, [r7, #0x8]
 800a336: 601a         	str	r2, [r3]
; }
 800a338: bf00         	nop
 800a33a: 3714         	adds	r7, #0x14
 800a33c: 46bd         	mov	sp, r7
 800a33e: bc80         	pop	{r7}
 800a340: 4770         	bx	lr
 800a342: bf00         	nop

0800a344 <$d>:
 800a344: 28 dd 01 08  	.word	0x0801dd28

0800a348 <uart_stm32_fifo_fill>:
; {
 800a348: b590         	push	{r4, r7, lr}
 800a34a: b085         	sub	sp, #0x14
 800a34c: af00         	add	r7, sp, #0x0
 800a34e: 60f8         	str	r0, [r7, #0xc]
 800a350: 60b9         	str	r1, [r7, #0x8]
 800a352: 607a         	str	r2, [r7, #0x4]
; 	if (uart_stm32_ll2cfg_databits(uart_stm32_get_databits(dev), uart_stm32_get_parity(dev)) ==
 800a354: 68f8         	ldr	r0, [r7, #0xc]
 800a356: f00f fea1    	bl	0x801a09c <uart_stm32_get_databits> @ imm = #0xfd42
 800a35a: 4604         	mov	r4, r0
 800a35c: 68f8         	ldr	r0, [r7, #0xc]
 800a35e: f00f fe57    	bl	0x801a010 <uart_stm32_get_parity> @ imm = #0xfcae
 800a362: 4603         	mov	r3, r0
 800a364: 4619         	mov	r1, r3
 800a366: 4620         	mov	r0, r4
 800a368: f00f ff51    	bl	0x801a20e <uart_stm32_ll2cfg_databits> @ imm = #0xfea2
 800a36c: 4603         	mov	r3, r0
 800a36e: 2b04         	cmp	r3, #0x4
 800a370: d102         	bne	0x800a378 <uart_stm32_fifo_fill+0x30> @ imm = #0x4
; 		return -ENOTSUP;
 800a372: f06f 0385    	mvn	r3, #0x85
 800a376: e006         	b	0x800a386 <uart_stm32_fifo_fill+0x3e> @ imm = #0xc
; 	return uart_stm32_fifo_fill_visitor(dev, (const void *)tx_data, size,
 800a378: 4b05         	ldr	r3, [pc, #0x14]         @ 0x800a390 <uart_stm32_fifo_fill+0x48>
 800a37a: 687a         	ldr	r2, [r7, #0x4]
 800a37c: 68b9         	ldr	r1, [r7, #0x8]
 800a37e: 68f8         	ldr	r0, [r7, #0xc]
 800a380: f010 f949    	bl	0x801a616 <uart_stm32_fifo_fill_visitor> @ imm = #0x10292
 800a384: 4603         	mov	r3, r0
; }
 800a386: 4618         	mov	r0, r3
 800a388: 3714         	adds	r7, #0x14
 800a38a: 46bd         	mov	sp, r7
 800a38c: bd90         	pop	{r4, r7, pc}
 800a38e: bf00         	nop

0800a390 <$d>:
 800a390: af a6 01 08  	.word	0x0801a6af

0800a394 <uart_stm32_fifo_read>:
; {
 800a394: b590         	push	{r4, r7, lr}
 800a396: b085         	sub	sp, #0x14
 800a398: af00         	add	r7, sp, #0x0
 800a39a: 60f8         	str	r0, [r7, #0xc]
 800a39c: 60b9         	str	r1, [r7, #0x8]
 800a39e: 607a         	str	r2, [r7, #0x4]
; 	if (uart_stm32_ll2cfg_databits(uart_stm32_get_databits(dev), uart_stm32_get_parity(dev)) ==
 800a3a0: 68f8         	ldr	r0, [r7, #0xc]
 800a3a2: f00f fe7b    	bl	0x801a09c <uart_stm32_get_databits> @ imm = #0xfcf6
 800a3a6: 4604         	mov	r4, r0
 800a3a8: 68f8         	ldr	r0, [r7, #0xc]
 800a3aa: f00f fe31    	bl	0x801a010 <uart_stm32_get_parity> @ imm = #0xfc62
 800a3ae: 4603         	mov	r3, r0
 800a3b0: 4619         	mov	r1, r3
 800a3b2: 4620         	mov	r0, r4
 800a3b4: f00f ff2b    	bl	0x801a20e <uart_stm32_ll2cfg_databits> @ imm = #0xfe56
 800a3b8: 4603         	mov	r3, r0
 800a3ba: 2b04         	cmp	r3, #0x4
 800a3bc: d102         	bne	0x800a3c4 <uart_stm32_fifo_read+0x30> @ imm = #0x4
; 		return -ENOTSUP;
 800a3be: f06f 0385    	mvn	r3, #0x85
 800a3c2: e006         	b	0x800a3d2 <uart_stm32_fifo_read+0x3e> @ imm = #0xc
; 	return uart_stm32_fifo_read_visitor(dev, (void *)rx_data, size,
 800a3c4: 4b05         	ldr	r3, [pc, #0x14]         @ 0x800a3dc <uart_stm32_fifo_read+0x48>
 800a3c6: 687a         	ldr	r2, [r7, #0x4]
 800a3c8: 68b9         	ldr	r1, [r7, #0x8]
 800a3ca: 68f8         	ldr	r0, [r7, #0xc]
 800a3cc: f010 f983    	bl	0x801a6d6 <uart_stm32_fifo_read_visitor> @ imm = #0x10306
 800a3d0: 4603         	mov	r3, r0
; }
 800a3d2: 4618         	mov	r0, r3
 800a3d4: 3714         	adds	r7, #0x14
 800a3d6: 46bd         	mov	sp, r7
 800a3d8: bd90         	pop	{r4, r7, pc}
 800a3da: bf00         	nop

0800a3dc <$d>:
 800a3dc: 39 a7 01 08  	.word	0x0801a739

0800a3e0 <uart_stm32_irq_err_enable>:
; {
 800a3e0: b580         	push	{r7, lr}
 800a3e2: b084         	sub	sp, #0x10
 800a3e4: af00         	add	r7, sp, #0x0
 800a3e6: 6078         	str	r0, [r7, #0x4]
; 	const struct uart_stm32_config *config = dev->config;
 800a3e8: 687b         	ldr	r3, [r7, #0x4]
 800a3ea: 685b         	ldr	r3, [r3, #0x4]
 800a3ec: 60fb         	str	r3, [r7, #0xc]
; 	USART_TypeDef *usart = config->usart;
 800a3ee: 68fb         	ldr	r3, [r7, #0xc]
 800a3f0: 681b         	ldr	r3, [r3]
 800a3f2: 60bb         	str	r3, [r7, #0x8]
; 	LL_USART_EnableIT_ERROR(usart);
 800a3f4: 68b8         	ldr	r0, [r7, #0x8]
 800a3f6: f00f fc3f    	bl	0x8019c78 <LL_USART_EnableIT_ERROR> @ imm = #0xf87e
; 	if (IS_UART_LIN_INSTANCE(usart)) {
 800a3fa: 68bb         	ldr	r3, [r7, #0x8]
 800a3fc: 4a10         	ldr	r2, [pc, #0x40]         @ 0x800a440 <uart_stm32_irq_err_enable+0x60>
 800a3fe: 4293         	cmp	r3, r2
 800a400: d013         	beq	0x800a42a <uart_stm32_irq_err_enable+0x4a> @ imm = #0x26
 800a402: 68bb         	ldr	r3, [r7, #0x8]
 800a404: 4a0f         	ldr	r2, [pc, #0x3c]         @ 0x800a444 <uart_stm32_irq_err_enable+0x64>
 800a406: 4293         	cmp	r3, r2
 800a408: d00f         	beq	0x800a42a <uart_stm32_irq_err_enable+0x4a> @ imm = #0x1e
 800a40a: 68bb         	ldr	r3, [r7, #0x8]
 800a40c: 4a0e         	ldr	r2, [pc, #0x38]         @ 0x800a448 <uart_stm32_irq_err_enable+0x68>
 800a40e: 4293         	cmp	r3, r2
 800a410: d00b         	beq	0x800a42a <uart_stm32_irq_err_enable+0x4a> @ imm = #0x16
 800a412: 68bb         	ldr	r3, [r7, #0x8]
 800a414: 4a0d         	ldr	r2, [pc, #0x34]         @ 0x800a44c <uart_stm32_irq_err_enable+0x6c>
 800a416: 4293         	cmp	r3, r2
 800a418: d007         	beq	0x800a42a <uart_stm32_irq_err_enable+0x4a> @ imm = #0xe
 800a41a: 68bb         	ldr	r3, [r7, #0x8]
 800a41c: 4a0c         	ldr	r2, [pc, #0x30]         @ 0x800a450 <uart_stm32_irq_err_enable+0x70>
 800a41e: 4293         	cmp	r3, r2
 800a420: d003         	beq	0x800a42a <uart_stm32_irq_err_enable+0x4a> @ imm = #0x6
 800a422: 68bb         	ldr	r3, [r7, #0x8]
 800a424: 4a0b         	ldr	r2, [pc, #0x2c]         @ 0x800a454 <uart_stm32_irq_err_enable+0x74>
 800a426: 4293         	cmp	r3, r2
 800a428: d102         	bne	0x800a430 <uart_stm32_irq_err_enable+0x50> @ imm = #0x4
; 		LL_USART_EnableIT_LBD(usart);
 800a42a: 68b8         	ldr	r0, [r7, #0x8]
 800a42c: f00f fc15    	bl	0x8019c5a <LL_USART_EnableIT_LBD> @ imm = #0xf82a
; 	LL_USART_EnableIT_PE(usart);
 800a430: 68b8         	ldr	r0, [r7, #0x8]
 800a432: f00f fbf0    	bl	0x8019c16 <LL_USART_EnableIT_PE> @ imm = #0xf7e0
; }
 800a436: bf00         	nop
 800a438: 3710         	adds	r7, #0x10
 800a43a: 46bd         	mov	sp, r7
 800a43c: bd80         	pop	{r7, pc}
 800a43e: bf00         	nop

0800a440 <$d>:
 800a440: 00 10 01 40  	.word	0x40011000
 800a444: 00 44 00 40  	.word	0x40004400
 800a448: 00 48 00 40  	.word	0x40004800
 800a44c: 00 4c 00 40  	.word	0x40004c00
 800a450: 00 50 00 40  	.word	0x40005000
 800a454: 00 14 01 40  	.word	0x40011400

0800a458 <uart_stm32_irq_err_disable>:
; {
 800a458: b580         	push	{r7, lr}
 800a45a: b084         	sub	sp, #0x10
 800a45c: af00         	add	r7, sp, #0x0
 800a45e: 6078         	str	r0, [r7, #0x4]
; 	const struct uart_stm32_config *config = dev->config;
 800a460: 687b         	ldr	r3, [r7, #0x4]
 800a462: 685b         	ldr	r3, [r3, #0x4]
 800a464: 60fb         	str	r3, [r7, #0xc]
; 	USART_TypeDef *usart = config->usart;
 800a466: 68fb         	ldr	r3, [r7, #0xc]
 800a468: 681b         	ldr	r3, [r3]
 800a46a: 60bb         	str	r3, [r7, #0x8]
; 	LL_USART_DisableIT_ERROR(usart);
 800a46c: 68b8         	ldr	r0, [r7, #0x8]
 800a46e: f00f fcbc    	bl	0x8019dea <LL_USART_DisableIT_ERROR> @ imm = #0xf978
; 	if (IS_UART_LIN_INSTANCE(usart)) {
 800a472: 68bb         	ldr	r3, [r7, #0x8]
 800a474: 4a10         	ldr	r2, [pc, #0x40]         @ 0x800a4b8 <uart_stm32_irq_err_disable+0x60>
 800a476: 4293         	cmp	r3, r2
 800a478: d013         	beq	0x800a4a2 <uart_stm32_irq_err_disable+0x4a> @ imm = #0x26
 800a47a: 68bb         	ldr	r3, [r7, #0x8]
 800a47c: 4a0f         	ldr	r2, [pc, #0x3c]         @ 0x800a4bc <uart_stm32_irq_err_disable+0x64>
 800a47e: 4293         	cmp	r3, r2
 800a480: d00f         	beq	0x800a4a2 <uart_stm32_irq_err_disable+0x4a> @ imm = #0x1e
 800a482: 68bb         	ldr	r3, [r7, #0x8]
 800a484: 4a0e         	ldr	r2, [pc, #0x38]         @ 0x800a4c0 <uart_stm32_irq_err_disable+0x68>
 800a486: 4293         	cmp	r3, r2
 800a488: d00b         	beq	0x800a4a2 <uart_stm32_irq_err_disable+0x4a> @ imm = #0x16
 800a48a: 68bb         	ldr	r3, [r7, #0x8]
 800a48c: 4a0d         	ldr	r2, [pc, #0x34]         @ 0x800a4c4 <uart_stm32_irq_err_disable+0x6c>
 800a48e: 4293         	cmp	r3, r2
 800a490: d007         	beq	0x800a4a2 <uart_stm32_irq_err_disable+0x4a> @ imm = #0xe
 800a492: 68bb         	ldr	r3, [r7, #0x8]
 800a494: 4a0c         	ldr	r2, [pc, #0x30]         @ 0x800a4c8 <uart_stm32_irq_err_disable+0x70>
 800a496: 4293         	cmp	r3, r2
 800a498: d003         	beq	0x800a4a2 <uart_stm32_irq_err_disable+0x4a> @ imm = #0x6
 800a49a: 68bb         	ldr	r3, [r7, #0x8]
 800a49c: 4a0b         	ldr	r2, [pc, #0x2c]         @ 0x800a4cc <uart_stm32_irq_err_disable+0x74>
 800a49e: 4293         	cmp	r3, r2
 800a4a0: d102         	bne	0x800a4a8 <uart_stm32_irq_err_disable+0x50> @ imm = #0x4
; 		LL_USART_DisableIT_LBD(usart);
 800a4a2: 68b8         	ldr	r0, [r7, #0x8]
 800a4a4: f00f fc92    	bl	0x8019dcc <LL_USART_DisableIT_LBD> @ imm = #0xf924
; 	LL_USART_DisableIT_PE(usart);
 800a4a8: 68b8         	ldr	r0, [r7, #0x8]
 800a4aa: f00f fc6d    	bl	0x8019d88 <LL_USART_DisableIT_PE> @ imm = #0xf8da
; }
 800a4ae: bf00         	nop
 800a4b0: 3710         	adds	r7, #0x10
 800a4b2: 46bd         	mov	sp, r7
 800a4b4: bd80         	pop	{r7, pc}
 800a4b6: bf00         	nop

0800a4b8 <$d>:
 800a4b8: 00 10 01 40  	.word	0x40011000
 800a4bc: 00 44 00 40  	.word	0x40004400
 800a4c0: 00 48 00 40  	.word	0x40004800
 800a4c4: 00 4c 00 40  	.word	0x40004c00
 800a4c8: 00 50 00 40  	.word	0x40005000
 800a4cc: 00 14 01 40  	.word	0x40011400

0800a4d0 <async_evt_rx_rdy>:
; {
 800a4d0: b580         	push	{r7, lr}
 800a4d2: b090         	sub	sp, #0x40
 800a4d4: af06         	add	r7, sp, #0x18
 800a4d6: 6078         	str	r0, [r7, #0x4]
; 	LOG_DBG("rx_rdy: (%d %d)", data->dma_rx.offset, data->dma_rx.counter);
 800a4d8: 2303         	movs	r3, #0x3
 800a4da: 2b03         	cmp	r3, #0x3
 800a4dc: d920         	bls	0x800a520 <async_evt_rx_rdy+0x50> @ imm = #0x40
 800a4de: 2301         	movs	r3, #0x1
 800a4e0: f887 3027    	strb.w	r3, [r7, #0x27]
 800a4e4: f897 3027    	ldrb.w	r3, [r7, #0x27]
 800a4e8: f083 0301    	eor	r3, r3, #0x1
 800a4ec: b2db         	uxtb	r3, r3
 800a4ee: 2b00         	cmp	r3, #0x0
 800a4f0: d116         	bne	0x800a520 <async_evt_rx_rdy+0x50> @ imm = #0x2c
 800a4f2: 4b1f         	ldr	r3, [pc, #0x7c]         @ 0x800a570 <async_evt_rx_rdy+0xa0>
 800a4f4: 6819         	ldr	r1, [r3]
 800a4f6: 687b         	ldr	r3, [r7, #0x4]
 800a4f8: 6f5b         	ldr	r3, [r3, #0x74]
 800a4fa: 687a         	ldr	r2, [r7, #0x4]
 800a4fc: 6f92         	ldr	r2, [r2, #0x78]
 800a4fe: 9205         	str	r2, [sp, #0x14]
 800a500: 9304         	str	r3, [sp, #0x10]
 800a502: 4b1c         	ldr	r3, [pc, #0x70]         @ 0x800a574 <async_evt_rx_rdy+0xa4>
 800a504: 9303         	str	r3, [sp, #0xc]
 800a506: 4b1c         	ldr	r3, [pc, #0x70]         @ 0x800a578 <async_evt_rx_rdy+0xa8>
 800a508: 9302         	str	r3, [sp, #0x8]
 800a50a: 2308         	movs	r3, #0x8
 800a50c: 9301         	str	r3, [sp, #0x4]
 800a50e: 2300         	movs	r3, #0x0
 800a510: 9300         	str	r3, [sp]
 800a512: 2300         	movs	r3, #0x0
 800a514: 2204         	movs	r2, #0x4
 800a516: 2000         	movs	r0, #0x0
 800a518: f00f fd4a    	bl	0x8019fb0 <z_log_msg_runtime_create> @ imm = #0xfa94
 800a51c: 2300         	movs	r3, #0x0
 800a51e: 623b         	str	r3, [r7, #0x20]
; 	struct uart_event event = {
 800a520: f107 030c    	add.w	r3, r7, #0xc
 800a524: 2200         	movs	r2, #0x0
 800a526: 601a         	str	r2, [r3]
 800a528: 605a         	str	r2, [r3, #0x4]
 800a52a: 609a         	str	r2, [r3, #0x8]
 800a52c: 60da         	str	r2, [r3, #0xc]
 800a52e: 611a         	str	r2, [r3, #0x10]
 800a530: 2302         	movs	r3, #0x2
 800a532: 733b         	strb	r3, [r7, #0xc]
; 		.data.rx.buf = data->dma_rx.buffer,
 800a534: 687b         	ldr	r3, [r7, #0x4]
 800a536: 6edb         	ldr	r3, [r3, #0x6c]
; 	struct uart_event event = {
 800a538: 613b         	str	r3, [r7, #0x10]
; 		.data.rx.offset = data->dma_rx.offset
 800a53a: 687b         	ldr	r3, [r7, #0x4]
 800a53c: 6f5b         	ldr	r3, [r3, #0x74]
; 	struct uart_event event = {
 800a53e: 617b         	str	r3, [r7, #0x14]
; 		.data.rx.len = data->dma_rx.counter - data->dma_rx.offset,
 800a540: 687b         	ldr	r3, [r7, #0x4]
 800a542: 6f9a         	ldr	r2, [r3, #0x78]
 800a544: 687b         	ldr	r3, [r7, #0x4]
 800a546: 6f5b         	ldr	r3, [r3, #0x74]
 800a548: 1ad3         	subs	r3, r2, r3
; 	struct uart_event event = {
 800a54a: 61bb         	str	r3, [r7, #0x18]
; 	data->dma_rx.offset = data->dma_rx.counter;
 800a54c: 687b         	ldr	r3, [r7, #0x4]
 800a54e: 6f9a         	ldr	r2, [r3, #0x78]
 800a550: 687b         	ldr	r3, [r7, #0x4]
 800a552: 675a         	str	r2, [r3, #0x74]
; 	if (event.data.rx.len > 0) {
 800a554: 69bb         	ldr	r3, [r7, #0x18]
 800a556: 2b00         	cmp	r3, #0x0
 800a558: d005         	beq	0x800a566 <async_evt_rx_rdy+0x96> @ imm = #0xa
; 		async_user_callback(data, &event);
 800a55a: f107 030c    	add.w	r3, r7, #0xc
 800a55e: 4619         	mov	r1, r3
 800a560: 6878         	ldr	r0, [r7, #0x4]
 800a562: f010 f9ca    	bl	0x801a8fa <async_user_callback> @ imm = #0x10394
; }
 800a566: bf00         	nop
 800a568: 3728         	adds	r7, #0x28
 800a56a: 46bd         	mov	sp, r7
 800a56c: bd80         	pop	{r7, pc}
 800a56e: bf00         	nop

0800a570 <$d>:
 800a570: 18 05 00 20  	.word	0x20000518
 800a574: e0 04 02 08  	.word	0x080204e0
 800a578: d0 f3 01 08  	.word	0x0801f3d0

0800a57c <async_evt_rx_err>:
; {
 800a57c: b580         	push	{r7, lr}
 800a57e: b090         	sub	sp, #0x40
 800a580: af06         	add	r7, sp, #0x18
 800a582: 6078         	str	r0, [r7, #0x4]
 800a584: 6039         	str	r1, [r7]
; 	LOG_DBG("rx error: %d", err_code);
 800a586: 2303         	movs	r3, #0x3
 800a588: 2b03         	cmp	r3, #0x3
 800a58a: d91c         	bls	0x800a5c6 <async_evt_rx_err+0x4a> @ imm = #0x38
 800a58c: 2301         	movs	r3, #0x1
 800a58e: f887 3027    	strb.w	r3, [r7, #0x27]
 800a592: f897 3027    	ldrb.w	r3, [r7, #0x27]
 800a596: f083 0301    	eor	r3, r3, #0x1
 800a59a: b2db         	uxtb	r3, r3
 800a59c: 2b00         	cmp	r3, #0x0
 800a59e: d112         	bne	0x800a5c6 <async_evt_rx_err+0x4a> @ imm = #0x24
 800a5a0: 4b14         	ldr	r3, [pc, #0x50]         @ 0x800a5f4 <async_evt_rx_err+0x78>
 800a5a2: 6819         	ldr	r1, [r3]
 800a5a4: 683b         	ldr	r3, [r7]
 800a5a6: 9304         	str	r3, [sp, #0x10]
 800a5a8: 4b13         	ldr	r3, [pc, #0x4c]         @ 0x800a5f8 <async_evt_rx_err+0x7c>
 800a5aa: 9303         	str	r3, [sp, #0xc]
 800a5ac: 4b13         	ldr	r3, [pc, #0x4c]         @ 0x800a5fc <async_evt_rx_err+0x80>
 800a5ae: 9302         	str	r3, [sp, #0x8]
 800a5b0: 2308         	movs	r3, #0x8
 800a5b2: 9301         	str	r3, [sp, #0x4]
 800a5b4: 2300         	movs	r3, #0x0
 800a5b6: 9300         	str	r3, [sp]
 800a5b8: 2300         	movs	r3, #0x0
 800a5ba: 2204         	movs	r2, #0x4
 800a5bc: 2000         	movs	r0, #0x0
 800a5be: f00f fcf7    	bl	0x8019fb0 <z_log_msg_runtime_create> @ imm = #0xf9ee
 800a5c2: 2300         	movs	r3, #0x0
 800a5c4: 623b         	str	r3, [r7, #0x20]
; 	struct uart_event event = {
 800a5c6: 2306         	movs	r3, #0x6
 800a5c8: 733b         	strb	r3, [r7, #0xc]
 800a5ca: 683b         	ldr	r3, [r7]
 800a5cc: b2db         	uxtb	r3, r3
 800a5ce: 743b         	strb	r3, [r7, #0x10]
; 		.data.rx_stop.data.buf = data->dma_rx.buffer
 800a5d0: 687b         	ldr	r3, [r7, #0x4]
 800a5d2: 6edb         	ldr	r3, [r3, #0x6c]
; 	struct uart_event event = {
 800a5d4: 617b         	str	r3, [r7, #0x14]
 800a5d6: 2300         	movs	r3, #0x0
 800a5d8: 61bb         	str	r3, [r7, #0x18]
; 		.data.rx_stop.data.len = data->dma_rx.counter,
 800a5da: 687b         	ldr	r3, [r7, #0x4]
 800a5dc: 6f9b         	ldr	r3, [r3, #0x78]
; 	struct uart_event event = {
 800a5de: 61fb         	str	r3, [r7, #0x1c]
; 	async_user_callback(data, &event);
 800a5e0: f107 030c    	add.w	r3, r7, #0xc
 800a5e4: 4619         	mov	r1, r3
 800a5e6: 6878         	ldr	r0, [r7, #0x4]
 800a5e8: f010 f987    	bl	0x801a8fa <async_user_callback> @ imm = #0x1030e
; }
 800a5ec: bf00         	nop
 800a5ee: 3728         	adds	r7, #0x28
 800a5f0: 46bd         	mov	sp, r7
 800a5f2: bd80         	pop	{r7, pc}

0800a5f4 <$d>:
 800a5f4: 18 05 00 20  	.word	0x20000518
 800a5f8: 68 05 02 08  	.word	0x08020568
 800a5fc: e4 f3 01 08  	.word	0x0801f3e4

0800a600 <async_evt_tx_done>:
; {
 800a600: b580         	push	{r7, lr}
 800a602: b090         	sub	sp, #0x40
 800a604: af06         	add	r7, sp, #0x18
 800a606: 6078         	str	r0, [r7, #0x4]
; 	LOG_DBG("tx done: %d", data->dma_tx.counter);
 800a608: 2303         	movs	r3, #0x3
 800a60a: 2b03         	cmp	r3, #0x3
 800a60c: d91e         	bls	0x800a64c <async_evt_tx_done+0x4c> @ imm = #0x3c
 800a60e: 2301         	movs	r3, #0x1
 800a610: f887 3027    	strb.w	r3, [r7, #0x27]
 800a614: f897 3027    	ldrb.w	r3, [r7, #0x27]
 800a618: f083 0301    	eor	r3, r3, #0x1
 800a61c: b2db         	uxtb	r3, r3
 800a61e: 2b00         	cmp	r3, #0x0
 800a620: d114         	bne	0x800a64c <async_evt_tx_done+0x4c> @ imm = #0x28
 800a622: 4b1b         	ldr	r3, [pc, #0x6c]         @ 0x800a690 <async_evt_tx_done+0x90>
 800a624: 6819         	ldr	r1, [r3]
 800a626: 687b         	ldr	r3, [r7, #0x4]
 800a628: f8d3 3110    	ldr.w	r3, [r3, #0x110]
 800a62c: 9304         	str	r3, [sp, #0x10]
 800a62e: 4b19         	ldr	r3, [pc, #0x64]         @ 0x800a694 <async_evt_tx_done+0x94>
 800a630: 9303         	str	r3, [sp, #0xc]
 800a632: 4b19         	ldr	r3, [pc, #0x64]         @ 0x800a698 <async_evt_tx_done+0x98>
 800a634: 9302         	str	r3, [sp, #0x8]
 800a636: 2308         	movs	r3, #0x8
 800a638: 9301         	str	r3, [sp, #0x4]
 800a63a: 2300         	movs	r3, #0x0
 800a63c: 9300         	str	r3, [sp]
 800a63e: 2300         	movs	r3, #0x0
 800a640: 2204         	movs	r2, #0x4
 800a642: 2000         	movs	r0, #0x0
 800a644: f00f fcb4    	bl	0x8019fb0 <z_log_msg_runtime_create> @ imm = #0xf968
 800a648: 2300         	movs	r3, #0x0
 800a64a: 623b         	str	r3, [r7, #0x20]
; 	struct uart_event event = {
 800a64c: f107 030c    	add.w	r3, r7, #0xc
 800a650: 2200         	movs	r2, #0x0
 800a652: 601a         	str	r2, [r3]
 800a654: 605a         	str	r2, [r3, #0x4]
 800a656: 609a         	str	r2, [r3, #0x8]
 800a658: 60da         	str	r2, [r3, #0xc]
 800a65a: 611a         	str	r2, [r3, #0x10]
; 		.data.tx.buf = data->dma_tx.buffer,
 800a65c: 687b         	ldr	r3, [r7, #0x4]
 800a65e: f8d3 3104    	ldr.w	r3, [r3, #0x104]
; 	struct uart_event event = {
 800a662: 613b         	str	r3, [r7, #0x10]
; 		.data.tx.len = data->dma_tx.counter
 800a664: 687b         	ldr	r3, [r7, #0x4]
 800a666: f8d3 3110    	ldr.w	r3, [r3, #0x110]
; 	struct uart_event event = {
 800a66a: 617b         	str	r3, [r7, #0x14]
; 	data->dma_tx.buffer_length = 0;
 800a66c: 687b         	ldr	r3, [r7, #0x4]
 800a66e: 2200         	movs	r2, #0x0
 800a670: f8c3 2108    	str.w	r2, [r3, #0x108]
; 	data->dma_tx.counter = 0;
 800a674: 687b         	ldr	r3, [r7, #0x4]
 800a676: 2200         	movs	r2, #0x0
 800a678: f8c3 2110    	str.w	r2, [r3, #0x110]
; 	async_user_callback(data, &event);
 800a67c: f107 030c    	add.w	r3, r7, #0xc
 800a680: 4619         	mov	r1, r3
 800a682: 6878         	ldr	r0, [r7, #0x4]
 800a684: f010 f939    	bl	0x801a8fa <async_user_callback> @ imm = #0x10272
; }
 800a688: bf00         	nop
 800a68a: 3728         	adds	r7, #0x28
 800a68c: 46bd         	mov	sp, r7
 800a68e: bd80         	pop	{r7, pc}

0800a690 <$d>:
 800a690: 18 05 00 20  	.word	0x20000518
 800a694: 18 05 02 08  	.word	0x08020518
 800a698: f8 f3 01 08  	.word	0x0801f3f8

0800a69c <async_evt_tx_abort>:
; {
 800a69c: b580         	push	{r7, lr}
 800a69e: b090         	sub	sp, #0x40
 800a6a0: af06         	add	r7, sp, #0x18
 800a6a2: 6078         	str	r0, [r7, #0x4]
; 	LOG_DBG("tx abort: %d", data->dma_tx.counter);
 800a6a4: 2303         	movs	r3, #0x3
 800a6a6: 2b03         	cmp	r3, #0x3
 800a6a8: d91e         	bls	0x800a6e8 <async_evt_tx_abort+0x4c> @ imm = #0x3c
 800a6aa: 2301         	movs	r3, #0x1
 800a6ac: f887 3027    	strb.w	r3, [r7, #0x27]
 800a6b0: f897 3027    	ldrb.w	r3, [r7, #0x27]
 800a6b4: f083 0301    	eor	r3, r3, #0x1
 800a6b8: b2db         	uxtb	r3, r3
 800a6ba: 2b00         	cmp	r3, #0x0
 800a6bc: d114         	bne	0x800a6e8 <async_evt_tx_abort+0x4c> @ imm = #0x28
 800a6be: 4b1c         	ldr	r3, [pc, #0x70]         @ 0x800a730 <async_evt_tx_abort+0x94>
 800a6c0: 6819         	ldr	r1, [r3]
 800a6c2: 687b         	ldr	r3, [r7, #0x4]
 800a6c4: f8d3 3110    	ldr.w	r3, [r3, #0x110]
 800a6c8: 9304         	str	r3, [sp, #0x10]
 800a6ca: 4b1a         	ldr	r3, [pc, #0x68]         @ 0x800a734 <async_evt_tx_abort+0x98>
 800a6cc: 9303         	str	r3, [sp, #0xc]
 800a6ce: 4b1a         	ldr	r3, [pc, #0x68]         @ 0x800a738 <async_evt_tx_abort+0x9c>
 800a6d0: 9302         	str	r3, [sp, #0x8]
 800a6d2: 2308         	movs	r3, #0x8
 800a6d4: 9301         	str	r3, [sp, #0x4]
 800a6d6: 2300         	movs	r3, #0x0
 800a6d8: 9300         	str	r3, [sp]
 800a6da: 2300         	movs	r3, #0x0
 800a6dc: 2204         	movs	r2, #0x4
 800a6de: 2000         	movs	r0, #0x0
 800a6e0: f00f fc66    	bl	0x8019fb0 <z_log_msg_runtime_create> @ imm = #0xf8cc
 800a6e4: 2300         	movs	r3, #0x0
 800a6e6: 623b         	str	r3, [r7, #0x20]
; 	struct uart_event event = {
 800a6e8: f107 030c    	add.w	r3, r7, #0xc
 800a6ec: 2200         	movs	r2, #0x0
 800a6ee: 601a         	str	r2, [r3]
 800a6f0: 605a         	str	r2, [r3, #0x4]
 800a6f2: 609a         	str	r2, [r3, #0x8]
 800a6f4: 60da         	str	r2, [r3, #0xc]
 800a6f6: 611a         	str	r2, [r3, #0x10]
 800a6f8: 2301         	movs	r3, #0x1
 800a6fa: 733b         	strb	r3, [r7, #0xc]
; 		.data.tx.buf = data->dma_tx.buffer,
 800a6fc: 687b         	ldr	r3, [r7, #0x4]
 800a6fe: f8d3 3104    	ldr.w	r3, [r3, #0x104]
; 	struct uart_event event = {
 800a702: 613b         	str	r3, [r7, #0x10]
; 		.data.tx.len = data->dma_tx.counter
 800a704: 687b         	ldr	r3, [r7, #0x4]
 800a706: f8d3 3110    	ldr.w	r3, [r3, #0x110]
; 	struct uart_event event = {
 800a70a: 617b         	str	r3, [r7, #0x14]
; 	data->dma_tx.buffer_length = 0;
 800a70c: 687b         	ldr	r3, [r7, #0x4]
 800a70e: 2200         	movs	r2, #0x0
 800a710: f8c3 2108    	str.w	r2, [r3, #0x108]
; 	data->dma_tx.counter = 0;
 800a714: 687b         	ldr	r3, [r7, #0x4]
 800a716: 2200         	movs	r2, #0x0
 800a718: f8c3 2110    	str.w	r2, [r3, #0x110]
; 	async_user_callback(data, &event);
 800a71c: f107 030c    	add.w	r3, r7, #0xc
 800a720: 4619         	mov	r1, r3
 800a722: 6878         	ldr	r0, [r7, #0x4]
 800a724: f010 f8e9    	bl	0x801a8fa <async_user_callback> @ imm = #0x101d2
; }
 800a728: bf00         	nop
 800a72a: 3728         	adds	r7, #0x28
 800a72c: 46bd         	mov	sp, r7
 800a72e: bd80         	pop	{r7, pc}

0800a730 <$d>:
 800a730: 18 05 00 20  	.word	0x20000518
 800a734: ac 05 02 08  	.word	0x080205ac
 800a738: 08 f4 01 08  	.word	0x0801f408

0800a73c <async_timer_start>:
; {
 800a73c: e92d 43b0    	push.w	{r4, r5, r7, r8, r9, lr}
 800a740: b08a         	sub	sp, #0x28
 800a742: af06         	add	r7, sp, #0x18
 800a744: 6078         	str	r0, [r7, #0x4]
 800a746: 6039         	str	r1, [r7]
; 	if ((timeout != SYS_FOREVER_US) && (timeout != 0)) {
 800a748: 683b         	ldr	r3, [r7]
 800a74a: f1b3 3fff    	cmp.w	r3, #0xffffffff
 800a74e: d037         	beq	0x800a7c0 <async_timer_start+0x84> @ imm = #0x6e
 800a750: 683b         	ldr	r3, [r7]
 800a752: 2b00         	cmp	r3, #0x0
 800a754: d034         	beq	0x800a7c0 <async_timer_start+0x84> @ imm = #0x68
; 		LOG_DBG("async timer started for %d us", timeout);
 800a756: 2303         	movs	r3, #0x3
 800a758: 2b03         	cmp	r3, #0x3
 800a75a: d91a         	bls	0x800a792 <async_timer_start+0x56> @ imm = #0x34
 800a75c: 2301         	movs	r3, #0x1
 800a75e: 73fb         	strb	r3, [r7, #0xf]
 800a760: 7bfb         	ldrb	r3, [r7, #0xf]
 800a762: f083 0301    	eor	r3, r3, #0x1
 800a766: b2db         	uxtb	r3, r3
 800a768: 2b00         	cmp	r3, #0x0
 800a76a: d112         	bne	0x800a792 <async_timer_start+0x56> @ imm = #0x24
 800a76c: 4b17         	ldr	r3, [pc, #0x5c]         @ 0x800a7cc <async_timer_start+0x90>
 800a76e: 6819         	ldr	r1, [r3]
 800a770: 683b         	ldr	r3, [r7]
 800a772: 9304         	str	r3, [sp, #0x10]
 800a774: 4b16         	ldr	r3, [pc, #0x58]         @ 0x800a7d0 <async_timer_start+0x94>
 800a776: 9303         	str	r3, [sp, #0xc]
 800a778: 4b16         	ldr	r3, [pc, #0x58]         @ 0x800a7d4 <async_timer_start+0x98>
 800a77a: 9302         	str	r3, [sp, #0x8]
 800a77c: 2308         	movs	r3, #0x8
 800a77e: 9301         	str	r3, [sp, #0x4]
 800a780: 2300         	movs	r3, #0x0
 800a782: 9300         	str	r3, [sp]
 800a784: 2300         	movs	r3, #0x0
 800a786: 2204         	movs	r2, #0x4
 800a788: 2000         	movs	r0, #0x0
 800a78a: f00f fc11    	bl	0x8019fb0 <z_log_msg_runtime_create> @ imm = #0xf822
 800a78e: 2300         	movs	r3, #0x0
 800a790: 60bb         	str	r3, [r7, #0x8]
; 		k_work_reschedule(work, K_USEC(timeout));
 800a792: 683b         	ldr	r3, [r7]
 800a794: ea23 73e3    	bic.w	r3, r3, r3, asr #31
 800a798: 17da         	asrs	r2, r3, #0x1f
 800a79a: 461c         	mov	r4, r3
 800a79c: 4615         	mov	r5, r2
 800a79e: f114 0863    	adds.w	r8, r4, #0x63
 800a7a2: f145 0900    	adc	r9, r5, #0x0
 800a7a6: f04f 0264    	mov.w	r2, #0x64
 800a7aa: f04f 0300    	mov.w	r3, #0x0
 800a7ae: 4640         	mov	r0, r8
 800a7b0: 4649         	mov	r1, r9
 800a7b2: f7f6 f833    	bl	0x800081c <__aeabi_uldivmod> @ imm = #-0x9f9a
 800a7b6: 4602         	mov	r2, r0
 800a7b8: 460b         	mov	r3, r1
 800a7ba: 6878         	ldr	r0, [r7, #0x4]
 800a7bc: f004 fa14    	bl	0x800ebe8 <k_work_reschedule> @ imm = #0x4428
; }
 800a7c0: bf00         	nop
 800a7c2: 3710         	adds	r7, #0x10
 800a7c4: 46bd         	mov	sp, r7
 800a7c6: e8bd 83b0    	pop.w	{r4, r5, r7, r8, r9, pc}
 800a7ca: bf00         	nop

0800a7cc <$d>:
 800a7cc: 18 05 00 20  	.word	0x20000518
 800a7d0: 04 05 02 08  	.word	0x08020504
 800a7d4: 1c f4 01 08  	.word	0x0801f41c

0800a7d8 <uart_stm32_isr>:
; {
 800a7d8: b580         	push	{r7, lr}
 800a7da: b08c         	sub	sp, #0x30
 800a7dc: af04         	add	r7, sp, #0x10
 800a7de: 6078         	str	r0, [r7, #0x4]
; 	struct uart_stm32_data *data = dev->data;
 800a7e0: 687b         	ldr	r3, [r7, #0x4]
 800a7e2: 691b         	ldr	r3, [r3, #0x10]
 800a7e4: 61fb         	str	r3, [r7, #0x1c]
; 	const struct uart_stm32_config *config = dev->config;
 800a7e6: 687b         	ldr	r3, [r7, #0x4]
 800a7e8: 685b         	ldr	r3, [r3, #0x4]
 800a7ea: 61bb         	str	r3, [r7, #0x18]
; 	USART_TypeDef *usart = config->usart;
 800a7ec: 69bb         	ldr	r3, [r7, #0x18]
 800a7ee: 681b         	ldr	r3, [r3]
 800a7f0: 617b         	str	r3, [r7, #0x14]
; 	if (data->user_cb) {
 800a7f2: 69fb         	ldr	r3, [r7, #0x1c]
 800a7f4: 689b         	ldr	r3, [r3, #0x8]
 800a7f6: 2b00         	cmp	r3, #0x0
 800a7f8: d006         	beq	0x800a808 <uart_stm32_isr+0x30> @ imm = #0xc
; 		data->user_cb(dev, data->user_data);
 800a7fa: 69fb         	ldr	r3, [r7, #0x1c]
 800a7fc: 689b         	ldr	r3, [r3, #0x8]
 800a7fe: 69fa         	ldr	r2, [r7, #0x1c]
 800a800: 68d2         	ldr	r2, [r2, #0xc]
 800a802: 4611         	mov	r1, r2
 800a804: 6878         	ldr	r0, [r7, #0x4]
 800a806: 4798         	blx	r3
; 	if (LL_USART_IsEnabledIT_IDLE(usart) &&
 800a808: 6978         	ldr	r0, [r7, #0x14]
 800a80a: f00f fb10    	bl	0x8019e2e <LL_USART_IsEnabledIT_IDLE> @ imm = #0xf620
 800a80e: 4603         	mov	r3, r0
 800a810: 2b00         	cmp	r3, #0x0
 800a812: d036         	beq	0x800a882 <uart_stm32_isr+0xaa> @ imm = #0x6c
; 			LL_USART_IsActiveFlag_IDLE(usart)) {
 800a814: 6978         	ldr	r0, [r7, #0x14]
 800a816: f00f f8c1    	bl	0x801999c <LL_USART_IsActiveFlag_IDLE> @ imm = #0xf182
 800a81a: 4603         	mov	r3, r0
; 	if (LL_USART_IsEnabledIT_IDLE(usart) &&
 800a81c: 2b00         	cmp	r3, #0x0
 800a81e: d030         	beq	0x800a882 <uart_stm32_isr+0xaa> @ imm = #0x60
; 		LL_USART_ClearFlag_IDLE(usart);
 800a820: 6978         	ldr	r0, [r7, #0x14]
 800a822: f00f f95a    	bl	0x8019ada <LL_USART_ClearFlag_IDLE> @ imm = #0xf2b4
; 		LOG_DBG("idle interrupt occurred");
 800a826: 2303         	movs	r3, #0x3
 800a828: 2b03         	cmp	r3, #0x3
 800a82a: d918         	bls	0x800a85e <uart_stm32_isr+0x86> @ imm = #0x30
 800a82c: 2301         	movs	r3, #0x1
 800a82e: 74fb         	strb	r3, [r7, #0x13]
 800a830: 7cfb         	ldrb	r3, [r7, #0x13]
 800a832: f083 0301    	eor	r3, r3, #0x1
 800a836: b2db         	uxtb	r3, r3
 800a838: 2b00         	cmp	r3, #0x0
 800a83a: d110         	bne	0x800a85e <uart_stm32_isr+0x86> @ imm = #0x20
 800a83c: 4b25         	ldr	r3, [pc, #0x94]         @ 0x800a8d4 <uart_stm32_isr+0xfc>
 800a83e: 6819         	ldr	r1, [r3]
 800a840: 4b25         	ldr	r3, [pc, #0x94]         @ 0x800a8d8 <uart_stm32_isr+0x100>
 800a842: 9303         	str	r3, [sp, #0xc]
 800a844: 4b25         	ldr	r3, [pc, #0x94]         @ 0x800a8dc <uart_stm32_isr+0x104>
 800a846: 9302         	str	r3, [sp, #0x8]
 800a848: 2308         	movs	r3, #0x8
 800a84a: 9301         	str	r3, [sp, #0x4]
 800a84c: 2300         	movs	r3, #0x0
 800a84e: 9300         	str	r3, [sp]
 800a850: 2300         	movs	r3, #0x0
 800a852: 2204         	movs	r2, #0x4
 800a854: 2000         	movs	r0, #0x0
 800a856: f00f fbab    	bl	0x8019fb0 <z_log_msg_runtime_create> @ imm = #0xf756
 800a85a: 2300         	movs	r3, #0x0
 800a85c: 60fb         	str	r3, [r7, #0xc]
; 		if (data->dma_rx.timeout == 0) {
 800a85e: 69fb         	ldr	r3, [r7, #0x1c]
 800a860: 6fdb         	ldr	r3, [r3, #0x7c]
 800a862: 2b00         	cmp	r3, #0x0
 800a864: d103         	bne	0x800a86e <uart_stm32_isr+0x96> @ imm = #0x6
; 			uart_stm32_dma_rx_flush(dev);
 800a866: 6878         	ldr	r0, [r7, #0x4]
 800a868: f010 f88f    	bl	0x801a98a <uart_stm32_dma_rx_flush> @ imm = #0x1011e
; 		if (data->dma_rx.timeout == 0) {
 800a86c: e02b         	b	0x800a8c6 <uart_stm32_isr+0xee> @ imm = #0x56
; 			async_timer_start(&data->dma_rx.timeout_work,
 800a86e: 69fb         	ldr	r3, [r7, #0x1c]
 800a870: f103 0280    	add.w	r2, r3, #0x80
 800a874: 69fb         	ldr	r3, [r7, #0x1c]
 800a876: 6fdb         	ldr	r3, [r3, #0x7c]
 800a878: 4619         	mov	r1, r3
 800a87a: 4610         	mov	r0, r2
 800a87c: f7ff ff5e    	bl	0x800a73c <async_timer_start> @ imm = #-0x144
; 		if (data->dma_rx.timeout == 0) {
 800a880: e021         	b	0x800a8c6 <uart_stm32_isr+0xee> @ imm = #0x42
; 	} else if (LL_USART_IsEnabledIT_TC(usart) &&
 800a882: 6978         	ldr	r0, [r7, #0x14]
 800a884: f00f faf7    	bl	0x8019e76 <LL_USART_IsEnabledIT_TC> @ imm = #0xf5ee
 800a888: 4603         	mov	r3, r0
 800a88a: 2b00         	cmp	r3, #0x0
 800a88c: d00c         	beq	0x800a8a8 <uart_stm32_isr+0xd0> @ imm = #0x18
; 			LL_USART_IsActiveFlag_TC(usart)) {
 800a88e: 6978         	ldr	r0, [r7, #0x14]
 800a890: f00f f8a8    	bl	0x80199e4 <LL_USART_IsActiveFlag_TC> @ imm = #0xf150
 800a894: 4603         	mov	r3, r0
; 	} else if (LL_USART_IsEnabledIT_TC(usart) &&
 800a896: 2b00         	cmp	r3, #0x0
 800a898: d006         	beq	0x800a8a8 <uart_stm32_isr+0xd0> @ imm = #0xc
; 		LL_USART_DisableIT_TC(usart);
 800a89a: 6978         	ldr	r0, [r7, #0x14]
 800a89c: f00f fa52    	bl	0x8019d44 <LL_USART_DisableIT_TC> @ imm = #0xf4a4
; 		async_evt_tx_done(data);
 800a8a0: 69f8         	ldr	r0, [r7, #0x1c]
 800a8a2: f7ff fead    	bl	0x800a600 <async_evt_tx_done> @ imm = #-0x2a6
 800a8a6: e00e         	b	0x800a8c6 <uart_stm32_isr+0xee> @ imm = #0x1c
; 	} else if (LL_USART_IsEnabledIT_RXNE(usart) &&
 800a8a8: 6978         	ldr	r0, [r7, #0x14]
 800a8aa: f00f fad2    	bl	0x8019e52 <LL_USART_IsEnabledIT_RXNE> @ imm = #0xf5a4
 800a8ae: 4603         	mov	r3, r0
 800a8b0: 2b00         	cmp	r3, #0x0
 800a8b2: d008         	beq	0x800a8c6 <uart_stm32_isr+0xee> @ imm = #0x10
; 			LL_USART_IsActiveFlag_RXNE(usart)) {
 800a8b4: 6978         	ldr	r0, [r7, #0x14]
 800a8b6: f00f f883    	bl	0x80199c0 <LL_USART_IsActiveFlag_RXNE> @ imm = #0xf106
 800a8ba: 4603         	mov	r3, r0
; 	} else if (LL_USART_IsEnabledIT_RXNE(usart) &&
 800a8bc: 2b00         	cmp	r3, #0x0
 800a8be: d002         	beq	0x800a8c6 <uart_stm32_isr+0xee> @ imm = #0x4
; 		LL_USART_ClearFlag_RXNE(usart);
 800a8c0: 6978         	ldr	r0, [r7, #0x14]
 800a8c2: f00f f928    	bl	0x8019b16 <LL_USART_ClearFlag_RXNE> @ imm = #0xf250
; 	uart_stm32_err_check(dev);
 800a8c6: 6878         	ldr	r0, [r7, #0x4]
 800a8c8: f00f fe3a    	bl	0x801a540 <uart_stm32_err_check> @ imm = #0xfc74
; }
 800a8cc: bf00         	nop
 800a8ce: 3720         	adds	r7, #0x20
 800a8d0: 46bd         	mov	sp, r7
 800a8d2: bd80         	pop	{r7, pc}

0800a8d4 <$d>:
 800a8d4: 18 05 00 20  	.word	0x20000518
 800a8d8: f4 04 02 08  	.word	0x080204f4
 800a8dc: 40 f4 01 08  	.word	0x0801f440

0800a8e0 <uart_stm32_async_rx_disable>:
; {
 800a8e0: b580         	push	{r7, lr}
 800a8e2: b096         	sub	sp, #0x58
 800a8e4: af04         	add	r7, sp, #0x10
 800a8e6: 6078         	str	r0, [r7, #0x4]
; 	const struct uart_stm32_config *config = dev->config;
 800a8e8: 687b         	ldr	r3, [r7, #0x4]
 800a8ea: 685b         	ldr	r3, [r3, #0x4]
 800a8ec: 647b         	str	r3, [r7, #0x44]
; 	USART_TypeDef *usart = config->usart;
 800a8ee: 6c7b         	ldr	r3, [r7, #0x44]
 800a8f0: 681b         	ldr	r3, [r3]
 800a8f2: 643b         	str	r3, [r7, #0x40]
; 	struct uart_stm32_data *data = dev->data;
 800a8f4: 687b         	ldr	r3, [r7, #0x4]
 800a8f6: 691b         	ldr	r3, [r3, #0x10]
 800a8f8: 63fb         	str	r3, [r7, #0x3c]
; 	struct uart_event disabled_event = {
 800a8fa: f107 0320    	add.w	r3, r7, #0x20
 800a8fe: 2200         	movs	r2, #0x0
 800a900: 601a         	str	r2, [r3]
 800a902: 605a         	str	r2, [r3, #0x4]
 800a904: 609a         	str	r2, [r3, #0x8]
 800a906: 60da         	str	r2, [r3, #0xc]
 800a908: 611a         	str	r2, [r3, #0x10]
 800a90a: 2305         	movs	r3, #0x5
 800a90c: f887 3020    	strb.w	r3, [r7, #0x20]
; 	if (!data->dma_rx.enabled) {
 800a910: 6bfb         	ldr	r3, [r7, #0x3c]
 800a912: f893 30b0    	ldrb.w	r3, [r3, #0xb0]
 800a916: f083 0301    	eor	r3, r3, #0x1
 800a91a: b2db         	uxtb	r3, r3
 800a91c: 2b00         	cmp	r3, #0x0
 800a91e: d008         	beq	0x800a932 <uart_stm32_async_rx_disable+0x52> @ imm = #0x10
; 		async_user_callback(data, &disabled_event);
 800a920: f107 0320    	add.w	r3, r7, #0x20
 800a924: 4619         	mov	r1, r3
 800a926: 6bf8         	ldr	r0, [r7, #0x3c]
 800a928: f00f ffe7    	bl	0x801a8fa <async_user_callback> @ imm = #0xffce
; 		return -EFAULT;
 800a92c: f06f 030d    	mvn	r3, #0xd
 800a930: e061         	b	0x800a9f6 <uart_stm32_async_rx_disable+0x116> @ imm = #0xc2
; 	LL_USART_DisableIT_IDLE(usart);
 800a932: 6c38         	ldr	r0, [r7, #0x40]
 800a934: f00f f9c2    	bl	0x8019cbc <LL_USART_DisableIT_IDLE> @ imm = #0xf384
; 	uart_stm32_dma_rx_flush(dev);
 800a938: 6878         	ldr	r0, [r7, #0x4]
 800a93a: f010 f826    	bl	0x801a98a <uart_stm32_dma_rx_flush> @ imm = #0x1004c
; 	async_evt_rx_buf_release(data);
 800a93e: 6bf8         	ldr	r0, [r7, #0x3c]
 800a940: f010 f808    	bl	0x801a954 <async_evt_rx_buf_release> @ imm = #0x10010
; 	uart_stm32_dma_rx_disable(dev);
 800a944: 6878         	ldr	r0, [r7, #0x4]
 800a946: f010 f899    	bl	0x801aa7c <uart_stm32_dma_rx_disable> @ imm = #0x10132
; 	(void)k_work_cancel_delayable(&data->dma_rx.timeout_work);
 800a94a: 6bfb         	ldr	r3, [r7, #0x3c]
 800a94c: 3380         	adds	r3, #0x80
 800a94e: 4618         	mov	r0, r3
 800a950: f004 f95e    	bl	0x800ec10 <k_work_cancel_delayable> @ imm = #0x42bc
; 	dma_stop(data->dma_rx.dma_dev, data->dma_rx.dma_channel);
 800a954: 6bfb         	ldr	r3, [r7, #0x3c]
 800a956: 6a1a         	ldr	r2, [r3, #0x20]
 800a958: 6bfb         	ldr	r3, [r7, #0x3c]
 800a95a: 6a5b         	ldr	r3, [r3, #0x24]
 800a95c: 4619         	mov	r1, r3
 800a95e: 4610         	mov	r0, r2
 800a960: f00e fe5f    	bl	0x8019622 <dma_stop>    @ imm = #0xecbe
; 	if (data->rx_next_buffer) {
 800a964: 6bfb         	ldr	r3, [r7, #0x3c]
 800a966: f8d3 3150    	ldr.w	r3, [r3, #0x150]
 800a96a: 2b00         	cmp	r3, #0x0
 800a96c: d013         	beq	0x800a996 <uart_stm32_async_rx_disable+0xb6> @ imm = #0x26
; 		struct uart_event rx_next_buf_release_evt = {
 800a96e: f107 030c    	add.w	r3, r7, #0xc
 800a972: 2200         	movs	r2, #0x0
 800a974: 601a         	str	r2, [r3]
 800a976: 605a         	str	r2, [r3, #0x4]
 800a978: 609a         	str	r2, [r3, #0x8]
 800a97a: 60da         	str	r2, [r3, #0xc]
 800a97c: 611a         	str	r2, [r3, #0x10]
 800a97e: 2304         	movs	r3, #0x4
 800a980: 733b         	strb	r3, [r7, #0xc]
; 			.data.rx_buf.buf = data->rx_next_buffer,
 800a982: 6bfb         	ldr	r3, [r7, #0x3c]
 800a984: f8d3 3150    	ldr.w	r3, [r3, #0x150]
; 		struct uart_event rx_next_buf_release_evt = {
 800a988: 613b         	str	r3, [r7, #0x10]
; 		async_user_callback(data, &rx_next_buf_release_evt);
 800a98a: f107 030c    	add.w	r3, r7, #0xc
 800a98e: 4619         	mov	r1, r3
 800a990: 6bf8         	ldr	r0, [r7, #0x3c]
 800a992: f00f ffb2    	bl	0x801a8fa <async_user_callback> @ imm = #0xff64
; 	data->rx_next_buffer = NULL;
 800a996: 6bfb         	ldr	r3, [r7, #0x3c]
 800a998: 2200         	movs	r2, #0x0
 800a99a: f8c3 2150    	str.w	r2, [r3, #0x150]
; 	data->rx_next_buffer_len = 0;
 800a99e: 6bfb         	ldr	r3, [r7, #0x3c]
 800a9a0: 2200         	movs	r2, #0x0
 800a9a2: f8c3 2154    	str.w	r2, [r3, #0x154]
; 	LL_USART_EnableIT_RXNE(usart);
 800a9a6: 6c38         	ldr	r0, [r7, #0x40]
 800a9a8: f00f f8f1    	bl	0x8019b8e <LL_USART_EnableIT_RXNE> @ imm = #0xf1e2
; 	LOG_DBG("rx: disabled");
 800a9ac: 2303         	movs	r3, #0x3
 800a9ae: 2b03         	cmp	r3, #0x3
 800a9b0: d91a         	bls	0x800a9e8 <uart_stm32_async_rx_disable+0x108> @ imm = #0x34
 800a9b2: 2301         	movs	r3, #0x1
 800a9b4: f887 303b    	strb.w	r3, [r7, #0x3b]
 800a9b8: f897 303b    	ldrb.w	r3, [r7, #0x3b]
 800a9bc: f083 0301    	eor	r3, r3, #0x1
 800a9c0: b2db         	uxtb	r3, r3
 800a9c2: 2b00         	cmp	r3, #0x0
 800a9c4: d110         	bne	0x800a9e8 <uart_stm32_async_rx_disable+0x108> @ imm = #0x20
 800a9c6: 4b0e         	ldr	r3, [pc, #0x38]         @ 0x800aa00 <uart_stm32_async_rx_disable+0x120>
 800a9c8: 6819         	ldr	r1, [r3]
 800a9ca: 4b0e         	ldr	r3, [pc, #0x38]         @ 0x800aa04 <uart_stm32_async_rx_disable+0x124>
 800a9cc: 9303         	str	r3, [sp, #0xc]
 800a9ce: 4b0e         	ldr	r3, [pc, #0x38]         @ 0x800aa08 <uart_stm32_async_rx_disable+0x128>
 800a9d0: 9302         	str	r3, [sp, #0x8]
 800a9d2: 2308         	movs	r3, #0x8
 800a9d4: 9301         	str	r3, [sp, #0x4]
 800a9d6: 2300         	movs	r3, #0x0
 800a9d8: 9300         	str	r3, [sp]
 800a9da: 2300         	movs	r3, #0x0
 800a9dc: 2204         	movs	r2, #0x4
 800a9de: 2000         	movs	r0, #0x0
 800a9e0: f00f fae6    	bl	0x8019fb0 <z_log_msg_runtime_create> @ imm = #0xf5cc
 800a9e4: 2300         	movs	r3, #0x0
 800a9e6: 637b         	str	r3, [r7, #0x34]
; 	async_user_callback(data, &disabled_event);
 800a9e8: f107 0320    	add.w	r3, r7, #0x20
 800a9ec: 4619         	mov	r1, r3
 800a9ee: 6bf8         	ldr	r0, [r7, #0x3c]
 800a9f0: f00f ff83    	bl	0x801a8fa <async_user_callback> @ imm = #0xff06
; 	return 0;
 800a9f4: 2300         	movs	r3, #0x0
; }
 800a9f6: 4618         	mov	r0, r3
 800a9f8: 3748         	adds	r7, #0x48
 800a9fa: 46bd         	mov	sp, r7
 800a9fc: bd80         	pop	{r7, pc}
 800a9fe: bf00         	nop

0800aa00 <$d>:
 800aa00: 18 05 00 20  	.word	0x20000518
 800aa04: 2c 05 02 08  	.word	0x0802052c
 800aa08: 5c f4 01 08  	.word	0x0801f45c

0800aa0c <uart_stm32_dma_replace_buffer>:
; {
 800aa0c: b590         	push	{r4, r7, lr}
 800aa0e: b08f         	sub	sp, #0x3c
 800aa10: af06         	add	r7, sp, #0x18
 800aa12: 6078         	str	r0, [r7, #0x4]
; 	const struct uart_stm32_config *config = dev->config;
 800aa14: 687b         	ldr	r3, [r7, #0x4]
 800aa16: 685b         	ldr	r3, [r3, #0x4]
 800aa18: 61fb         	str	r3, [r7, #0x1c]
; 	USART_TypeDef *usart = config->usart;
 800aa1a: 69fb         	ldr	r3, [r7, #0x1c]
 800aa1c: 681b         	ldr	r3, [r3]
 800aa1e: 61bb         	str	r3, [r7, #0x18]
; 	struct uart_stm32_data *data = dev->data;
 800aa20: 687b         	ldr	r3, [r7, #0x4]
 800aa22: 691b         	ldr	r3, [r3, #0x10]
 800aa24: 617b         	str	r3, [r7, #0x14]
; 	LOG_DBG("Replacing RX buffer: %d", data->rx_next_buffer_len);
 800aa26: 2303         	movs	r3, #0x3
 800aa28: 2b03         	cmp	r3, #0x3
 800aa2a: d91c         	bls	0x800aa66 <uart_stm32_dma_replace_buffer+0x5a> @ imm = #0x38
 800aa2c: 2301         	movs	r3, #0x1
 800aa2e: 74fb         	strb	r3, [r7, #0x13]
 800aa30: 7cfb         	ldrb	r3, [r7, #0x13]
 800aa32: f083 0301    	eor	r3, r3, #0x1
 800aa36: b2db         	uxtb	r3, r3
 800aa38: 2b00         	cmp	r3, #0x0
 800aa3a: d114         	bne	0x800aa66 <uart_stm32_dma_replace_buffer+0x5a> @ imm = #0x28
 800aa3c: 4b2a         	ldr	r3, [pc, #0xa8]         @ 0x800aae8 <uart_stm32_dma_replace_buffer+0xdc>
 800aa3e: 6819         	ldr	r1, [r3]
 800aa40: 697b         	ldr	r3, [r7, #0x14]
 800aa42: f8d3 3154    	ldr.w	r3, [r3, #0x154]
 800aa46: 9304         	str	r3, [sp, #0x10]
 800aa48: 4b28         	ldr	r3, [pc, #0xa0]         @ 0x800aaec <uart_stm32_dma_replace_buffer+0xe0>
 800aa4a: 9303         	str	r3, [sp, #0xc]
 800aa4c: 4b28         	ldr	r3, [pc, #0xa0]         @ 0x800aaf0 <uart_stm32_dma_replace_buffer+0xe4>
 800aa4e: 9302         	str	r3, [sp, #0x8]
 800aa50: 2308         	movs	r3, #0x8
 800aa52: 9301         	str	r3, [sp, #0x4]
 800aa54: 2300         	movs	r3, #0x0
 800aa56: 9300         	str	r3, [sp]
 800aa58: 2300         	movs	r3, #0x0
 800aa5a: 2204         	movs	r2, #0x4
 800aa5c: 2000         	movs	r0, #0x0
 800aa5e: f00f faa7    	bl	0x8019fb0 <z_log_msg_runtime_create> @ imm = #0xf54e
 800aa62: 2300         	movs	r3, #0x0
 800aa64: 60fb         	str	r3, [r7, #0xc]
; 	data->dma_rx.offset = 0;
 800aa66: 697b         	ldr	r3, [r7, #0x14]
 800aa68: 2200         	movs	r2, #0x0
 800aa6a: 675a         	str	r2, [r3, #0x74]
; 	data->dma_rx.counter = 0;
 800aa6c: 697b         	ldr	r3, [r7, #0x14]
 800aa6e: 2200         	movs	r2, #0x0
 800aa70: 679a         	str	r2, [r3, #0x78]
; 	data->dma_rx.buffer = data->rx_next_buffer;
 800aa72: 697b         	ldr	r3, [r7, #0x14]
 800aa74: f8d3 2150    	ldr.w	r2, [r3, #0x150]
 800aa78: 697b         	ldr	r3, [r7, #0x14]
 800aa7a: 66da         	str	r2, [r3, #0x6c]
; 	data->dma_rx.buffer_length = data->rx_next_buffer_len;
 800aa7c: 697b         	ldr	r3, [r7, #0x14]
 800aa7e: f8d3 2154    	ldr.w	r2, [r3, #0x154]
 800aa82: 697b         	ldr	r3, [r7, #0x14]
 800aa84: 671a         	str	r2, [r3, #0x70]
; 	data->dma_rx.blk_cfg.block_size = data->dma_rx.buffer_length;
 800aa86: 697b         	ldr	r3, [r7, #0x14]
 800aa88: 6f1a         	ldr	r2, [r3, #0x70]
 800aa8a: 697b         	ldr	r3, [r7, #0x14]
 800aa8c: 661a         	str	r2, [r3, #0x60]
; 	data->dma_rx.blk_cfg.dest_address = (uint32_t)data->dma_rx.buffer;
 800aa8e: 697b         	ldr	r3, [r7, #0x14]
 800aa90: 6edb         	ldr	r3, [r3, #0x6c]
 800aa92: 461a         	mov	r2, r3
 800aa94: 697b         	ldr	r3, [r7, #0x14]
 800aa96: 651a         	str	r2, [r3, #0x50]
; 	data->rx_next_buffer = NULL;
 800aa98: 697b         	ldr	r3, [r7, #0x14]
 800aa9a: 2200         	movs	r2, #0x0
 800aa9c: f8c3 2150    	str.w	r2, [r3, #0x150]
; 	data->rx_next_buffer_len = 0;
 800aaa0: 697b         	ldr	r3, [r7, #0x14]
 800aaa2: 2200         	movs	r2, #0x0
 800aaa4: f8c3 2154    	str.w	r2, [r3, #0x154]
; 	dma_reload(data->dma_rx.dma_dev, data->dma_rx.dma_channel,
 800aaa8: 697b         	ldr	r3, [r7, #0x14]
 800aaaa: 6a18         	ldr	r0, [r3, #0x20]
 800aaac: 697b         	ldr	r3, [r7, #0x14]
 800aaae: 6a59         	ldr	r1, [r3, #0x24]
 800aab0: 697b         	ldr	r3, [r7, #0x14]
 800aab2: 6cda         	ldr	r2, [r3, #0x4c]
 800aab4: 697b         	ldr	r3, [r7, #0x14]
 800aab6: 6d1c         	ldr	r4, [r3, #0x50]
 800aab8: 697b         	ldr	r3, [r7, #0x14]
 800aaba: 6e1b         	ldr	r3, [r3, #0x60]
 800aabc: 9300         	str	r3, [sp]
 800aabe: 4623         	mov	r3, r4
 800aac0: f00e fd43    	bl	0x801954a <dma_reload>  @ imm = #0xea86
; 	dma_start(data->dma_rx.dma_dev, data->dma_rx.dma_channel);
 800aac4: 697b         	ldr	r3, [r7, #0x14]
 800aac6: 6a1a         	ldr	r2, [r3, #0x20]
 800aac8: 697b         	ldr	r3, [r7, #0x14]
 800aaca: 6a5b         	ldr	r3, [r3, #0x24]
 800aacc: 4619         	mov	r1, r3
 800aace: 4610         	mov	r0, r2
 800aad0: f00e fd99    	bl	0x8019606 <dma_start>   @ imm = #0xeb32
; 	LL_USART_ClearFlag_IDLE(usart);
 800aad4: 69b8         	ldr	r0, [r7, #0x18]
 800aad6: f00f f800    	bl	0x8019ada <LL_USART_ClearFlag_IDLE> @ imm = #0xf000
; 	async_evt_rx_buf_request(data);
 800aada: 6978         	ldr	r0, [r7, #0x14]
 800aadc: f00f ff22    	bl	0x801a924 <async_evt_rx_buf_request> @ imm = #0xfe44
; }
 800aae0: bf00         	nop
 800aae2: 3724         	adds	r7, #0x24
 800aae4: 46bd         	mov	sp, r7
 800aae6: bd90         	pop	{r4, r7, pc}

0800aae8 <$d>:
 800aae8: 18 05 00 20  	.word	0x20000518
 800aaec: 48 05 02 08  	.word	0x08020548
 800aaf0: 70 f4 01 08  	.word	0x0801f470

0800aaf4 <uart_stm32_async_tx>:
; {
 800aaf4: b580         	push	{r7, lr}
 800aaf6: b094         	sub	sp, #0x50
 800aaf8: af06         	add	r7, sp, #0x18
 800aafa: 60f8         	str	r0, [r7, #0xc]
 800aafc: 60b9         	str	r1, [r7, #0x8]
 800aafe: 607a         	str	r2, [r7, #0x4]
 800ab00: 603b         	str	r3, [r7]
; 	const struct uart_stm32_config *config = dev->config;
 800ab02: 68fb         	ldr	r3, [r7, #0xc]
 800ab04: 685b         	ldr	r3, [r3, #0x4]
 800ab06: 637b         	str	r3, [r7, #0x34]
; 	USART_TypeDef *usart = config->usart;
 800ab08: 6b7b         	ldr	r3, [r7, #0x34]
 800ab0a: 681b         	ldr	r3, [r3]
 800ab0c: 633b         	str	r3, [r7, #0x30]
; 	struct uart_stm32_data *data = dev->data;
 800ab0e: 68fb         	ldr	r3, [r7, #0xc]
 800ab10: 691b         	ldr	r3, [r3, #0x10]
 800ab12: 62fb         	str	r3, [r7, #0x2c]
; 	if (data->dma_tx.dma_dev == NULL) {
 800ab14: 6afb         	ldr	r3, [r7, #0x2c]
 800ab16: f8d3 30b8    	ldr.w	r3, [r3, #0xb8]
 800ab1a: 2b00         	cmp	r3, #0x0
 800ab1c: d102         	bne	0x800ab24 <uart_stm32_async_tx+0x30> @ imm = #0x4
; 		return -ENODEV;
 800ab1e: f06f 0312    	mvn	r3, #0x12
 800ab22: e0ac         	b	0x800ac7e <uart_stm32_async_tx+0x18a> @ imm = #0x158
; 	if (data->dma_tx.buffer_length != 0) {
 800ab24: 6afb         	ldr	r3, [r7, #0x2c]
 800ab26: f8d3 3108    	ldr.w	r3, [r3, #0x108]
 800ab2a: 2b00         	cmp	r3, #0x0
 800ab2c: d002         	beq	0x800ab34 <uart_stm32_async_tx+0x40> @ imm = #0x4
; 		return -EBUSY;
 800ab2e: f06f 030f    	mvn	r3, #0xf
 800ab32: e0a4         	b	0x800ac7e <uart_stm32_async_tx+0x18a> @ imm = #0x148
; 	data->dma_tx.buffer = (uint8_t *)tx_data;
 800ab34: 6afb         	ldr	r3, [r7, #0x2c]
 800ab36: 68ba         	ldr	r2, [r7, #0x8]
 800ab38: f8c3 2104    	str.w	r2, [r3, #0x104]
; 	data->dma_tx.buffer_length = buf_size;
 800ab3c: 6afb         	ldr	r3, [r7, #0x2c]
 800ab3e: 687a         	ldr	r2, [r7, #0x4]
 800ab40: f8c3 2108    	str.w	r2, [r3, #0x108]
; 	data->dma_tx.timeout = timeout;
 800ab44: 6afb         	ldr	r3, [r7, #0x2c]
 800ab46: 683a         	ldr	r2, [r7]
 800ab48: f8c3 2114    	str.w	r2, [r3, #0x114]
; 	LOG_DBG("tx: l=%d", data->dma_tx.buffer_length);
 800ab4c: 2303         	movs	r3, #0x3
 800ab4e: 2b03         	cmp	r3, #0x3
 800ab50: d91e         	bls	0x800ab90 <uart_stm32_async_tx+0x9c> @ imm = #0x3c
 800ab52: 2301         	movs	r3, #0x1
 800ab54: f887 302b    	strb.w	r3, [r7, #0x2b]
 800ab58: f897 302b    	ldrb.w	r3, [r7, #0x2b]
 800ab5c: f083 0301    	eor	r3, r3, #0x1
 800ab60: b2db         	uxtb	r3, r3
 800ab62: 2b00         	cmp	r3, #0x0
 800ab64: d114         	bne	0x800ab90 <uart_stm32_async_tx+0x9c> @ imm = #0x28
 800ab66: 4b48         	ldr	r3, [pc, #0x120]        @ 0x800ac88 <uart_stm32_async_tx+0x194>
 800ab68: 6819         	ldr	r1, [r3]
 800ab6a: 6afb         	ldr	r3, [r7, #0x2c]
 800ab6c: f8d3 3108    	ldr.w	r3, [r3, #0x108]
 800ab70: 9304         	str	r3, [sp, #0x10]
 800ab72: 4b46         	ldr	r3, [pc, #0x118]        @ 0x800ac8c <uart_stm32_async_tx+0x198>
 800ab74: 9303         	str	r3, [sp, #0xc]
 800ab76: 4b46         	ldr	r3, [pc, #0x118]        @ 0x800ac90 <uart_stm32_async_tx+0x19c>
 800ab78: 9302         	str	r3, [sp, #0x8]
 800ab7a: 2308         	movs	r3, #0x8
 800ab7c: 9301         	str	r3, [sp, #0x4]
 800ab7e: 2300         	movs	r3, #0x0
 800ab80: 9300         	str	r3, [sp]
 800ab82: 2300         	movs	r3, #0x0
 800ab84: 2204         	movs	r2, #0x4
 800ab86: 2000         	movs	r0, #0x0
 800ab88: f00f fa12    	bl	0x8019fb0 <z_log_msg_runtime_create> @ imm = #0xf424
 800ab8c: 2300         	movs	r3, #0x0
 800ab8e: 627b         	str	r3, [r7, #0x24]
; 	LL_USART_ClearFlag_TC(usart);
 800ab90: 6b38         	ldr	r0, [r7, #0x30]
 800ab92: f00e ffb3    	bl	0x8019afc <LL_USART_ClearFlag_TC> @ imm = #0xef66
; 	LL_USART_EnableIT_TC(usart);
 800ab96: 6b38         	ldr	r0, [r7, #0x30]
 800ab98: f00f f81b    	bl	0x8019bd2 <LL_USART_EnableIT_TC> @ imm = #0xf036
; 	data->dma_tx.blk_cfg.source_address = (uint32_t)data->dma_tx.buffer;
 800ab9c: 6afb         	ldr	r3, [r7, #0x2c]
 800ab9e: f8d3 3104    	ldr.w	r3, [r3, #0x104]
 800aba2: 461a         	mov	r2, r3
 800aba4: 6afb         	ldr	r3, [r7, #0x2c]
 800aba6: f8c3 20e4    	str.w	r2, [r3, #0xe4]
; 	data->dma_tx.blk_cfg.block_size = data->dma_tx.buffer_length;
 800abaa: 6afb         	ldr	r3, [r7, #0x2c]
 800abac: f8d3 2108    	ldr.w	r2, [r3, #0x108]
 800abb0: 6afb         	ldr	r3, [r7, #0x2c]
 800abb2: f8c3 20f8    	str.w	r2, [r3, #0xf8]
; 	ret = dma_config(data->dma_tx.dma_dev, data->dma_tx.dma_channel,
 800abb6: 6afb         	ldr	r3, [r7, #0x2c]
 800abb8: f8d3 00b8    	ldr.w	r0, [r3, #0xb8]
 800abbc: 6afb         	ldr	r3, [r7, #0x2c]
 800abbe: f8d3 10bc    	ldr.w	r1, [r3, #0xbc]
 800abc2: 6afb         	ldr	r3, [r7, #0x2c]
 800abc4: 33c0         	adds	r3, #0xc0
 800abc6: 461a         	mov	r2, r3
 800abc8: f00e fcab    	bl	0x8019522 <dma_config>  @ imm = #0xe956
 800abcc: 6238         	str	r0, [r7, #0x20]
; 	if (ret != 0) {
 800abce: 6a3b         	ldr	r3, [r7, #0x20]
 800abd0: 2b00         	cmp	r3, #0x0
 800abd2: d01c         	beq	0x800ac0e <uart_stm32_async_tx+0x11a> @ imm = #0x38
; 		LOG_ERR("dma tx config error!");
 800abd4: 2303         	movs	r3, #0x3
 800abd6: 2b00         	cmp	r3, #0x0
 800abd8: d016         	beq	0x800ac08 <uart_stm32_async_tx+0x114> @ imm = #0x2c
 800abda: 2301         	movs	r3, #0x1
 800abdc: 75fb         	strb	r3, [r7, #0x17]
 800abde: 7dfb         	ldrb	r3, [r7, #0x17]
 800abe0: f083 0301    	eor	r3, r3, #0x1
 800abe4: b2db         	uxtb	r3, r3
 800abe6: 2b00         	cmp	r3, #0x0
 800abe8: d10e         	bne	0x800ac08 <uart_stm32_async_tx+0x114> @ imm = #0x1c
 800abea: 4b27         	ldr	r3, [pc, #0x9c]         @ 0x800ac88 <uart_stm32_async_tx+0x194>
 800abec: 6819         	ldr	r1, [r3]
 800abee: 4b29         	ldr	r3, [pc, #0xa4]         @ 0x800ac94 <uart_stm32_async_tx+0x1a0>
 800abf0: 9302         	str	r3, [sp, #0x8]
 800abf2: 2300         	movs	r3, #0x0
 800abf4: 9301         	str	r3, [sp, #0x4]
 800abf6: 2300         	movs	r3, #0x0
 800abf8: 9300         	str	r3, [sp]
 800abfa: 2300         	movs	r3, #0x0
 800abfc: 2201         	movs	r2, #0x1
 800abfe: 2000         	movs	r0, #0x0
 800ac00: f00f f9d6    	bl	0x8019fb0 <z_log_msg_runtime_create> @ imm = #0xf3ac
 800ac04: 2300         	movs	r3, #0x0
 800ac06: 613b         	str	r3, [r7, #0x10]
; 		return -EINVAL;
 800ac08: f06f 0315    	mvn	r3, #0x15
 800ac0c: e037         	b	0x800ac7e <uart_stm32_async_tx+0x18a> @ imm = #0x6e
; 	if (dma_start(data->dma_tx.dma_dev, data->dma_tx.dma_channel)) {
 800ac0e: 6afb         	ldr	r3, [r7, #0x2c]
 800ac10: f8d3 20b8    	ldr.w	r2, [r3, #0xb8]
 800ac14: 6afb         	ldr	r3, [r7, #0x2c]
 800ac16: f8d3 30bc    	ldr.w	r3, [r3, #0xbc]
 800ac1a: 4619         	mov	r1, r3
 800ac1c: 4610         	mov	r0, r2
 800ac1e: f00e fcf2    	bl	0x8019606 <dma_start>   @ imm = #0xe9e4
 800ac22: 4603         	mov	r3, r0
 800ac24: 2b00         	cmp	r3, #0x0
 800ac26: d01c         	beq	0x800ac62 <uart_stm32_async_tx+0x16e> @ imm = #0x38
; 		LOG_ERR("UART err: TX DMA start failed!");
 800ac28: 2303         	movs	r3, #0x3
 800ac2a: 2b00         	cmp	r3, #0x0
 800ac2c: d016         	beq	0x800ac5c <uart_stm32_async_tx+0x168> @ imm = #0x2c
 800ac2e: 2301         	movs	r3, #0x1
 800ac30: 77fb         	strb	r3, [r7, #0x1f]
 800ac32: 7ffb         	ldrb	r3, [r7, #0x1f]
 800ac34: f083 0301    	eor	r3, r3, #0x1
 800ac38: b2db         	uxtb	r3, r3
 800ac3a: 2b00         	cmp	r3, #0x0
 800ac3c: d10e         	bne	0x800ac5c <uart_stm32_async_tx+0x168> @ imm = #0x1c
 800ac3e: 4b12         	ldr	r3, [pc, #0x48]         @ 0x800ac88 <uart_stm32_async_tx+0x194>
 800ac40: 6819         	ldr	r1, [r3]
 800ac42: 4b15         	ldr	r3, [pc, #0x54]         @ 0x800ac98 <uart_stm32_async_tx+0x1a4>
 800ac44: 9302         	str	r3, [sp, #0x8]
 800ac46: 2300         	movs	r3, #0x0
 800ac48: 9301         	str	r3, [sp, #0x4]
 800ac4a: 2300         	movs	r3, #0x0
 800ac4c: 9300         	str	r3, [sp]
 800ac4e: 2300         	movs	r3, #0x0
 800ac50: 2201         	movs	r2, #0x1
 800ac52: 2000         	movs	r0, #0x0
 800ac54: f00f f9ac    	bl	0x8019fb0 <z_log_msg_runtime_create> @ imm = #0xf358
 800ac58: 2300         	movs	r3, #0x0
 800ac5a: 61bb         	str	r3, [r7, #0x18]
; 		return -EFAULT;
 800ac5c: f06f 030d    	mvn	r3, #0xd
 800ac60: e00d         	b	0x800ac7e <uart_stm32_async_tx+0x18a> @ imm = #0x1a
; 	async_timer_start(&data->dma_tx.timeout_work, data->dma_tx.timeout);
 800ac62: 6afb         	ldr	r3, [r7, #0x2c]
 800ac64: f503 728c    	add.w	r2, r3, #0x118
 800ac68: 6afb         	ldr	r3, [r7, #0x2c]
 800ac6a: f8d3 3114    	ldr.w	r3, [r3, #0x114]
 800ac6e: 4619         	mov	r1, r3
 800ac70: 4610         	mov	r0, r2
 800ac72: f7ff fd63    	bl	0x800a73c <async_timer_start> @ imm = #-0x53a
; 	uart_stm32_dma_tx_enable(dev);
 800ac76: 68f8         	ldr	r0, [r7, #0xc]
 800ac78: f00f fec9    	bl	0x801aa0e <uart_stm32_dma_tx_enable> @ imm = #0xfd92
; 	return 0;
 800ac7c: 2300         	movs	r3, #0x0
; }
 800ac7e: 4618         	mov	r0, r3
 800ac80: 3738         	adds	r7, #0x38
 800ac82: 46bd         	mov	sp, r7
 800ac84: bd80         	pop	{r7, pc}
 800ac86: bf00         	nop

0800ac88 <$d>:
 800ac88: 18 05 00 20  	.word	0x20000518
 800ac8c: 7c 05 02 08  	.word	0x0802057c
 800ac90: 8c f4 01 08  	.word	0x0801f48c
 800ac94: 9c f4 01 08  	.word	0x0801f49c
 800ac98: b4 f4 01 08  	.word	0x0801f4b4

0800ac9c <uart_stm32_async_rx_enable>:
; {
 800ac9c: b580         	push	{r7, lr}
 800ac9e: b094         	sub	sp, #0x50
 800aca0: af04         	add	r7, sp, #0x10
 800aca2: 60f8         	str	r0, [r7, #0xc]
 800aca4: 60b9         	str	r1, [r7, #0x8]
 800aca6: 607a         	str	r2, [r7, #0x4]
 800aca8: 603b         	str	r3, [r7]
; 	const struct uart_stm32_config *config = dev->config;
 800acaa: 68fb         	ldr	r3, [r7, #0xc]
 800acac: 685b         	ldr	r3, [r3, #0x4]
 800acae: 63fb         	str	r3, [r7, #0x3c]
; 	USART_TypeDef *usart = config->usart;
 800acb0: 6bfb         	ldr	r3, [r7, #0x3c]
 800acb2: 681b         	ldr	r3, [r3]
 800acb4: 63bb         	str	r3, [r7, #0x38]
; 	struct uart_stm32_data *data = dev->data;
 800acb6: 68fb         	ldr	r3, [r7, #0xc]
 800acb8: 691b         	ldr	r3, [r3, #0x10]
 800acba: 637b         	str	r3, [r7, #0x34]
; 	if (data->dma_rx.dma_dev == NULL) {
 800acbc: 6b7b         	ldr	r3, [r7, #0x34]
 800acbe: 6a1b         	ldr	r3, [r3, #0x20]
 800acc0: 2b00         	cmp	r3, #0x0
 800acc2: d102         	bne	0x800acca <uart_stm32_async_rx_enable+0x2e> @ imm = #0x4
; 		return -ENODEV;
 800acc4: f06f 0312    	mvn	r3, #0x12
 800acc8: e0c0         	b	0x800ae4c <uart_stm32_async_rx_enable+0x1b0> @ imm = #0x180
; 	if (data->dma_rx.enabled) {
 800acca: 6b7b         	ldr	r3, [r7, #0x34]
 800accc: f893 30b0    	ldrb.w	r3, [r3, #0xb0]
 800acd0: 2b00         	cmp	r3, #0x0
 800acd2: d01c         	beq	0x800ad0e <uart_stm32_async_rx_enable+0x72> @ imm = #0x38
; 		LOG_WRN("RX was already enabled");
 800acd4: 2303         	movs	r3, #0x3
 800acd6: 2b01         	cmp	r3, #0x1
 800acd8: d916         	bls	0x800ad08 <uart_stm32_async_rx_enable+0x6c> @ imm = #0x2c
 800acda: 2301         	movs	r3, #0x1
 800acdc: 75fb         	strb	r3, [r7, #0x17]
 800acde: 7dfb         	ldrb	r3, [r7, #0x17]
 800ace0: f083 0301    	eor	r3, r3, #0x1
 800ace4: b2db         	uxtb	r3, r3
 800ace6: 2b00         	cmp	r3, #0x0
 800ace8: d10e         	bne	0x800ad08 <uart_stm32_async_rx_enable+0x6c> @ imm = #0x1c
 800acea: 4b5a         	ldr	r3, [pc, #0x168]        @ 0x800ae54 <uart_stm32_async_rx_enable+0x1b8>
 800acec: 6819         	ldr	r1, [r3]
 800acee: 4b5a         	ldr	r3, [pc, #0x168]        @ 0x800ae58 <uart_stm32_async_rx_enable+0x1bc>
 800acf0: 9302         	str	r3, [sp, #0x8]
 800acf2: 2300         	movs	r3, #0x0
 800acf4: 9301         	str	r3, [sp, #0x4]
 800acf6: 2300         	movs	r3, #0x0
 800acf8: 9300         	str	r3, [sp]
 800acfa: 2300         	movs	r3, #0x0
 800acfc: 2202         	movs	r2, #0x2
 800acfe: 2000         	movs	r0, #0x0
 800ad00: f00f f956    	bl	0x8019fb0 <z_log_msg_runtime_create> @ imm = #0xf2ac
 800ad04: 2300         	movs	r3, #0x0
 800ad06: 613b         	str	r3, [r7, #0x10]
; 		return -EBUSY;
 800ad08: f06f 030f    	mvn	r3, #0xf
 800ad0c: e09e         	b	0x800ae4c <uart_stm32_async_rx_enable+0x1b0> @ imm = #0x13c
; 	data->dma_rx.offset = 0;
 800ad0e: 6b7b         	ldr	r3, [r7, #0x34]
 800ad10: 2200         	movs	r2, #0x0
 800ad12: 675a         	str	r2, [r3, #0x74]
; 	data->dma_rx.buffer = rx_buf;
 800ad14: 6b7b         	ldr	r3, [r7, #0x34]
 800ad16: 68ba         	ldr	r2, [r7, #0x8]
 800ad18: 66da         	str	r2, [r3, #0x6c]
; 	data->dma_rx.buffer_length = buf_size;
 800ad1a: 6b7b         	ldr	r3, [r7, #0x34]
 800ad1c: 687a         	ldr	r2, [r7, #0x4]
 800ad1e: 671a         	str	r2, [r3, #0x70]
; 	data->dma_rx.counter = 0;
 800ad20: 6b7b         	ldr	r3, [r7, #0x34]
 800ad22: 2200         	movs	r2, #0x0
 800ad24: 679a         	str	r2, [r3, #0x78]
; 	data->dma_rx.timeout = timeout;
 800ad26: 6b7b         	ldr	r3, [r7, #0x34]
 800ad28: 683a         	ldr	r2, [r7]
 800ad2a: 67da         	str	r2, [r3, #0x7c]
; 	LL_USART_DisableIT_RXNE(usart);
 800ad2c: 6bb8         	ldr	r0, [r7, #0x38]
 800ad2e: f00e ffe7    	bl	0x8019d00 <LL_USART_DisableIT_RXNE> @ imm = #0xefce
; 	data->dma_rx.blk_cfg.block_size = buf_size;
 800ad32: 6b7b         	ldr	r3, [r7, #0x34]
 800ad34: 687a         	ldr	r2, [r7, #0x4]
 800ad36: 661a         	str	r2, [r3, #0x60]
; 	data->dma_rx.blk_cfg.dest_address = (uint32_t)data->dma_rx.buffer;
 800ad38: 6b7b         	ldr	r3, [r7, #0x34]
 800ad3a: 6edb         	ldr	r3, [r3, #0x6c]
 800ad3c: 461a         	mov	r2, r3
 800ad3e: 6b7b         	ldr	r3, [r7, #0x34]
 800ad40: 651a         	str	r2, [r3, #0x50]
; 	ret = dma_config(data->dma_rx.dma_dev, data->dma_rx.dma_channel,
 800ad42: 6b7b         	ldr	r3, [r7, #0x34]
 800ad44: 6a18         	ldr	r0, [r3, #0x20]
 800ad46: 6b7b         	ldr	r3, [r7, #0x34]
 800ad48: 6a59         	ldr	r1, [r3, #0x24]
 800ad4a: 6b7b         	ldr	r3, [r7, #0x34]
 800ad4c: 3328         	adds	r3, #0x28
 800ad4e: 461a         	mov	r2, r3
 800ad50: f00e fbe7    	bl	0x8019522 <dma_config>  @ imm = #0xe7ce
 800ad54: 6338         	str	r0, [r7, #0x30]
; 	if (ret != 0) {
 800ad56: 6b3b         	ldr	r3, [r7, #0x30]
 800ad58: 2b00         	cmp	r3, #0x0
 800ad5a: d01c         	beq	0x800ad96 <uart_stm32_async_rx_enable+0xfa> @ imm = #0x38
; 		LOG_ERR("UART ERR: RX DMA config failed!");
 800ad5c: 2303         	movs	r3, #0x3
 800ad5e: 2b00         	cmp	r3, #0x0
 800ad60: d016         	beq	0x800ad90 <uart_stm32_async_rx_enable+0xf4> @ imm = #0x2c
 800ad62: 2301         	movs	r3, #0x1
 800ad64: 77fb         	strb	r3, [r7, #0x1f]
 800ad66: 7ffb         	ldrb	r3, [r7, #0x1f]
 800ad68: f083 0301    	eor	r3, r3, #0x1
 800ad6c: b2db         	uxtb	r3, r3
 800ad6e: 2b00         	cmp	r3, #0x0
 800ad70: d10e         	bne	0x800ad90 <uart_stm32_async_rx_enable+0xf4> @ imm = #0x1c
 800ad72: 4b38         	ldr	r3, [pc, #0xe0]         @ 0x800ae54 <uart_stm32_async_rx_enable+0x1b8>
 800ad74: 6819         	ldr	r1, [r3]
 800ad76: 4b39         	ldr	r3, [pc, #0xe4]         @ 0x800ae5c <uart_stm32_async_rx_enable+0x1c0>
 800ad78: 9302         	str	r3, [sp, #0x8]
 800ad7a: 2300         	movs	r3, #0x0
 800ad7c: 9301         	str	r3, [sp, #0x4]
 800ad7e: 2300         	movs	r3, #0x0
 800ad80: 9300         	str	r3, [sp]
 800ad82: 2300         	movs	r3, #0x0
 800ad84: 2201         	movs	r2, #0x1
 800ad86: 2000         	movs	r0, #0x0
 800ad88: f00f f912    	bl	0x8019fb0 <z_log_msg_runtime_create> @ imm = #0xf224
 800ad8c: 2300         	movs	r3, #0x0
 800ad8e: 61bb         	str	r3, [r7, #0x18]
; 		return -EINVAL;
 800ad90: f06f 0315    	mvn	r3, #0x15
 800ad94: e05a         	b	0x800ae4c <uart_stm32_async_rx_enable+0x1b0> @ imm = #0xb4
; 	if (dma_start(data->dma_rx.dma_dev, data->dma_rx.dma_channel)) {
 800ad96: 6b7b         	ldr	r3, [r7, #0x34]
 800ad98: 6a1a         	ldr	r2, [r3, #0x20]
 800ad9a: 6b7b         	ldr	r3, [r7, #0x34]
 800ad9c: 6a5b         	ldr	r3, [r3, #0x24]
 800ad9e: 4619         	mov	r1, r3
 800ada0: 4610         	mov	r0, r2
 800ada2: f00e fc30    	bl	0x8019606 <dma_start>   @ imm = #0xe860
 800ada6: 4603         	mov	r3, r0
 800ada8: 2b00         	cmp	r3, #0x0
 800adaa: d01e         	beq	0x800adea <uart_stm32_async_rx_enable+0x14e> @ imm = #0x3c
; 		LOG_ERR("UART ERR: RX DMA start failed!");
 800adac: 2303         	movs	r3, #0x3
 800adae: 2b00         	cmp	r3, #0x0
 800adb0: d018         	beq	0x800ade4 <uart_stm32_async_rx_enable+0x148> @ imm = #0x30
 800adb2: 2301         	movs	r3, #0x1
 800adb4: f887 3027    	strb.w	r3, [r7, #0x27]
 800adb8: f897 3027    	ldrb.w	r3, [r7, #0x27]
 800adbc: f083 0301    	eor	r3, r3, #0x1
 800adc0: b2db         	uxtb	r3, r3
 800adc2: 2b00         	cmp	r3, #0x0
 800adc4: d10e         	bne	0x800ade4 <uart_stm32_async_rx_enable+0x148> @ imm = #0x1c
 800adc6: 4b23         	ldr	r3, [pc, #0x8c]         @ 0x800ae54 <uart_stm32_async_rx_enable+0x1b8>
 800adc8: 6819         	ldr	r1, [r3]
 800adca: 4b25         	ldr	r3, [pc, #0x94]         @ 0x800ae60 <uart_stm32_async_rx_enable+0x1c4>
 800adcc: 9302         	str	r3, [sp, #0x8]
 800adce: 2300         	movs	r3, #0x0
 800add0: 9301         	str	r3, [sp, #0x4]
 800add2: 2300         	movs	r3, #0x0
 800add4: 9300         	str	r3, [sp]
 800add6: 2300         	movs	r3, #0x0
 800add8: 2201         	movs	r2, #0x1
 800adda: 2000         	movs	r0, #0x0
 800addc: f00f f8e8    	bl	0x8019fb0 <z_log_msg_runtime_create> @ imm = #0xf1d0
 800ade0: 2300         	movs	r3, #0x0
 800ade2: 623b         	str	r3, [r7, #0x20]
; 		return -EFAULT;
 800ade4: f06f 030d    	mvn	r3, #0xd
 800ade8: e030         	b	0x800ae4c <uart_stm32_async_rx_enable+0x1b0> @ imm = #0x60
; 	LL_USART_ClearFlag_RXNE(usart);
 800adea: 6bb8         	ldr	r0, [r7, #0x38]
 800adec: f00e fe93    	bl	0x8019b16 <LL_USART_ClearFlag_RXNE> @ imm = #0xed26
; 	uart_stm32_dma_rx_enable(dev);
 800adf0: 68f8         	ldr	r0, [r7, #0xc]
 800adf2: f00f fe2c    	bl	0x801aa4e <uart_stm32_dma_rx_enable> @ imm = #0xfc58
; 	LL_USART_ClearFlag_IDLE(usart);
 800adf6: 6bb8         	ldr	r0, [r7, #0x38]
 800adf8: f00e fe6f    	bl	0x8019ada <LL_USART_ClearFlag_IDLE> @ imm = #0xecde
; 	LL_USART_EnableIT_IDLE(usart);
 800adfc: 6bb8         	ldr	r0, [r7, #0x38]
 800adfe: f00e fea4    	bl	0x8019b4a <LL_USART_EnableIT_IDLE> @ imm = #0xed48
; 	LL_USART_EnableIT_ERROR(usart);
 800ae02: 6bb8         	ldr	r0, [r7, #0x38]
 800ae04: f00e ff38    	bl	0x8019c78 <LL_USART_EnableIT_ERROR> @ imm = #0xee70
; 	async_evt_rx_buf_request(data);
 800ae08: 6b78         	ldr	r0, [r7, #0x34]
 800ae0a: f00f fd8b    	bl	0x801a924 <async_evt_rx_buf_request> @ imm = #0xfb16
; 	LOG_DBG("async rx enabled");
 800ae0e: 2303         	movs	r3, #0x3
 800ae10: 2b03         	cmp	r3, #0x3
 800ae12: d91a         	bls	0x800ae4a <uart_stm32_async_rx_enable+0x1ae> @ imm = #0x34
 800ae14: 2301         	movs	r3, #0x1
 800ae16: f887 302f    	strb.w	r3, [r7, #0x2f]
 800ae1a: f897 302f    	ldrb.w	r3, [r7, #0x2f]
 800ae1e: f083 0301    	eor	r3, r3, #0x1
 800ae22: b2db         	uxtb	r3, r3
 800ae24: 2b00         	cmp	r3, #0x0
 800ae26: d110         	bne	0x800ae4a <uart_stm32_async_rx_enable+0x1ae> @ imm = #0x20
 800ae28: 4b0a         	ldr	r3, [pc, #0x28]         @ 0x800ae54 <uart_stm32_async_rx_enable+0x1b8>
 800ae2a: 6819         	ldr	r1, [r3]
 800ae2c: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x800ae64 <uart_stm32_async_rx_enable+0x1c8>
 800ae2e: 9303         	str	r3, [sp, #0xc]
 800ae30: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x800ae68 <uart_stm32_async_rx_enable+0x1cc>
 800ae32: 9302         	str	r3, [sp, #0x8]
 800ae34: 2308         	movs	r3, #0x8
 800ae36: 9301         	str	r3, [sp, #0x4]
 800ae38: 2300         	movs	r3, #0x0
 800ae3a: 9300         	str	r3, [sp]
 800ae3c: 2300         	movs	r3, #0x0
 800ae3e: 2204         	movs	r2, #0x4
 800ae40: 2000         	movs	r0, #0x0
 800ae42: f00f f8b5    	bl	0x8019fb0 <z_log_msg_runtime_create> @ imm = #0xf16a
 800ae46: 2300         	movs	r3, #0x0
 800ae48: 62bb         	str	r3, [r7, #0x28]
; 	return ret;
 800ae4a: 6b3b         	ldr	r3, [r7, #0x30]
; }
 800ae4c: 4618         	mov	r0, r3
 800ae4e: 3740         	adds	r7, #0x40
 800ae50: 46bd         	mov	sp, r7
 800ae52: bd80         	pop	{r7, pc}

0800ae54 <$d>:
 800ae54: 18 05 00 20  	.word	0x20000518
 800ae58: d4 f4 01 08  	.word	0x0801f4d4
 800ae5c: ec f4 01 08  	.word	0x0801f4ec
 800ae60: 0c f5 01 08  	.word	0x0801f50c
 800ae64: 90 05 02 08  	.word	0x08020590
 800ae68: 2c f5 01 08  	.word	0x0801f52c

0800ae6c <uart_stm32_async_rx_timeout>:
; {
 800ae6c: b580         	push	{r7, lr}
 800ae6e: b08c         	sub	sp, #0x30
 800ae70: af04         	add	r7, sp, #0x10
 800ae72: 6078         	str	r0, [r7, #0x4]
; 	struct k_work_delayable *dwork = k_work_delayable_from_work(work);
 800ae74: 6878         	ldr	r0, [r7, #0x4]
 800ae76: f00e fb1d    	bl	0x80194b4 <k_work_delayable_from_work> @ imm = #0xe63a
 800ae7a: 61f8         	str	r0, [r7, #0x1c]
; 	struct uart_dma_stream *rx_stream = CONTAINER_OF(dwork,
 800ae7c: 69fb         	ldr	r3, [r7, #0x1c]
 800ae7e: 3b60         	subs	r3, #0x60
 800ae80: 61bb         	str	r3, [r7, #0x18]
; 	struct uart_stm32_data *data = CONTAINER_OF(rx_stream,
 800ae82: 69bb         	ldr	r3, [r7, #0x18]
 800ae84: 3b20         	subs	r3, #0x20
 800ae86: 617b         	str	r3, [r7, #0x14]
; 	const struct device *dev = data->uart_dev;
 800ae88: 697b         	ldr	r3, [r7, #0x14]
 800ae8a: 691b         	ldr	r3, [r3, #0x10]
 800ae8c: 613b         	str	r3, [r7, #0x10]
; 	LOG_DBG("rx timeout");
 800ae8e: 2303         	movs	r3, #0x3
 800ae90: 2b03         	cmp	r3, #0x3
 800ae92: d918         	bls	0x800aec6 <uart_stm32_async_rx_timeout+0x5a> @ imm = #0x30
 800ae94: 2301         	movs	r3, #0x1
 800ae96: 73fb         	strb	r3, [r7, #0xf]
 800ae98: 7bfb         	ldrb	r3, [r7, #0xf]
 800ae9a: f083 0301    	eor	r3, r3, #0x1
 800ae9e: b2db         	uxtb	r3, r3
 800aea0: 2b00         	cmp	r3, #0x0
 800aea2: d110         	bne	0x800aec6 <uart_stm32_async_rx_timeout+0x5a> @ imm = #0x20
 800aea4: 4b10         	ldr	r3, [pc, #0x40]         @ 0x800aee8 <uart_stm32_async_rx_timeout+0x7c>
 800aea6: 6819         	ldr	r1, [r3]
 800aea8: 4b10         	ldr	r3, [pc, #0x40]         @ 0x800aeec <uart_stm32_async_rx_timeout+0x80>
 800aeaa: 9303         	str	r3, [sp, #0xc]
 800aeac: 4b10         	ldr	r3, [pc, #0x40]         @ 0x800aef0 <uart_stm32_async_rx_timeout+0x84>
 800aeae: 9302         	str	r3, [sp, #0x8]
 800aeb0: 2308         	movs	r3, #0x8
 800aeb2: 9301         	str	r3, [sp, #0x4]
 800aeb4: 2300         	movs	r3, #0x0
 800aeb6: 9300         	str	r3, [sp]
 800aeb8: 2300         	movs	r3, #0x0
 800aeba: 2204         	movs	r2, #0x4
 800aebc: 2000         	movs	r0, #0x0
 800aebe: f00f f877    	bl	0x8019fb0 <z_log_msg_runtime_create> @ imm = #0xf0ee
 800aec2: 2300         	movs	r3, #0x0
 800aec4: 60bb         	str	r3, [r7, #0x8]
; 	if (data->dma_rx.counter == data->dma_rx.buffer_length) {
 800aec6: 697b         	ldr	r3, [r7, #0x14]
 800aec8: 6f9a         	ldr	r2, [r3, #0x78]
 800aeca: 697b         	ldr	r3, [r7, #0x14]
 800aecc: 6f1b         	ldr	r3, [r3, #0x70]
 800aece: 429a         	cmp	r2, r3
 800aed0: d103         	bne	0x800aeda <uart_stm32_async_rx_timeout+0x6e> @ imm = #0x6
; 		uart_stm32_async_rx_disable(dev);
 800aed2: 6938         	ldr	r0, [r7, #0x10]
 800aed4: f7ff fd04    	bl	0x800a8e0 <uart_stm32_async_rx_disable> @ imm = #-0x5f8
; }
 800aed8: e002         	b	0x800aee0 <uart_stm32_async_rx_timeout+0x74> @ imm = #0x4
; 		uart_stm32_dma_rx_flush(dev);
 800aeda: 6938         	ldr	r0, [r7, #0x10]
 800aedc: f00f fd55    	bl	0x801a98a <uart_stm32_dma_rx_flush> @ imm = #0xfaaa
; }
 800aee0: bf00         	nop
 800aee2: 3720         	adds	r7, #0x20
 800aee4: 46bd         	mov	sp, r7
 800aee6: bd80         	pop	{r7, pc}

0800aee8 <$d>:
 800aee8: 18 05 00 20  	.word	0x20000518
 800aeec: c0 05 02 08  	.word	0x080205c0
 800aef0: 44 f5 01 08  	.word	0x0801f544

0800aef4 <uart_stm32_async_tx_timeout>:
; {
 800aef4: b580         	push	{r7, lr}
 800aef6: b08c         	sub	sp, #0x30
 800aef8: af04         	add	r7, sp, #0x10
 800aefa: 6078         	str	r0, [r7, #0x4]
; 	struct k_work_delayable *dwork = k_work_delayable_from_work(work);
 800aefc: 6878         	ldr	r0, [r7, #0x4]
 800aefe: f00e fad9    	bl	0x80194b4 <k_work_delayable_from_work> @ imm = #0xe5b2
 800af02: 61f8         	str	r0, [r7, #0x1c]
; 	struct uart_dma_stream *tx_stream = CONTAINER_OF(dwork,
 800af04: 69fb         	ldr	r3, [r7, #0x1c]
 800af06: 3b60         	subs	r3, #0x60
 800af08: 61bb         	str	r3, [r7, #0x18]
; 	struct uart_stm32_data *data = CONTAINER_OF(tx_stream,
 800af0a: 69bb         	ldr	r3, [r7, #0x18]
 800af0c: 3bb8         	subs	r3, #0xb8
 800af0e: 617b         	str	r3, [r7, #0x14]
; 	const struct device *dev = data->uart_dev;
 800af10: 697b         	ldr	r3, [r7, #0x14]
 800af12: 691b         	ldr	r3, [r3, #0x10]
 800af14: 613b         	str	r3, [r7, #0x10]
; 	uart_stm32_async_tx_abort(dev);
 800af16: 6938         	ldr	r0, [r7, #0x10]
 800af18: f00f fe48    	bl	0x801abac <uart_stm32_async_tx_abort> @ imm = #0xfc90
; 	LOG_DBG("tx: async timeout");
 800af1c: 2303         	movs	r3, #0x3
 800af1e: 2b03         	cmp	r3, #0x3
 800af20: d919         	bls	0x800af56 <uart_stm32_async_tx_timeout+0x62> @ imm = #0x32
 800af22: 2301         	movs	r3, #0x1
 800af24: 73fb         	strb	r3, [r7, #0xf]
 800af26: 7bfb         	ldrb	r3, [r7, #0xf]
 800af28: f083 0301    	eor	r3, r3, #0x1
 800af2c: b2db         	uxtb	r3, r3
 800af2e: 2b00         	cmp	r3, #0x0
 800af30: d111         	bne	0x800af56 <uart_stm32_async_tx_timeout+0x62> @ imm = #0x22
 800af32: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x800af60 <uart_stm32_async_tx_timeout+0x6c>
 800af34: 6819         	ldr	r1, [r3]
 800af36: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x800af64 <uart_stm32_async_tx_timeout+0x70>
 800af38: 9303         	str	r3, [sp, #0xc]
 800af3a: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x800af68 <uart_stm32_async_tx_timeout+0x74>
 800af3c: 9302         	str	r3, [sp, #0x8]
 800af3e: 2308         	movs	r3, #0x8
 800af40: 9301         	str	r3, [sp, #0x4]
 800af42: 2300         	movs	r3, #0x0
 800af44: 9300         	str	r3, [sp]
 800af46: 2300         	movs	r3, #0x0
 800af48: 2204         	movs	r2, #0x4
 800af4a: 2000         	movs	r0, #0x0
 800af4c: f00f f830    	bl	0x8019fb0 <z_log_msg_runtime_create> @ imm = #0xf060
 800af50: 2300         	movs	r3, #0x0
 800af52: 60bb         	str	r3, [r7, #0x8]
; }
 800af54: bf00         	nop
 800af56: bf00         	nop
 800af58: 3720         	adds	r7, #0x20
 800af5a: 46bd         	mov	sp, r7
 800af5c: bd80         	pop	{r7, pc}
 800af5e: bf00         	nop

0800af60 <$d>:
 800af60: 18 05 00 20  	.word	0x20000518
 800af64: dc 05 02 08  	.word	0x080205dc
 800af68: 54 f5 01 08  	.word	0x0801f554

0800af6c <uart_stm32_async_rx_buf_rsp>:
; {
 800af6c: b580         	push	{r7, lr}
 800af6e: b094         	sub	sp, #0x50
 800af70: af06         	add	r7, sp, #0x18
 800af72: 60f8         	str	r0, [r7, #0xc]
 800af74: 60b9         	str	r1, [r7, #0x8]
 800af76: 607a         	str	r2, [r7, #0x4]
; 	struct uart_stm32_data *data = dev->data;
 800af78: 68fb         	ldr	r3, [r7, #0xc]
 800af7a: 691b         	ldr	r3, [r3, #0x10]
 800af7c: 633b         	str	r3, [r7, #0x30]
; 	int err = 0;
 800af7e: 2300         	movs	r3, #0x0
 800af80: 637b         	str	r3, [r7, #0x34]
; 	LOG_DBG("replace buffer (%d)", len);
 800af82: 2303         	movs	r3, #0x3
 800af84: 2b03         	cmp	r3, #0x3
 800af86: d91c         	bls	0x800afc2 <uart_stm32_async_rx_buf_rsp+0x56> @ imm = #0x38
 800af88: 2301         	movs	r3, #0x1
 800af8a: f887 302f    	strb.w	r3, [r7, #0x2f]
 800af8e: f897 302f    	ldrb.w	r3, [r7, #0x2f]
 800af92: f083 0301    	eor	r3, r3, #0x1
 800af96: b2db         	uxtb	r3, r3
 800af98: 2b00         	cmp	r3, #0x0
 800af9a: d112         	bne	0x800afc2 <uart_stm32_async_rx_buf_rsp+0x56> @ imm = #0x24
 800af9c: 4b28         	ldr	r3, [pc, #0xa0]         @ 0x800b040 <uart_stm32_async_rx_buf_rsp+0xd4>
 800af9e: 6819         	ldr	r1, [r3]
 800afa0: 687b         	ldr	r3, [r7, #0x4]
 800afa2: 9304         	str	r3, [sp, #0x10]
 800afa4: 4b27         	ldr	r3, [pc, #0x9c]         @ 0x800b044 <uart_stm32_async_rx_buf_rsp+0xd8>
 800afa6: 9303         	str	r3, [sp, #0xc]
 800afa8: 4b27         	ldr	r3, [pc, #0x9c]         @ 0x800b048 <uart_stm32_async_rx_buf_rsp+0xdc>
 800afaa: 9302         	str	r3, [sp, #0x8]
 800afac: 2308         	movs	r3, #0x8
 800afae: 9301         	str	r3, [sp, #0x4]
 800afb0: 2300         	movs	r3, #0x0
 800afb2: 9300         	str	r3, [sp]
 800afb4: 2300         	movs	r3, #0x0
 800afb6: 2204         	movs	r2, #0x4
 800afb8: 2000         	movs	r0, #0x0
 800afba: f00e fff9    	bl	0x8019fb0 <z_log_msg_runtime_create> @ imm = #0xeff2
 800afbe: 2300         	movs	r3, #0x0
 800afc0: 62bb         	str	r3, [r7, #0x28]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800afc2: f3ef 8311    	mrs	r3, basepri
 800afc6: 623b         	str	r3, [r7, #0x20]
;   return(result);
 800afc8: 6a3b         	ldr	r3, [r7, #0x20]
; 	key = __get_BASEPRI();
 800afca: 61fb         	str	r3, [r7, #0x1c]
 800afcc: 2310         	movs	r3, #0x10
 800afce: 61bb         	str	r3, [r7, #0x18]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 800afd0: 69bb         	ldr	r3, [r7, #0x18]
 800afd2: f383 8812    	msr	basepri_max, r3
; }
 800afd6: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800afd8: f3bf 8f6f    	isb	sy
; }
 800afdc: bf00         	nop
; 	return key;
 800afde: 69fb         	ldr	r3, [r7, #0x1c]
; 	key = irq_lock();
 800afe0: 627b         	str	r3, [r7, #0x24]
; 	if (data->rx_next_buffer != NULL) {
 800afe2: 6b3b         	ldr	r3, [r7, #0x30]
 800afe4: f8d3 3150    	ldr.w	r3, [r3, #0x150]
 800afe8: 2b00         	cmp	r3, #0x0
 800afea: d003         	beq	0x800aff4 <uart_stm32_async_rx_buf_rsp+0x88> @ imm = #0x6
; 		err = -EBUSY;
 800afec: f06f 030f    	mvn	r3, #0xf
 800aff0: 637b         	str	r3, [r7, #0x34]
 800aff2: e013         	b	0x800b01c <uart_stm32_async_rx_buf_rsp+0xb0> @ imm = #0x26
; 	} else if (!data->dma_rx.enabled) {
 800aff4: 6b3b         	ldr	r3, [r7, #0x30]
 800aff6: f893 30b0    	ldrb.w	r3, [r3, #0xb0]
 800affa: f083 0301    	eor	r3, r3, #0x1
 800affe: b2db         	uxtb	r3, r3
 800b000: 2b00         	cmp	r3, #0x0
 800b002: d003         	beq	0x800b00c <uart_stm32_async_rx_buf_rsp+0xa0> @ imm = #0x6
; 		err = -EACCES;
 800b004: f06f 030c    	mvn	r3, #0xc
 800b008: 637b         	str	r3, [r7, #0x34]
 800b00a: e007         	b	0x800b01c <uart_stm32_async_rx_buf_rsp+0xb0> @ imm = #0xe
; 		data->rx_next_buffer = buf;
 800b00c: 6b3b         	ldr	r3, [r7, #0x30]
 800b00e: 68ba         	ldr	r2, [r7, #0x8]
 800b010: f8c3 2150    	str.w	r2, [r3, #0x150]
; 		data->rx_next_buffer_len = len;
 800b014: 6b3b         	ldr	r3, [r7, #0x30]
 800b016: 687a         	ldr	r2, [r7, #0x4]
 800b018: f8c3 2154    	str.w	r2, [r3, #0x154]
 800b01c: 6a7b         	ldr	r3, [r7, #0x24]
 800b01e: 617b         	str	r3, [r7, #0x14]
 800b020: 697b         	ldr	r3, [r7, #0x14]
 800b022: 613b         	str	r3, [r7, #0x10]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800b024: 693b         	ldr	r3, [r7, #0x10]
 800b026: f383 8811    	msr	basepri, r3
; }
 800b02a: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800b02c: f3bf 8f6f    	isb	sy
; }
 800b030: bf00         	nop
; }
 800b032: bf00         	nop
; 	return err;
 800b034: 6b7b         	ldr	r3, [r7, #0x34]
; }
 800b036: 4618         	mov	r0, r3
 800b038: 3738         	adds	r7, #0x38
 800b03a: 46bd         	mov	sp, r7
 800b03c: bd80         	pop	{r7, pc}
 800b03e: bf00         	nop

0800b040 <$d>:
 800b040: 18 05 00 20  	.word	0x20000518
 800b044: f8 05 02 08  	.word	0x080205f8
 800b048: 6c f5 01 08  	.word	0x0801f56c

0800b04c <uart_stm32_async_init>:
; {
 800b04c: b580         	push	{r7, lr}
 800b04e: b086         	sub	sp, #0x18
 800b050: af00         	add	r7, sp, #0x0
 800b052: 6078         	str	r0, [r7, #0x4]
; 	const struct uart_stm32_config *config = dev->config;
 800b054: 687b         	ldr	r3, [r7, #0x4]
 800b056: 685b         	ldr	r3, [r3, #0x4]
 800b058: 617b         	str	r3, [r7, #0x14]
; 	USART_TypeDef *usart = config->usart;
 800b05a: 697b         	ldr	r3, [r7, #0x14]
 800b05c: 681b         	ldr	r3, [r3]
 800b05e: 613b         	str	r3, [r7, #0x10]
; 	struct uart_stm32_data *data = dev->data;
 800b060: 687b         	ldr	r3, [r7, #0x4]
 800b062: 691b         	ldr	r3, [r3, #0x10]
 800b064: 60fb         	str	r3, [r7, #0xc]
; 	data->uart_dev = dev;
 800b066: 68fb         	ldr	r3, [r7, #0xc]
 800b068: 687a         	ldr	r2, [r7, #0x4]
 800b06a: 611a         	str	r2, [r3, #0x10]
; 	if (data->dma_rx.dma_dev != NULL) {
 800b06c: 68fb         	ldr	r3, [r7, #0xc]
 800b06e: 6a1b         	ldr	r3, [r3, #0x20]
 800b070: 2b00         	cmp	r3, #0x0
 800b072: d00d         	beq	0x800b090 <uart_stm32_async_init+0x44> @ imm = #0x1a
; 		if (!device_is_ready(data->dma_rx.dma_dev)) {
 800b074: 68fb         	ldr	r3, [r7, #0xc]
 800b076: 6a1b         	ldr	r3, [r3, #0x20]
 800b078: 4618         	mov	r0, r3
 800b07a: f00e fa0f    	bl	0x801949c <device_is_ready> @ imm = #0xe41e
 800b07e: 4603         	mov	r3, r0
 800b080: f083 0301    	eor	r3, r3, #0x1
 800b084: b2db         	uxtb	r3, r3
 800b086: 2b00         	cmp	r3, #0x0
 800b088: d002         	beq	0x800b090 <uart_stm32_async_init+0x44> @ imm = #0x4
; 			return -ENODEV;
 800b08a: f06f 0312    	mvn	r3, #0x12
 800b08e: e0de         	b	0x800b24e <uart_stm32_async_init+0x202> @ imm = #0x1bc
; 	if (data->dma_tx.dma_dev != NULL) {
 800b090: 68fb         	ldr	r3, [r7, #0xc]
 800b092: f8d3 30b8    	ldr.w	r3, [r3, #0xb8]
 800b096: 2b00         	cmp	r3, #0x0
 800b098: d00e         	beq	0x800b0b8 <uart_stm32_async_init+0x6c> @ imm = #0x1c
; 		if (!device_is_ready(data->dma_tx.dma_dev)) {
 800b09a: 68fb         	ldr	r3, [r7, #0xc]
 800b09c: f8d3 30b8    	ldr.w	r3, [r3, #0xb8]
 800b0a0: 4618         	mov	r0, r3
 800b0a2: f00e f9fb    	bl	0x801949c <device_is_ready> @ imm = #0xe3f6
 800b0a6: 4603         	mov	r3, r0
 800b0a8: f083 0301    	eor	r3, r3, #0x1
 800b0ac: b2db         	uxtb	r3, r3
 800b0ae: 2b00         	cmp	r3, #0x0
 800b0b0: d002         	beq	0x800b0b8 <uart_stm32_async_init+0x6c> @ imm = #0x4
; 			return -ENODEV;
 800b0b2: f06f 0312    	mvn	r3, #0x12
 800b0b6: e0ca         	b	0x800b24e <uart_stm32_async_init+0x202> @ imm = #0x194
; 	uart_stm32_dma_rx_disable(dev);
 800b0b8: 6878         	ldr	r0, [r7, #0x4]
 800b0ba: f00f fcdf    	bl	0x801aa7c <uart_stm32_dma_rx_disable> @ imm = #0xf9be
; 	uart_stm32_dma_tx_disable(dev);
 800b0be: 6878         	ldr	r0, [r7, #0x4]
 800b0c0: f00f fcb5    	bl	0x801aa2e <uart_stm32_dma_tx_disable> @ imm = #0xf96a
; 	k_work_init_delayable(&data->dma_rx.timeout_work,
 800b0c4: 68fb         	ldr	r3, [r7, #0xc]
 800b0c6: 3380         	adds	r3, #0x80
 800b0c8: 4963         	ldr	r1, [pc, #0x18c]        @ 0x800b258 <uart_stm32_async_init+0x20c>
 800b0ca: 4618         	mov	r0, r3
 800b0cc: f011 fc2d    	bl	0x801c92a <k_work_init_delayable> @ imm = #0x1185a
; 	k_work_init_delayable(&data->dma_tx.timeout_work,
 800b0d0: 68fb         	ldr	r3, [r7, #0xc]
 800b0d2: f503 738c    	add.w	r3, r3, #0x118
 800b0d6: 4961         	ldr	r1, [pc, #0x184]        @ 0x800b25c <uart_stm32_async_init+0x210>
 800b0d8: 4618         	mov	r0, r3
 800b0da: f011 fc26    	bl	0x801c92a <k_work_init_delayable> @ imm = #0x1184c
; 	memset(&data->dma_rx.blk_cfg, 0, sizeof(data->dma_rx.blk_cfg));
 800b0de: 68fb         	ldr	r3, [r7, #0xc]
 800b0e0: 334c         	adds	r3, #0x4c
 800b0e2: 2220         	movs	r2, #0x20
 800b0e4: 2100         	movs	r1, #0x0
 800b0e6: 4618         	mov	r0, r3
 800b0e8: f012 fb80    	bl	0x801d7ec <memset>      @ imm = #0x12700
; 				LL_USART_DMA_GetRegAddr(usart);
 800b0ec: 6938         	ldr	r0, [r7, #0x10]
 800b0ee: f00e ff3a    	bl	0x8019f66 <LL_USART_DMA_GetRegAddr> @ imm = #0xee74
 800b0f2: 4602         	mov	r2, r0
; 	data->dma_rx.blk_cfg.source_address =
 800b0f4: 68fb         	ldr	r3, [r7, #0xc]
 800b0f6: 64da         	str	r2, [r3, #0x4c]
; 	data->dma_rx.blk_cfg.dest_address = 0; /* dest not ready */
 800b0f8: 68fb         	ldr	r3, [r7, #0xc]
 800b0fa: 2200         	movs	r2, #0x0
 800b0fc: 651a         	str	r2, [r3, #0x50]
; 	if (data->dma_rx.src_addr_increment) {
 800b0fe: 68fb         	ldr	r3, [r7, #0xc]
 800b100: f893 3045    	ldrb.w	r3, [r3, #0x45]
 800b104: 2b00         	cmp	r3, #0x0
 800b106: d007         	beq	0x800b118 <uart_stm32_async_init+0xcc> @ imm = #0xe
; 		data->dma_rx.blk_cfg.source_addr_adj = DMA_ADDR_ADJ_INCREMENT;
 800b108: 68fa         	ldr	r2, [r7, #0xc]
 800b10a: f892 3068    	ldrb.w	r3, [r2, #0x68]
 800b10e: f36f 0383    	bfc	r3, #2, #2
 800b112: f882 3068    	strb.w	r3, [r2, #0x68]
 800b116: e007         	b	0x800b128 <uart_stm32_async_init+0xdc> @ imm = #0xe
; 		data->dma_rx.blk_cfg.source_addr_adj = DMA_ADDR_ADJ_NO_CHANGE;
 800b118: 68fa         	ldr	r2, [r7, #0xc]
 800b11a: f892 3068    	ldrb.w	r3, [r2, #0x68]
 800b11e: 2102         	movs	r1, #0x2
 800b120: f361 0383    	bfi	r3, r1, #2, #2
 800b124: f882 3068    	strb.w	r3, [r2, #0x68]
; 	if (data->dma_rx.dst_addr_increment) {
 800b128: 68fb         	ldr	r3, [r7, #0xc]
 800b12a: f893 3046    	ldrb.w	r3, [r3, #0x46]
 800b12e: 2b00         	cmp	r3, #0x0
 800b130: d007         	beq	0x800b142 <uart_stm32_async_init+0xf6> @ imm = #0xe
; 		data->dma_rx.blk_cfg.dest_addr_adj = DMA_ADDR_ADJ_INCREMENT;
 800b132: 68fa         	ldr	r2, [r7, #0xc]
 800b134: f892 3068    	ldrb.w	r3, [r2, #0x68]
 800b138: f36f 1305    	bfc	r3, #4, #2
 800b13c: f882 3068    	strb.w	r3, [r2, #0x68]
 800b140: e007         	b	0x800b152 <uart_stm32_async_init+0x106> @ imm = #0xe
; 		data->dma_rx.blk_cfg.dest_addr_adj = DMA_ADDR_ADJ_NO_CHANGE;
 800b142: 68fa         	ldr	r2, [r7, #0xc]
 800b144: f892 3068    	ldrb.w	r3, [r2, #0x68]
 800b148: 2102         	movs	r1, #0x2
 800b14a: f361 1305    	bfi	r3, r1, #4, #2
 800b14e: f882 3068    	strb.w	r3, [r2, #0x68]
; 	data->dma_rx.blk_cfg.source_reload_en  = 0;
 800b152: 68fa         	ldr	r2, [r7, #0xc]
 800b154: f892 3068    	ldrb.w	r3, [r2, #0x68]
 800b158: f36f 1386    	bfc	r3, #6, #1
 800b15c: f882 3068    	strb.w	r3, [r2, #0x68]
; 	data->dma_rx.blk_cfg.dest_reload_en = 0;
 800b160: 68fa         	ldr	r2, [r7, #0xc]
 800b162: f892 3068    	ldrb.w	r3, [r2, #0x68]
 800b166: f36f 13c7    	bfc	r3, #7, #1
 800b16a: f882 3068    	strb.w	r3, [r2, #0x68]
; 	data->dma_rx.blk_cfg.fifo_mode_control = data->dma_rx.fifo_threshold;
 800b16e: 68fb         	ldr	r3, [r7, #0xc]
 800b170: 6c9b         	ldr	r3, [r3, #0x48]
 800b172: f003 030f    	and	r3, r3, #0xf
 800b176: b2d9         	uxtb	r1, r3
 800b178: 68fa         	ldr	r2, [r7, #0xc]
 800b17a: f892 3069    	ldrb.w	r3, [r2, #0x69]
 800b17e: f361 0303    	bfi	r3, r1, #0, #4
 800b182: f882 3069    	strb.w	r3, [r2, #0x69]
; 	data->dma_rx.dma_cfg.head_block = &data->dma_rx.blk_cfg;
 800b186: 68fb         	ldr	r3, [r7, #0xc]
 800b188: f103 024c    	add.w	r2, r3, #0x4c
 800b18c: 68fb         	ldr	r3, [r7, #0xc]
 800b18e: 639a         	str	r2, [r3, #0x38]
; 	data->dma_rx.dma_cfg.user_data = (void *)dev;
 800b190: 68fb         	ldr	r3, [r7, #0xc]
 800b192: 687a         	ldr	r2, [r7, #0x4]
 800b194: 63da         	str	r2, [r3, #0x3c]
; 	data->rx_next_buffer = NULL;
 800b196: 68fb         	ldr	r3, [r7, #0xc]
 800b198: 2200         	movs	r2, #0x0
 800b19a: f8c3 2150    	str.w	r2, [r3, #0x150]
; 	data->rx_next_buffer_len = 0;
 800b19e: 68fb         	ldr	r3, [r7, #0xc]
 800b1a0: 2200         	movs	r2, #0x0
 800b1a2: f8c3 2154    	str.w	r2, [r3, #0x154]
; 	memset(&data->dma_tx.blk_cfg, 0, sizeof(data->dma_tx.blk_cfg));
 800b1a6: 68fb         	ldr	r3, [r7, #0xc]
 800b1a8: 33e4         	adds	r3, #0xe4
 800b1aa: 2220         	movs	r2, #0x20
 800b1ac: 2100         	movs	r1, #0x0
 800b1ae: 4618         	mov	r0, r3
 800b1b0: f012 fb1c    	bl	0x801d7ec <memset>      @ imm = #0x12638
; 			LL_USART_DMA_GetRegAddr(usart);
 800b1b4: 6938         	ldr	r0, [r7, #0x10]
 800b1b6: f00e fed6    	bl	0x8019f66 <LL_USART_DMA_GetRegAddr> @ imm = #0xedac
 800b1ba: 4602         	mov	r2, r0
; 	data->dma_tx.blk_cfg.dest_address =
 800b1bc: 68fb         	ldr	r3, [r7, #0xc]
 800b1be: f8c3 20e8    	str.w	r2, [r3, #0xe8]
; 	data->dma_tx.blk_cfg.source_address = 0; /* not ready */
 800b1c2: 68fb         	ldr	r3, [r7, #0xc]
 800b1c4: 2200         	movs	r2, #0x0
 800b1c6: f8c3 20e4    	str.w	r2, [r3, #0xe4]
; 	if (data->dma_tx.src_addr_increment) {
 800b1ca: 68fb         	ldr	r3, [r7, #0xc]
 800b1cc: f893 30dd    	ldrb.w	r3, [r3, #0xdd]
 800b1d0: 2b00         	cmp	r3, #0x0
 800b1d2: d007         	beq	0x800b1e4 <uart_stm32_async_init+0x198> @ imm = #0xe
; 		data->dma_tx.blk_cfg.source_addr_adj = DMA_ADDR_ADJ_INCREMENT;
 800b1d4: 68fa         	ldr	r2, [r7, #0xc]
 800b1d6: f892 3100    	ldrb.w	r3, [r2, #0x100]
 800b1da: f36f 0383    	bfc	r3, #2, #2
 800b1de: f882 3100    	strb.w	r3, [r2, #0x100]
 800b1e2: e007         	b	0x800b1f4 <uart_stm32_async_init+0x1a8> @ imm = #0xe
; 		data->dma_tx.blk_cfg.source_addr_adj = DMA_ADDR_ADJ_NO_CHANGE;
 800b1e4: 68fa         	ldr	r2, [r7, #0xc]
 800b1e6: f892 3100    	ldrb.w	r3, [r2, #0x100]
 800b1ea: 2102         	movs	r1, #0x2
 800b1ec: f361 0383    	bfi	r3, r1, #2, #2
 800b1f0: f882 3100    	strb.w	r3, [r2, #0x100]
; 	if (data->dma_tx.dst_addr_increment) {
 800b1f4: 68fb         	ldr	r3, [r7, #0xc]
 800b1f6: f893 30de    	ldrb.w	r3, [r3, #0xde]
 800b1fa: 2b00         	cmp	r3, #0x0
 800b1fc: d007         	beq	0x800b20e <uart_stm32_async_init+0x1c2> @ imm = #0xe
; 		data->dma_tx.blk_cfg.dest_addr_adj = DMA_ADDR_ADJ_INCREMENT;
 800b1fe: 68fa         	ldr	r2, [r7, #0xc]
 800b200: f892 3100    	ldrb.w	r3, [r2, #0x100]
 800b204: f36f 1305    	bfc	r3, #4, #2
 800b208: f882 3100    	strb.w	r3, [r2, #0x100]
 800b20c: e007         	b	0x800b21e <uart_stm32_async_init+0x1d2> @ imm = #0xe
; 		data->dma_tx.blk_cfg.dest_addr_adj = DMA_ADDR_ADJ_NO_CHANGE;
 800b20e: 68fa         	ldr	r2, [r7, #0xc]
 800b210: f892 3100    	ldrb.w	r3, [r2, #0x100]
 800b214: 2102         	movs	r1, #0x2
 800b216: f361 1305    	bfi	r3, r1, #4, #2
 800b21a: f882 3100    	strb.w	r3, [r2, #0x100]
; 	data->dma_tx.blk_cfg.fifo_mode_control = data->dma_tx.fifo_threshold;
 800b21e: 68fb         	ldr	r3, [r7, #0xc]
 800b220: f8d3 30e0    	ldr.w	r3, [r3, #0xe0]
 800b224: f003 030f    	and	r3, r3, #0xf
 800b228: b2d9         	uxtb	r1, r3
 800b22a: 68fa         	ldr	r2, [r7, #0xc]
 800b22c: f892 3101    	ldrb.w	r3, [r2, #0x101]
 800b230: f361 0303    	bfi	r3, r1, #0, #4
 800b234: f882 3101    	strb.w	r3, [r2, #0x101]
; 	data->dma_tx.dma_cfg.head_block = &data->dma_tx.blk_cfg;
 800b238: 68fb         	ldr	r3, [r7, #0xc]
 800b23a: f103 02e4    	add.w	r2, r3, #0xe4
 800b23e: 68fb         	ldr	r3, [r7, #0xc]
 800b240: f8c3 20d0    	str.w	r2, [r3, #0xd0]
; 	data->dma_tx.dma_cfg.user_data = (void *)dev;
 800b244: 68fb         	ldr	r3, [r7, #0xc]
 800b246: 687a         	ldr	r2, [r7, #0x4]
 800b248: f8c3 20d4    	str.w	r2, [r3, #0xd4]
; 	return 0;
 800b24c: 2300         	movs	r3, #0x0
; }
 800b24e: 4618         	mov	r0, r3
 800b250: 3718         	adds	r7, #0x18
 800b252: 46bd         	mov	sp, r7
 800b254: bd80         	pop	{r7, pc}
 800b256: bf00         	nop

0800b258 <$d>:
 800b258: 6d ae 00 08  	.word	0x0800ae6d
 800b25c: f5 ae 00 08  	.word	0x0800aef5

0800b260 <uart_stm32_clocks_enable>:
; {
 800b260: b580         	push	{r7, lr}
 800b262: b08e         	sub	sp, #0x38
 800b264: af04         	add	r7, sp, #0x10
 800b266: 6078         	str	r0, [r7, #0x4]
; 	const struct uart_stm32_config *config = dev->config;
 800b268: 687b         	ldr	r3, [r7, #0x4]
 800b26a: 685b         	ldr	r3, [r3, #0x4]
 800b26c: 623b         	str	r3, [r7, #0x20]
; 	struct uart_stm32_data *data = dev->data;
 800b26e: 687b         	ldr	r3, [r7, #0x4]
 800b270: 691b         	ldr	r3, [r3, #0x10]
 800b272: 627b         	str	r3, [r7, #0x24]
; 	__uart_stm32_get_clock(dev);
 800b274: 6878         	ldr	r0, [r7, #0x4]
 800b276: f7ff f853    	bl	0x800a320 <__uart_stm32_get_clock> @ imm = #-0xf5a
; 	if (!device_is_ready(data->clock)) {
 800b27a: 6a7b         	ldr	r3, [r7, #0x24]
 800b27c: 681b         	ldr	r3, [r3]
 800b27e: 4618         	mov	r0, r3
 800b280: f00e f90c    	bl	0x801949c <device_is_ready> @ imm = #0xe218
 800b284: 4603         	mov	r3, r0
 800b286: f083 0301    	eor	r3, r3, #0x1
 800b28a: b2db         	uxtb	r3, r3
 800b28c: 2b00         	cmp	r3, #0x0
 800b28e: d01c         	beq	0x800b2ca <uart_stm32_clocks_enable+0x6a> @ imm = #0x38
; 		LOG_ERR("clock control device not ready");
 800b290: 2303         	movs	r3, #0x3
 800b292: 2b00         	cmp	r3, #0x0
 800b294: d016         	beq	0x800b2c4 <uart_stm32_clocks_enable+0x64> @ imm = #0x2c
 800b296: 2301         	movs	r3, #0x1
 800b298: 74fb         	strb	r3, [r7, #0x13]
 800b29a: 7cfb         	ldrb	r3, [r7, #0x13]
 800b29c: f083 0301    	eor	r3, r3, #0x1
 800b2a0: b2db         	uxtb	r3, r3
 800b2a2: 2b00         	cmp	r3, #0x0
 800b2a4: d10e         	bne	0x800b2c4 <uart_stm32_clocks_enable+0x64> @ imm = #0x1c
 800b2a6: 4b1f         	ldr	r3, [pc, #0x7c]         @ 0x800b324 <uart_stm32_clocks_enable+0xc4>
 800b2a8: 6819         	ldr	r1, [r3]
 800b2aa: 4b1f         	ldr	r3, [pc, #0x7c]         @ 0x800b328 <uart_stm32_clocks_enable+0xc8>
 800b2ac: 9302         	str	r3, [sp, #0x8]
 800b2ae: 2300         	movs	r3, #0x0
 800b2b0: 9301         	str	r3, [sp, #0x4]
 800b2b2: 2300         	movs	r3, #0x0
 800b2b4: 9300         	str	r3, [sp]
 800b2b6: 2300         	movs	r3, #0x0
 800b2b8: 2201         	movs	r2, #0x1
 800b2ba: 2000         	movs	r0, #0x0
 800b2bc: f00e fe78    	bl	0x8019fb0 <z_log_msg_runtime_create> @ imm = #0xecf0
 800b2c0: 2300         	movs	r3, #0x0
 800b2c2: 60fb         	str	r3, [r7, #0xc]
; 		return -ENODEV;
 800b2c4: f06f 0312    	mvn	r3, #0x12
 800b2c8: e028         	b	0x800b31c <uart_stm32_clocks_enable+0xbc> @ imm = #0x50
; 	err = clock_control_on(data->clock, (clock_control_subsys_t)&config->pclken[0]);
 800b2ca: 6a7b         	ldr	r3, [r7, #0x24]
 800b2cc: 681a         	ldr	r2, [r3]
 800b2ce: 6a3b         	ldr	r3, [r7, #0x20]
 800b2d0: 68db         	ldr	r3, [r3, #0xc]
 800b2d2: 4619         	mov	r1, r3
 800b2d4: 4610         	mov	r0, r2
 800b2d6: f00e f8f7    	bl	0x80194c8 <clock_control_on> @ imm = #0xe1ee
 800b2da: 61f8         	str	r0, [r7, #0x1c]
; 	if (err != 0) {
 800b2dc: 69fb         	ldr	r3, [r7, #0x1c]
 800b2de: 2b00         	cmp	r3, #0x0
 800b2e0: d01b         	beq	0x800b31a <uart_stm32_clocks_enable+0xba> @ imm = #0x36
; 		LOG_ERR("Could not enable (LP)UART clock");
 800b2e2: 2303         	movs	r3, #0x3
 800b2e4: 2b00         	cmp	r3, #0x0
 800b2e6: d016         	beq	0x800b316 <uart_stm32_clocks_enable+0xb6> @ imm = #0x2c
 800b2e8: 2301         	movs	r3, #0x1
 800b2ea: 76fb         	strb	r3, [r7, #0x1b]
 800b2ec: 7efb         	ldrb	r3, [r7, #0x1b]
 800b2ee: f083 0301    	eor	r3, r3, #0x1
 800b2f2: b2db         	uxtb	r3, r3
 800b2f4: 2b00         	cmp	r3, #0x0
 800b2f6: d10e         	bne	0x800b316 <uart_stm32_clocks_enable+0xb6> @ imm = #0x1c
 800b2f8: 4b0a         	ldr	r3, [pc, #0x28]         @ 0x800b324 <uart_stm32_clocks_enable+0xc4>
 800b2fa: 6819         	ldr	r1, [r3]
 800b2fc: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x800b32c <uart_stm32_clocks_enable+0xcc>
 800b2fe: 9302         	str	r3, [sp, #0x8]
 800b300: 2300         	movs	r3, #0x0
 800b302: 9301         	str	r3, [sp, #0x4]
 800b304: 2300         	movs	r3, #0x0
 800b306: 9300         	str	r3, [sp]
 800b308: 2300         	movs	r3, #0x0
 800b30a: 2201         	movs	r2, #0x1
 800b30c: 2000         	movs	r0, #0x0
 800b30e: f00e fe4f    	bl	0x8019fb0 <z_log_msg_runtime_create> @ imm = #0xec9e
 800b312: 2300         	movs	r3, #0x0
 800b314: 617b         	str	r3, [r7, #0x14]
; 		return err;
 800b316: 69fb         	ldr	r3, [r7, #0x1c]
 800b318: e000         	b	0x800b31c <uart_stm32_clocks_enable+0xbc> @ imm = #0x0
; 	return 0;
 800b31a: 2300         	movs	r3, #0x0
; }
 800b31c: 4618         	mov	r0, r3
 800b31e: 3728         	adds	r7, #0x28
 800b320: 46bd         	mov	sp, r7
 800b322: bd80         	pop	{r7, pc}

0800b324 <$d>:
 800b324: 18 05 00 20  	.word	0x20000518
 800b328: 84 f5 01 08  	.word	0x0801f584
 800b32c: a4 f5 01 08  	.word	0x0801f5a4

0800b330 <uart_stm32_registers_configure>:
; {
 800b330: b580         	push	{r7, lr}
 800b332: b08c         	sub	sp, #0x30
 800b334: af04         	add	r7, sp, #0x10
 800b336: 6078         	str	r0, [r7, #0x4]
; 	const struct uart_stm32_config *config = dev->config;
 800b338: 687b         	ldr	r3, [r7, #0x4]
 800b33a: 685b         	ldr	r3, [r3, #0x4]
 800b33c: 61fb         	str	r3, [r7, #0x1c]
; 	USART_TypeDef *usart = config->usart;
 800b33e: 69fb         	ldr	r3, [r7, #0x1c]
 800b340: 681b         	ldr	r3, [r3]
 800b342: 61bb         	str	r3, [r7, #0x18]
; 	struct uart_stm32_data *data = dev->data;
 800b344: 687b         	ldr	r3, [r7, #0x4]
 800b346: 691b         	ldr	r3, [r3, #0x10]
 800b348: 617b         	str	r3, [r7, #0x14]
; 	struct uart_config *uart_cfg = data->uart_cfg;
 800b34a: 697b         	ldr	r3, [r7, #0x14]
 800b34c: 685b         	ldr	r3, [r3, #0x4]
 800b34e: 613b         	str	r3, [r7, #0x10]
; 	LL_USART_Disable(usart);
 800b350: 69b8         	ldr	r0, [r7, #0x18]
 800b352: f00e f9ec    	bl	0x801972e <LL_USART_Disable> @ imm = #0xe3d8
; 	if (!device_is_ready(config->reset.dev)) {
 800b356: 69fb         	ldr	r3, [r7, #0x1c]
 800b358: 685b         	ldr	r3, [r3, #0x4]
 800b35a: 4618         	mov	r0, r3
 800b35c: f00e f89e    	bl	0x801949c <device_is_ready> @ imm = #0xe13c
 800b360: 4603         	mov	r3, r0
 800b362: f083 0301    	eor	r3, r3, #0x1
 800b366: b2db         	uxtb	r3, r3
 800b368: 2b00         	cmp	r3, #0x0
 800b36a: d01c         	beq	0x800b3a6 <uart_stm32_registers_configure+0x76> @ imm = #0x38
; 		LOG_ERR("reset controller not ready");
 800b36c: 2303         	movs	r3, #0x3
 800b36e: 2b00         	cmp	r3, #0x0
 800b370: d016         	beq	0x800b3a0 <uart_stm32_registers_configure+0x70> @ imm = #0x2c
 800b372: 2301         	movs	r3, #0x1
 800b374: 73fb         	strb	r3, [r7, #0xf]
 800b376: 7bfb         	ldrb	r3, [r7, #0xf]
 800b378: f083 0301    	eor	r3, r3, #0x1
 800b37c: b2db         	uxtb	r3, r3
 800b37e: 2b00         	cmp	r3, #0x0
 800b380: d10e         	bne	0x800b3a0 <uart_stm32_registers_configure+0x70> @ imm = #0x1c
 800b382: 4b17         	ldr	r3, [pc, #0x5c]         @ 0x800b3e0 <uart_stm32_registers_configure+0xb0>
 800b384: 6819         	ldr	r1, [r3]
 800b386: 4b17         	ldr	r3, [pc, #0x5c]         @ 0x800b3e4 <uart_stm32_registers_configure+0xb4>
 800b388: 9302         	str	r3, [sp, #0x8]
 800b38a: 2300         	movs	r3, #0x0
 800b38c: 9301         	str	r3, [sp, #0x4]
 800b38e: 2300         	movs	r3, #0x0
 800b390: 9300         	str	r3, [sp]
 800b392: 2300         	movs	r3, #0x0
 800b394: 2201         	movs	r2, #0x1
 800b396: 2000         	movs	r0, #0x0
 800b398: f00e fe0a    	bl	0x8019fb0 <z_log_msg_runtime_create> @ imm = #0xec14
 800b39c: 2300         	movs	r3, #0x0
 800b39e: 60bb         	str	r3, [r7, #0x8]
; 		return -ENODEV;
 800b3a0: f06f 0312    	mvn	r3, #0x12
 800b3a4: e017         	b	0x800b3d6 <uart_stm32_registers_configure+0xa6> @ imm = #0x2e
; 	(void)reset_line_toggle_dt(&config->reset);
 800b3a6: 69fb         	ldr	r3, [r7, #0x1c]
 800b3a8: 3304         	adds	r3, #0x4
 800b3aa: 4618         	mov	r0, r3
 800b3ac: f00e f991    	bl	0x80196d2 <reset_line_toggle_dt> @ imm = #0xe322
; 	LL_USART_SetTransferDirection(usart, LL_USART_DIRECTION_TX_RX);
 800b3b0: 210c         	movs	r1, #0xc
 800b3b2: 69b8         	ldr	r0, [r7, #0x18]
 800b3b4: f00e f9ca    	bl	0x801974c <LL_USART_SetTransferDirection> @ imm = #0xe394
; 	uart_stm32_parameters_set(dev, uart_cfg);
 800b3b8: 6939         	ldr	r1, [r7, #0x10]
 800b3ba: 6878         	ldr	r0, [r7, #0x4]
 800b3bc: f00e ff68    	bl	0x801a290 <uart_stm32_parameters_set> @ imm = #0xeed0
; 	if (config->single_wire) {
 800b3c0: 69fb         	ldr	r3, [r7, #0x1c]
 800b3c2: 7d1b         	ldrb	r3, [r3, #0x14]
 800b3c4: 2b00         	cmp	r3, #0x0
 800b3c6: d002         	beq	0x800b3ce <uart_stm32_registers_configure+0x9e> @ imm = #0x4
; 		LL_USART_EnableHalfDuplex(usart);
 800b3c8: 69b8         	ldr	r0, [r7, #0x18]
 800b3ca: f00e fa90    	bl	0x80198ee <LL_USART_EnableHalfDuplex> @ imm = #0xe520
; 	LL_USART_Enable(usart);
 800b3ce: 69b8         	ldr	r0, [r7, #0x18]
 800b3d0: f00e f99e    	bl	0x8019710 <LL_USART_Enable> @ imm = #0xe33c
; 	return 0;
 800b3d4: 2300         	movs	r3, #0x0
; }
 800b3d6: 4618         	mov	r0, r3
 800b3d8: 3720         	adds	r7, #0x20
 800b3da: 46bd         	mov	sp, r7
 800b3dc: bd80         	pop	{r7, pc}
 800b3de: bf00         	nop

0800b3e0 <$d>:
 800b3e0: 18 05 00 20  	.word	0x20000518
 800b3e4: c4 f5 01 08  	.word	0x0801f5c4

0800b3e8 <spi_context_cs_configure_all>:
; {
 800b3e8: b580         	push	{r7, lr}
 800b3ea: b08c         	sub	sp, #0x30
 800b3ec: af06         	add	r7, sp, #0x18
 800b3ee: 6078         	str	r0, [r7, #0x4]
; 	for (cs_gpio = ctx->cs_gpios; cs_gpio < &ctx->cs_gpios[ctx->num_cs_gpios]; cs_gpio++) {
 800b3f0: 687b         	ldr	r3, [r7, #0x4]
 800b3f2: 689b         	ldr	r3, [r3, #0x8]
 800b3f4: 617b         	str	r3, [r7, #0x14]
 800b3f6: e03c         	b	0x800b472 <spi_context_cs_configure_all+0x8a> @ imm = #0x78
; 		if (!device_is_ready(cs_gpio->port)) {
 800b3f8: 697b         	ldr	r3, [r7, #0x14]
 800b3fa: 681b         	ldr	r3, [r3]
 800b3fc: 4618         	mov	r0, r3
 800b3fe: f00f fc70    	bl	0x801ace2 <device_is_ready> @ imm = #0xf8e0
 800b402: 4603         	mov	r3, r0
 800b404: f083 0301    	eor	r3, r3, #0x1
 800b408: b2db         	uxtb	r3, r3
 800b40a: 2b00         	cmp	r3, #0x0
 800b40c: d023         	beq	0x800b456 <spi_context_cs_configure_all+0x6e> @ imm = #0x46
; 			LOG_ERR("CS GPIO port %s pin %d is not ready",
 800b40e: 2303         	movs	r3, #0x3
 800b410: 2b00         	cmp	r3, #0x0
 800b412: d01d         	beq	0x800b450 <spi_context_cs_configure_all+0x68> @ imm = #0x3a
 800b414: 2301         	movs	r3, #0x1
 800b416: 73fb         	strb	r3, [r7, #0xf]
 800b418: 7bfb         	ldrb	r3, [r7, #0xf]
 800b41a: f083 0301    	eor	r3, r3, #0x1
 800b41e: b2db         	uxtb	r3, r3
 800b420: 2b00         	cmp	r3, #0x0
 800b422: d115         	bne	0x800b450 <spi_context_cs_configure_all+0x68> @ imm = #0x2a
 800b424: 4b1a         	ldr	r3, [pc, #0x68]         @ 0x800b490 <spi_context_cs_configure_all+0xa8>
 800b426: 6819         	ldr	r1, [r3]
 800b428: 697b         	ldr	r3, [r7, #0x14]
 800b42a: 681b         	ldr	r3, [r3]
 800b42c: 681b         	ldr	r3, [r3]
 800b42e: 697a         	ldr	r2, [r7, #0x14]
 800b430: 7912         	ldrb	r2, [r2, #0x4]
 800b432: 9204         	str	r2, [sp, #0x10]
 800b434: 9303         	str	r3, [sp, #0xc]
 800b436: 4b17         	ldr	r3, [pc, #0x5c]         @ 0x800b494 <spi_context_cs_configure_all+0xac>
 800b438: 9302         	str	r3, [sp, #0x8]
 800b43a: 2300         	movs	r3, #0x0
 800b43c: 9301         	str	r3, [sp, #0x4]
 800b43e: 2300         	movs	r3, #0x0
 800b440: 9300         	str	r3, [sp]
 800b442: 2300         	movs	r3, #0x0
 800b444: 2201         	movs	r2, #0x1
 800b446: 2000         	movs	r0, #0x0
 800b448: f00f fc57    	bl	0x801acfa <z_log_msg_runtime_create> @ imm = #0xf8ae
 800b44c: 2300         	movs	r3, #0x0
 800b44e: 60bb         	str	r3, [r7, #0x8]
; 			return -ENODEV;
 800b450: f06f 0312    	mvn	r3, #0x12
 800b454: e017         	b	0x800b486 <spi_context_cs_configure_all+0x9e> @ imm = #0x2e
; 		ret = gpio_pin_configure_dt(cs_gpio, GPIO_OUTPUT_INACTIVE);
 800b456: f44f 11b0    	mov.w	r1, #0x160000
 800b45a: 6978         	ldr	r0, [r7, #0x14]
 800b45c: f00f feb2    	bl	0x801b1c4 <gpio_pin_configure_dt> @ imm = #0xfd64
 800b460: 6138         	str	r0, [r7, #0x10]
; 		if (ret < 0) {
 800b462: 693b         	ldr	r3, [r7, #0x10]
 800b464: 2b00         	cmp	r3, #0x0
 800b466: da01         	bge	0x800b46c <spi_context_cs_configure_all+0x84> @ imm = #0x2
; 			return ret;
 800b468: 693b         	ldr	r3, [r7, #0x10]
 800b46a: e00c         	b	0x800b486 <spi_context_cs_configure_all+0x9e> @ imm = #0x18
; 	for (cs_gpio = ctx->cs_gpios; cs_gpio < &ctx->cs_gpios[ctx->num_cs_gpios]; cs_gpio++) {
 800b46c: 697b         	ldr	r3, [r7, #0x14]
 800b46e: 3308         	adds	r3, #0x8
 800b470: 617b         	str	r3, [r7, #0x14]
 800b472: 687b         	ldr	r3, [r7, #0x4]
 800b474: 689a         	ldr	r2, [r3, #0x8]
 800b476: 687b         	ldr	r3, [r7, #0x4]
 800b478: 68db         	ldr	r3, [r3, #0xc]
 800b47a: 00db         	lsls	r3, r3, #0x3
 800b47c: 4413         	add	r3, r2
 800b47e: 697a         	ldr	r2, [r7, #0x14]
 800b480: 429a         	cmp	r2, r3
 800b482: d3b9         	blo	0x800b3f8 <spi_context_cs_configure_all+0x10> @ imm = #-0x8e
; 	return 0;
 800b484: 2300         	movs	r3, #0x0
; }
 800b486: 4618         	mov	r0, r3
 800b488: 3718         	adds	r7, #0x18
 800b48a: 46bd         	mov	sp, r7
 800b48c: bd80         	pop	{r7, pc}
 800b48e: bf00         	nop

0800b490 <$d>:
 800b490: 34 05 00 20  	.word	0x20000534
 800b494: 20 f6 01 08  	.word	0x0801f620

0800b498 <spi_context_buffers_setup>:
; {
 800b498: b5f0         	push	{r4, r5, r6, r7, lr}
 800b49a: b097         	sub	sp, #0x5c
 800b49c: af0c         	add	r7, sp, #0x30
 800b49e: 6178         	str	r0, [r7, #0x14]
 800b4a0: 6139         	str	r1, [r7, #0x10]
 800b4a2: 60fa         	str	r2, [r7, #0xc]
 800b4a4: 72fb         	strb	r3, [r7, #0xb]
; 	LOG_DBG("tx_bufs %p - rx_bufs %p - %u", tx_bufs, rx_bufs, dfs);
 800b4a6: 2303         	movs	r3, #0x3
 800b4a8: 2b03         	cmp	r3, #0x3
 800b4aa: d920         	bls	0x800b4ee <spi_context_buffers_setup+0x56> @ imm = #0x40
 800b4ac: 2301         	movs	r3, #0x1
 800b4ae: f887 3023    	strb.w	r3, [r7, #0x23]
 800b4b2: f897 3023    	ldrb.w	r3, [r7, #0x23]
 800b4b6: f083 0301    	eor	r3, r3, #0x1
 800b4ba: b2db         	uxtb	r3, r3
 800b4bc: 2b00         	cmp	r3, #0x0
 800b4be: d116         	bne	0x800b4ee <spi_context_buffers_setup+0x56> @ imm = #0x2c
 800b4c0: 4b4e         	ldr	r3, [pc, #0x138]        @ 0x800b5fc <spi_context_buffers_setup+0x164>
 800b4c2: 6819         	ldr	r1, [r3]
 800b4c4: 7afb         	ldrb	r3, [r7, #0xb]
 800b4c6: 9306         	str	r3, [sp, #0x18]
 800b4c8: 68fb         	ldr	r3, [r7, #0xc]
 800b4ca: 9305         	str	r3, [sp, #0x14]
 800b4cc: 693b         	ldr	r3, [r7, #0x10]
 800b4ce: 9304         	str	r3, [sp, #0x10]
 800b4d0: 4b4b         	ldr	r3, [pc, #0x12c]        @ 0x800b600 <spi_context_buffers_setup+0x168>
 800b4d2: 9303         	str	r3, [sp, #0xc]
 800b4d4: 4b4b         	ldr	r3, [pc, #0x12c]        @ 0x800b604 <spi_context_buffers_setup+0x16c>
 800b4d6: 9302         	str	r3, [sp, #0x8]
 800b4d8: 2308         	movs	r3, #0x8
 800b4da: 9301         	str	r3, [sp, #0x4]
 800b4dc: 2300         	movs	r3, #0x0
 800b4de: 9300         	str	r3, [sp]
 800b4e0: 2300         	movs	r3, #0x0
 800b4e2: 2204         	movs	r2, #0x4
 800b4e4: 2000         	movs	r0, #0x0
 800b4e6: f00f fc08    	bl	0x801acfa <z_log_msg_runtime_create> @ imm = #0xf810
 800b4ea: 2300         	movs	r3, #0x0
 800b4ec: 627b         	str	r3, [r7, #0x24]
; 	ctx->current_tx = tx_bufs ? tx_bufs->buffers : NULL;
 800b4ee: 693b         	ldr	r3, [r7, #0x10]
 800b4f0: 2b00         	cmp	r3, #0x0
 800b4f2: d002         	beq	0x800b4fa <spi_context_buffers_setup+0x62> @ imm = #0x4
 800b4f4: 693b         	ldr	r3, [r7, #0x10]
 800b4f6: 681b         	ldr	r3, [r3]
 800b4f8: e000         	b	0x800b4fc <spi_context_buffers_setup+0x64> @ imm = #0x0
 800b4fa: 2300         	movs	r3, #0x0
 800b4fc: 697a         	ldr	r2, [r7, #0x14]
 800b4fe: 6353         	str	r3, [r2, #0x34]
; 	ctx->tx_count = ctx->current_tx ? tx_bufs->count : 0;
 800b500: 697b         	ldr	r3, [r7, #0x14]
 800b502: 6b5b         	ldr	r3, [r3, #0x34]
 800b504: 2b00         	cmp	r3, #0x0
 800b506: d002         	beq	0x800b50e <spi_context_buffers_setup+0x76> @ imm = #0x4
 800b508: 693b         	ldr	r3, [r7, #0x10]
 800b50a: 685b         	ldr	r3, [r3, #0x4]
 800b50c: e000         	b	0x800b510 <spi_context_buffers_setup+0x78> @ imm = #0x0
 800b50e: 2300         	movs	r3, #0x0
 800b510: 697a         	ldr	r2, [r7, #0x14]
 800b512: 6393         	str	r3, [r2, #0x38]
; 		spi_context_get_next_buf(&ctx->current_tx, &ctx->tx_count,
 800b514: 697b         	ldr	r3, [r7, #0x14]
 800b516: f103 0034    	add.w	r0, r3, #0x34
 800b51a: 697b         	ldr	r3, [r7, #0x14]
 800b51c: f103 0138    	add.w	r1, r3, #0x38
 800b520: 697b         	ldr	r3, [r7, #0x14]
 800b522: f103 0248    	add.w	r2, r3, #0x48
 800b526: 7afb         	ldrb	r3, [r7, #0xb]
 800b528: f010 f852    	bl	0x801b5d0 <spi_context_get_next_buf> @ imm = #0x100a4
 800b52c: 4602         	mov	r2, r0
; 	ctx->tx_buf = (const uint8_t *)
 800b52e: 697b         	ldr	r3, [r7, #0x14]
 800b530: 645a         	str	r2, [r3, #0x44]
; 	ctx->current_rx = rx_bufs ? rx_bufs->buffers : NULL;
 800b532: 68fb         	ldr	r3, [r7, #0xc]
 800b534: 2b00         	cmp	r3, #0x0
 800b536: d002         	beq	0x800b53e <spi_context_buffers_setup+0xa6> @ imm = #0x4
 800b538: 68fb         	ldr	r3, [r7, #0xc]
 800b53a: 681b         	ldr	r3, [r3]
 800b53c: e000         	b	0x800b540 <spi_context_buffers_setup+0xa8> @ imm = #0x0
 800b53e: 2300         	movs	r3, #0x0
 800b540: 697a         	ldr	r2, [r7, #0x14]
 800b542: 63d3         	str	r3, [r2, #0x3c]
; 	ctx->rx_count = ctx->current_rx ? rx_bufs->count : 0;
 800b544: 697b         	ldr	r3, [r7, #0x14]
 800b546: 6bdb         	ldr	r3, [r3, #0x3c]
 800b548: 2b00         	cmp	r3, #0x0
 800b54a: d002         	beq	0x800b552 <spi_context_buffers_setup+0xba> @ imm = #0x4
 800b54c: 68fb         	ldr	r3, [r7, #0xc]
 800b54e: 685b         	ldr	r3, [r3, #0x4]
 800b550: e000         	b	0x800b554 <spi_context_buffers_setup+0xbc> @ imm = #0x0
 800b552: 2300         	movs	r3, #0x0
 800b554: 697a         	ldr	r2, [r7, #0x14]
 800b556: 6413         	str	r3, [r2, #0x40]
; 		spi_context_get_next_buf(&ctx->current_rx, &ctx->rx_count,
 800b558: 697b         	ldr	r3, [r7, #0x14]
 800b55a: f103 003c    	add.w	r0, r3, #0x3c
 800b55e: 697b         	ldr	r3, [r7, #0x14]
 800b560: f103 0140    	add.w	r1, r3, #0x40
 800b564: 697b         	ldr	r3, [r7, #0x14]
 800b566: f103 0250    	add.w	r2, r3, #0x50
 800b56a: 7afb         	ldrb	r3, [r7, #0xb]
 800b56c: f010 f830    	bl	0x801b5d0 <spi_context_get_next_buf> @ imm = #0x10060
 800b570: 4602         	mov	r2, r0
; 	ctx->rx_buf = (uint8_t *)
 800b572: 697b         	ldr	r3, [r7, #0x14]
 800b574: 64da         	str	r2, [r3, #0x4c]
; 	ctx->sync_status = 0;
 800b576: 697b         	ldr	r3, [r7, #0x14]
 800b578: 2200         	movs	r2, #0x0
 800b57a: 631a         	str	r2, [r3, #0x30]
; 	LOG_DBG("current_tx %p (%zu), current_rx %p (%zu),"
 800b57c: 2303         	movs	r3, #0x3
 800b57e: 2b03         	cmp	r3, #0x3
 800b580: d938         	bls	0x800b5f4 <spi_context_buffers_setup+0x15c> @ imm = #0x70
 800b582: 2301         	movs	r3, #0x1
 800b584: f887 3022    	strb.w	r3, [r7, #0x22]
 800b588: f897 3022    	ldrb.w	r3, [r7, #0x22]
 800b58c: f083 0301    	eor	r3, r3, #0x1
 800b590: b2db         	uxtb	r3, r3
 800b592: 2b00         	cmp	r3, #0x0
 800b594: d12e         	bne	0x800b5f4 <spi_context_buffers_setup+0x15c> @ imm = #0x5c
 800b596: 4b19         	ldr	r3, [pc, #0x64]         @ 0x800b5fc <spi_context_buffers_setup+0x164>
 800b598: 681b         	ldr	r3, [r3]
 800b59a: 607b         	str	r3, [r7, #0x4]
 800b59c: 697b         	ldr	r3, [r7, #0x14]
 800b59e: 6b5b         	ldr	r3, [r3, #0x34]
 800b5a0: 697a         	ldr	r2, [r7, #0x14]
 800b5a2: 6b92         	ldr	r2, [r2, #0x38]
 800b5a4: 6979         	ldr	r1, [r7, #0x14]
 800b5a6: 6bc9         	ldr	r1, [r1, #0x3c]
 800b5a8: 6978         	ldr	r0, [r7, #0x14]
 800b5aa: 6c00         	ldr	r0, [r0, #0x40]
 800b5ac: 697c         	ldr	r4, [r7, #0x14]
 800b5ae: 6c64         	ldr	r4, [r4, #0x44]
 800b5b0: 697d         	ldr	r5, [r7, #0x14]
 800b5b2: 6cad         	ldr	r5, [r5, #0x48]
 800b5b4: 697e         	ldr	r6, [r7, #0x14]
 800b5b6: 6cf6         	ldr	r6, [r6, #0x4c]
 800b5b8: f8d7 c014    	ldr.w	r12, [r7, #0x14]
 800b5bc: f8dc c050    	ldr.w	r12, [r12, #0x50]
 800b5c0: f8cd c02c    	str.w	r12, [sp, #0x2c]
 800b5c4: 960a         	str	r6, [sp, #0x28]
 800b5c6: 9509         	str	r5, [sp, #0x24]
 800b5c8: 9408         	str	r4, [sp, #0x20]
 800b5ca: 9007         	str	r0, [sp, #0x1c]
 800b5cc: 9106         	str	r1, [sp, #0x18]
 800b5ce: 9205         	str	r2, [sp, #0x14]
 800b5d0: 9304         	str	r3, [sp, #0x10]
 800b5d2: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x800b600 <spi_context_buffers_setup+0x168>
 800b5d4: 9303         	str	r3, [sp, #0xc]
 800b5d6: 4b0c         	ldr	r3, [pc, #0x30]         @ 0x800b608 <spi_context_buffers_setup+0x170>
 800b5d8: 9302         	str	r3, [sp, #0x8]
 800b5da: 2308         	movs	r3, #0x8
 800b5dc: 9301         	str	r3, [sp, #0x4]
 800b5de: 2300         	movs	r3, #0x0
 800b5e0: 9300         	str	r3, [sp]
 800b5e2: 2300         	movs	r3, #0x0
 800b5e4: 2204         	movs	r2, #0x4
 800b5e6: 6879         	ldr	r1, [r7, #0x4]
 800b5e8: 2000         	movs	r0, #0x0
 800b5ea: f00f fb86    	bl	0x801acfa <z_log_msg_runtime_create> @ imm = #0xf70c
 800b5ee: 2300         	movs	r3, #0x0
 800b5f0: 61fb         	str	r3, [r7, #0x1c]
; }
 800b5f2: bf00         	nop
 800b5f4: bf00         	nop
 800b5f6: 372c         	adds	r7, #0x2c
 800b5f8: 46bd         	mov	sp, r7
 800b5fa: bdf0         	pop	{r4, r5, r6, r7, pc}

0800b5fc <$d>:
 800b5fc: 34 05 00 20  	.word	0x20000534
 800b600: c0 06 02 08  	.word	0x080206c0
 800b604: 44 f6 01 08  	.word	0x0801f644
 800b608: 68 f6 01 08  	.word	0x0801f668

0800b60c <spi_stm32_send_next_frame>:
; {
 800b60c: b580         	push	{r7, lr}
 800b60e: b09c         	sub	sp, #0x70
 800b610: af06         	add	r7, sp, #0x18
 800b612: 6078         	str	r0, [r7, #0x4]
 800b614: 6039         	str	r1, [r7]
; 	const uint8_t frame_size = SPI_WORD_SIZE_GET(data->ctx.config->operation);
 800b616: 683b         	ldr	r3, [r7]
 800b618: 681b         	ldr	r3, [r3]
 800b61a: 889b         	ldrh	r3, [r3, #0x4]
 800b61c: 095b         	lsrs	r3, r3, #0x5
 800b61e: b2db         	uxtb	r3, r3
 800b620: f003 033f    	and	r3, r3, #0x3f
 800b624: f887 3053    	strb.w	r3, [r7, #0x53]
; 	uint32_t tx_frame = SPI_STM32_TX_NOP;
 800b628: 2300         	movs	r3, #0x0
 800b62a: 657b         	str	r3, [r7, #0x54]
; 	if (frame_size == 8) {
 800b62c: f897 3053    	ldrb.w	r3, [r7, #0x53]
 800b630: 2b08         	cmp	r3, #0x8
 800b632: f040 80a8    	bne.w	0x800b786 <spi_stm32_send_next_frame+0x17a> @ imm = #0x150
; 		if (spi_context_tx_buf_on(&data->ctx)) {
 800b636: 683b         	ldr	r3, [r7]
 800b638: 647b         	str	r3, [r7, #0x44]
; 	return !!(ctx->tx_buf && ctx->tx_len);
 800b63a: 6c7b         	ldr	r3, [r7, #0x44]
 800b63c: 6c5b         	ldr	r3, [r3, #0x44]
 800b63e: 2b00         	cmp	r3, #0x0
 800b640: d005         	beq	0x800b64e <spi_stm32_send_next_frame+0x42> @ imm = #0xa
 800b642: 6c7b         	ldr	r3, [r7, #0x44]
 800b644: 6c9b         	ldr	r3, [r3, #0x48]
 800b646: 2b00         	cmp	r3, #0x0
 800b648: d001         	beq	0x800b64e <spi_stm32_send_next_frame+0x42> @ imm = #0x2
 800b64a: 2301         	movs	r3, #0x1
 800b64c: e000         	b	0x800b650 <spi_stm32_send_next_frame+0x44> @ imm = #0x0
 800b64e: 2300         	movs	r3, #0x0
 800b650: f003 0301    	and	r3, r3, #0x1
 800b654: b2db         	uxtb	r3, r3
; 		if (spi_context_tx_buf_on(&data->ctx)) {
 800b656: 2b00         	cmp	r3, #0x0
 800b658: d005         	beq	0x800b666 <spi_stm32_send_next_frame+0x5a> @ imm = #0xa
; 			tx_frame = UNALIGNED_GET((uint8_t *)(data->ctx.tx_buf));
 800b65a: 683b         	ldr	r3, [r7]
 800b65c: 6c5b         	ldr	r3, [r3, #0x44]
 800b65e: 64bb         	str	r3, [r7, #0x48]
 800b660: 6cbb         	ldr	r3, [r7, #0x48]
 800b662: 781b         	ldrb	r3, [r3]
 800b664: 657b         	str	r3, [r7, #0x54]
; 		LL_SPI_TransmitData8(spi, tx_frame);
 800b666: 6d7b         	ldr	r3, [r7, #0x54]
 800b668: b2db         	uxtb	r3, r3
 800b66a: 4619         	mov	r1, r3
 800b66c: 6878         	ldr	r0, [r7, #0x4]
 800b66e: f00f fd3c    	bl	0x801b0ea <LL_SPI_TransmitData8> @ imm = #0xfa78
; 		spi_context_update_tx(&data->ctx, 1, 1);
 800b672: 683b         	ldr	r3, [r7]
 800b674: 643b         	str	r3, [r7, #0x40]
 800b676: 2301         	movs	r3, #0x1
 800b678: f887 303f    	strb.w	r3, [r7, #0x3f]
 800b67c: 2301         	movs	r3, #0x1
 800b67e: 63bb         	str	r3, [r7, #0x38]
; 	if (!ctx->tx_len) {
 800b680: 6c3b         	ldr	r3, [r7, #0x40]
 800b682: 6c9b         	ldr	r3, [r3, #0x48]
 800b684: 2b00         	cmp	r3, #0x0
 800b686: f000 811d    	beq.w	0x800b8c4 <spi_stm32_send_next_frame+0x2b8> @ imm = #0x23a
; 	if (len > ctx->tx_len) {
 800b68a: 6c3b         	ldr	r3, [r7, #0x40]
 800b68c: 6c9b         	ldr	r3, [r3, #0x48]
 800b68e: 6bba         	ldr	r2, [r7, #0x38]
 800b690: 429a         	cmp	r2, r3
 800b692: d91d         	bls	0x800b6d0 <spi_stm32_send_next_frame+0xc4> @ imm = #0x3a
; 		LOG_ERR("Update exceeds current buffer");
 800b694: 2303         	movs	r3, #0x3
 800b696: 2b00         	cmp	r3, #0x0
 800b698: d019         	beq	0x800b6ce <spi_stm32_send_next_frame+0xc2> @ imm = #0x32
 800b69a: 2301         	movs	r3, #0x1
 800b69c: f887 3037    	strb.w	r3, [r7, #0x37]
 800b6a0: f897 3037    	ldrb.w	r3, [r7, #0x37]
 800b6a4: f083 0301    	eor	r3, r3, #0x1
 800b6a8: b2db         	uxtb	r3, r3
 800b6aa: 2b00         	cmp	r3, #0x0
 800b6ac: d10f         	bne	0x800b6ce <spi_stm32_send_next_frame+0xc2> @ imm = #0x1e
 800b6ae: 4b89         	ldr	r3, [pc, #0x224]        @ 0x800b8d4 <spi_stm32_send_next_frame+0x2c8>
 800b6b0: 6819         	ldr	r1, [r3]
 800b6b2: 4b89         	ldr	r3, [pc, #0x224]        @ 0x800b8d8 <spi_stm32_send_next_frame+0x2cc>
 800b6b4: 9302         	str	r3, [sp, #0x8]
 800b6b6: 2300         	movs	r3, #0x0
 800b6b8: 9301         	str	r3, [sp, #0x4]
 800b6ba: 2300         	movs	r3, #0x0
 800b6bc: 9300         	str	r3, [sp]
 800b6be: 2300         	movs	r3, #0x0
 800b6c0: 2201         	movs	r2, #0x1
 800b6c2: 2000         	movs	r0, #0x0
 800b6c4: f00f fb19    	bl	0x801acfa <z_log_msg_runtime_create> @ imm = #0xf632
 800b6c8: 2300         	movs	r3, #0x0
 800b6ca: 633b         	str	r3, [r7, #0x30]
; 		return;
 800b6cc: e0fd         	b	0x800b8ca <spi_stm32_send_next_frame+0x2be> @ imm = #0x1fa
 800b6ce: e0fc         	b	0x800b8ca <spi_stm32_send_next_frame+0x2be> @ imm = #0x1f8
; 	ctx->tx_len -= len;
 800b6d0: 6c3b         	ldr	r3, [r7, #0x40]
 800b6d2: 6c9a         	ldr	r2, [r3, #0x48]
 800b6d4: 6bbb         	ldr	r3, [r7, #0x38]
 800b6d6: 1ad2         	subs	r2, r2, r3
 800b6d8: 6c3b         	ldr	r3, [r7, #0x40]
 800b6da: 649a         	str	r2, [r3, #0x48]
; 	if (!ctx->tx_len) {
 800b6dc: 6c3b         	ldr	r3, [r7, #0x40]
 800b6de: 6c9b         	ldr	r3, [r3, #0x48]
 800b6e0: 2b00         	cmp	r3, #0x0
 800b6e2: d11b         	bne	0x800b71c <spi_stm32_send_next_frame+0x110> @ imm = #0x36
; 		++ctx->current_tx;
 800b6e4: 6c3b         	ldr	r3, [r7, #0x40]
 800b6e6: 6b5b         	ldr	r3, [r3, #0x34]
 800b6e8: f103 0208    	add.w	r2, r3, #0x8
 800b6ec: 6c3b         	ldr	r3, [r7, #0x40]
 800b6ee: 635a         	str	r2, [r3, #0x34]
; 		--ctx->tx_count;
 800b6f0: 6c3b         	ldr	r3, [r7, #0x40]
 800b6f2: 6b9b         	ldr	r3, [r3, #0x38]
 800b6f4: 1e5a         	subs	r2, r3, #0x1
 800b6f6: 6c3b         	ldr	r3, [r7, #0x40]
 800b6f8: 639a         	str	r2, [r3, #0x38]
; 			spi_context_get_next_buf(&ctx->current_tx,
 800b6fa: 6c3b         	ldr	r3, [r7, #0x40]
 800b6fc: f103 0034    	add.w	r0, r3, #0x34
 800b700: 6c3b         	ldr	r3, [r7, #0x40]
 800b702: f103 0138    	add.w	r1, r3, #0x38
 800b706: 6c3b         	ldr	r3, [r7, #0x40]
 800b708: f103 0248    	add.w	r2, r3, #0x48
 800b70c: f897 303f    	ldrb.w	r3, [r7, #0x3f]
 800b710: f00f ff5e    	bl	0x801b5d0 <spi_context_get_next_buf> @ imm = #0xfebc
 800b714: 4602         	mov	r2, r0
; 		ctx->tx_buf = (const uint8_t *)
 800b716: 6c3b         	ldr	r3, [r7, #0x40]
 800b718: 645a         	str	r2, [r3, #0x44]
 800b71a: e00d         	b	0x800b738 <spi_stm32_send_next_frame+0x12c> @ imm = #0x1a
; 	} else if (ctx->tx_buf) {
 800b71c: 6c3b         	ldr	r3, [r7, #0x40]
 800b71e: 6c5b         	ldr	r3, [r3, #0x44]
 800b720: 2b00         	cmp	r3, #0x0
 800b722: d009         	beq	0x800b738 <spi_stm32_send_next_frame+0x12c> @ imm = #0x12
; 		ctx->tx_buf += dfs * len;
 800b724: 6c3b         	ldr	r3, [r7, #0x40]
 800b726: 6c5a         	ldr	r2, [r3, #0x44]
 800b728: f897 303f    	ldrb.w	r3, [r7, #0x3f]
 800b72c: 6bb9         	ldr	r1, [r7, #0x38]
 800b72e: fb01 f303    	mul	r3, r1, r3
 800b732: 441a         	add	r2, r3
 800b734: 6c3b         	ldr	r3, [r7, #0x40]
 800b736: 645a         	str	r2, [r3, #0x44]
; 	LOG_DBG("tx buf/len %p/%zu", (void *)ctx->tx_buf, ctx->tx_len);
 800b738: 2303         	movs	r3, #0x3
 800b73a: 2b03         	cmp	r3, #0x3
 800b73c: f240 80c5    	bls.w	0x800b8ca <spi_stm32_send_next_frame+0x2be> @ imm = #0x18a
 800b740: 2301         	movs	r3, #0x1
 800b742: f887 302f    	strb.w	r3, [r7, #0x2f]
 800b746: f897 302f    	ldrb.w	r3, [r7, #0x2f]
 800b74a: f083 0301    	eor	r3, r3, #0x1
 800b74e: b2db         	uxtb	r3, r3
 800b750: 2b00         	cmp	r3, #0x0
 800b752: f040 80ba    	bne.w	0x800b8ca <spi_stm32_send_next_frame+0x2be> @ imm = #0x174
 800b756: 4b5f         	ldr	r3, [pc, #0x17c]        @ 0x800b8d4 <spi_stm32_send_next_frame+0x2c8>
 800b758: 6819         	ldr	r1, [r3]
 800b75a: 6c3b         	ldr	r3, [r7, #0x40]
 800b75c: 6c5b         	ldr	r3, [r3, #0x44]
 800b75e: 6c3a         	ldr	r2, [r7, #0x40]
 800b760: 6c92         	ldr	r2, [r2, #0x48]
 800b762: 9205         	str	r2, [sp, #0x14]
 800b764: 9304         	str	r3, [sp, #0x10]
 800b766: 4b5d         	ldr	r3, [pc, #0x174]        @ 0x800b8dc <spi_stm32_send_next_frame+0x2d0>
 800b768: 9303         	str	r3, [sp, #0xc]
 800b76a: 4b5d         	ldr	r3, [pc, #0x174]        @ 0x800b8e0 <spi_stm32_send_next_frame+0x2d4>
 800b76c: 9302         	str	r3, [sp, #0x8]
 800b76e: 2308         	movs	r3, #0x8
 800b770: 9301         	str	r3, [sp, #0x4]
 800b772: 2300         	movs	r3, #0x0
 800b774: 9300         	str	r3, [sp]
 800b776: 2300         	movs	r3, #0x0
 800b778: 2204         	movs	r2, #0x4
 800b77a: 2000         	movs	r0, #0x0
 800b77c: f00f fabd    	bl	0x801acfa <z_log_msg_runtime_create> @ imm = #0xf57a
 800b780: 2300         	movs	r3, #0x0
 800b782: 62bb         	str	r3, [r7, #0x28]
; }
 800b784: e0a1         	b	0x800b8ca <spi_stm32_send_next_frame+0x2be> @ imm = #0x142
; 		if (spi_context_tx_buf_on(&data->ctx)) {
 800b786: 683b         	ldr	r3, [r7]
 800b788: 627b         	str	r3, [r7, #0x24]
; 	return !!(ctx->tx_buf && ctx->tx_len);
 800b78a: 6a7b         	ldr	r3, [r7, #0x24]
 800b78c: 6c5b         	ldr	r3, [r3, #0x44]
 800b78e: 2b00         	cmp	r3, #0x0
 800b790: d005         	beq	0x800b79e <spi_stm32_send_next_frame+0x192> @ imm = #0xa
 800b792: 6a7b         	ldr	r3, [r7, #0x24]
 800b794: 6c9b         	ldr	r3, [r3, #0x48]
 800b796: 2b00         	cmp	r3, #0x0
 800b798: d001         	beq	0x800b79e <spi_stm32_send_next_frame+0x192> @ imm = #0x2
 800b79a: 2301         	movs	r3, #0x1
 800b79c: e000         	b	0x800b7a0 <spi_stm32_send_next_frame+0x194> @ imm = #0x0
 800b79e: 2300         	movs	r3, #0x0
 800b7a0: f003 0301    	and	r3, r3, #0x1
 800b7a4: b2db         	uxtb	r3, r3
; 		if (spi_context_tx_buf_on(&data->ctx)) {
 800b7a6: 2b00         	cmp	r3, #0x0
 800b7a8: d006         	beq	0x800b7b8 <spi_stm32_send_next_frame+0x1ac> @ imm = #0xc
; 			tx_frame = UNALIGNED_GET((uint16_t *)(data->ctx.tx_buf));
 800b7aa: 683b         	ldr	r3, [r7]
 800b7ac: 6c5b         	ldr	r3, [r3, #0x44]
 800b7ae: 64fb         	str	r3, [r7, #0x4c]
 800b7b0: 6cfb         	ldr	r3, [r7, #0x4c]
 800b7b2: 881b         	ldrh	r3, [r3]
 800b7b4: b29b         	uxth	r3, r3
 800b7b6: 657b         	str	r3, [r7, #0x54]
; 		LL_SPI_TransmitData16(spi, tx_frame);
 800b7b8: 6d7b         	ldr	r3, [r7, #0x54]
 800b7ba: b29b         	uxth	r3, r3
 800b7bc: 4619         	mov	r1, r3
 800b7be: 6878         	ldr	r0, [r7, #0x4]
 800b7c0: f00f fca4    	bl	0x801b10c <LL_SPI_TransmitData16> @ imm = #0xf948
; 		spi_context_update_tx(&data->ctx, 2, 1);
 800b7c4: 683b         	ldr	r3, [r7]
 800b7c6: 623b         	str	r3, [r7, #0x20]
 800b7c8: 2302         	movs	r3, #0x2
 800b7ca: 77fb         	strb	r3, [r7, #0x1f]
 800b7cc: 2301         	movs	r3, #0x1
 800b7ce: 61bb         	str	r3, [r7, #0x18]
; 	if (!ctx->tx_len) {
 800b7d0: 6a3b         	ldr	r3, [r7, #0x20]
 800b7d2: 6c9b         	ldr	r3, [r3, #0x48]
 800b7d4: 2b00         	cmp	r3, #0x0
 800b7d6: d077         	beq	0x800b8c8 <spi_stm32_send_next_frame+0x2bc> @ imm = #0xee
; 	if (len > ctx->tx_len) {
 800b7d8: 6a3b         	ldr	r3, [r7, #0x20]
 800b7da: 6c9b         	ldr	r3, [r3, #0x48]
 800b7dc: 69ba         	ldr	r2, [r7, #0x18]
 800b7de: 429a         	cmp	r2, r3
 800b7e0: d91b         	bls	0x800b81a <spi_stm32_send_next_frame+0x20e> @ imm = #0x36
; 		LOG_ERR("Update exceeds current buffer");
 800b7e2: 2303         	movs	r3, #0x3
 800b7e4: 2b00         	cmp	r3, #0x0
 800b7e6: d017         	beq	0x800b818 <spi_stm32_send_next_frame+0x20c> @ imm = #0x2e
 800b7e8: 2301         	movs	r3, #0x1
 800b7ea: 75fb         	strb	r3, [r7, #0x17]
 800b7ec: 7dfb         	ldrb	r3, [r7, #0x17]
 800b7ee: f083 0301    	eor	r3, r3, #0x1
 800b7f2: b2db         	uxtb	r3, r3
 800b7f4: 2b00         	cmp	r3, #0x0
 800b7f6: d10f         	bne	0x800b818 <spi_stm32_send_next_frame+0x20c> @ imm = #0x1e
 800b7f8: 4b36         	ldr	r3, [pc, #0xd8]         @ 0x800b8d4 <spi_stm32_send_next_frame+0x2c8>
 800b7fa: 6819         	ldr	r1, [r3]
 800b7fc: 4b36         	ldr	r3, [pc, #0xd8]         @ 0x800b8d8 <spi_stm32_send_next_frame+0x2cc>
 800b7fe: 9302         	str	r3, [sp, #0x8]
 800b800: 2300         	movs	r3, #0x0
 800b802: 9301         	str	r3, [sp, #0x4]
 800b804: 2300         	movs	r3, #0x0
 800b806: 9300         	str	r3, [sp]
 800b808: 2300         	movs	r3, #0x0
 800b80a: 2201         	movs	r2, #0x1
 800b80c: 2000         	movs	r0, #0x0
 800b80e: f00f fa74    	bl	0x801acfa <z_log_msg_runtime_create> @ imm = #0xf4e8
 800b812: 2300         	movs	r3, #0x0
 800b814: 613b         	str	r3, [r7, #0x10]
; 		return;
 800b816: e058         	b	0x800b8ca <spi_stm32_send_next_frame+0x2be> @ imm = #0xb0
 800b818: e057         	b	0x800b8ca <spi_stm32_send_next_frame+0x2be> @ imm = #0xae
; 	ctx->tx_len -= len;
 800b81a: 6a3b         	ldr	r3, [r7, #0x20]
 800b81c: 6c9a         	ldr	r2, [r3, #0x48]
 800b81e: 69bb         	ldr	r3, [r7, #0x18]
 800b820: 1ad2         	subs	r2, r2, r3
 800b822: 6a3b         	ldr	r3, [r7, #0x20]
 800b824: 649a         	str	r2, [r3, #0x48]
; 	if (!ctx->tx_len) {
 800b826: 6a3b         	ldr	r3, [r7, #0x20]
 800b828: 6c9b         	ldr	r3, [r3, #0x48]
 800b82a: 2b00         	cmp	r3, #0x0
 800b82c: d11a         	bne	0x800b864 <spi_stm32_send_next_frame+0x258> @ imm = #0x34
; 		++ctx->current_tx;
 800b82e: 6a3b         	ldr	r3, [r7, #0x20]
 800b830: 6b5b         	ldr	r3, [r3, #0x34]
 800b832: f103 0208    	add.w	r2, r3, #0x8
 800b836: 6a3b         	ldr	r3, [r7, #0x20]
 800b838: 635a         	str	r2, [r3, #0x34]
; 		--ctx->tx_count;
 800b83a: 6a3b         	ldr	r3, [r7, #0x20]
 800b83c: 6b9b         	ldr	r3, [r3, #0x38]
 800b83e: 1e5a         	subs	r2, r3, #0x1
 800b840: 6a3b         	ldr	r3, [r7, #0x20]
 800b842: 639a         	str	r2, [r3, #0x38]
; 			spi_context_get_next_buf(&ctx->current_tx,
 800b844: 6a3b         	ldr	r3, [r7, #0x20]
 800b846: f103 0034    	add.w	r0, r3, #0x34
 800b84a: 6a3b         	ldr	r3, [r7, #0x20]
 800b84c: f103 0138    	add.w	r1, r3, #0x38
 800b850: 6a3b         	ldr	r3, [r7, #0x20]
 800b852: f103 0248    	add.w	r2, r3, #0x48
 800b856: 7ffb         	ldrb	r3, [r7, #0x1f]
 800b858: f00f feba    	bl	0x801b5d0 <spi_context_get_next_buf> @ imm = #0xfd74
 800b85c: 4602         	mov	r2, r0
; 		ctx->tx_buf = (const uint8_t *)
 800b85e: 6a3b         	ldr	r3, [r7, #0x20]
 800b860: 645a         	str	r2, [r3, #0x44]
 800b862: e00c         	b	0x800b87e <spi_stm32_send_next_frame+0x272> @ imm = #0x18
; 	} else if (ctx->tx_buf) {
 800b864: 6a3b         	ldr	r3, [r7, #0x20]
 800b866: 6c5b         	ldr	r3, [r3, #0x44]
 800b868: 2b00         	cmp	r3, #0x0
 800b86a: d008         	beq	0x800b87e <spi_stm32_send_next_frame+0x272> @ imm = #0x10
; 		ctx->tx_buf += dfs * len;
 800b86c: 6a3b         	ldr	r3, [r7, #0x20]
 800b86e: 6c5a         	ldr	r2, [r3, #0x44]
 800b870: 7ffb         	ldrb	r3, [r7, #0x1f]
 800b872: 69b9         	ldr	r1, [r7, #0x18]
 800b874: fb01 f303    	mul	r3, r1, r3
 800b878: 441a         	add	r2, r3
 800b87a: 6a3b         	ldr	r3, [r7, #0x20]
 800b87c: 645a         	str	r2, [r3, #0x44]
; 	LOG_DBG("tx buf/len %p/%zu", (void *)ctx->tx_buf, ctx->tx_len);
 800b87e: 2303         	movs	r3, #0x3
 800b880: 2b03         	cmp	r3, #0x3
 800b882: d922         	bls	0x800b8ca <spi_stm32_send_next_frame+0x2be> @ imm = #0x44
 800b884: 2301         	movs	r3, #0x1
 800b886: 73fb         	strb	r3, [r7, #0xf]
 800b888: 7bfb         	ldrb	r3, [r7, #0xf]
 800b88a: f083 0301    	eor	r3, r3, #0x1
 800b88e: b2db         	uxtb	r3, r3
 800b890: 2b00         	cmp	r3, #0x0
 800b892: d11a         	bne	0x800b8ca <spi_stm32_send_next_frame+0x2be> @ imm = #0x34
 800b894: 4b0f         	ldr	r3, [pc, #0x3c]         @ 0x800b8d4 <spi_stm32_send_next_frame+0x2c8>
 800b896: 6819         	ldr	r1, [r3]
 800b898: 6a3b         	ldr	r3, [r7, #0x20]
 800b89a: 6c5b         	ldr	r3, [r3, #0x44]
 800b89c: 6a3a         	ldr	r2, [r7, #0x20]
 800b89e: 6c92         	ldr	r2, [r2, #0x48]
 800b8a0: 9205         	str	r2, [sp, #0x14]
 800b8a2: 9304         	str	r3, [sp, #0x10]
 800b8a4: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x800b8dc <spi_stm32_send_next_frame+0x2d0>
 800b8a6: 9303         	str	r3, [sp, #0xc]
 800b8a8: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x800b8e0 <spi_stm32_send_next_frame+0x2d4>
 800b8aa: 9302         	str	r3, [sp, #0x8]
 800b8ac: 2308         	movs	r3, #0x8
 800b8ae: 9301         	str	r3, [sp, #0x4]
 800b8b0: 2300         	movs	r3, #0x0
 800b8b2: 9300         	str	r3, [sp]
 800b8b4: 2300         	movs	r3, #0x0
 800b8b6: 2204         	movs	r2, #0x4
 800b8b8: 2000         	movs	r0, #0x0
 800b8ba: f00f fa1e    	bl	0x801acfa <z_log_msg_runtime_create> @ imm = #0xf43c
 800b8be: 2300         	movs	r3, #0x0
 800b8c0: 60bb         	str	r3, [r7, #0x8]
; }
 800b8c2: e002         	b	0x800b8ca <spi_stm32_send_next_frame+0x2be> @ imm = #0x4
; 		return;
 800b8c4: bf00         	nop
 800b8c6: e000         	b	0x800b8ca <spi_stm32_send_next_frame+0x2be> @ imm = #0x0
 800b8c8: bf00         	nop
; }
 800b8ca: bf00         	nop
 800b8cc: 3758         	adds	r7, #0x58
 800b8ce: 46bd         	mov	sp, r7
 800b8d0: bd80         	pop	{r7, pc}
 800b8d2: bf00         	nop

0800b8d4 <$d>:
 800b8d4: 34 05 00 20  	.word	0x20000534
 800b8d8: bc f6 01 08  	.word	0x0801f6bc
 800b8dc: 68 06 02 08  	.word	0x08020668
 800b8e0: dc f6 01 08  	.word	0x0801f6dc

0800b8e4 <spi_stm32_read_next_frame>:
; {
 800b8e4: b580         	push	{r7, lr}
 800b8e6: b09c         	sub	sp, #0x70
 800b8e8: af06         	add	r7, sp, #0x18
 800b8ea: 6078         	str	r0, [r7, #0x4]
 800b8ec: 6039         	str	r1, [r7]
; 	const uint8_t frame_size = SPI_WORD_SIZE_GET(data->ctx.config->operation);
 800b8ee: 683b         	ldr	r3, [r7]
 800b8f0: 681b         	ldr	r3, [r3]
 800b8f2: 889b         	ldrh	r3, [r3, #0x4]
 800b8f4: 095b         	lsrs	r3, r3, #0x5
 800b8f6: b2db         	uxtb	r3, r3
 800b8f8: f003 033f    	and	r3, r3, #0x3f
 800b8fc: f887 3057    	strb.w	r3, [r7, #0x57]
; 	uint32_t rx_frame = 0;
 800b900: 2300         	movs	r3, #0x0
 800b902: 653b         	str	r3, [r7, #0x50]
; 	if (frame_size == 8) {
 800b904: f897 3057    	ldrb.w	r3, [r7, #0x57]
 800b908: 2b08         	cmp	r3, #0x8
 800b90a: f040 80a8    	bne.w	0x800ba5e <spi_stm32_read_next_frame+0x17a> @ imm = #0x150
; 		rx_frame = LL_SPI_ReceiveData8(spi);
 800b90e: 6878         	ldr	r0, [r7, #0x4]
 800b910: f00f fbd2    	bl	0x801b0b8 <LL_SPI_ReceiveData8> @ imm = #0xf7a4
 800b914: 4603         	mov	r3, r0
 800b916: 653b         	str	r3, [r7, #0x50]
; 		if (spi_context_rx_buf_on(&data->ctx)) {
 800b918: 683b         	ldr	r3, [r7]
 800b91a: 647b         	str	r3, [r7, #0x44]
; 	return !!(ctx->rx_buf && ctx->rx_len);
 800b91c: 6c7b         	ldr	r3, [r7, #0x44]
 800b91e: 6cdb         	ldr	r3, [r3, #0x4c]
 800b920: 2b00         	cmp	r3, #0x0
 800b922: d005         	beq	0x800b930 <spi_stm32_read_next_frame+0x4c> @ imm = #0xa
 800b924: 6c7b         	ldr	r3, [r7, #0x44]
 800b926: 6d1b         	ldr	r3, [r3, #0x50]
 800b928: 2b00         	cmp	r3, #0x0
 800b92a: d001         	beq	0x800b930 <spi_stm32_read_next_frame+0x4c> @ imm = #0x2
 800b92c: 2301         	movs	r3, #0x1
 800b92e: e000         	b	0x800b932 <spi_stm32_read_next_frame+0x4e> @ imm = #0x0
 800b930: 2300         	movs	r3, #0x0
 800b932: f003 0301    	and	r3, r3, #0x1
 800b936: b2db         	uxtb	r3, r3
; 		if (spi_context_rx_buf_on(&data->ctx)) {
 800b938: 2b00         	cmp	r3, #0x0
 800b93a: d006         	beq	0x800b94a <spi_stm32_read_next_frame+0x66> @ imm = #0xc
; 			UNALIGNED_PUT(rx_frame, (uint8_t *)data->ctx.rx_buf);
 800b93c: 683b         	ldr	r3, [r7]
 800b93e: 6cdb         	ldr	r3, [r3, #0x4c]
 800b940: 64bb         	str	r3, [r7, #0x48]
 800b942: 6d3b         	ldr	r3, [r7, #0x50]
 800b944: b2da         	uxtb	r2, r3
 800b946: 6cbb         	ldr	r3, [r7, #0x48]
 800b948: 701a         	strb	r2, [r3]
; 		spi_context_update_rx(&data->ctx, 1, 1);
 800b94a: 683b         	ldr	r3, [r7]
 800b94c: 643b         	str	r3, [r7, #0x40]
 800b94e: 2301         	movs	r3, #0x1
 800b950: f887 303f    	strb.w	r3, [r7, #0x3f]
 800b954: 2301         	movs	r3, #0x1
 800b956: 63bb         	str	r3, [r7, #0x38]
; 	if (!ctx->rx_len) {
 800b958: 6c3b         	ldr	r3, [r7, #0x40]
 800b95a: 6d1b         	ldr	r3, [r3, #0x50]
 800b95c: 2b00         	cmp	r3, #0x0
 800b95e: f000 811c    	beq.w	0x800bb9a <spi_stm32_read_next_frame+0x2b6> @ imm = #0x238
; 	if (len > ctx->rx_len) {
 800b962: 6c3b         	ldr	r3, [r7, #0x40]
 800b964: 6d1b         	ldr	r3, [r3, #0x50]
 800b966: 6bba         	ldr	r2, [r7, #0x38]
 800b968: 429a         	cmp	r2, r3
 800b96a: d91d         	bls	0x800b9a8 <spi_stm32_read_next_frame+0xc4> @ imm = #0x3a
; 		LOG_ERR("Update exceeds current buffer");
 800b96c: 2303         	movs	r3, #0x3
 800b96e: 2b00         	cmp	r3, #0x0
 800b970: d019         	beq	0x800b9a6 <spi_stm32_read_next_frame+0xc2> @ imm = #0x32
 800b972: 2301         	movs	r3, #0x1
 800b974: f887 3037    	strb.w	r3, [r7, #0x37]
 800b978: f897 3037    	ldrb.w	r3, [r7, #0x37]
 800b97c: f083 0301    	eor	r3, r3, #0x1
 800b980: b2db         	uxtb	r3, r3
 800b982: 2b00         	cmp	r3, #0x0
 800b984: d10f         	bne	0x800b9a6 <spi_stm32_read_next_frame+0xc2> @ imm = #0x1e
 800b986: 4b88         	ldr	r3, [pc, #0x220]        @ 0x800bba8 <spi_stm32_read_next_frame+0x2c4>
 800b988: 6819         	ldr	r1, [r3]
 800b98a: 4b88         	ldr	r3, [pc, #0x220]        @ 0x800bbac <spi_stm32_read_next_frame+0x2c8>
 800b98c: 9302         	str	r3, [sp, #0x8]
 800b98e: 2300         	movs	r3, #0x0
 800b990: 9301         	str	r3, [sp, #0x4]
 800b992: 2300         	movs	r3, #0x0
 800b994: 9300         	str	r3, [sp]
 800b996: 2300         	movs	r3, #0x0
 800b998: 2201         	movs	r2, #0x1
 800b99a: 2000         	movs	r0, #0x0
 800b99c: f00f f9ad    	bl	0x801acfa <z_log_msg_runtime_create> @ imm = #0xf35a
 800b9a0: 2300         	movs	r3, #0x0
 800b9a2: 633b         	str	r3, [r7, #0x30]
; 		return;
 800b9a4: e0fc         	b	0x800bba0 <spi_stm32_read_next_frame+0x2bc> @ imm = #0x1f8
 800b9a6: e0fb         	b	0x800bba0 <spi_stm32_read_next_frame+0x2bc> @ imm = #0x1f6
; 	ctx->rx_len -= len;
 800b9a8: 6c3b         	ldr	r3, [r7, #0x40]
 800b9aa: 6d1a         	ldr	r2, [r3, #0x50]
 800b9ac: 6bbb         	ldr	r3, [r7, #0x38]
 800b9ae: 1ad2         	subs	r2, r2, r3
 800b9b0: 6c3b         	ldr	r3, [r7, #0x40]
 800b9b2: 651a         	str	r2, [r3, #0x50]
; 	if (!ctx->rx_len) {
 800b9b4: 6c3b         	ldr	r3, [r7, #0x40]
 800b9b6: 6d1b         	ldr	r3, [r3, #0x50]
 800b9b8: 2b00         	cmp	r3, #0x0
 800b9ba: d11b         	bne	0x800b9f4 <spi_stm32_read_next_frame+0x110> @ imm = #0x36
; 		++ctx->current_rx;
 800b9bc: 6c3b         	ldr	r3, [r7, #0x40]
 800b9be: 6bdb         	ldr	r3, [r3, #0x3c]
 800b9c0: f103 0208    	add.w	r2, r3, #0x8
 800b9c4: 6c3b         	ldr	r3, [r7, #0x40]
 800b9c6: 63da         	str	r2, [r3, #0x3c]
; 		--ctx->rx_count;
 800b9c8: 6c3b         	ldr	r3, [r7, #0x40]
 800b9ca: 6c1b         	ldr	r3, [r3, #0x40]
 800b9cc: 1e5a         	subs	r2, r3, #0x1
 800b9ce: 6c3b         	ldr	r3, [r7, #0x40]
 800b9d0: 641a         	str	r2, [r3, #0x40]
; 			spi_context_get_next_buf(&ctx->current_rx,
 800b9d2: 6c3b         	ldr	r3, [r7, #0x40]
 800b9d4: f103 003c    	add.w	r0, r3, #0x3c
 800b9d8: 6c3b         	ldr	r3, [r7, #0x40]
 800b9da: f103 0140    	add.w	r1, r3, #0x40
 800b9de: 6c3b         	ldr	r3, [r7, #0x40]
 800b9e0: f103 0250    	add.w	r2, r3, #0x50
 800b9e4: f897 303f    	ldrb.w	r3, [r7, #0x3f]
 800b9e8: f00f fdf2    	bl	0x801b5d0 <spi_context_get_next_buf> @ imm = #0xfbe4
 800b9ec: 4602         	mov	r2, r0
; 		ctx->rx_buf = (uint8_t *)
 800b9ee: 6c3b         	ldr	r3, [r7, #0x40]
 800b9f0: 64da         	str	r2, [r3, #0x4c]
 800b9f2: e00d         	b	0x800ba10 <spi_stm32_read_next_frame+0x12c> @ imm = #0x1a
; 	} else if (ctx->rx_buf) {
 800b9f4: 6c3b         	ldr	r3, [r7, #0x40]
 800b9f6: 6cdb         	ldr	r3, [r3, #0x4c]
 800b9f8: 2b00         	cmp	r3, #0x0
 800b9fa: d009         	beq	0x800ba10 <spi_stm32_read_next_frame+0x12c> @ imm = #0x12
; 		ctx->rx_buf += dfs * len;
 800b9fc: 6c3b         	ldr	r3, [r7, #0x40]
 800b9fe: 6cda         	ldr	r2, [r3, #0x4c]
 800ba00: f897 303f    	ldrb.w	r3, [r7, #0x3f]
 800ba04: 6bb9         	ldr	r1, [r7, #0x38]
 800ba06: fb01 f303    	mul	r3, r1, r3
 800ba0a: 441a         	add	r2, r3
 800ba0c: 6c3b         	ldr	r3, [r7, #0x40]
 800ba0e: 64da         	str	r2, [r3, #0x4c]
; 	LOG_DBG("rx buf/len %p/%zu", (void *)ctx->rx_buf, ctx->rx_len);
 800ba10: 2303         	movs	r3, #0x3
 800ba12: 2b03         	cmp	r3, #0x3
 800ba14: f240 80c4    	bls.w	0x800bba0 <spi_stm32_read_next_frame+0x2bc> @ imm = #0x188
 800ba18: 2301         	movs	r3, #0x1
 800ba1a: f887 302f    	strb.w	r3, [r7, #0x2f]
 800ba1e: f897 302f    	ldrb.w	r3, [r7, #0x2f]
 800ba22: f083 0301    	eor	r3, r3, #0x1
 800ba26: b2db         	uxtb	r3, r3
 800ba28: 2b00         	cmp	r3, #0x0
 800ba2a: f040 80b9    	bne.w	0x800bba0 <spi_stm32_read_next_frame+0x2bc> @ imm = #0x172
 800ba2e: 4b5e         	ldr	r3, [pc, #0x178]        @ 0x800bba8 <spi_stm32_read_next_frame+0x2c4>
 800ba30: 6819         	ldr	r1, [r3]
 800ba32: 6c3b         	ldr	r3, [r7, #0x40]
 800ba34: 6cdb         	ldr	r3, [r3, #0x4c]
 800ba36: 6c3a         	ldr	r2, [r7, #0x40]
 800ba38: 6d12         	ldr	r2, [r2, #0x50]
 800ba3a: 9205         	str	r2, [sp, #0x14]
 800ba3c: 9304         	str	r3, [sp, #0x10]
 800ba3e: 4b5c         	ldr	r3, [pc, #0x170]        @ 0x800bbb0 <spi_stm32_read_next_frame+0x2cc>
 800ba40: 9303         	str	r3, [sp, #0xc]
 800ba42: 4b5c         	ldr	r3, [pc, #0x170]        @ 0x800bbb4 <spi_stm32_read_next_frame+0x2d0>
 800ba44: 9302         	str	r3, [sp, #0x8]
 800ba46: 2308         	movs	r3, #0x8
 800ba48: 9301         	str	r3, [sp, #0x4]
 800ba4a: 2300         	movs	r3, #0x0
 800ba4c: 9300         	str	r3, [sp]
 800ba4e: 2300         	movs	r3, #0x0
 800ba50: 2204         	movs	r2, #0x4
 800ba52: 2000         	movs	r0, #0x0
 800ba54: f00f f951    	bl	0x801acfa <z_log_msg_runtime_create> @ imm = #0xf2a2
 800ba58: 2300         	movs	r3, #0x0
 800ba5a: 62bb         	str	r3, [r7, #0x28]
; }
 800ba5c: e0a0         	b	0x800bba0 <spi_stm32_read_next_frame+0x2bc> @ imm = #0x140
; 		rx_frame = LL_SPI_ReceiveData16(spi);
 800ba5e: 6878         	ldr	r0, [r7, #0x4]
 800ba60: f00f fb37    	bl	0x801b0d2 <LL_SPI_ReceiveData16> @ imm = #0xf66e
 800ba64: 4603         	mov	r3, r0
 800ba66: 653b         	str	r3, [r7, #0x50]
; 		if (spi_context_rx_buf_on(&data->ctx)) {
 800ba68: 683b         	ldr	r3, [r7]
 800ba6a: 627b         	str	r3, [r7, #0x24]
; 	return !!(ctx->rx_buf && ctx->rx_len);
 800ba6c: 6a7b         	ldr	r3, [r7, #0x24]
 800ba6e: 6cdb         	ldr	r3, [r3, #0x4c]
 800ba70: 2b00         	cmp	r3, #0x0
 800ba72: d005         	beq	0x800ba80 <spi_stm32_read_next_frame+0x19c> @ imm = #0xa
 800ba74: 6a7b         	ldr	r3, [r7, #0x24]
 800ba76: 6d1b         	ldr	r3, [r3, #0x50]
 800ba78: 2b00         	cmp	r3, #0x0
 800ba7a: d001         	beq	0x800ba80 <spi_stm32_read_next_frame+0x19c> @ imm = #0x2
 800ba7c: 2301         	movs	r3, #0x1
 800ba7e: e000         	b	0x800ba82 <spi_stm32_read_next_frame+0x19e> @ imm = #0x0
 800ba80: 2300         	movs	r3, #0x0
 800ba82: f003 0301    	and	r3, r3, #0x1
 800ba86: b2db         	uxtb	r3, r3
; 		if (spi_context_rx_buf_on(&data->ctx)) {
 800ba88: 2b00         	cmp	r3, #0x0
 800ba8a: d006         	beq	0x800ba9a <spi_stm32_read_next_frame+0x1b6> @ imm = #0xc
; 			UNALIGNED_PUT(rx_frame, (uint16_t *)data->ctx.rx_buf);
 800ba8c: 683b         	ldr	r3, [r7]
 800ba8e: 6cdb         	ldr	r3, [r3, #0x4c]
 800ba90: 64fb         	str	r3, [r7, #0x4c]
 800ba92: 6d3b         	ldr	r3, [r7, #0x50]
 800ba94: b29a         	uxth	r2, r3
 800ba96: 6cfb         	ldr	r3, [r7, #0x4c]
 800ba98: 801a         	strh	r2, [r3]
; 		spi_context_update_rx(&data->ctx, 2, 1);
 800ba9a: 683b         	ldr	r3, [r7]
 800ba9c: 623b         	str	r3, [r7, #0x20]
 800ba9e: 2302         	movs	r3, #0x2
 800baa0: 77fb         	strb	r3, [r7, #0x1f]
 800baa2: 2301         	movs	r3, #0x1
 800baa4: 61bb         	str	r3, [r7, #0x18]
; 	if (!ctx->rx_len) {
 800baa6: 6a3b         	ldr	r3, [r7, #0x20]
 800baa8: 6d1b         	ldr	r3, [r3, #0x50]
 800baaa: 2b00         	cmp	r3, #0x0
 800baac: d077         	beq	0x800bb9e <spi_stm32_read_next_frame+0x2ba> @ imm = #0xee
; 	if (len > ctx->rx_len) {
 800baae: 6a3b         	ldr	r3, [r7, #0x20]
 800bab0: 6d1b         	ldr	r3, [r3, #0x50]
 800bab2: 69ba         	ldr	r2, [r7, #0x18]
 800bab4: 429a         	cmp	r2, r3
 800bab6: d91b         	bls	0x800baf0 <spi_stm32_read_next_frame+0x20c> @ imm = #0x36
; 		LOG_ERR("Update exceeds current buffer");
 800bab8: 2303         	movs	r3, #0x3
 800baba: 2b00         	cmp	r3, #0x0
 800babc: d017         	beq	0x800baee <spi_stm32_read_next_frame+0x20a> @ imm = #0x2e
 800babe: 2301         	movs	r3, #0x1
 800bac0: 75fb         	strb	r3, [r7, #0x17]
 800bac2: 7dfb         	ldrb	r3, [r7, #0x17]
 800bac4: f083 0301    	eor	r3, r3, #0x1
 800bac8: b2db         	uxtb	r3, r3
 800baca: 2b00         	cmp	r3, #0x0
 800bacc: d10f         	bne	0x800baee <spi_stm32_read_next_frame+0x20a> @ imm = #0x1e
 800bace: 4b36         	ldr	r3, [pc, #0xd8]         @ 0x800bba8 <spi_stm32_read_next_frame+0x2c4>
 800bad0: 6819         	ldr	r1, [r3]
 800bad2: 4b36         	ldr	r3, [pc, #0xd8]         @ 0x800bbac <spi_stm32_read_next_frame+0x2c8>
 800bad4: 9302         	str	r3, [sp, #0x8]
 800bad6: 2300         	movs	r3, #0x0
 800bad8: 9301         	str	r3, [sp, #0x4]
 800bada: 2300         	movs	r3, #0x0
 800badc: 9300         	str	r3, [sp]
 800bade: 2300         	movs	r3, #0x0
 800bae0: 2201         	movs	r2, #0x1
 800bae2: 2000         	movs	r0, #0x0
 800bae4: f00f f909    	bl	0x801acfa <z_log_msg_runtime_create> @ imm = #0xf212
 800bae8: 2300         	movs	r3, #0x0
 800baea: 613b         	str	r3, [r7, #0x10]
; 		return;
 800baec: e058         	b	0x800bba0 <spi_stm32_read_next_frame+0x2bc> @ imm = #0xb0
 800baee: e057         	b	0x800bba0 <spi_stm32_read_next_frame+0x2bc> @ imm = #0xae
; 	ctx->rx_len -= len;
 800baf0: 6a3b         	ldr	r3, [r7, #0x20]
 800baf2: 6d1a         	ldr	r2, [r3, #0x50]
 800baf4: 69bb         	ldr	r3, [r7, #0x18]
 800baf6: 1ad2         	subs	r2, r2, r3
 800baf8: 6a3b         	ldr	r3, [r7, #0x20]
 800bafa: 651a         	str	r2, [r3, #0x50]
; 	if (!ctx->rx_len) {
 800bafc: 6a3b         	ldr	r3, [r7, #0x20]
 800bafe: 6d1b         	ldr	r3, [r3, #0x50]
 800bb00: 2b00         	cmp	r3, #0x0
 800bb02: d11a         	bne	0x800bb3a <spi_stm32_read_next_frame+0x256> @ imm = #0x34
; 		++ctx->current_rx;
 800bb04: 6a3b         	ldr	r3, [r7, #0x20]
 800bb06: 6bdb         	ldr	r3, [r3, #0x3c]
 800bb08: f103 0208    	add.w	r2, r3, #0x8
 800bb0c: 6a3b         	ldr	r3, [r7, #0x20]
 800bb0e: 63da         	str	r2, [r3, #0x3c]
; 		--ctx->rx_count;
 800bb10: 6a3b         	ldr	r3, [r7, #0x20]
 800bb12: 6c1b         	ldr	r3, [r3, #0x40]
 800bb14: 1e5a         	subs	r2, r3, #0x1
 800bb16: 6a3b         	ldr	r3, [r7, #0x20]
 800bb18: 641a         	str	r2, [r3, #0x40]
; 			spi_context_get_next_buf(&ctx->current_rx,
 800bb1a: 6a3b         	ldr	r3, [r7, #0x20]
 800bb1c: f103 003c    	add.w	r0, r3, #0x3c
 800bb20: 6a3b         	ldr	r3, [r7, #0x20]
 800bb22: f103 0140    	add.w	r1, r3, #0x40
 800bb26: 6a3b         	ldr	r3, [r7, #0x20]
 800bb28: f103 0250    	add.w	r2, r3, #0x50
 800bb2c: 7ffb         	ldrb	r3, [r7, #0x1f]
 800bb2e: f00f fd4f    	bl	0x801b5d0 <spi_context_get_next_buf> @ imm = #0xfa9e
 800bb32: 4602         	mov	r2, r0
; 		ctx->rx_buf = (uint8_t *)
 800bb34: 6a3b         	ldr	r3, [r7, #0x20]
 800bb36: 64da         	str	r2, [r3, #0x4c]
 800bb38: e00c         	b	0x800bb54 <spi_stm32_read_next_frame+0x270> @ imm = #0x18
; 	} else if (ctx->rx_buf) {
 800bb3a: 6a3b         	ldr	r3, [r7, #0x20]
 800bb3c: 6cdb         	ldr	r3, [r3, #0x4c]
 800bb3e: 2b00         	cmp	r3, #0x0
 800bb40: d008         	beq	0x800bb54 <spi_stm32_read_next_frame+0x270> @ imm = #0x10
; 		ctx->rx_buf += dfs * len;
 800bb42: 6a3b         	ldr	r3, [r7, #0x20]
 800bb44: 6cda         	ldr	r2, [r3, #0x4c]
 800bb46: 7ffb         	ldrb	r3, [r7, #0x1f]
 800bb48: 69b9         	ldr	r1, [r7, #0x18]
 800bb4a: fb01 f303    	mul	r3, r1, r3
 800bb4e: 441a         	add	r2, r3
 800bb50: 6a3b         	ldr	r3, [r7, #0x20]
 800bb52: 64da         	str	r2, [r3, #0x4c]
; 	LOG_DBG("rx buf/len %p/%zu", (void *)ctx->rx_buf, ctx->rx_len);
 800bb54: 2303         	movs	r3, #0x3
 800bb56: 2b03         	cmp	r3, #0x3
 800bb58: d922         	bls	0x800bba0 <spi_stm32_read_next_frame+0x2bc> @ imm = #0x44
 800bb5a: 2301         	movs	r3, #0x1
 800bb5c: 73fb         	strb	r3, [r7, #0xf]
 800bb5e: 7bfb         	ldrb	r3, [r7, #0xf]
 800bb60: f083 0301    	eor	r3, r3, #0x1
 800bb64: b2db         	uxtb	r3, r3
 800bb66: 2b00         	cmp	r3, #0x0
 800bb68: d11a         	bne	0x800bba0 <spi_stm32_read_next_frame+0x2bc> @ imm = #0x34
 800bb6a: 4b0f         	ldr	r3, [pc, #0x3c]         @ 0x800bba8 <spi_stm32_read_next_frame+0x2c4>
 800bb6c: 6819         	ldr	r1, [r3]
 800bb6e: 6a3b         	ldr	r3, [r7, #0x20]
 800bb70: 6cdb         	ldr	r3, [r3, #0x4c]
 800bb72: 6a3a         	ldr	r2, [r7, #0x20]
 800bb74: 6d12         	ldr	r2, [r2, #0x50]
 800bb76: 9205         	str	r2, [sp, #0x14]
 800bb78: 9304         	str	r3, [sp, #0x10]
 800bb7a: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x800bbb0 <spi_stm32_read_next_frame+0x2cc>
 800bb7c: 9303         	str	r3, [sp, #0xc]
 800bb7e: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x800bbb4 <spi_stm32_read_next_frame+0x2d0>
 800bb80: 9302         	str	r3, [sp, #0x8]
 800bb82: 2308         	movs	r3, #0x8
 800bb84: 9301         	str	r3, [sp, #0x4]
 800bb86: 2300         	movs	r3, #0x0
 800bb88: 9300         	str	r3, [sp]
 800bb8a: 2300         	movs	r3, #0x0
 800bb8c: 2204         	movs	r2, #0x4
 800bb8e: 2000         	movs	r0, #0x0
 800bb90: f00f f8b3    	bl	0x801acfa <z_log_msg_runtime_create> @ imm = #0xf166
 800bb94: 2300         	movs	r3, #0x0
 800bb96: 60bb         	str	r3, [r7, #0x8]
; }
 800bb98: e002         	b	0x800bba0 <spi_stm32_read_next_frame+0x2bc> @ imm = #0x4
; 		return;
 800bb9a: bf00         	nop
 800bb9c: e000         	b	0x800bba0 <spi_stm32_read_next_frame+0x2bc> @ imm = #0x0
 800bb9e: bf00         	nop
; }
 800bba0: bf00         	nop
 800bba2: 3758         	adds	r7, #0x58
 800bba4: 46bd         	mov	sp, r7
 800bba6: bd80         	pop	{r7, pc}

0800bba8 <$d>:
 800bba8: 34 05 00 20  	.word	0x20000534
 800bbac: bc f6 01 08  	.word	0x0801f6bc
 800bbb0: 80 06 02 08  	.word	0x08020680
 800bbb4: f4 f6 01 08  	.word	0x0801f6f4

0800bbb8 <spi_stm32_get_err>:
; {
 800bbb8: b580         	push	{r7, lr}
 800bbba: b08c         	sub	sp, #0x30
 800bbbc: af06         	add	r7, sp, #0x18
 800bbbe: 6078         	str	r0, [r7, #0x4]
; 	uint32_t sr = LL_SPI_ReadReg(spi, SR);
 800bbc0: 687b         	ldr	r3, [r7, #0x4]
 800bbc2: 689b         	ldr	r3, [r3, #0x8]
 800bbc4: 617b         	str	r3, [r7, #0x14]
; 	if (sr & SPI_STM32_ERR_MSK) {
 800bbc6: 697b         	ldr	r3, [r7, #0x14]
 800bbc8: f403 73b8    	and	r3, r3, #0x170
 800bbcc: 2b00         	cmp	r3, #0x0
 800bbce: d02b         	beq	0x800bc28 <spi_stm32_get_err+0x70> @ imm = #0x56
; 		LOG_ERR("%s: err=%d", __func__,
 800bbd0: 2303         	movs	r3, #0x3
 800bbd2: 2b00         	cmp	r3, #0x0
 800bbd4: d01c         	beq	0x800bc10 <spi_stm32_get_err+0x58> @ imm = #0x38
 800bbd6: 2301         	movs	r3, #0x1
 800bbd8: 74fb         	strb	r3, [r7, #0x13]
 800bbda: 7cfb         	ldrb	r3, [r7, #0x13]
 800bbdc: f083 0301    	eor	r3, r3, #0x1
 800bbe0: b2db         	uxtb	r3, r3
 800bbe2: 2b00         	cmp	r3, #0x0
 800bbe4: d114         	bne	0x800bc10 <spi_stm32_get_err+0x58> @ imm = #0x28
 800bbe6: 4b13         	ldr	r3, [pc, #0x4c]         @ 0x800bc34 <spi_stm32_get_err+0x7c>
 800bbe8: 6819         	ldr	r1, [r3]
 800bbea: 697b         	ldr	r3, [r7, #0x14]
 800bbec: f403 73b8    	and	r3, r3, #0x170
 800bbf0: 9304         	str	r3, [sp, #0x10]
 800bbf2: 4b11         	ldr	r3, [pc, #0x44]         @ 0x800bc38 <spi_stm32_get_err+0x80>
 800bbf4: 9303         	str	r3, [sp, #0xc]
 800bbf6: 4b11         	ldr	r3, [pc, #0x44]         @ 0x800bc3c <spi_stm32_get_err+0x84>
 800bbf8: 9302         	str	r3, [sp, #0x8]
 800bbfa: 2300         	movs	r3, #0x0
 800bbfc: 9301         	str	r3, [sp, #0x4]
 800bbfe: 2300         	movs	r3, #0x0
 800bc00: 9300         	str	r3, [sp]
 800bc02: 2300         	movs	r3, #0x0
 800bc04: 2201         	movs	r2, #0x1
 800bc06: 2000         	movs	r0, #0x0
 800bc08: f00f f877    	bl	0x801acfa <z_log_msg_runtime_create> @ imm = #0xf0ee
 800bc0c: 2300         	movs	r3, #0x0
 800bc0e: 60fb         	str	r3, [r7, #0xc]
; 		if (LL_SPI_IsActiveFlag_OVR(spi)) {
 800bc10: 6878         	ldr	r0, [r7, #0x4]
 800bc12: f00f f9fa    	bl	0x801b00a <LL_SPI_IsActiveFlag_OVR> @ imm = #0xf3f4
 800bc16: 4603         	mov	r3, r0
 800bc18: 2b00         	cmp	r3, #0x0
 800bc1a: d002         	beq	0x800bc22 <spi_stm32_get_err+0x6a> @ imm = #0x4
; 			LL_SPI_ClearFlag_OVR(spi);
 800bc1c: 6878         	ldr	r0, [r7, #0x4]
 800bc1e: f00f fa2b    	bl	0x801b078 <LL_SPI_ClearFlag_OVR> @ imm = #0xf456
; 		return -EIO;
 800bc22: f06f 0304    	mvn	r3, #0x4
 800bc26: e000         	b	0x800bc2a <spi_stm32_get_err+0x72> @ imm = #0x0
; 	return 0;
 800bc28: 2300         	movs	r3, #0x0
; }
 800bc2a: 4618         	mov	r0, r3
 800bc2c: 3718         	adds	r7, #0x18
 800bc2e: 46bd         	mov	sp, r7
 800bc30: bd80         	pop	{r7, pc}
 800bc32: bf00         	nop

0800bc34 <$d>:
 800bc34: 34 05 00 20  	.word	0x20000534
 800bc38: 98 06 02 08  	.word	0x08020698
 800bc3c: 0c f7 01 08  	.word	0x0801f70c

0800bc40 <spi_stm32_shift_s>:
; {
 800bc40: b580         	push	{r7, lr}
 800bc42: b0ac         	sub	sp, #0xb0
 800bc44: af06         	add	r7, sp, #0x18
 800bc46: 6078         	str	r0, [r7, #0x4]
 800bc48: 6039         	str	r1, [r7]
; 	if (ll_func_tx_is_not_full(spi) && spi_context_tx_on(&data->ctx)) {
 800bc4a: 6878         	ldr	r0, [r7, #0x4]
 800bc4c: f00f fcf2    	bl	0x801b634 <ll_func_tx_is_not_full> @ imm = #0xf9e4
 800bc50: 4603         	mov	r3, r0
 800bc52: 2b00         	cmp	r3, #0x0
 800bc54: f000 814a    	beq.w	0x800beec <spi_stm32_shift_s+0x2ac> @ imm = #0x294
 800bc58: 683b         	ldr	r3, [r7]
 800bc5a: 67fb         	str	r3, [r7, #0x7c]
; 	return !!(ctx->tx_len);
 800bc5c: 6ffb         	ldr	r3, [r7, #0x7c]
 800bc5e: 6c9b         	ldr	r3, [r3, #0x48]
 800bc60: 2b00         	cmp	r3, #0x0
 800bc62: bf14         	ite	ne
 800bc64: 2301         	movne	r3, #0x1
 800bc66: 2300         	moveq	r3, #0x0
 800bc68: b2db         	uxtb	r3, r3
; 	if (ll_func_tx_is_not_full(spi) && spi_context_tx_on(&data->ctx)) {
 800bc6a: 2b00         	cmp	r3, #0x0
 800bc6c: f000 813e    	beq.w	0x800beec <spi_stm32_shift_s+0x2ac> @ imm = #0x27c
; 		if (SPI_WORD_SIZE_GET(data->ctx.config->operation) == 8) {
 800bc70: 683b         	ldr	r3, [r7]
 800bc72: 681b         	ldr	r3, [r3]
 800bc74: 889b         	ldrh	r3, [r3, #0x4]
 800bc76: 095b         	lsrs	r3, r3, #0x5
 800bc78: f003 033f    	and	r3, r3, #0x3f
 800bc7c: 2b08         	cmp	r3, #0x8
 800bc7e: f040 809a    	bne.w	0x800bdb6 <spi_stm32_shift_s+0x176> @ imm = #0x134
; 			tx_frame = UNALIGNED_GET((uint8_t *)(data->ctx.tx_buf));
 800bc82: 683b         	ldr	r3, [r7]
 800bc84: 6c5b         	ldr	r3, [r3, #0x44]
 800bc86: f8c7 308c    	str.w	r3, [r7, #0x8c]
 800bc8a: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 800bc8e: 781b         	ldrb	r3, [r3]
 800bc90: f8a7 3092    	strh.w	r3, [r7, #0x92]
; 			LL_SPI_TransmitData8(spi, tx_frame);
 800bc94: f8b7 3092    	ldrh.w	r3, [r7, #0x92]
 800bc98: b2db         	uxtb	r3, r3
 800bc9a: 4619         	mov	r1, r3
 800bc9c: 6878         	ldr	r0, [r7, #0x4]
 800bc9e: f00f fa24    	bl	0x801b0ea <LL_SPI_TransmitData8> @ imm = #0xf448
; 			spi_context_update_tx(&data->ctx, 1, 1);
 800bca2: 683b         	ldr	r3, [r7]
 800bca4: 67bb         	str	r3, [r7, #0x78]
 800bca6: 2301         	movs	r3, #0x1
 800bca8: f887 3077    	strb.w	r3, [r7, #0x77]
 800bcac: 2301         	movs	r3, #0x1
 800bcae: 673b         	str	r3, [r7, #0x70]
; 	if (!ctx->tx_len) {
 800bcb0: 6fbb         	ldr	r3, [r7, #0x78]
 800bcb2: 6c9b         	ldr	r3, [r3, #0x48]
 800bcb4: 2b00         	cmp	r3, #0x0
 800bcb6: f000 8115    	beq.w	0x800bee4 <spi_stm32_shift_s+0x2a4> @ imm = #0x22a
; 	if (len > ctx->tx_len) {
 800bcba: 6fbb         	ldr	r3, [r7, #0x78]
 800bcbc: 6c9b         	ldr	r3, [r3, #0x48]
 800bcbe: 6f3a         	ldr	r2, [r7, #0x70]
 800bcc0: 429a         	cmp	r2, r3
 800bcc2: d91d         	bls	0x800bd00 <spi_stm32_shift_s+0xc0> @ imm = #0x3a
; 		LOG_ERR("Update exceeds current buffer");
 800bcc4: 2303         	movs	r3, #0x3
 800bcc6: 2b00         	cmp	r3, #0x0
 800bcc8: d019         	beq	0x800bcfe <spi_stm32_shift_s+0xbe> @ imm = #0x32
 800bcca: 2301         	movs	r3, #0x1
 800bccc: f887 306f    	strb.w	r3, [r7, #0x6f]
 800bcd0: f897 306f    	ldrb.w	r3, [r7, #0x6f]
 800bcd4: f083 0301    	eor	r3, r3, #0x1
 800bcd8: b2db         	uxtb	r3, r3
 800bcda: 2b00         	cmp	r3, #0x0
 800bcdc: d10f         	bne	0x800bcfe <spi_stm32_shift_s+0xbe> @ imm = #0x1e
 800bcde: 4b8e         	ldr	r3, [pc, #0x238]        @ 0x800bf18 <spi_stm32_shift_s+0x2d8>
 800bce0: 6819         	ldr	r1, [r3]
 800bce2: 4b8e         	ldr	r3, [pc, #0x238]        @ 0x800bf1c <spi_stm32_shift_s+0x2dc>
 800bce4: 9302         	str	r3, [sp, #0x8]
 800bce6: 2300         	movs	r3, #0x0
 800bce8: 9301         	str	r3, [sp, #0x4]
 800bcea: 2300         	movs	r3, #0x0
 800bcec: 9300         	str	r3, [sp]
 800bcee: 2300         	movs	r3, #0x0
 800bcf0: 2201         	movs	r2, #0x1
 800bcf2: 2000         	movs	r0, #0x0
 800bcf4: f00f f801    	bl	0x801acfa <z_log_msg_runtime_create> @ imm = #0xf002
 800bcf8: 2300         	movs	r3, #0x0
 800bcfa: 66bb         	str	r3, [r7, #0x68]
; 		return;
 800bcfc: e0f5         	b	0x800beea <spi_stm32_shift_s+0x2aa> @ imm = #0x1ea
 800bcfe: e0f4         	b	0x800beea <spi_stm32_shift_s+0x2aa> @ imm = #0x1e8
; 	ctx->tx_len -= len;
 800bd00: 6fbb         	ldr	r3, [r7, #0x78]
 800bd02: 6c9a         	ldr	r2, [r3, #0x48]
 800bd04: 6f3b         	ldr	r3, [r7, #0x70]
 800bd06: 1ad2         	subs	r2, r2, r3
 800bd08: 6fbb         	ldr	r3, [r7, #0x78]
 800bd0a: 649a         	str	r2, [r3, #0x48]
; 	if (!ctx->tx_len) {
 800bd0c: 6fbb         	ldr	r3, [r7, #0x78]
 800bd0e: 6c9b         	ldr	r3, [r3, #0x48]
 800bd10: 2b00         	cmp	r3, #0x0
 800bd12: d11b         	bne	0x800bd4c <spi_stm32_shift_s+0x10c> @ imm = #0x36
; 		++ctx->current_tx;
 800bd14: 6fbb         	ldr	r3, [r7, #0x78]
 800bd16: 6b5b         	ldr	r3, [r3, #0x34]
 800bd18: f103 0208    	add.w	r2, r3, #0x8
 800bd1c: 6fbb         	ldr	r3, [r7, #0x78]
 800bd1e: 635a         	str	r2, [r3, #0x34]
; 		--ctx->tx_count;
 800bd20: 6fbb         	ldr	r3, [r7, #0x78]
 800bd22: 6b9b         	ldr	r3, [r3, #0x38]
 800bd24: 1e5a         	subs	r2, r3, #0x1
 800bd26: 6fbb         	ldr	r3, [r7, #0x78]
 800bd28: 639a         	str	r2, [r3, #0x38]
; 			spi_context_get_next_buf(&ctx->current_tx,
 800bd2a: 6fbb         	ldr	r3, [r7, #0x78]
 800bd2c: f103 0034    	add.w	r0, r3, #0x34
 800bd30: 6fbb         	ldr	r3, [r7, #0x78]
 800bd32: f103 0138    	add.w	r1, r3, #0x38
 800bd36: 6fbb         	ldr	r3, [r7, #0x78]
 800bd38: f103 0248    	add.w	r2, r3, #0x48
 800bd3c: f897 3077    	ldrb.w	r3, [r7, #0x77]
 800bd40: f00f fc46    	bl	0x801b5d0 <spi_context_get_next_buf> @ imm = #0xf88c
 800bd44: 4602         	mov	r2, r0
; 		ctx->tx_buf = (const uint8_t *)
 800bd46: 6fbb         	ldr	r3, [r7, #0x78]
 800bd48: 645a         	str	r2, [r3, #0x44]
 800bd4a: e00d         	b	0x800bd68 <spi_stm32_shift_s+0x128> @ imm = #0x1a
; 	} else if (ctx->tx_buf) {
 800bd4c: 6fbb         	ldr	r3, [r7, #0x78]
 800bd4e: 6c5b         	ldr	r3, [r3, #0x44]
 800bd50: 2b00         	cmp	r3, #0x0
 800bd52: d009         	beq	0x800bd68 <spi_stm32_shift_s+0x128> @ imm = #0x12
; 		ctx->tx_buf += dfs * len;
 800bd54: 6fbb         	ldr	r3, [r7, #0x78]
 800bd56: 6c5a         	ldr	r2, [r3, #0x44]
 800bd58: f897 3077    	ldrb.w	r3, [r7, #0x77]
 800bd5c: 6f39         	ldr	r1, [r7, #0x70]
 800bd5e: fb01 f303    	mul	r3, r1, r3
 800bd62: 441a         	add	r2, r3
 800bd64: 6fbb         	ldr	r3, [r7, #0x78]
 800bd66: 645a         	str	r2, [r3, #0x44]
; 	LOG_DBG("tx buf/len %p/%zu", (void *)ctx->tx_buf, ctx->tx_len);
 800bd68: 2303         	movs	r3, #0x3
 800bd6a: 2b03         	cmp	r3, #0x3
 800bd6c: f240 80bd    	bls.w	0x800beea <spi_stm32_shift_s+0x2aa> @ imm = #0x17a
 800bd70: 2301         	movs	r3, #0x1
 800bd72: f887 3067    	strb.w	r3, [r7, #0x67]
 800bd76: f897 3067    	ldrb.w	r3, [r7, #0x67]
 800bd7a: f083 0301    	eor	r3, r3, #0x1
 800bd7e: b2db         	uxtb	r3, r3
 800bd80: 2b00         	cmp	r3, #0x0
 800bd82: f040 80b2    	bne.w	0x800beea <spi_stm32_shift_s+0x2aa> @ imm = #0x164
 800bd86: 4b64         	ldr	r3, [pc, #0x190]        @ 0x800bf18 <spi_stm32_shift_s+0x2d8>
 800bd88: 6819         	ldr	r1, [r3]
 800bd8a: 6fbb         	ldr	r3, [r7, #0x78]
 800bd8c: 6c5b         	ldr	r3, [r3, #0x44]
 800bd8e: 6fba         	ldr	r2, [r7, #0x78]
 800bd90: 6c92         	ldr	r2, [r2, #0x48]
 800bd92: 9205         	str	r2, [sp, #0x14]
 800bd94: 9304         	str	r3, [sp, #0x10]
 800bd96: 4b62         	ldr	r3, [pc, #0x188]        @ 0x800bf20 <spi_stm32_shift_s+0x2e0>
 800bd98: 9303         	str	r3, [sp, #0xc]
 800bd9a: 4b62         	ldr	r3, [pc, #0x188]        @ 0x800bf24 <spi_stm32_shift_s+0x2e4>
 800bd9c: 9302         	str	r3, [sp, #0x8]
 800bd9e: 2308         	movs	r3, #0x8
 800bda0: 9301         	str	r3, [sp, #0x4]
 800bda2: 2300         	movs	r3, #0x0
 800bda4: 9300         	str	r3, [sp]
 800bda6: 2300         	movs	r3, #0x0
 800bda8: 2204         	movs	r2, #0x4
 800bdaa: 2000         	movs	r0, #0x0
 800bdac: f00e ffa5    	bl	0x801acfa <z_log_msg_runtime_create> @ imm = #0xef4a
 800bdb0: 2300         	movs	r3, #0x0
 800bdb2: 663b         	str	r3, [r7, #0x60]
; 	if (ll_func_tx_is_not_full(spi) && spi_context_tx_on(&data->ctx)) {
 800bdb4: e09d         	b	0x800bef2 <spi_stm32_shift_s+0x2b2> @ imm = #0x13a
; 			tx_frame = UNALIGNED_GET((uint16_t *)(data->ctx.tx_buf));
 800bdb6: 683b         	ldr	r3, [r7]
 800bdb8: 6c5b         	ldr	r3, [r3, #0x44]
 800bdba: f8c7 3094    	str.w	r3, [r7, #0x94]
 800bdbe: f8d7 3094    	ldr.w	r3, [r7, #0x94]
 800bdc2: 881b         	ldrh	r3, [r3]
 800bdc4: b29b         	uxth	r3, r3
 800bdc6: f8a7 3092    	strh.w	r3, [r7, #0x92]
; 			LL_SPI_TransmitData16(spi, tx_frame);
 800bdca: f8b7 3092    	ldrh.w	r3, [r7, #0x92]
 800bdce: 4619         	mov	r1, r3
 800bdd0: 6878         	ldr	r0, [r7, #0x4]
 800bdd2: f00f f99b    	bl	0x801b10c <LL_SPI_TransmitData16> @ imm = #0xf336
; 			spi_context_update_tx(&data->ctx, 2, 1);
 800bdd6: 683b         	ldr	r3, [r7]
 800bdd8: 65fb         	str	r3, [r7, #0x5c]
 800bdda: 2302         	movs	r3, #0x2
 800bddc: f887 305b    	strb.w	r3, [r7, #0x5b]
 800bde0: 2301         	movs	r3, #0x1
 800bde2: 657b         	str	r3, [r7, #0x54]
; 	if (!ctx->tx_len) {
 800bde4: 6dfb         	ldr	r3, [r7, #0x5c]
 800bde6: 6c9b         	ldr	r3, [r3, #0x48]
 800bde8: 2b00         	cmp	r3, #0x0
 800bdea: d07d         	beq	0x800bee8 <spi_stm32_shift_s+0x2a8> @ imm = #0xfa
; 	if (len > ctx->tx_len) {
 800bdec: 6dfb         	ldr	r3, [r7, #0x5c]
 800bdee: 6c9b         	ldr	r3, [r3, #0x48]
 800bdf0: 6d7a         	ldr	r2, [r7, #0x54]
 800bdf2: 429a         	cmp	r2, r3
 800bdf4: d91d         	bls	0x800be32 <spi_stm32_shift_s+0x1f2> @ imm = #0x3a
; 		LOG_ERR("Update exceeds current buffer");
 800bdf6: 2303         	movs	r3, #0x3
 800bdf8: 2b00         	cmp	r3, #0x0
 800bdfa: d019         	beq	0x800be30 <spi_stm32_shift_s+0x1f0> @ imm = #0x32
 800bdfc: 2301         	movs	r3, #0x1
 800bdfe: f887 3053    	strb.w	r3, [r7, #0x53]
 800be02: f897 3053    	ldrb.w	r3, [r7, #0x53]
 800be06: f083 0301    	eor	r3, r3, #0x1
 800be0a: b2db         	uxtb	r3, r3
 800be0c: 2b00         	cmp	r3, #0x0
 800be0e: d10f         	bne	0x800be30 <spi_stm32_shift_s+0x1f0> @ imm = #0x1e
 800be10: 4b41         	ldr	r3, [pc, #0x104]        @ 0x800bf18 <spi_stm32_shift_s+0x2d8>
 800be12: 6819         	ldr	r1, [r3]
 800be14: 4b41         	ldr	r3, [pc, #0x104]        @ 0x800bf1c <spi_stm32_shift_s+0x2dc>
 800be16: 9302         	str	r3, [sp, #0x8]
 800be18: 2300         	movs	r3, #0x0
 800be1a: 9301         	str	r3, [sp, #0x4]
 800be1c: 2300         	movs	r3, #0x0
 800be1e: 9300         	str	r3, [sp]
 800be20: 2300         	movs	r3, #0x0
 800be22: 2201         	movs	r2, #0x1
 800be24: 2000         	movs	r0, #0x0
 800be26: f00e ff68    	bl	0x801acfa <z_log_msg_runtime_create> @ imm = #0xeed0
 800be2a: 2300         	movs	r3, #0x0
 800be2c: 64fb         	str	r3, [r7, #0x4c]
; 		return;
 800be2e: e05c         	b	0x800beea <spi_stm32_shift_s+0x2aa> @ imm = #0xb8
 800be30: e05b         	b	0x800beea <spi_stm32_shift_s+0x2aa> @ imm = #0xb6
; 	ctx->tx_len -= len;
 800be32: 6dfb         	ldr	r3, [r7, #0x5c]
 800be34: 6c9a         	ldr	r2, [r3, #0x48]
 800be36: 6d7b         	ldr	r3, [r7, #0x54]
 800be38: 1ad2         	subs	r2, r2, r3
 800be3a: 6dfb         	ldr	r3, [r7, #0x5c]
 800be3c: 649a         	str	r2, [r3, #0x48]
; 	if (!ctx->tx_len) {
 800be3e: 6dfb         	ldr	r3, [r7, #0x5c]
 800be40: 6c9b         	ldr	r3, [r3, #0x48]
 800be42: 2b00         	cmp	r3, #0x0
 800be44: d11b         	bne	0x800be7e <spi_stm32_shift_s+0x23e> @ imm = #0x36
; 		++ctx->current_tx;
 800be46: 6dfb         	ldr	r3, [r7, #0x5c]
 800be48: 6b5b         	ldr	r3, [r3, #0x34]
 800be4a: f103 0208    	add.w	r2, r3, #0x8
 800be4e: 6dfb         	ldr	r3, [r7, #0x5c]
 800be50: 635a         	str	r2, [r3, #0x34]
; 		--ctx->tx_count;
 800be52: 6dfb         	ldr	r3, [r7, #0x5c]
 800be54: 6b9b         	ldr	r3, [r3, #0x38]
 800be56: 1e5a         	subs	r2, r3, #0x1
 800be58: 6dfb         	ldr	r3, [r7, #0x5c]
 800be5a: 639a         	str	r2, [r3, #0x38]
; 			spi_context_get_next_buf(&ctx->current_tx,
 800be5c: 6dfb         	ldr	r3, [r7, #0x5c]
 800be5e: f103 0034    	add.w	r0, r3, #0x34
 800be62: 6dfb         	ldr	r3, [r7, #0x5c]
 800be64: f103 0138    	add.w	r1, r3, #0x38
 800be68: 6dfb         	ldr	r3, [r7, #0x5c]
 800be6a: f103 0248    	add.w	r2, r3, #0x48
 800be6e: f897 305b    	ldrb.w	r3, [r7, #0x5b]
 800be72: f00f fbad    	bl	0x801b5d0 <spi_context_get_next_buf> @ imm = #0xf75a
 800be76: 4602         	mov	r2, r0
; 		ctx->tx_buf = (const uint8_t *)
 800be78: 6dfb         	ldr	r3, [r7, #0x5c]
 800be7a: 645a         	str	r2, [r3, #0x44]
 800be7c: e00d         	b	0x800be9a <spi_stm32_shift_s+0x25a> @ imm = #0x1a
; 	} else if (ctx->tx_buf) {
 800be7e: 6dfb         	ldr	r3, [r7, #0x5c]
 800be80: 6c5b         	ldr	r3, [r3, #0x44]
 800be82: 2b00         	cmp	r3, #0x0
 800be84: d009         	beq	0x800be9a <spi_stm32_shift_s+0x25a> @ imm = #0x12
; 		ctx->tx_buf += dfs * len;
 800be86: 6dfb         	ldr	r3, [r7, #0x5c]
 800be88: 6c5a         	ldr	r2, [r3, #0x44]
 800be8a: f897 305b    	ldrb.w	r3, [r7, #0x5b]
 800be8e: 6d79         	ldr	r1, [r7, #0x54]
 800be90: fb01 f303    	mul	r3, r1, r3
 800be94: 441a         	add	r2, r3
 800be96: 6dfb         	ldr	r3, [r7, #0x5c]
 800be98: 645a         	str	r2, [r3, #0x44]
; 	LOG_DBG("tx buf/len %p/%zu", (void *)ctx->tx_buf, ctx->tx_len);
 800be9a: 2303         	movs	r3, #0x3
 800be9c: 2b03         	cmp	r3, #0x3
 800be9e: d924         	bls	0x800beea <spi_stm32_shift_s+0x2aa> @ imm = #0x48
 800bea0: 2301         	movs	r3, #0x1
 800bea2: f887 304b    	strb.w	r3, [r7, #0x4b]
 800bea6: f897 304b    	ldrb.w	r3, [r7, #0x4b]
 800beaa: f083 0301    	eor	r3, r3, #0x1
 800beae: b2db         	uxtb	r3, r3
 800beb0: 2b00         	cmp	r3, #0x0
 800beb2: d11a         	bne	0x800beea <spi_stm32_shift_s+0x2aa> @ imm = #0x34
 800beb4: 4b18         	ldr	r3, [pc, #0x60]         @ 0x800bf18 <spi_stm32_shift_s+0x2d8>
 800beb6: 6819         	ldr	r1, [r3]
 800beb8: 6dfb         	ldr	r3, [r7, #0x5c]
 800beba: 6c5b         	ldr	r3, [r3, #0x44]
 800bebc: 6dfa         	ldr	r2, [r7, #0x5c]
 800bebe: 6c92         	ldr	r2, [r2, #0x48]
 800bec0: 9205         	str	r2, [sp, #0x14]
 800bec2: 9304         	str	r3, [sp, #0x10]
 800bec4: 4b16         	ldr	r3, [pc, #0x58]         @ 0x800bf20 <spi_stm32_shift_s+0x2e0>
 800bec6: 9303         	str	r3, [sp, #0xc]
 800bec8: 4b16         	ldr	r3, [pc, #0x58]         @ 0x800bf24 <spi_stm32_shift_s+0x2e4>
 800beca: 9302         	str	r3, [sp, #0x8]
 800becc: 2308         	movs	r3, #0x8
 800bece: 9301         	str	r3, [sp, #0x4]
 800bed0: 2300         	movs	r3, #0x0
 800bed2: 9300         	str	r3, [sp]
 800bed4: 2300         	movs	r3, #0x0
 800bed6: 2204         	movs	r2, #0x4
 800bed8: 2000         	movs	r0, #0x0
 800beda: f00e ff0e    	bl	0x801acfa <z_log_msg_runtime_create> @ imm = #0xee1c
 800bede: 2300         	movs	r3, #0x0
 800bee0: 647b         	str	r3, [r7, #0x44]
; 	if (ll_func_tx_is_not_full(spi) && spi_context_tx_on(&data->ctx)) {
 800bee2: e006         	b	0x800bef2 <spi_stm32_shift_s+0x2b2> @ imm = #0xc
; 		return;
 800bee4: bf00         	nop
 800bee6: e004         	b	0x800bef2 <spi_stm32_shift_s+0x2b2> @ imm = #0x8
 800bee8: bf00         	nop
; 	if (ll_func_tx_is_not_full(spi) && spi_context_tx_on(&data->ctx)) {
 800beea: e002         	b	0x800bef2 <spi_stm32_shift_s+0x2b2> @ imm = #0x4
; 		ll_func_disable_int_tx_empty(spi);
 800beec: 6878         	ldr	r0, [r7, #0x4]
 800beee: f00f fbb9    	bl	0x801b664 <ll_func_disable_int_tx_empty> @ imm = #0xf772
; 	if (ll_func_rx_is_not_empty(spi) &&
 800bef2: 6878         	ldr	r0, [r7, #0x4]
 800bef4: f00f fbaa    	bl	0x801b64c <ll_func_rx_is_not_empty> @ imm = #0xf754
 800bef8: 4603         	mov	r3, r0
 800befa: 2b00         	cmp	r3, #0x0
 800befc: f000 8150    	beq.w	0x800c1a0 <spi_stm32_shift_s+0x560> @ imm = #0x2a0
; 	    spi_context_rx_buf_on(&data->ctx)) {
 800bf00: 683b         	ldr	r3, [r7]
 800bf02: 643b         	str	r3, [r7, #0x40]
; 	return !!(ctx->rx_buf && ctx->rx_len);
 800bf04: 6c3b         	ldr	r3, [r7, #0x40]
 800bf06: 6cdb         	ldr	r3, [r3, #0x4c]
 800bf08: 2b00         	cmp	r3, #0x0
 800bf0a: d00d         	beq	0x800bf28 <spi_stm32_shift_s+0x2e8> @ imm = #0x1a
 800bf0c: 6c3b         	ldr	r3, [r7, #0x40]
 800bf0e: 6d1b         	ldr	r3, [r3, #0x50]
 800bf10: 2b00         	cmp	r3, #0x0
 800bf12: d009         	beq	0x800bf28 <spi_stm32_shift_s+0x2e8> @ imm = #0x12
 800bf14: 2301         	movs	r3, #0x1
 800bf16: e008         	b	0x800bf2a <spi_stm32_shift_s+0x2ea> @ imm = #0x10

0800bf18 <$d>:
 800bf18: 34 05 00 20  	.word	0x20000534
 800bf1c: bc f6 01 08  	.word	0x0801f6bc
 800bf20: 68 06 02 08  	.word	0x08020668
 800bf24: dc f6 01 08  	.word	0x0801f6dc

0800bf28 <$t>:
 800bf28: 2300         	movs	r3, #0x0
 800bf2a: f003 0301    	and	r3, r3, #0x1
 800bf2e: b2db         	uxtb	r3, r3
; 	if (ll_func_rx_is_not_empty(spi) &&
 800bf30: 2b00         	cmp	r3, #0x0
 800bf32: f000 8135    	beq.w	0x800c1a0 <spi_stm32_shift_s+0x560> @ imm = #0x26a
; 		if (SPI_WORD_SIZE_GET(data->ctx.config->operation) == 8) {
 800bf36: 683b         	ldr	r3, [r7]
 800bf38: 681b         	ldr	r3, [r3]
 800bf3a: 889b         	ldrh	r3, [r3, #0x4]
 800bf3c: 095b         	lsrs	r3, r3, #0x5
 800bf3e: f003 033f    	and	r3, r3, #0x3f
 800bf42: 2b08         	cmp	r3, #0x8
 800bf44: f040 809a    	bne.w	0x800c07c <spi_stm32_shift_s+0x43c> @ imm = #0x134
; 			rx_frame = LL_SPI_ReceiveData8(spi);
 800bf48: 6878         	ldr	r0, [r7, #0x4]
 800bf4a: f00f f8b5    	bl	0x801b0b8 <LL_SPI_ReceiveData8> @ imm = #0xf16a
 800bf4e: 4603         	mov	r3, r0
 800bf50: f8a7 308a    	strh.w	r3, [r7, #0x8a]
; 			UNALIGNED_PUT(rx_frame, (uint8_t *)data->ctx.rx_buf);
 800bf54: 683b         	ldr	r3, [r7]
 800bf56: 6cdb         	ldr	r3, [r3, #0x4c]
 800bf58: f8c7 3080    	str.w	r3, [r7, #0x80]
 800bf5c: f8b7 308a    	ldrh.w	r3, [r7, #0x8a]
 800bf60: b2da         	uxtb	r2, r3
 800bf62: f8d7 3080    	ldr.w	r3, [r7, #0x80]
 800bf66: 701a         	strb	r2, [r3]
; 			spi_context_update_rx(&data->ctx, 1, 1);
 800bf68: 683b         	ldr	r3, [r7]
 800bf6a: 63fb         	str	r3, [r7, #0x3c]
 800bf6c: 2301         	movs	r3, #0x1
 800bf6e: f887 303b    	strb.w	r3, [r7, #0x3b]
 800bf72: 2301         	movs	r3, #0x1
 800bf74: 637b         	str	r3, [r7, #0x34]
; 	if (!ctx->rx_len) {
 800bf76: 6bfb         	ldr	r3, [r7, #0x3c]
 800bf78: 6d1b         	ldr	r3, [r3, #0x50]
 800bf7a: 2b00         	cmp	r3, #0x0
 800bf7c: f000 810d    	beq.w	0x800c19a <spi_stm32_shift_s+0x55a> @ imm = #0x21a
; 	if (len > ctx->rx_len) {
 800bf80: 6bfb         	ldr	r3, [r7, #0x3c]
 800bf82: 6d1b         	ldr	r3, [r3, #0x50]
 800bf84: 6b7a         	ldr	r2, [r7, #0x34]
 800bf86: 429a         	cmp	r2, r3
 800bf88: d91d         	bls	0x800bfc6 <spi_stm32_shift_s+0x386> @ imm = #0x3a
; 		LOG_ERR("Update exceeds current buffer");
 800bf8a: 2303         	movs	r3, #0x3
 800bf8c: 2b00         	cmp	r3, #0x0
 800bf8e: d019         	beq	0x800bfc4 <spi_stm32_shift_s+0x384> @ imm = #0x32
 800bf90: 2301         	movs	r3, #0x1
 800bf92: f887 3033    	strb.w	r3, [r7, #0x33]
 800bf96: f897 3033    	ldrb.w	r3, [r7, #0x33]
 800bf9a: f083 0301    	eor	r3, r3, #0x1
 800bf9e: b2db         	uxtb	r3, r3
 800bfa0: 2b00         	cmp	r3, #0x0
 800bfa2: d10f         	bne	0x800bfc4 <spi_stm32_shift_s+0x384> @ imm = #0x1e
 800bfa4: 4b80         	ldr	r3, [pc, #0x200]        @ 0x800c1a8 <spi_stm32_shift_s+0x568>
 800bfa6: 6819         	ldr	r1, [r3]
 800bfa8: 4b80         	ldr	r3, [pc, #0x200]        @ 0x800c1ac <spi_stm32_shift_s+0x56c>
 800bfaa: 9302         	str	r3, [sp, #0x8]
 800bfac: 2300         	movs	r3, #0x0
 800bfae: 9301         	str	r3, [sp, #0x4]
 800bfb0: 2300         	movs	r3, #0x0
 800bfb2: 9300         	str	r3, [sp]
 800bfb4: 2300         	movs	r3, #0x0
 800bfb6: 2201         	movs	r2, #0x1
 800bfb8: 2000         	movs	r0, #0x0
 800bfba: f00e fe9e    	bl	0x801acfa <z_log_msg_runtime_create> @ imm = #0xed3c
 800bfbe: 2300         	movs	r3, #0x0
 800bfc0: 62fb         	str	r3, [r7, #0x2c]
; 		return;
 800bfc2: e0ed         	b	0x800c1a0 <spi_stm32_shift_s+0x560> @ imm = #0x1da
 800bfc4: e0ec         	b	0x800c1a0 <spi_stm32_shift_s+0x560> @ imm = #0x1d8
; 	ctx->rx_len -= len;
 800bfc6: 6bfb         	ldr	r3, [r7, #0x3c]
 800bfc8: 6d1a         	ldr	r2, [r3, #0x50]
 800bfca: 6b7b         	ldr	r3, [r7, #0x34]
 800bfcc: 1ad2         	subs	r2, r2, r3
 800bfce: 6bfb         	ldr	r3, [r7, #0x3c]
 800bfd0: 651a         	str	r2, [r3, #0x50]
; 	if (!ctx->rx_len) {
 800bfd2: 6bfb         	ldr	r3, [r7, #0x3c]
 800bfd4: 6d1b         	ldr	r3, [r3, #0x50]
 800bfd6: 2b00         	cmp	r3, #0x0
 800bfd8: d11b         	bne	0x800c012 <spi_stm32_shift_s+0x3d2> @ imm = #0x36
; 		++ctx->current_rx;
 800bfda: 6bfb         	ldr	r3, [r7, #0x3c]
 800bfdc: 6bdb         	ldr	r3, [r3, #0x3c]
 800bfde: f103 0208    	add.w	r2, r3, #0x8
 800bfe2: 6bfb         	ldr	r3, [r7, #0x3c]
 800bfe4: 63da         	str	r2, [r3, #0x3c]
; 		--ctx->rx_count;
 800bfe6: 6bfb         	ldr	r3, [r7, #0x3c]
 800bfe8: 6c1b         	ldr	r3, [r3, #0x40]
 800bfea: 1e5a         	subs	r2, r3, #0x1
 800bfec: 6bfb         	ldr	r3, [r7, #0x3c]
 800bfee: 641a         	str	r2, [r3, #0x40]
; 			spi_context_get_next_buf(&ctx->current_rx,
 800bff0: 6bfb         	ldr	r3, [r7, #0x3c]
 800bff2: f103 003c    	add.w	r0, r3, #0x3c
 800bff6: 6bfb         	ldr	r3, [r7, #0x3c]
 800bff8: f103 0140    	add.w	r1, r3, #0x40
 800bffc: 6bfb         	ldr	r3, [r7, #0x3c]
 800bffe: f103 0250    	add.w	r2, r3, #0x50
 800c002: f897 303b    	ldrb.w	r3, [r7, #0x3b]
 800c006: f00f fae3    	bl	0x801b5d0 <spi_context_get_next_buf> @ imm = #0xf5c6
 800c00a: 4602         	mov	r2, r0
; 		ctx->rx_buf = (uint8_t *)
 800c00c: 6bfb         	ldr	r3, [r7, #0x3c]
 800c00e: 64da         	str	r2, [r3, #0x4c]
 800c010: e00d         	b	0x800c02e <spi_stm32_shift_s+0x3ee> @ imm = #0x1a
; 	} else if (ctx->rx_buf) {
 800c012: 6bfb         	ldr	r3, [r7, #0x3c]
 800c014: 6cdb         	ldr	r3, [r3, #0x4c]
 800c016: 2b00         	cmp	r3, #0x0
 800c018: d009         	beq	0x800c02e <spi_stm32_shift_s+0x3ee> @ imm = #0x12
; 		ctx->rx_buf += dfs * len;
 800c01a: 6bfb         	ldr	r3, [r7, #0x3c]
 800c01c: 6cda         	ldr	r2, [r3, #0x4c]
 800c01e: f897 303b    	ldrb.w	r3, [r7, #0x3b]
 800c022: 6b79         	ldr	r1, [r7, #0x34]
 800c024: fb01 f303    	mul	r3, r1, r3
 800c028: 441a         	add	r2, r3
 800c02a: 6bfb         	ldr	r3, [r7, #0x3c]
 800c02c: 64da         	str	r2, [r3, #0x4c]
; 	LOG_DBG("rx buf/len %p/%zu", (void *)ctx->rx_buf, ctx->rx_len);
 800c02e: 2303         	movs	r3, #0x3
 800c030: 2b03         	cmp	r3, #0x3
 800c032: f240 80b5    	bls.w	0x800c1a0 <spi_stm32_shift_s+0x560> @ imm = #0x16a
 800c036: 2301         	movs	r3, #0x1
 800c038: f887 302b    	strb.w	r3, [r7, #0x2b]
 800c03c: f897 302b    	ldrb.w	r3, [r7, #0x2b]
 800c040: f083 0301    	eor	r3, r3, #0x1
 800c044: b2db         	uxtb	r3, r3
 800c046: 2b00         	cmp	r3, #0x0
 800c048: f040 80aa    	bne.w	0x800c1a0 <spi_stm32_shift_s+0x560> @ imm = #0x154
 800c04c: 4b56         	ldr	r3, [pc, #0x158]        @ 0x800c1a8 <spi_stm32_shift_s+0x568>
 800c04e: 6819         	ldr	r1, [r3]
 800c050: 6bfb         	ldr	r3, [r7, #0x3c]
 800c052: 6cdb         	ldr	r3, [r3, #0x4c]
 800c054: 6bfa         	ldr	r2, [r7, #0x3c]
 800c056: 6d12         	ldr	r2, [r2, #0x50]
 800c058: 9205         	str	r2, [sp, #0x14]
 800c05a: 9304         	str	r3, [sp, #0x10]
 800c05c: 4b54         	ldr	r3, [pc, #0x150]        @ 0x800c1b0 <spi_stm32_shift_s+0x570>
 800c05e: 9303         	str	r3, [sp, #0xc]
 800c060: 4b54         	ldr	r3, [pc, #0x150]        @ 0x800c1b4 <spi_stm32_shift_s+0x574>
 800c062: 9302         	str	r3, [sp, #0x8]
 800c064: 2308         	movs	r3, #0x8
 800c066: 9301         	str	r3, [sp, #0x4]
 800c068: 2300         	movs	r3, #0x0
 800c06a: 9300         	str	r3, [sp]
 800c06c: 2300         	movs	r3, #0x0
 800c06e: 2204         	movs	r2, #0x4
 800c070: 2000         	movs	r0, #0x0
 800c072: f00e fe42    	bl	0x801acfa <z_log_msg_runtime_create> @ imm = #0xec84
 800c076: 2300         	movs	r3, #0x0
 800c078: 627b         	str	r3, [r7, #0x24]
; }
 800c07a: e091         	b	0x800c1a0 <spi_stm32_shift_s+0x560> @ imm = #0x122
; 			rx_frame = LL_SPI_ReceiveData16(spi);
 800c07c: 6878         	ldr	r0, [r7, #0x4]
 800c07e: f00f f828    	bl	0x801b0d2 <LL_SPI_ReceiveData16> @ imm = #0xf050
 800c082: 4603         	mov	r3, r0
 800c084: f8a7 308a    	strh.w	r3, [r7, #0x8a]
; 			UNALIGNED_PUT(rx_frame, (uint16_t *)data->ctx.rx_buf);
 800c088: 683b         	ldr	r3, [r7]
 800c08a: 6cdb         	ldr	r3, [r3, #0x4c]
 800c08c: f8c7 3084    	str.w	r3, [r7, #0x84]
 800c090: f8d7 3084    	ldr.w	r3, [r7, #0x84]
 800c094: f8b7 208a    	ldrh.w	r2, [r7, #0x8a]
 800c098: 801a         	strh	r2, [r3]
; 			spi_context_update_rx(&data->ctx, 2, 1);
 800c09a: 683b         	ldr	r3, [r7]
 800c09c: 623b         	str	r3, [r7, #0x20]
 800c09e: 2302         	movs	r3, #0x2
 800c0a0: 77fb         	strb	r3, [r7, #0x1f]
 800c0a2: 2301         	movs	r3, #0x1
 800c0a4: 61bb         	str	r3, [r7, #0x18]
; 	if (!ctx->rx_len) {
 800c0a6: 6a3b         	ldr	r3, [r7, #0x20]
 800c0a8: 6d1b         	ldr	r3, [r3, #0x50]
 800c0aa: 2b00         	cmp	r3, #0x0
 800c0ac: d077         	beq	0x800c19e <spi_stm32_shift_s+0x55e> @ imm = #0xee
; 	if (len > ctx->rx_len) {
 800c0ae: 6a3b         	ldr	r3, [r7, #0x20]
 800c0b0: 6d1b         	ldr	r3, [r3, #0x50]
 800c0b2: 69ba         	ldr	r2, [r7, #0x18]
 800c0b4: 429a         	cmp	r2, r3
 800c0b6: d91b         	bls	0x800c0f0 <spi_stm32_shift_s+0x4b0> @ imm = #0x36
; 		LOG_ERR("Update exceeds current buffer");
 800c0b8: 2303         	movs	r3, #0x3
 800c0ba: 2b00         	cmp	r3, #0x0
 800c0bc: d017         	beq	0x800c0ee <spi_stm32_shift_s+0x4ae> @ imm = #0x2e
 800c0be: 2301         	movs	r3, #0x1
 800c0c0: 75fb         	strb	r3, [r7, #0x17]
 800c0c2: 7dfb         	ldrb	r3, [r7, #0x17]
 800c0c4: f083 0301    	eor	r3, r3, #0x1
 800c0c8: b2db         	uxtb	r3, r3
 800c0ca: 2b00         	cmp	r3, #0x0
 800c0cc: d10f         	bne	0x800c0ee <spi_stm32_shift_s+0x4ae> @ imm = #0x1e
 800c0ce: 4b36         	ldr	r3, [pc, #0xd8]         @ 0x800c1a8 <spi_stm32_shift_s+0x568>
 800c0d0: 6819         	ldr	r1, [r3]
 800c0d2: 4b36         	ldr	r3, [pc, #0xd8]         @ 0x800c1ac <spi_stm32_shift_s+0x56c>
 800c0d4: 9302         	str	r3, [sp, #0x8]
 800c0d6: 2300         	movs	r3, #0x0
 800c0d8: 9301         	str	r3, [sp, #0x4]
 800c0da: 2300         	movs	r3, #0x0
 800c0dc: 9300         	str	r3, [sp]
 800c0de: 2300         	movs	r3, #0x0
 800c0e0: 2201         	movs	r2, #0x1
 800c0e2: 2000         	movs	r0, #0x0
 800c0e4: f00e fe09    	bl	0x801acfa <z_log_msg_runtime_create> @ imm = #0xec12
 800c0e8: 2300         	movs	r3, #0x0
 800c0ea: 613b         	str	r3, [r7, #0x10]
; 		return;
 800c0ec: e058         	b	0x800c1a0 <spi_stm32_shift_s+0x560> @ imm = #0xb0
 800c0ee: e057         	b	0x800c1a0 <spi_stm32_shift_s+0x560> @ imm = #0xae
; 	ctx->rx_len -= len;
 800c0f0: 6a3b         	ldr	r3, [r7, #0x20]
 800c0f2: 6d1a         	ldr	r2, [r3, #0x50]
 800c0f4: 69bb         	ldr	r3, [r7, #0x18]
 800c0f6: 1ad2         	subs	r2, r2, r3
 800c0f8: 6a3b         	ldr	r3, [r7, #0x20]
 800c0fa: 651a         	str	r2, [r3, #0x50]
; 	if (!ctx->rx_len) {
 800c0fc: 6a3b         	ldr	r3, [r7, #0x20]
 800c0fe: 6d1b         	ldr	r3, [r3, #0x50]
 800c100: 2b00         	cmp	r3, #0x0
 800c102: d11a         	bne	0x800c13a <spi_stm32_shift_s+0x4fa> @ imm = #0x34
; 		++ctx->current_rx;
 800c104: 6a3b         	ldr	r3, [r7, #0x20]
 800c106: 6bdb         	ldr	r3, [r3, #0x3c]
 800c108: f103 0208    	add.w	r2, r3, #0x8
 800c10c: 6a3b         	ldr	r3, [r7, #0x20]
 800c10e: 63da         	str	r2, [r3, #0x3c]
; 		--ctx->rx_count;
 800c110: 6a3b         	ldr	r3, [r7, #0x20]
 800c112: 6c1b         	ldr	r3, [r3, #0x40]
 800c114: 1e5a         	subs	r2, r3, #0x1
 800c116: 6a3b         	ldr	r3, [r7, #0x20]
 800c118: 641a         	str	r2, [r3, #0x40]
; 			spi_context_get_next_buf(&ctx->current_rx,
 800c11a: 6a3b         	ldr	r3, [r7, #0x20]
 800c11c: f103 003c    	add.w	r0, r3, #0x3c
 800c120: 6a3b         	ldr	r3, [r7, #0x20]
 800c122: f103 0140    	add.w	r1, r3, #0x40
 800c126: 6a3b         	ldr	r3, [r7, #0x20]
 800c128: f103 0250    	add.w	r2, r3, #0x50
 800c12c: 7ffb         	ldrb	r3, [r7, #0x1f]
 800c12e: f00f fa4f    	bl	0x801b5d0 <spi_context_get_next_buf> @ imm = #0xf49e
 800c132: 4602         	mov	r2, r0
; 		ctx->rx_buf = (uint8_t *)
 800c134: 6a3b         	ldr	r3, [r7, #0x20]
 800c136: 64da         	str	r2, [r3, #0x4c]
 800c138: e00c         	b	0x800c154 <spi_stm32_shift_s+0x514> @ imm = #0x18
; 	} else if (ctx->rx_buf) {
 800c13a: 6a3b         	ldr	r3, [r7, #0x20]
 800c13c: 6cdb         	ldr	r3, [r3, #0x4c]
 800c13e: 2b00         	cmp	r3, #0x0
 800c140: d008         	beq	0x800c154 <spi_stm32_shift_s+0x514> @ imm = #0x10
; 		ctx->rx_buf += dfs * len;
 800c142: 6a3b         	ldr	r3, [r7, #0x20]
 800c144: 6cda         	ldr	r2, [r3, #0x4c]
 800c146: 7ffb         	ldrb	r3, [r7, #0x1f]
 800c148: 69b9         	ldr	r1, [r7, #0x18]
 800c14a: fb01 f303    	mul	r3, r1, r3
 800c14e: 441a         	add	r2, r3
 800c150: 6a3b         	ldr	r3, [r7, #0x20]
 800c152: 64da         	str	r2, [r3, #0x4c]
; 	LOG_DBG("rx buf/len %p/%zu", (void *)ctx->rx_buf, ctx->rx_len);
 800c154: 2303         	movs	r3, #0x3
 800c156: 2b03         	cmp	r3, #0x3
 800c158: d922         	bls	0x800c1a0 <spi_stm32_shift_s+0x560> @ imm = #0x44
 800c15a: 2301         	movs	r3, #0x1
 800c15c: 73fb         	strb	r3, [r7, #0xf]
 800c15e: 7bfb         	ldrb	r3, [r7, #0xf]
 800c160: f083 0301    	eor	r3, r3, #0x1
 800c164: b2db         	uxtb	r3, r3
 800c166: 2b00         	cmp	r3, #0x0
 800c168: d11a         	bne	0x800c1a0 <spi_stm32_shift_s+0x560> @ imm = #0x34
 800c16a: 4b0f         	ldr	r3, [pc, #0x3c]         @ 0x800c1a8 <spi_stm32_shift_s+0x568>
 800c16c: 6819         	ldr	r1, [r3]
 800c16e: 6a3b         	ldr	r3, [r7, #0x20]
 800c170: 6cdb         	ldr	r3, [r3, #0x4c]
 800c172: 6a3a         	ldr	r2, [r7, #0x20]
 800c174: 6d12         	ldr	r2, [r2, #0x50]
 800c176: 9205         	str	r2, [sp, #0x14]
 800c178: 9304         	str	r3, [sp, #0x10]
 800c17a: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x800c1b0 <spi_stm32_shift_s+0x570>
 800c17c: 9303         	str	r3, [sp, #0xc]
 800c17e: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x800c1b4 <spi_stm32_shift_s+0x574>
 800c180: 9302         	str	r3, [sp, #0x8]
 800c182: 2308         	movs	r3, #0x8
 800c184: 9301         	str	r3, [sp, #0x4]
 800c186: 2300         	movs	r3, #0x0
 800c188: 9300         	str	r3, [sp]
 800c18a: 2300         	movs	r3, #0x0
 800c18c: 2204         	movs	r2, #0x4
 800c18e: 2000         	movs	r0, #0x0
 800c190: f00e fdb3    	bl	0x801acfa <z_log_msg_runtime_create> @ imm = #0xeb66
 800c194: 2300         	movs	r3, #0x0
 800c196: 60bb         	str	r3, [r7, #0x8]
; }
 800c198: e002         	b	0x800c1a0 <spi_stm32_shift_s+0x560> @ imm = #0x4
; 		return;
 800c19a: bf00         	nop
 800c19c: e000         	b	0x800c1a0 <spi_stm32_shift_s+0x560> @ imm = #0x0
 800c19e: bf00         	nop
; }
 800c1a0: bf00         	nop
 800c1a2: 3798         	adds	r7, #0x98
 800c1a4: 46bd         	mov	sp, r7
 800c1a6: bd80         	pop	{r7, pc}

0800c1a8 <$d>:
 800c1a8: 34 05 00 20  	.word	0x20000534
 800c1ac: bc f6 01 08  	.word	0x0801f6bc
 800c1b0: 80 06 02 08  	.word	0x08020680
 800c1b4: f4 f6 01 08  	.word	0x0801f6f4

0800c1b8 <spi_stm32_configure>:
; {
 800c1b8: b5f0         	push	{r4, r5, r6, r7, lr}
 800c1ba: b0a3         	sub	sp, #0x8c
 800c1bc: af0c         	add	r7, sp, #0x30
 800c1be: 6078         	str	r0, [r7, #0x4]
 800c1c0: 6039         	str	r1, [r7]
; 	const struct spi_stm32_config *cfg = dev->config;
 800c1c2: 687b         	ldr	r3, [r7, #0x4]
 800c1c4: 685b         	ldr	r3, [r3, #0x4]
 800c1c6: 63bb         	str	r3, [r7, #0x38]
; 	struct spi_stm32_data *data = dev->data;
 800c1c8: 687b         	ldr	r3, [r7, #0x4]
 800c1ca: 691b         	ldr	r3, [r3, #0x10]
 800c1cc: 637b         	str	r3, [r7, #0x34]
; 	const uint32_t scaler[] = {
 800c1ce: 4b8d         	ldr	r3, [pc, #0x234]        @ 0x800c404 <spi_stm32_configure+0x24c>
 800c1d0: f107 0410    	add.w	r4, r7, #0x10
 800c1d4: 461d         	mov	r5, r3
 800c1d6: cd0f         	ldm	r5!, {r0, r1, r2, r3}
 800c1d8: c40f         	stm	r4!, {r0, r1, r2, r3}
 800c1da: e895 000f    	ldm.w	r5, {r0, r1, r2, r3}
 800c1de: e884 000f    	stm.w	r4, {r0, r1, r2, r3}
; 	SPI_TypeDef *spi = cfg->spi;
 800c1e2: 6bbb         	ldr	r3, [r7, #0x38]
 800c1e4: 681b         	ldr	r3, [r3]
 800c1e6: 633b         	str	r3, [r7, #0x30]
; 	if (spi_context_configured(&data->ctx, config)) {
 800c1e8: 6b7b         	ldr	r3, [r7, #0x34]
 800c1ea: 6839         	ldr	r1, [r7]
 800c1ec: 4618         	mov	r0, r3
 800c1ee: f00f f928    	bl	0x801b442 <spi_context_configured> @ imm = #0xf250
 800c1f2: 4603         	mov	r3, r0
 800c1f4: 2b00         	cmp	r3, #0x0
 800c1f6: d001         	beq	0x800c1fc <spi_stm32_configure+0x44> @ imm = #0x2
; 		return 0;
 800c1f8: 2300         	movs	r3, #0x0
 800c1fa: e156         	b	0x800c4aa <spi_stm32_configure+0x2f2> @ imm = #0x2ac
; 	if ((SPI_WORD_SIZE_GET(config->operation) != 8)
 800c1fc: 683b         	ldr	r3, [r7]
 800c1fe: 889b         	ldrh	r3, [r3, #0x4]
 800c200: 095b         	lsrs	r3, r3, #0x5
 800c202: f003 033f    	and	r3, r3, #0x3f
 800c206: 2b08         	cmp	r3, #0x8
 800c208: d009         	beq	0x800c21e <spi_stm32_configure+0x66> @ imm = #0x12
; 	    && (SPI_WORD_SIZE_GET(config->operation) != 16)) {
 800c20a: 683b         	ldr	r3, [r7]
 800c20c: 889b         	ldrh	r3, [r3, #0x4]
 800c20e: 095b         	lsrs	r3, r3, #0x5
 800c210: f003 033f    	and	r3, r3, #0x3f
 800c214: 2b10         	cmp	r3, #0x10
 800c216: d002         	beq	0x800c21e <spi_stm32_configure+0x66> @ imm = #0x4
; 		return -ENOTSUP;
 800c218: f06f 0385    	mvn	r3, #0x85
 800c21c: e145         	b	0x800c4aa <spi_stm32_configure+0x2f2> @ imm = #0x28a
; 	if ((config->operation & SPI_FRAME_FORMAT_TI) == SPI_FRAME_FORMAT_TI) {
 800c21e: 683b         	ldr	r3, [r7]
 800c220: 889b         	ldrh	r3, [r3, #0x4]
 800c222: b21b         	sxth	r3, r3
 800c224: 2b00         	cmp	r3, #0x0
 800c226: da04         	bge	0x800c232 <spi_stm32_configure+0x7a> @ imm = #0x8
; 		LL_SPI_SetStandard(spi, LL_SPI_PROTOCOL_TI);
 800c228: 2110         	movs	r1, #0x10
 800c22a: 6b38         	ldr	r0, [r7, #0x30]
 800c22c: f00e fe0f    	bl	0x801ae4e <LL_SPI_SetStandard> @ imm = #0xec1e
 800c230: e003         	b	0x800c23a <spi_stm32_configure+0x82> @ imm = #0x6
; 		LL_SPI_SetStandard(spi, LL_SPI_PROTOCOL_MOTOROLA);
 800c232: 2100         	movs	r1, #0x0
 800c234: 6b38         	ldr	r0, [r7, #0x30]
 800c236: f00e fe0a    	bl	0x801ae4e <LL_SPI_SetStandard> @ imm = #0xec14
; 					   (clock_control_subsys_t) &cfg->pclken[0], &clock) < 0) {
 800c23a: 6bbb         	ldr	r3, [r7, #0x38]
 800c23c: 68db         	ldr	r3, [r3, #0xc]
; 		if (clock_control_get_rate(DEVICE_DT_GET(STM32_CLOCK_CONTROL_NODE),
 800c23e: f107 020c    	add.w	r2, r7, #0xc
 800c242: 4619         	mov	r1, r3
 800c244: 4870         	ldr	r0, [pc, #0x1c0]        @ 0x800c408 <spi_stm32_configure+0x250>
 800c246: f00f f8e1    	bl	0x801b40c <clock_control_get_rate> @ imm = #0xf1c2
 800c24a: 4603         	mov	r3, r0
 800c24c: 2b00         	cmp	r3, #0x0
 800c24e: da1e         	bge	0x800c28e <spi_stm32_configure+0xd6> @ imm = #0x3c
; 			LOG_ERR("Failed call clock_control_get_rate(pclk[0])");
 800c250: 2303         	movs	r3, #0x3
 800c252: 2b00         	cmp	r3, #0x0
 800c254: d018         	beq	0x800c288 <spi_stm32_configure+0xd0> @ imm = #0x30
 800c256: 2301         	movs	r3, #0x1
 800c258: f887 3053    	strb.w	r3, [r7, #0x53]
 800c25c: f897 3053    	ldrb.w	r3, [r7, #0x53]
 800c260: f083 0301    	eor	r3, r3, #0x1
 800c264: b2db         	uxtb	r3, r3
 800c266: 2b00         	cmp	r3, #0x0
 800c268: d10e         	bne	0x800c288 <spi_stm32_configure+0xd0> @ imm = #0x1c
 800c26a: 4b68         	ldr	r3, [pc, #0x1a0]        @ 0x800c40c <spi_stm32_configure+0x254>
 800c26c: 6819         	ldr	r1, [r3]
 800c26e: 4b68         	ldr	r3, [pc, #0x1a0]        @ 0x800c410 <spi_stm32_configure+0x258>
 800c270: 9302         	str	r3, [sp, #0x8]
 800c272: 2300         	movs	r3, #0x0
 800c274: 9301         	str	r3, [sp, #0x4]
 800c276: 2300         	movs	r3, #0x0
 800c278: 9300         	str	r3, [sp]
 800c27a: 2300         	movs	r3, #0x0
 800c27c: 2201         	movs	r2, #0x1
 800c27e: 2000         	movs	r0, #0x0
 800c280: f00e fd3b    	bl	0x801acfa <z_log_msg_runtime_create> @ imm = #0xea76
 800c284: 2300         	movs	r3, #0x0
 800c286: 657b         	str	r3, [r7, #0x54]
; 			return -EIO;
 800c288: f06f 0304    	mvn	r3, #0x4
 800c28c: e10d         	b	0x800c4aa <spi_stm32_configure+0x2f2> @ imm = #0x21a
; 	for (br = 1 ; br <= ARRAY_SIZE(scaler) ; ++br) {
 800c28e: 2301         	movs	r3, #0x1
 800c290: 643b         	str	r3, [r7, #0x40]
 800c292: e00c         	b	0x800c2ae <spi_stm32_configure+0xf6> @ imm = #0x18
; 		uint32_t clk = clock >> br;
 800c294: 68fa         	ldr	r2, [r7, #0xc]
 800c296: 6c3b         	ldr	r3, [r7, #0x40]
 800c298: fa22 f303    	lsr.w	r3, r2, r3
 800c29c: 63fb         	str	r3, [r7, #0x3c]
; 		if (clk <= config->frequency) {
 800c29e: 683b         	ldr	r3, [r7]
 800c2a0: 681b         	ldr	r3, [r3]
 800c2a2: 6bfa         	ldr	r2, [r7, #0x3c]
 800c2a4: 429a         	cmp	r2, r3
 800c2a6: d906         	bls	0x800c2b6 <spi_stm32_configure+0xfe> @ imm = #0xc
; 	for (br = 1 ; br <= ARRAY_SIZE(scaler) ; ++br) {
 800c2a8: 6c3b         	ldr	r3, [r7, #0x40]
 800c2aa: 3301         	adds	r3, #0x1
 800c2ac: 643b         	str	r3, [r7, #0x40]
 800c2ae: 6c3b         	ldr	r3, [r7, #0x40]
 800c2b0: 2b08         	cmp	r3, #0x8
 800c2b2: d9ef         	bls	0x800c294 <spi_stm32_configure+0xdc> @ imm = #-0x22
 800c2b4: e000         	b	0x800c2b8 <spi_stm32_configure+0x100> @ imm = #0x0
; 			break;
 800c2b6: bf00         	nop
; 	if (br > ARRAY_SIZE(scaler)) {
 800c2b8: 6c3b         	ldr	r3, [r7, #0x40]
 800c2ba: 2b08         	cmp	r3, #0x8
 800c2bc: d928         	bls	0x800c310 <spi_stm32_configure+0x158> @ imm = #0x50
; 		LOG_ERR("Unsupported frequency %uHz, max %uHz, min %uHz",
 800c2be: 2303         	movs	r3, #0x3
 800c2c0: 2b00         	cmp	r3, #0x0
 800c2c2: d022         	beq	0x800c30a <spi_stm32_configure+0x152> @ imm = #0x44
 800c2c4: 2301         	movs	r3, #0x1
 800c2c6: f887 304b    	strb.w	r3, [r7, #0x4b]
 800c2ca: f897 304b    	ldrb.w	r3, [r7, #0x4b]
 800c2ce: f083 0301    	eor	r3, r3, #0x1
 800c2d2: b2db         	uxtb	r3, r3
 800c2d4: 2b00         	cmp	r3, #0x0
 800c2d6: d118         	bne	0x800c30a <spi_stm32_configure+0x152> @ imm = #0x30
 800c2d8: 4b4c         	ldr	r3, [pc, #0x130]        @ 0x800c40c <spi_stm32_configure+0x254>
 800c2da: 6818         	ldr	r0, [r3]
 800c2dc: 683b         	ldr	r3, [r7]
 800c2de: 681b         	ldr	r3, [r3]
 800c2e0: 68fa         	ldr	r2, [r7, #0xc]
 800c2e2: 0852         	lsrs	r2, r2, #0x1
 800c2e4: 68f9         	ldr	r1, [r7, #0xc]
 800c2e6: 0a09         	lsrs	r1, r1, #0x8
 800c2e8: 9105         	str	r1, [sp, #0x14]
 800c2ea: 9204         	str	r2, [sp, #0x10]
 800c2ec: 9303         	str	r3, [sp, #0xc]
 800c2ee: 4b49         	ldr	r3, [pc, #0x124]        @ 0x800c414 <spi_stm32_configure+0x25c>
 800c2f0: 9302         	str	r3, [sp, #0x8]
 800c2f2: 2300         	movs	r3, #0x0
 800c2f4: 9301         	str	r3, [sp, #0x4]
 800c2f6: 2300         	movs	r3, #0x0
 800c2f8: 9300         	str	r3, [sp]
 800c2fa: 2300         	movs	r3, #0x0
 800c2fc: 2201         	movs	r2, #0x1
 800c2fe: 4601         	mov	r1, r0
 800c300: 2000         	movs	r0, #0x0
 800c302: f00e fcfa    	bl	0x801acfa <z_log_msg_runtime_create> @ imm = #0xe9f4
 800c306: 2300         	movs	r3, #0x0
 800c308: 647b         	str	r3, [r7, #0x44]
; 		return -EINVAL;
 800c30a: f06f 0315    	mvn	r3, #0x15
 800c30e: e0cc         	b	0x800c4aa <spi_stm32_configure+0x2f2> @ imm = #0x198
; 	LL_SPI_Disable(spi);
 800c310: 6b38         	ldr	r0, [r7, #0x30]
 800c312: f00e fd5c    	bl	0x801adce <LL_SPI_Disable> @ imm = #0xeab8
; 	LL_SPI_SetBaudRatePrescaler(spi, scaler[br - 1]);
 800c316: 6c3b         	ldr	r3, [r7, #0x40]
 800c318: 3b01         	subs	r3, #0x1
 800c31a: 009b         	lsls	r3, r3, #0x2
 800c31c: 3358         	adds	r3, #0x58
 800c31e: 443b         	add	r3, r7
 800c320: f853 3c48    	ldr	r3, [r3, #-72]
 800c324: 4619         	mov	r1, r3
 800c326: 6b38         	ldr	r0, [r7, #0x30]
 800c328: f00e fdc7    	bl	0x801aeba <LL_SPI_SetBaudRatePrescaler> @ imm = #0xeb8e
; 	if (SPI_MODE_GET(config->operation) & SPI_MODE_CPOL) {
 800c32c: 683b         	ldr	r3, [r7]
 800c32e: 889b         	ldrh	r3, [r3, #0x4]
 800c330: f003 0302    	and	r3, r3, #0x2
 800c334: 2b00         	cmp	r3, #0x0
 800c336: d004         	beq	0x800c342 <spi_stm32_configure+0x18a> @ imm = #0x8
; 		LL_SPI_SetClockPolarity(spi, LL_SPI_POLARITY_HIGH);
 800c338: 2102         	movs	r1, #0x2
 800c33a: 6b38         	ldr	r0, [r7, #0x30]
 800c33c: f00e fdab    	bl	0x801ae96 <LL_SPI_SetClockPolarity> @ imm = #0xeb56
 800c340: e003         	b	0x800c34a <spi_stm32_configure+0x192> @ imm = #0x6
; 		LL_SPI_SetClockPolarity(spi, LL_SPI_POLARITY_LOW);
 800c342: 2100         	movs	r1, #0x0
 800c344: 6b38         	ldr	r0, [r7, #0x30]
 800c346: f00e fda6    	bl	0x801ae96 <LL_SPI_SetClockPolarity> @ imm = #0xeb4c
; 	if (SPI_MODE_GET(config->operation) & SPI_MODE_CPHA) {
 800c34a: 683b         	ldr	r3, [r7]
 800c34c: 889b         	ldrh	r3, [r3, #0x4]
 800c34e: f003 0304    	and	r3, r3, #0x4
 800c352: 2b00         	cmp	r3, #0x0
 800c354: d004         	beq	0x800c360 <spi_stm32_configure+0x1a8> @ imm = #0x8
; 		LL_SPI_SetClockPhase(spi, LL_SPI_PHASE_2EDGE);
 800c356: 2101         	movs	r1, #0x1
 800c358: 6b38         	ldr	r0, [r7, #0x30]
 800c35a: f00e fd8a    	bl	0x801ae72 <LL_SPI_SetClockPhase> @ imm = #0xeb14
 800c35e: e003         	b	0x800c368 <spi_stm32_configure+0x1b0> @ imm = #0x6
; 		LL_SPI_SetClockPhase(spi, LL_SPI_PHASE_1EDGE);
 800c360: 2100         	movs	r1, #0x0
 800c362: 6b38         	ldr	r0, [r7, #0x30]
 800c364: f00e fd85    	bl	0x801ae72 <LL_SPI_SetClockPhase> @ imm = #0xeb0a
; 	LL_SPI_SetTransferDirection(spi, LL_SPI_FULL_DUPLEX);
 800c368: 2100         	movs	r1, #0x0
 800c36a: 6b38         	ldr	r0, [r7, #0x30]
 800c36c: f00e fdc9    	bl	0x801af02 <LL_SPI_SetTransferDirection> @ imm = #0xeb92
; 	if (config->operation & SPI_TRANSFER_LSB) {
 800c370: 683b         	ldr	r3, [r7]
 800c372: 889b         	ldrh	r3, [r3, #0x4]
 800c374: f003 0310    	and	r3, r3, #0x10
 800c378: 2b00         	cmp	r3, #0x0
 800c37a: d004         	beq	0x800c386 <spi_stm32_configure+0x1ce> @ imm = #0x8
; 		LL_SPI_SetTransferBitOrder(spi, LL_SPI_LSB_FIRST);
 800c37c: 2180         	movs	r1, #0x80
 800c37e: 6b38         	ldr	r0, [r7, #0x30]
 800c380: f00e fdad    	bl	0x801aede <LL_SPI_SetTransferBitOrder> @ imm = #0xeb5a
 800c384: e003         	b	0x800c38e <spi_stm32_configure+0x1d6> @ imm = #0x6
; 		LL_SPI_SetTransferBitOrder(spi, LL_SPI_MSB_FIRST);
 800c386: 2100         	movs	r1, #0x0
 800c388: 6b38         	ldr	r0, [r7, #0x30]
 800c38a: f00e fda8    	bl	0x801aede <LL_SPI_SetTransferBitOrder> @ imm = #0xeb50
; 	LL_SPI_DisableCRC(spi);
 800c38e: 6b38         	ldr	r0, [r7, #0x30]
 800c390: f00e fddb    	bl	0x801af4a <LL_SPI_DisableCRC> @ imm = #0xebb6
; 	if (spi_cs_is_gpio(config) || !IS_ENABLED(CONFIG_SPI_STM32_USE_HW_SS)) {
 800c394: 6838         	ldr	r0, [r7]
 800c396: f00e ffdc    	bl	0x801b352 <spi_cs_is_gpio> @ imm = #0xefb8
 800c39a: 4603         	mov	r3, r0
 800c39c: 2b00         	cmp	r3, #0x0
 800c39e: d005         	beq	0x800c3ac <spi_stm32_configure+0x1f4> @ imm = #0xa
; 		LL_SPI_SetNSSMode(spi, LL_SPI_NSS_SOFT);
 800c3a0: f44f 7100    	mov.w	r1, #0x200
 800c3a4: 6b38         	ldr	r0, [r7, #0x30]
 800c3a6: f00e fddf    	bl	0x801af68 <LL_SPI_SetNSSMode> @ imm = #0xebbe
 800c3aa: e00f         	b	0x800c3cc <spi_stm32_configure+0x214> @ imm = #0x1e
; 		if (config->operation & SPI_OP_MODE_SLAVE) {
 800c3ac: 683b         	ldr	r3, [r7]
 800c3ae: 889b         	ldrh	r3, [r3, #0x4]
 800c3b0: f003 0301    	and	r3, r3, #0x1
 800c3b4: 2b00         	cmp	r3, #0x0
 800c3b6: d004         	beq	0x800c3c2 <spi_stm32_configure+0x20a> @ imm = #0x8
; 			LL_SPI_SetNSSMode(spi, LL_SPI_NSS_HARD_INPUT);
 800c3b8: 2100         	movs	r1, #0x0
 800c3ba: 6b38         	ldr	r0, [r7, #0x30]
 800c3bc: f00e fdd4    	bl	0x801af68 <LL_SPI_SetNSSMode> @ imm = #0xeba8
 800c3c0: e004         	b	0x800c3cc <spi_stm32_configure+0x214> @ imm = #0x8
; 			LL_SPI_SetNSSMode(spi, LL_SPI_NSS_HARD_OUTPUT);
 800c3c2: f44f 2180    	mov.w	r1, #0x40000
 800c3c6: 6b38         	ldr	r0, [r7, #0x30]
 800c3c8: f00e fdce    	bl	0x801af68 <LL_SPI_SetNSSMode> @ imm = #0xeb9c
; 	if (config->operation & SPI_OP_MODE_SLAVE) {
 800c3cc: 683b         	ldr	r3, [r7]
 800c3ce: 889b         	ldrh	r3, [r3, #0x4]
 800c3d0: f003 0301    	and	r3, r3, #0x1
 800c3d4: 2b00         	cmp	r3, #0x0
 800c3d6: d004         	beq	0x800c3e2 <spi_stm32_configure+0x22a> @ imm = #0x8
; 		LL_SPI_SetMode(spi, LL_SPI_MODE_SLAVE);
 800c3d8: 2100         	movs	r1, #0x0
 800c3da: 6b38         	ldr	r0, [r7, #0x30]
 800c3dc: f00e fd18    	bl	0x801ae10 <LL_SPI_SetMode> @ imm = #0xea30
 800c3e0: e004         	b	0x800c3ec <spi_stm32_configure+0x234> @ imm = #0x8
; 		LL_SPI_SetMode(spi, LL_SPI_MODE_MASTER);
 800c3e2: f44f 7182    	mov.w	r1, #0x104
 800c3e6: 6b38         	ldr	r0, [r7, #0x30]
 800c3e8: f00e fd12    	bl	0x801ae10 <LL_SPI_SetMode> @ imm = #0xea24
; 	if (SPI_WORD_SIZE_GET(config->operation) ==  8) {
 800c3ec: 683b         	ldr	r3, [r7]
 800c3ee: 889b         	ldrh	r3, [r3, #0x4]
 800c3f0: 095b         	lsrs	r3, r3, #0x5
 800c3f2: f003 033f    	and	r3, r3, #0x3f
 800c3f6: 2b08         	cmp	r3, #0x8
 800c3f8: d10e         	bne	0x800c418 <spi_stm32_configure+0x260> @ imm = #0x1c
; 		LL_SPI_SetDataWidth(spi, LL_SPI_DATAWIDTH_8BIT);
 800c3fa: 2100         	movs	r1, #0x0
 800c3fc: 6b38         	ldr	r0, [r7, #0x30]
 800c3fe: f00e fd92    	bl	0x801af26 <LL_SPI_SetDataWidth> @ imm = #0xeb24
 800c402: e00e         	b	0x800c422 <spi_stm32_configure+0x26a> @ imm = #0x1c

0800c404 <$d>:
 800c404: bc f7 01 08  	.word	0x0801f7bc
 800c408: 28 dd 01 08  	.word	0x0801dd28
 800c40c: 34 05 00 20  	.word	0x20000534
 800c410: 18 f7 01 08  	.word	0x0801f718
 800c414: 44 f7 01 08  	.word	0x0801f744

0800c418 <$t>:
; 		LL_SPI_SetDataWidth(spi, LL_SPI_DATAWIDTH_16BIT);
 800c418: f44f 6100    	mov.w	r1, #0x800
 800c41c: 6b38         	ldr	r0, [r7, #0x30]
 800c41e: f00e fd82    	bl	0x801af26 <LL_SPI_SetDataWidth> @ imm = #0xeb04
; 	data->ctx.config = config;
 800c422: 6b7b         	ldr	r3, [r7, #0x34]
 800c424: 683a         	ldr	r2, [r7]
 800c426: 601a         	str	r2, [r3]
; 	LOG_DBG("Installed config %p: freq %uHz (div = %u),"
 800c428: 2303         	movs	r3, #0x3
 800c42a: 2b03         	cmp	r3, #0x3
 800c42c: d93c         	bls	0x800c4a8 <spi_stm32_configure+0x2f0> @ imm = #0x78
 800c42e: 2301         	movs	r3, #0x1
 800c430: f887 3052    	strb.w	r3, [r7, #0x52]
 800c434: f897 3052    	ldrb.w	r3, [r7, #0x52]
 800c438: f083 0301    	eor	r3, r3, #0x1
 800c43c: b2db         	uxtb	r3, r3
 800c43e: 2b00         	cmp	r3, #0x0
 800c440: d132         	bne	0x800c4a8 <spi_stm32_configure+0x2f0> @ imm = #0x64
 800c442: 4b1c         	ldr	r3, [pc, #0x70]         @ 0x800c4b4 <spi_stm32_configure+0x2fc>
 800c444: 681e         	ldr	r6, [r3]
 800c446: 68fa         	ldr	r2, [r7, #0xc]
 800c448: 6c3b         	ldr	r3, [r7, #0x40]
 800c44a: fa22 f303    	lsr.w	r3, r2, r3
 800c44e: 2101         	movs	r1, #0x1
 800c450: 6c3a         	ldr	r2, [r7, #0x40]
 800c452: fa01 f202    	lsl.w	r2, r1, r2
 800c456: 6839         	ldr	r1, [r7]
 800c458: 8889         	ldrh	r1, [r1, #0x4]
 800c45a: 0849         	lsrs	r1, r1, #0x1
 800c45c: f001 0101    	and	r1, r1, #0x1
 800c460: 6838         	ldr	r0, [r7]
 800c462: 8880         	ldrh	r0, [r0, #0x4]
 800c464: 0880         	lsrs	r0, r0, #0x2
 800c466: f000 0001    	and	r0, r0, #0x1
 800c46a: 683c         	ldr	r4, [r7]
 800c46c: 88a4         	ldrh	r4, [r4, #0x4]
 800c46e: 08e4         	lsrs	r4, r4, #0x3
 800c470: f004 0401    	and	r4, r4, #0x1
 800c474: 683d         	ldr	r5, [r7]
 800c476: 88ed         	ldrh	r5, [r5, #0x6]
 800c478: 950a         	str	r5, [sp, #0x28]
 800c47a: 9409         	str	r4, [sp, #0x24]
 800c47c: 9008         	str	r0, [sp, #0x20]
 800c47e: 9107         	str	r1, [sp, #0x1c]
 800c480: 9206         	str	r2, [sp, #0x18]
 800c482: 9305         	str	r3, [sp, #0x14]
 800c484: 683b         	ldr	r3, [r7]
 800c486: 9304         	str	r3, [sp, #0x10]
 800c488: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x800c4b8 <spi_stm32_configure+0x300>
 800c48a: 9303         	str	r3, [sp, #0xc]
 800c48c: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x800c4bc <spi_stm32_configure+0x304>
 800c48e: 9302         	str	r3, [sp, #0x8]
 800c490: 2308         	movs	r3, #0x8
 800c492: 9301         	str	r3, [sp, #0x4]
 800c494: 2300         	movs	r3, #0x0
 800c496: 9300         	str	r3, [sp]
 800c498: 2300         	movs	r3, #0x0
 800c49a: 2204         	movs	r2, #0x4
 800c49c: 4631         	mov	r1, r6
 800c49e: 2000         	movs	r0, #0x0
 800c4a0: f00e fc2b    	bl	0x801acfa <z_log_msg_runtime_create> @ imm = #0xe856
 800c4a4: 2300         	movs	r3, #0x0
 800c4a6: 64fb         	str	r3, [r7, #0x4c]
; 	return 0;
 800c4a8: 2300         	movs	r3, #0x0
; }
 800c4aa: 4618         	mov	r0, r3
 800c4ac: 375c         	adds	r7, #0x5c
 800c4ae: 46bd         	mov	sp, r7
 800c4b0: bdf0         	pop	{r4, r5, r6, r7, pc}
 800c4b2: bf00         	nop

0800c4b4 <$d>:
 800c4b4: 34 05 00 20  	.word	0x20000534
 800c4b8: ac 06 02 08  	.word	0x080206ac
 800c4bc: 74 f7 01 08  	.word	0x0801f774

0800c4c0 <spi_stm32_init>:
; {
 800c4c0: b580         	push	{r7, lr}
 800c4c2: b090         	sub	sp, #0x40
 800c4c4: af04         	add	r7, sp, #0x10
 800c4c6: 6078         	str	r0, [r7, #0x4]
; 	struct spi_stm32_data *data __attribute__((unused)) = dev->data;
 800c4c8: 687b         	ldr	r3, [r7, #0x4]
 800c4ca: 691b         	ldr	r3, [r3, #0x10]
 800c4cc: 627b         	str	r3, [r7, #0x24]
; 	const struct spi_stm32_config *cfg = dev->config;
 800c4ce: 687b         	ldr	r3, [r7, #0x4]
 800c4d0: 685b         	ldr	r3, [r3, #0x4]
 800c4d2: 62bb         	str	r3, [r7, #0x28]
; 	if (!device_is_ready(DEVICE_DT_GET(STM32_CLOCK_CONTROL_NODE))) {
 800c4d4: 484a         	ldr	r0, [pc, #0x128]        @ 0x800c600 <spi_stm32_init+0x140>
 800c4d6: f00e fc04    	bl	0x801ace2 <device_is_ready> @ imm = #0xe808
 800c4da: 4603         	mov	r3, r0
 800c4dc: f083 0301    	eor	r3, r3, #0x1
 800c4e0: b2db         	uxtb	r3, r3
 800c4e2: 2b00         	cmp	r3, #0x0
 800c4e4: d01c         	beq	0x800c520 <spi_stm32_init+0x60> @ imm = #0x38
; 		LOG_ERR("clock control device not ready");
 800c4e6: 2303         	movs	r3, #0x3
 800c4e8: 2b00         	cmp	r3, #0x0
 800c4ea: d016         	beq	0x800c51a <spi_stm32_init+0x5a> @ imm = #0x2c
 800c4ec: 2301         	movs	r3, #0x1
 800c4ee: 74fb         	strb	r3, [r7, #0x13]
 800c4f0: 7cfb         	ldrb	r3, [r7, #0x13]
 800c4f2: f083 0301    	eor	r3, r3, #0x1
 800c4f6: b2db         	uxtb	r3, r3
 800c4f8: 2b00         	cmp	r3, #0x0
 800c4fa: d10e         	bne	0x800c51a <spi_stm32_init+0x5a> @ imm = #0x1c
 800c4fc: 4b41         	ldr	r3, [pc, #0x104]        @ 0x800c604 <spi_stm32_init+0x144>
 800c4fe: 6819         	ldr	r1, [r3]
 800c500: 4b41         	ldr	r3, [pc, #0x104]        @ 0x800c608 <spi_stm32_init+0x148>
 800c502: 9302         	str	r3, [sp, #0x8]
 800c504: 2300         	movs	r3, #0x0
 800c506: 9301         	str	r3, [sp, #0x4]
 800c508: 2300         	movs	r3, #0x0
 800c50a: 9300         	str	r3, [sp]
 800c50c: 2300         	movs	r3, #0x0
 800c50e: 2201         	movs	r2, #0x1
 800c510: 2000         	movs	r0, #0x0
 800c512: f00e fbf2    	bl	0x801acfa <z_log_msg_runtime_create> @ imm = #0xe7e4
 800c516: 2300         	movs	r3, #0x0
 800c518: 60fb         	str	r3, [r7, #0xc]
; 		return -ENODEV;
 800c51a: f06f 0312    	mvn	r3, #0x12
 800c51e: e06a         	b	0x800c5f6 <spi_stm32_init+0x136> @ imm = #0xd4
; 			       (clock_control_subsys_t) &cfg->pclken[0]);
 800c520: 6abb         	ldr	r3, [r7, #0x28]
 800c522: 68db         	ldr	r3, [r3, #0xc]
; 	err = clock_control_on(DEVICE_DT_GET(STM32_CLOCK_CONTROL_NODE),
 800c524: 4619         	mov	r1, r3
 800c526: 4836         	ldr	r0, [pc, #0xd8]         @ 0x800c600 <spi_stm32_init+0x140>
 800c528: f00e ff5e    	bl	0x801b3e8 <clock_control_on> @ imm = #0xeebc
 800c52c: 62f8         	str	r0, [r7, #0x2c]
; 	if (err < 0) {
 800c52e: 6afb         	ldr	r3, [r7, #0x2c]
 800c530: 2b00         	cmp	r3, #0x0
 800c532: da1b         	bge	0x800c56c <spi_stm32_init+0xac> @ imm = #0x36
; 		LOG_ERR("Could not enable SPI clock");
 800c534: 2303         	movs	r3, #0x3
 800c536: 2b00         	cmp	r3, #0x0
 800c538: d016         	beq	0x800c568 <spi_stm32_init+0xa8> @ imm = #0x2c
 800c53a: 2301         	movs	r3, #0x1
 800c53c: 76fb         	strb	r3, [r7, #0x1b]
 800c53e: 7efb         	ldrb	r3, [r7, #0x1b]
 800c540: f083 0301    	eor	r3, r3, #0x1
 800c544: b2db         	uxtb	r3, r3
 800c546: 2b00         	cmp	r3, #0x0
 800c548: d10e         	bne	0x800c568 <spi_stm32_init+0xa8> @ imm = #0x1c
 800c54a: 4b2e         	ldr	r3, [pc, #0xb8]         @ 0x800c604 <spi_stm32_init+0x144>
 800c54c: 6819         	ldr	r1, [r3]
 800c54e: 4b2f         	ldr	r3, [pc, #0xbc]         @ 0x800c60c <spi_stm32_init+0x14c>
 800c550: 9302         	str	r3, [sp, #0x8]
 800c552: 2300         	movs	r3, #0x0
 800c554: 9301         	str	r3, [sp, #0x4]
 800c556: 2300         	movs	r3, #0x0
 800c558: 9300         	str	r3, [sp]
 800c55a: 2300         	movs	r3, #0x0
 800c55c: 2201         	movs	r2, #0x1
 800c55e: 2000         	movs	r0, #0x0
 800c560: f00e fbcb    	bl	0x801acfa <z_log_msg_runtime_create> @ imm = #0xe796
 800c564: 2300         	movs	r3, #0x0
 800c566: 617b         	str	r3, [r7, #0x14]
; 		return err;
 800c568: 6afb         	ldr	r3, [r7, #0x2c]
 800c56a: e044         	b	0x800c5f6 <spi_stm32_init+0x136> @ imm = #0x88
; 	if (!spi_stm32_is_subghzspi(dev)) {
 800c56c: 6878         	ldr	r0, [r7, #0x4]
 800c56e: f00f fa36    	bl	0x801b9de <spi_stm32_is_subghzspi> @ imm = #0xf46c
 800c572: 4603         	mov	r3, r0
 800c574: f083 0301    	eor	r3, r3, #0x1
 800c578: b2db         	uxtb	r3, r3
 800c57a: 2b00         	cmp	r3, #0x0
 800c57c: d029         	beq	0x800c5d2 <spi_stm32_init+0x112> @ imm = #0x52
; 		err = pinctrl_apply_state(cfg->pcfg, PINCTRL_STATE_DEFAULT);
 800c57e: 6abb         	ldr	r3, [r7, #0x28]
 800c580: 685b         	ldr	r3, [r3, #0x4]
 800c582: 2100         	movs	r1, #0x0
 800c584: 4618         	mov	r0, r3
 800c586: f00e ff08    	bl	0x801b39a <pinctrl_apply_state> @ imm = #0xee10
 800c58a: 62f8         	str	r0, [r7, #0x2c]
; 		if (err < 0) {
 800c58c: 6afb         	ldr	r3, [r7, #0x2c]
 800c58e: 2b00         	cmp	r3, #0x0
 800c590: da1f         	bge	0x800c5d2 <spi_stm32_init+0x112> @ imm = #0x3e
; 			LOG_ERR("SPI pinctrl setup failed (%d)", err);
 800c592: 2303         	movs	r3, #0x3
 800c594: 2b00         	cmp	r3, #0x0
 800c596: d01a         	beq	0x800c5ce <spi_stm32_init+0x10e> @ imm = #0x34
 800c598: 2301         	movs	r3, #0x1
 800c59a: f887 3023    	strb.w	r3, [r7, #0x23]
 800c59e: f897 3023    	ldrb.w	r3, [r7, #0x23]
 800c5a2: f083 0301    	eor	r3, r3, #0x1
 800c5a6: b2db         	uxtb	r3, r3
 800c5a8: 2b00         	cmp	r3, #0x0
 800c5aa: d110         	bne	0x800c5ce <spi_stm32_init+0x10e> @ imm = #0x20
 800c5ac: 4b15         	ldr	r3, [pc, #0x54]         @ 0x800c604 <spi_stm32_init+0x144>
 800c5ae: 6819         	ldr	r1, [r3]
 800c5b0: 6afb         	ldr	r3, [r7, #0x2c]
 800c5b2: 9303         	str	r3, [sp, #0xc]
 800c5b4: 4b16         	ldr	r3, [pc, #0x58]         @ 0x800c610 <spi_stm32_init+0x150>
 800c5b6: 9302         	str	r3, [sp, #0x8]
 800c5b8: 2300         	movs	r3, #0x0
 800c5ba: 9301         	str	r3, [sp, #0x4]
 800c5bc: 2300         	movs	r3, #0x0
 800c5be: 9300         	str	r3, [sp]
 800c5c0: 2300         	movs	r3, #0x0
 800c5c2: 2201         	movs	r2, #0x1
 800c5c4: 2000         	movs	r0, #0x0
 800c5c6: f00e fb98    	bl	0x801acfa <z_log_msg_runtime_create> @ imm = #0xe730
 800c5ca: 2300         	movs	r3, #0x0
 800c5cc: 61fb         	str	r3, [r7, #0x1c]
; 			return err;
 800c5ce: 6afb         	ldr	r3, [r7, #0x2c]
 800c5d0: e011         	b	0x800c5f6 <spi_stm32_init+0x136> @ imm = #0x22
; 	err = spi_context_cs_configure_all(&data->ctx);
 800c5d2: 6a7b         	ldr	r3, [r7, #0x24]
 800c5d4: 4618         	mov	r0, r3
 800c5d6: f7fe ff07    	bl	0x800b3e8 <spi_context_cs_configure_all> @ imm = #-0x11f2
 800c5da: 62f8         	str	r0, [r7, #0x2c]
; 	if (err < 0) {
 800c5dc: 6afb         	ldr	r3, [r7, #0x2c]
 800c5de: 2b00         	cmp	r3, #0x0
 800c5e0: da01         	bge	0x800c5e6 <spi_stm32_init+0x126> @ imm = #0x2
; 		return err;
 800c5e2: 6afb         	ldr	r3, [r7, #0x2c]
 800c5e4: e007         	b	0x800c5f6 <spi_stm32_init+0x136> @ imm = #0xe
; 	spi_context_unlock_unconditionally(&data->ctx);
 800c5e6: 6a7b         	ldr	r3, [r7, #0x24]
 800c5e8: 4618         	mov	r0, r3
 800c5ea: f00e ffd4    	bl	0x801b596 <spi_context_unlock_unconditionally> @ imm = #0xefa8
; 	return pm_device_runtime_enable(dev);
 800c5ee: 6878         	ldr	r0, [r7, #0x4]
 800c5f0: f00e fef0    	bl	0x801b3d4 <pm_device_runtime_enable> @ imm = #0xede0
 800c5f4: 4603         	mov	r3, r0
; }
 800c5f6: 4618         	mov	r0, r3
 800c5f8: 3730         	adds	r7, #0x30
 800c5fa: 46bd         	mov	sp, r7
 800c5fc: bd80         	pop	{r7, pc}
 800c5fe: bf00         	nop

0800c600 <$d>:
 800c600: 28 dd 01 08  	.word	0x0801dd28
 800c604: 34 05 00 20  	.word	0x20000534
 800c608: dc f7 01 08  	.word	0x0801f7dc
 800c60c: fc f7 01 08  	.word	0x0801f7fc
 800c610: 18 f8 01 08  	.word	0x0801f818

0800c614 <__NVIC_SetPriority>:
; {
 800c614: b480         	push	{r7}
 800c616: b083         	sub	sp, #0xc
 800c618: af00         	add	r7, sp, #0x0
 800c61a: 4603         	mov	r3, r0
 800c61c: 6039         	str	r1, [r7]
 800c61e: 71fb         	strb	r3, [r7, #0x7]
;   if ((int32_t)(IRQn) >= 0)
 800c620: f997 3007    	ldrsb.w	r3, [r7, #0x7]
 800c624: 2b00         	cmp	r3, #0x0
 800c626: db0a         	blt	0x800c63e <__NVIC_SetPriority+0x2a> @ imm = #0x14
;     NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800c628: 683b         	ldr	r3, [r7]
 800c62a: b2da         	uxtb	r2, r3
 800c62c: 490c         	ldr	r1, [pc, #0x30]         @ 0x800c660 <__NVIC_SetPriority+0x4c>
 800c62e: f997 3007    	ldrsb.w	r3, [r7, #0x7]
 800c632: 0112         	lsls	r2, r2, #0x4
 800c634: b2d2         	uxtb	r2, r2
 800c636: 440b         	add	r3, r1
 800c638: f883 2300    	strb.w	r2, [r3, #0x300]
; }
 800c63c: e00a         	b	0x800c654 <__NVIC_SetPriority+0x40> @ imm = #0x14
;     SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800c63e: 683b         	ldr	r3, [r7]
 800c640: b2da         	uxtb	r2, r3
 800c642: 4908         	ldr	r1, [pc, #0x20]         @ 0x800c664 <__NVIC_SetPriority+0x50>
 800c644: 79fb         	ldrb	r3, [r7, #0x7]
 800c646: f003 030f    	and	r3, r3, #0xf
 800c64a: 3b04         	subs	r3, #0x4
 800c64c: 0112         	lsls	r2, r2, #0x4
 800c64e: b2d2         	uxtb	r2, r2
 800c650: 440b         	add	r3, r1
 800c652: 761a         	strb	r2, [r3, #0x18]
; }
 800c654: bf00         	nop
 800c656: 370c         	adds	r7, #0xc
 800c658: 46bd         	mov	sp, r7
 800c65a: bc80         	pop	{r7}
 800c65c: 4770         	bx	lr
 800c65e: bf00         	nop

0800c660 <$d>:
 800c660: 00 e1 00 e0  	.word	0xe000e100
 800c664: 00 ed 00 e0  	.word	0xe000ed00

0800c668 <elapsed>:
; {
 800c668: b480         	push	{r7}
 800c66a: b085         	sub	sp, #0x14
 800c66c: af00         	add	r7, sp, #0x0
; 	uint32_t val1 = SysTick->VAL;	/* A */
 800c66e: 4b19         	ldr	r3, [pc, #0x64]         @ 0x800c6d4 <elapsed+0x6c>
 800c670: 689b         	ldr	r3, [r3, #0x8]
 800c672: 60fb         	str	r3, [r7, #0xc]
; 	uint32_t ctrl = SysTick->CTRL;	/* B */
 800c674: 4b17         	ldr	r3, [pc, #0x5c]         @ 0x800c6d4 <elapsed+0x6c>
 800c676: 681b         	ldr	r3, [r3]
 800c678: 607b         	str	r3, [r7, #0x4]
; 	uint32_t val2 = SysTick->VAL;	/* C */
 800c67a: 4b16         	ldr	r3, [pc, #0x58]         @ 0x800c6d4 <elapsed+0x6c>
 800c67c: 689b         	ldr	r3, [r3, #0x8]
 800c67e: 60bb         	str	r3, [r7, #0x8]
; 	if (val1 == 0) {
 800c680: 68fb         	ldr	r3, [r7, #0xc]
 800c682: 2b00         	cmp	r3, #0x0
 800c684: d102         	bne	0x800c68c <elapsed+0x24> @ imm = #0x4
; 		val1 = last_load;
 800c686: 4b14         	ldr	r3, [pc, #0x50]         @ 0x800c6d8 <elapsed+0x70>
 800c688: 681b         	ldr	r3, [r3]
 800c68a: 60fb         	str	r3, [r7, #0xc]
; 	if (val2 == 0) {
 800c68c: 68bb         	ldr	r3, [r7, #0x8]
 800c68e: 2b00         	cmp	r3, #0x0
 800c690: d102         	bne	0x800c698 <elapsed+0x30> @ imm = #0x4
; 		val2 = last_load;
 800c692: 4b11         	ldr	r3, [pc, #0x44]         @ 0x800c6d8 <elapsed+0x70>
 800c694: 681b         	ldr	r3, [r3]
 800c696: 60bb         	str	r3, [r7, #0x8]
; 	if ((ctrl & SysTick_CTRL_COUNTFLAG_Msk)
 800c698: 687b         	ldr	r3, [r7, #0x4]
 800c69a: f403 3380    	and	r3, r3, #0x10000
 800c69e: 2b00         	cmp	r3, #0x0
 800c6a0: d103         	bne	0x800c6aa <elapsed+0x42> @ imm = #0x6
; 	    || (val1 < val2)) {
 800c6a2: 68fa         	ldr	r2, [r7, #0xc]
 800c6a4: 68bb         	ldr	r3, [r7, #0x8]
 800c6a6: 429a         	cmp	r2, r3
 800c6a8: d208         	bhs	0x800c6bc <elapsed+0x54> @ imm = #0x10
; 		overflow_cyc += last_load;
 800c6aa: 4b0c         	ldr	r3, [pc, #0x30]         @ 0x800c6dc <elapsed+0x74>
 800c6ac: 681a         	ldr	r2, [r3]
 800c6ae: 4b0a         	ldr	r3, [pc, #0x28]         @ 0x800c6d8 <elapsed+0x70>
 800c6b0: 681b         	ldr	r3, [r3]
 800c6b2: 4413         	add	r3, r2
 800c6b4: 4a09         	ldr	r2, [pc, #0x24]         @ 0x800c6dc <elapsed+0x74>
 800c6b6: 6013         	str	r3, [r2]
; 		(void)SysTick->CTRL;
 800c6b8: 4b06         	ldr	r3, [pc, #0x18]         @ 0x800c6d4 <elapsed+0x6c>
 800c6ba: 681b         	ldr	r3, [r3]
; 	return (last_load - val2) + overflow_cyc;
 800c6bc: 4b06         	ldr	r3, [pc, #0x18]         @ 0x800c6d8 <elapsed+0x70>
 800c6be: 681a         	ldr	r2, [r3]
 800c6c0: 68bb         	ldr	r3, [r7, #0x8]
 800c6c2: 1ad2         	subs	r2, r2, r3
 800c6c4: 4b05         	ldr	r3, [pc, #0x14]         @ 0x800c6dc <elapsed+0x74>
 800c6c6: 681b         	ldr	r3, [r3]
 800c6c8: 4413         	add	r3, r2
; }
 800c6ca: 4618         	mov	r0, r3
 800c6cc: 3714         	adds	r7, #0x14
 800c6ce: 46bd         	mov	sp, r7
 800c6d0: bc80         	pop	{r7}
 800c6d2: 4770         	bx	lr

0800c6d4 <$d>:
 800c6d4: 10 e0 00 e0  	.word	0xe000e010
 800c6d8: 60 1f 00 20  	.word	0x20001f60
 800c6dc: 64 1f 00 20  	.word	0x20001f64

0800c6e0 <sys_clock_isr>:
; {
 800c6e0: 4668         	mov	r0, sp
 800c6e2: f020 0107    	bic	r1, r0, #0x7
 800c6e6: 468d         	mov	sp, r1
 800c6e8: e92d 4fb1    	push.w	{r0, r4, r5, r7, r8, r9, r10, r11, lr}
 800c6ec: b085         	sub	sp, #0x14
 800c6ee: af00         	add	r7, sp, #0x0
; 	elapsed();
 800c6f0: f7ff ffba    	bl	0x800c668 <elapsed>     @ imm = #-0x8c
; 	cycle_count += overflow_cyc;
 800c6f4: 4b22         	ldr	r3, [pc, #0x88]         @ 0x800c780 <sys_clock_isr+0xa0>
 800c6f6: 681b         	ldr	r3, [r3]
 800c6f8: 2200         	movs	r2, #0x0
 800c6fa: 4698         	mov	r8, r3
 800c6fc: 4691         	mov	r9, r2
 800c6fe: 4b21         	ldr	r3, [pc, #0x84]         @ 0x800c784 <sys_clock_isr+0xa4>
 800c700: e9d3 2300    	ldrd	r2, r3, [r3]
 800c704: eb18 0102    	adds.w	r1, r8, r2
 800c708: 6039         	str	r1, [r7]
 800c70a: eb49 0303    	adc.w	r3, r9, r3
 800c70e: 607b         	str	r3, [r7, #0x4]
 800c710: 4b1c         	ldr	r3, [pc, #0x70]         @ 0x800c784 <sys_clock_isr+0xa4>
 800c712: e9d7 1200    	ldrd	r1, r2, [r7]
 800c716: e9c3 1200    	strd	r1, r2, [r3]
; 	overflow_cyc = 0;
 800c71a: 4b19         	ldr	r3, [pc, #0x64]         @ 0x800c780 <sys_clock_isr+0xa0>
 800c71c: 2200         	movs	r2, #0x0
 800c71e: 601a         	str	r2, [r3]
; 		dcycles = cycle_count - announced_cycles;
 800c720: 4b18         	ldr	r3, [pc, #0x60]         @ 0x800c784 <sys_clock_isr+0xa4>
 800c722: e9d3 2300    	ldrd	r2, r3, [r3]
 800c726: 4611         	mov	r1, r2
 800c728: 4b17         	ldr	r3, [pc, #0x5c]         @ 0x800c788 <sys_clock_isr+0xa8>
 800c72a: e9d3 2300    	ldrd	r2, r3, [r3]
 800c72e: 4613         	mov	r3, r2
 800c730: 1acb         	subs	r3, r1, r3
 800c732: 60fb         	str	r3, [r7, #0xc]
; 		dticks = dcycles / CYC_PER_TICK;
 800c734: 68fb         	ldr	r3, [r7, #0xc]
 800c736: 4a15         	ldr	r2, [pc, #0x54]         @ 0x800c78c <sys_clock_isr+0xac>
 800c738: fba2 2303    	umull	r2, r3, r2, r3
 800c73c: 0b9b         	lsrs	r3, r3, #0xe
 800c73e: 60bb         	str	r3, [r7, #0x8]
; 		announced_cycles += dticks * CYC_PER_TICK;
 800c740: 68bb         	ldr	r3, [r7, #0x8]
 800c742: f244 12a0    	movw	r2, #0x41a0
 800c746: fb02 f303    	mul	r3, r2, r3
 800c74a: 2200         	movs	r2, #0x0
 800c74c: 461c         	mov	r4, r3
 800c74e: 4615         	mov	r5, r2
 800c750: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x800c788 <sys_clock_isr+0xa8>
 800c752: e9d3 2300    	ldrd	r2, r3, [r3]
 800c756: eb14 0a02    	adds.w	r10, r4, r2
 800c75a: eb45 0b03    	adc.w	r11, r5, r3
 800c75e: 4b0a         	ldr	r3, [pc, #0x28]         @ 0x800c788 <sys_clock_isr+0xa8>
 800c760: e9c3 ab00    	strd	r10, r11, [r3]
; 		sys_clock_announce(dticks);
 800c764: 68bb         	ldr	r3, [r7, #0x8]
 800c766: 4618         	mov	r0, r3
 800c768: f004 fba6    	bl	0x8010eb8 <sys_clock_announce> @ imm = #0x474c
; 	z_arm_int_exit();
 800c76c: f7f8 fc02    	bl	0x8004f74 <z_arm_int_exit> @ imm = #-0x77fc
; }
 800c770: bf00         	nop
 800c772: 3714         	adds	r7, #0x14
 800c774: 46bd         	mov	sp, r7
 800c776: e8bd 4fb1    	pop.w	{r0, r4, r5, r7, r8, r9, r10, r11, lr}
 800c77a: 4685         	mov	sp, r0
 800c77c: 4770         	bx	lr
 800c77e: bf00         	nop

0800c780 <$d>:
 800c780: 64 1f 00 20  	.word	0x20001f64
 800c784: e0 16 00 20  	.word	0x200016e0
 800c788: e8 16 00 20  	.word	0x200016e8
 800c78c: 2d 34 a9 f9  	.word	0xf9a9342d

0800c790 <sys_clock_set_timeout>:
; {
 800c790: e92d 4fb0    	push.w	{r4, r5, r7, r8, r9, r10, r11, lr}
 800c794: b09a         	sub	sp, #0x68
 800c796: af00         	add	r7, sp, #0x0
 800c798: 61f8         	str	r0, [r7, #0x1c]
 800c79a: 460b         	mov	r3, r1
 800c79c: 76fb         	strb	r3, [r7, #0x1b]
; 	if (IS_ENABLED(CONFIG_TICKLESS_KERNEL) && idle && ticks == K_TICKS_FOREVER) {
 800c79e: 7efb         	ldrb	r3, [r7, #0x1b]
 800c7a0: 2b00         	cmp	r3, #0x0
 800c7a2: d00e         	beq	0x800c7c2 <sys_clock_set_timeout+0x32> @ imm = #0x1c
 800c7a4: 69fb         	ldr	r3, [r7, #0x1c]
 800c7a6: f1b3 3fff    	cmp.w	r3, #0xffffffff
 800c7aa: d10a         	bne	0x800c7c2 <sys_clock_set_timeout+0x32> @ imm = #0x14
; 		SysTick->CTRL &= ~SysTick_CTRL_ENABLE_Msk;
 800c7ac: 4b72         	ldr	r3, [pc, #0x1c8]        @ 0x800c978 <sys_clock_set_timeout+0x1e8>
 800c7ae: 681b         	ldr	r3, [r3]
 800c7b0: 4a71         	ldr	r2, [pc, #0x1c4]        @ 0x800c978 <sys_clock_set_timeout+0x1e8>
 800c7b2: f023 0301    	bic	r3, r3, #0x1
 800c7b6: 6013         	str	r3, [r2]
; 		last_load = TIMER_STOPPED;
 800c7b8: 4b70         	ldr	r3, [pc, #0x1c0]        @ 0x800c97c <sys_clock_set_timeout+0x1ec>
 800c7ba: f04f 427f    	mov.w	r2, #0xff000000
 800c7be: 601a         	str	r2, [r3]
 800c7c0: e0d6         	b	0x800c970 <sys_clock_set_timeout+0x1e0> @ imm = #0x1ac
; 	uint32_t last_load_ = last_load;
 800c7c2: 4b6e         	ldr	r3, [pc, #0x1b8]        @ 0x800c97c <sys_clock_set_timeout+0x1ec>
 800c7c4: 681b         	ldr	r3, [r3]
 800c7c6: 667b         	str	r3, [r7, #0x64]
; 	ticks = (ticks == K_TICKS_FOREVER) ? MAX_TICKS : ticks;
 800c7c8: 69fb         	ldr	r3, [r7, #0x1c]
 800c7ca: f1b3 3fff    	cmp.w	r3, #0xffffffff
 800c7ce: d001         	beq	0x800c7d4 <sys_clock_set_timeout+0x44> @ imm = #0x2
 800c7d0: 69fb         	ldr	r3, [r7, #0x1c]
 800c7d2: e001         	b	0x800c7d8 <sys_clock_set_timeout+0x48> @ imm = #0x2
 800c7d4: f240 33e5    	movw	r3, #0x3e5
 800c7d8: 61fb         	str	r3, [r7, #0x1c]
; 	ticks = CLAMP(ticks - 1, 0, (int32_t)MAX_TICKS);
 800c7da: 69fb         	ldr	r3, [r7, #0x1c]
 800c7dc: 2b01         	cmp	r3, #0x1
 800c7de: dd07         	ble	0x800c7f0 <sys_clock_set_timeout+0x60> @ imm = #0xe
 800c7e0: 69fb         	ldr	r3, [r7, #0x1c]
 800c7e2: f240 32e6    	movw	r2, #0x3e6
 800c7e6: 4293         	cmp	r3, r2
 800c7e8: bfa8         	it	ge
 800c7ea: 4613         	movge	r3, r2
 800c7ec: 3b01         	subs	r3, #0x1
 800c7ee: e000         	b	0x800c7f2 <sys_clock_set_timeout+0x62> @ imm = #0x0
 800c7f0: 2300         	movs	r3, #0x0
 800c7f2: 61fb         	str	r3, [r7, #0x1c]
 800c7f4: 4b62         	ldr	r3, [pc, #0x188]        @ 0x800c980 <sys_clock_set_timeout+0x1f0>
 800c7f6: 64fb         	str	r3, [r7, #0x4c]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800c7f8: f3ef 8311    	mrs	r3, basepri
 800c7fc: 64bb         	str	r3, [r7, #0x48]
;   return(result);
 800c7fe: 6cbb         	ldr	r3, [r7, #0x48]
; 	key = __get_BASEPRI();
 800c800: 647b         	str	r3, [r7, #0x44]
 800c802: 2310         	movs	r3, #0x10
 800c804: 643b         	str	r3, [r7, #0x40]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 800c806: 6c3b         	ldr	r3, [r7, #0x40]
 800c808: f383 8812    	msr	basepri_max, r3
; }
 800c80c: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800c80e: f3bf 8f6f    	isb	sy
; }
 800c812: bf00         	nop
; 	return key;
 800c814: 6c7b         	ldr	r3, [r7, #0x44]
; 	k.key = arch_irq_lock();
 800c816: 623b         	str	r3, [r7, #0x20]
 800c818: 6cfb         	ldr	r3, [r7, #0x4c]
 800c81a: 63fb         	str	r3, [r7, #0x3c]
; }
 800c81c: bf00         	nop
 800c81e: 6cfb         	ldr	r3, [r7, #0x4c]
 800c820: 63bb         	str	r3, [r7, #0x38]
; }
 800c822: bf00         	nop
; 	return k;
 800c824: 6a3b         	ldr	r3, [r7, #0x20]
 800c826: 62bb         	str	r3, [r7, #0x28]
; 	uint32_t pending = elapsed();
 800c828: f7ff ff1e    	bl	0x800c668 <elapsed>     @ imm = #-0x1c4
 800c82c: 6638         	str	r0, [r7, #0x60]
; 	val1 = SysTick->VAL;
 800c82e: 4b52         	ldr	r3, [pc, #0x148]        @ 0x800c978 <sys_clock_set_timeout+0x1e8>
 800c830: 689b         	ldr	r3, [r3, #0x8]
 800c832: 65fb         	str	r3, [r7, #0x5c]
; 	cycle_count += pending;
 800c834: 6e3b         	ldr	r3, [r7, #0x60]
 800c836: 2200         	movs	r2, #0x0
 800c838: 469a         	mov	r10, r3
 800c83a: 4693         	mov	r11, r2
 800c83c: 4b51         	ldr	r3, [pc, #0x144]        @ 0x800c984 <sys_clock_set_timeout+0x1f4>
 800c83e: e9d3 2300    	ldrd	r2, r3, [r3]
 800c842: eb1a 0102    	adds.w	r1, r10, r2
 800c846: 6139         	str	r1, [r7, #0x10]
 800c848: eb4b 0303    	adc.w	r3, r11, r3
 800c84c: 617b         	str	r3, [r7, #0x14]
 800c84e: 4b4d         	ldr	r3, [pc, #0x134]        @ 0x800c984 <sys_clock_set_timeout+0x1f4>
 800c850: e9d7 1204    	ldrd	r1, r2, [r7, #16]
 800c854: e9c3 1200    	strd	r1, r2, [r3]
; 	overflow_cyc = 0U;
 800c858: 4b4b         	ldr	r3, [pc, #0x12c]        @ 0x800c988 <sys_clock_set_timeout+0x1f8>
 800c85a: 2200         	movs	r2, #0x0
 800c85c: 601a         	str	r2, [r3]
; 	uint32_t unannounced = cycle_count - announced_cycles;
 800c85e: 4b49         	ldr	r3, [pc, #0x124]        @ 0x800c984 <sys_clock_set_timeout+0x1f4>
 800c860: e9d3 2300    	ldrd	r2, r3, [r3]
 800c864: 4611         	mov	r1, r2
 800c866: 4b49         	ldr	r3, [pc, #0x124]        @ 0x800c98c <sys_clock_set_timeout+0x1fc>
 800c868: e9d3 2300    	ldrd	r2, r3, [r3]
 800c86c: 4613         	mov	r3, r2
 800c86e: 1acb         	subs	r3, r1, r3
 800c870: 65bb         	str	r3, [r7, #0x58]
; 	if ((int32_t)unannounced < 0) {
 800c872: 6dbb         	ldr	r3, [r7, #0x58]
 800c874: 2b00         	cmp	r3, #0x0
 800c876: da04         	bge	0x800c882 <sys_clock_set_timeout+0xf2> @ imm = #0x8
; 		last_load = MIN_DELAY;
 800c878: 4b40         	ldr	r3, [pc, #0x100]        @ 0x800c97c <sys_clock_set_timeout+0x1ec>
 800c87a: f240 421a    	movw	r2, #0x41a
 800c87e: 601a         	str	r2, [r3]
 800c880: e02c         	b	0x800c8dc <sys_clock_set_timeout+0x14c> @ imm = #0x58
; 		delay = ticks * CYC_PER_TICK;
 800c882: 69fb         	ldr	r3, [r7, #0x1c]
 800c884: f244 12a0    	movw	r2, #0x41a0
 800c888: fb02 f303    	mul	r3, r2, r3
 800c88c: 657b         	str	r3, [r7, #0x54]
; 		delay += unannounced;
 800c88e: 6d7a         	ldr	r2, [r7, #0x54]
 800c890: 6dbb         	ldr	r3, [r7, #0x58]
 800c892: 4413         	add	r3, r2
 800c894: 657b         	str	r3, [r7, #0x54]
; 		delay = DIV_ROUND_UP(delay, CYC_PER_TICK) * CYC_PER_TICK;
 800c896: 6d7b         	ldr	r3, [r7, #0x54]
 800c898: f503 4383    	add.w	r3, r3, #0x4180
 800c89c: 331f         	adds	r3, #0x1f
 800c89e: 4a3c         	ldr	r2, [pc, #0xf0]         @ 0x800c990 <sys_clock_set_timeout+0x200>
 800c8a0: fba2 2303    	umull	r2, r3, r2, r3
 800c8a4: 0b9b         	lsrs	r3, r3, #0xe
 800c8a6: f244 12a0    	movw	r2, #0x41a0
 800c8aa: fb02 f303    	mul	r3, r2, r3
 800c8ae: 657b         	str	r3, [r7, #0x54]
; 		delay -= unannounced;
 800c8b0: 6d7a         	ldr	r2, [r7, #0x54]
 800c8b2: 6dbb         	ldr	r3, [r7, #0x58]
 800c8b4: 1ad3         	subs	r3, r2, r3
 800c8b6: 657b         	str	r3, [r7, #0x54]
; 		delay = MAX(delay, MIN_DELAY);
 800c8b8: 6d7b         	ldr	r3, [r7, #0x54]
 800c8ba: f240 421a    	movw	r2, #0x41a
 800c8be: 4293         	cmp	r3, r2
 800c8c0: bf38         	it	lo
 800c8c2: 4613         	movlo	r3, r2
 800c8c4: 657b         	str	r3, [r7, #0x54]
; 		if (delay > MAX_CYCLES) {
 800c8c6: 6d7b         	ldr	r3, [r7, #0x54]
 800c8c8: 4a32         	ldr	r2, [pc, #0xc8]         @ 0x800c994 <sys_clock_set_timeout+0x204>
 800c8ca: 4293         	cmp	r3, r2
 800c8cc: d903         	bls	0x800c8d6 <sys_clock_set_timeout+0x146> @ imm = #0x6
; 			last_load = MAX_CYCLES;
 800c8ce: 4b2b         	ldr	r3, [pc, #0xac]         @ 0x800c97c <sys_clock_set_timeout+0x1ec>
 800c8d0: 4a30         	ldr	r2, [pc, #0xc0]         @ 0x800c994 <sys_clock_set_timeout+0x204>
 800c8d2: 601a         	str	r2, [r3]
 800c8d4: e002         	b	0x800c8dc <sys_clock_set_timeout+0x14c> @ imm = #0x4
; 			last_load = delay;
 800c8d6: 4a29         	ldr	r2, [pc, #0xa4]         @ 0x800c97c <sys_clock_set_timeout+0x1ec>
 800c8d8: 6d7b         	ldr	r3, [r7, #0x54]
 800c8da: 6013         	str	r3, [r2]
; 	val2 = SysTick->VAL;
 800c8dc: 4b26         	ldr	r3, [pc, #0x98]         @ 0x800c978 <sys_clock_set_timeout+0x1e8>
 800c8de: 689b         	ldr	r3, [r3, #0x8]
 800c8e0: 653b         	str	r3, [r7, #0x50]
; 	SysTick->LOAD = last_load - 1;
 800c8e2: 4b26         	ldr	r3, [pc, #0x98]         @ 0x800c97c <sys_clock_set_timeout+0x1ec>
 800c8e4: 681b         	ldr	r3, [r3]
 800c8e6: 4a24         	ldr	r2, [pc, #0x90]         @ 0x800c978 <sys_clock_set_timeout+0x1e8>
 800c8e8: 3b01         	subs	r3, #0x1
 800c8ea: 6053         	str	r3, [r2, #0x4]
; 	SysTick->VAL = 0; /* resets timer to last_load */
 800c8ec: 4b22         	ldr	r3, [pc, #0x88]         @ 0x800c978 <sys_clock_set_timeout+0x1e8>
 800c8ee: 2200         	movs	r2, #0x0
 800c8f0: 609a         	str	r2, [r3, #0x8]
; 	if (val1 < val2) {
 800c8f2: 6dfa         	ldr	r2, [r7, #0x5c]
 800c8f4: 6d3b         	ldr	r3, [r7, #0x50]
 800c8f6: 429a         	cmp	r2, r3
 800c8f8: d216         	bhs	0x800c928 <sys_clock_set_timeout+0x198> @ imm = #0x2c
; 		cycle_count += (val1 + (last_load_ - val2));
 800c8fa: 6e7a         	ldr	r2, [r7, #0x64]
 800c8fc: 6d3b         	ldr	r3, [r7, #0x50]
 800c8fe: 1ad2         	subs	r2, r2, r3
 800c900: 6dfb         	ldr	r3, [r7, #0x5c]
 800c902: 4413         	add	r3, r2
 800c904: 2200         	movs	r2, #0x0
 800c906: 4698         	mov	r8, r3
 800c908: 4691         	mov	r9, r2
 800c90a: 4b1e         	ldr	r3, [pc, #0x78]         @ 0x800c984 <sys_clock_set_timeout+0x1f4>
 800c90c: e9d3 2300    	ldrd	r2, r3, [r3]
 800c910: eb18 0102    	adds.w	r1, r8, r2
 800c914: 60b9         	str	r1, [r7, #0x8]
 800c916: eb49 0303    	adc.w	r3, r9, r3
 800c91a: 60fb         	str	r3, [r7, #0xc]
 800c91c: 4b19         	ldr	r3, [pc, #0x64]         @ 0x800c984 <sys_clock_set_timeout+0x1f4>
 800c91e: e9d7 1202    	ldrd	r1, r2, [r7, #8]
 800c922: e9c3 1200    	strd	r1, r2, [r3]
 800c926: e012         	b	0x800c94e <sys_clock_set_timeout+0x1be> @ imm = #0x24
; 		cycle_count += (val1 - val2);
 800c928: 6dfa         	ldr	r2, [r7, #0x5c]
 800c92a: 6d3b         	ldr	r3, [r7, #0x50]
 800c92c: 1ad3         	subs	r3, r2, r3
 800c92e: 2200         	movs	r2, #0x0
 800c930: 461c         	mov	r4, r3
 800c932: 4615         	mov	r5, r2
 800c934: 4b13         	ldr	r3, [pc, #0x4c]         @ 0x800c984 <sys_clock_set_timeout+0x1f4>
 800c936: e9d3 2300    	ldrd	r2, r3, [r3]
 800c93a: 18a1         	adds	r1, r4, r2
 800c93c: 6039         	str	r1, [r7]
 800c93e: eb45 0303    	adc.w	r3, r5, r3
 800c942: 607b         	str	r3, [r7, #0x4]
 800c944: 4b0f         	ldr	r3, [pc, #0x3c]         @ 0x800c984 <sys_clock_set_timeout+0x1f4>
 800c946: e9d7 1200    	ldrd	r1, r2, [r7]
 800c94a: e9c3 1200    	strd	r1, r2, [r3]
 800c94e: 4b0c         	ldr	r3, [pc, #0x30]         @ 0x800c980 <sys_clock_set_timeout+0x1f0>
 800c950: 637b         	str	r3, [r7, #0x34]
 800c952: 6abb         	ldr	r3, [r7, #0x28]
 800c954: 627b         	str	r3, [r7, #0x24]
; 	arch_irq_unlock(key.key);
 800c956: 6a7b         	ldr	r3, [r7, #0x24]
 800c958: 633b         	str	r3, [r7, #0x30]
 800c95a: 6b3b         	ldr	r3, [r7, #0x30]
 800c95c: 62fb         	str	r3, [r7, #0x2c]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800c95e: 6afb         	ldr	r3, [r7, #0x2c]
 800c960: f383 8811    	msr	basepri, r3
; }
 800c964: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800c966: f3bf 8f6f    	isb	sy
; }
 800c96a: bf00         	nop
; }
 800c96c: bf00         	nop
; }
 800c96e: bf00         	nop
; }
 800c970: 3768         	adds	r7, #0x68
 800c972: 46bd         	mov	sp, r7
 800c974: e8bd 8fb0    	pop.w	{r4, r5, r7, r8, r9, r10, r11, pc}

0800c978 <$d>:
 800c978: 10 e0 00 e0  	.word	0xe000e010
 800c97c: 60 1f 00 20  	.word	0x20001f60
 800c980: 60 1f 00 20  	.word	0x20001f60
 800c984: e0 16 00 20  	.word	0x200016e0
 800c988: 64 1f 00 20  	.word	0x20001f64
 800c98c: e8 16 00 20  	.word	0x200016e8
 800c990: 2d 34 a9 f9  	.word	0xf9a9342d
 800c994: 20 94 ff 00  	.word	0x00ff9420

0800c998 <sys_clock_elapsed>:
; {
 800c998: b580         	push	{r7, lr}
 800c99a: b08e         	sub	sp, #0x38
 800c99c: af00         	add	r7, sp, #0x0
 800c99e: 4b22         	ldr	r3, [pc, #0x88]         @ 0x800ca28 <sys_clock_elapsed+0x90>
 800c9a0: 623b         	str	r3, [r7, #0x20]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800c9a2: f3ef 8311    	mrs	r3, basepri
 800c9a6: 61fb         	str	r3, [r7, #0x1c]
;   return(result);
 800c9a8: 69fb         	ldr	r3, [r7, #0x1c]
; 	key = __get_BASEPRI();
 800c9aa: 61bb         	str	r3, [r7, #0x18]
 800c9ac: 2310         	movs	r3, #0x10
 800c9ae: 617b         	str	r3, [r7, #0x14]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 800c9b0: 697b         	ldr	r3, [r7, #0x14]
 800c9b2: f383 8812    	msr	basepri_max, r3
; }
 800c9b6: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800c9b8: f3bf 8f6f    	isb	sy
; }
 800c9bc: bf00         	nop
; 	return key;
 800c9be: 69bb         	ldr	r3, [r7, #0x18]
; 	k.key = arch_irq_lock();
 800c9c0: 607b         	str	r3, [r7, #0x4]
 800c9c2: 6a3b         	ldr	r3, [r7, #0x20]
 800c9c4: 613b         	str	r3, [r7, #0x10]
; }
 800c9c6: bf00         	nop
 800c9c8: 6a3b         	ldr	r3, [r7, #0x20]
 800c9ca: 60fb         	str	r3, [r7, #0xc]
; }
 800c9cc: bf00         	nop
; 	return k;
 800c9ce: 687b         	ldr	r3, [r7, #0x4]
 800c9d0: 60bb         	str	r3, [r7, #0x8]
; 	uint32_t unannounced = cycle_count - announced_cycles;
 800c9d2: 4b16         	ldr	r3, [pc, #0x58]         @ 0x800ca2c <sys_clock_elapsed+0x94>
 800c9d4: e9d3 2300    	ldrd	r2, r3, [r3]
 800c9d8: 4611         	mov	r1, r2
 800c9da: 4b15         	ldr	r3, [pc, #0x54]         @ 0x800ca30 <sys_clock_elapsed+0x98>
 800c9dc: e9d3 2300    	ldrd	r2, r3, [r3]
 800c9e0: 4613         	mov	r3, r2
 800c9e2: 1acb         	subs	r3, r1, r3
 800c9e4: 637b         	str	r3, [r7, #0x34]
; 	uint32_t cyc = elapsed() + unannounced;
 800c9e6: f7ff fe3f    	bl	0x800c668 <elapsed>     @ imm = #-0x382
 800c9ea: 4602         	mov	r2, r0
 800c9ec: 6b7b         	ldr	r3, [r7, #0x34]
 800c9ee: 4413         	add	r3, r2
 800c9f0: 633b         	str	r3, [r7, #0x30]
 800c9f2: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x800ca28 <sys_clock_elapsed+0x90>
 800c9f4: 62fb         	str	r3, [r7, #0x2c]
 800c9f6: 68bb         	ldr	r3, [r7, #0x8]
 800c9f8: 603b         	str	r3, [r7]
; 	arch_irq_unlock(key.key);
 800c9fa: 683b         	ldr	r3, [r7]
 800c9fc: 62bb         	str	r3, [r7, #0x28]
 800c9fe: 6abb         	ldr	r3, [r7, #0x28]
 800ca00: 627b         	str	r3, [r7, #0x24]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800ca02: 6a7b         	ldr	r3, [r7, #0x24]
 800ca04: f383 8811    	msr	basepri, r3
; }
 800ca08: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800ca0a: f3bf 8f6f    	isb	sy
; }
 800ca0e: bf00         	nop
; }
 800ca10: bf00         	nop
; }
 800ca12: bf00         	nop
; 	return cyc / CYC_PER_TICK;
 800ca14: 6b3b         	ldr	r3, [r7, #0x30]
 800ca16: 4a07         	ldr	r2, [pc, #0x1c]         @ 0x800ca34 <sys_clock_elapsed+0x9c>
 800ca18: fba2 2303    	umull	r2, r3, r2, r3
 800ca1c: 0b9b         	lsrs	r3, r3, #0xe
; }
 800ca1e: 4618         	mov	r0, r3
 800ca20: 3738         	adds	r7, #0x38
 800ca22: 46bd         	mov	sp, r7
 800ca24: bd80         	pop	{r7, pc}
 800ca26: bf00         	nop

0800ca28 <$d>:
 800ca28: 60 1f 00 20  	.word	0x20001f60
 800ca2c: e0 16 00 20  	.word	0x200016e0
 800ca30: e8 16 00 20  	.word	0x200016e8
 800ca34: 2d 34 a9 f9  	.word	0xf9a9342d

0800ca38 <sys_clock_cycle_get_32>:
; {
 800ca38: b580         	push	{r7, lr}
 800ca3a: b08e         	sub	sp, #0x38
 800ca3c: af00         	add	r7, sp, #0x0
 800ca3e: 4b1d         	ldr	r3, [pc, #0x74]         @ 0x800cab4 <sys_clock_cycle_get_32+0x7c>
 800ca40: 627b         	str	r3, [r7, #0x24]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800ca42: f3ef 8311    	mrs	r3, basepri
 800ca46: 623b         	str	r3, [r7, #0x20]
;   return(result);
 800ca48: 6a3b         	ldr	r3, [r7, #0x20]
; 	key = __get_BASEPRI();
 800ca4a: 61fb         	str	r3, [r7, #0x1c]
 800ca4c: 2310         	movs	r3, #0x10
 800ca4e: 61bb         	str	r3, [r7, #0x18]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 800ca50: 69bb         	ldr	r3, [r7, #0x18]
 800ca52: f383 8812    	msr	basepri_max, r3
; }
 800ca56: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800ca58: f3bf 8f6f    	isb	sy
; }
 800ca5c: bf00         	nop
; 	return key;
 800ca5e: 69fb         	ldr	r3, [r7, #0x1c]
; 	k.key = arch_irq_lock();
 800ca60: 60bb         	str	r3, [r7, #0x8]
 800ca62: 6a7b         	ldr	r3, [r7, #0x24]
 800ca64: 617b         	str	r3, [r7, #0x14]
; }
 800ca66: bf00         	nop
 800ca68: 6a7b         	ldr	r3, [r7, #0x24]
 800ca6a: 613b         	str	r3, [r7, #0x10]
; }
 800ca6c: bf00         	nop
; 	return k;
 800ca6e: 68bb         	ldr	r3, [r7, #0x8]
 800ca70: 60fb         	str	r3, [r7, #0xc]
; 	uint32_t ret = cycle_count;
 800ca72: 4b11         	ldr	r3, [pc, #0x44]         @ 0x800cab8 <sys_clock_cycle_get_32+0x80>
 800ca74: e9d3 2300    	ldrd	r2, r3, [r3]
 800ca78: 4613         	mov	r3, r2
 800ca7a: 637b         	str	r3, [r7, #0x34]
; 	ret += elapsed();
 800ca7c: f7ff fdf4    	bl	0x800c668 <elapsed>     @ imm = #-0x418
 800ca80: 4602         	mov	r2, r0
 800ca82: 6b7b         	ldr	r3, [r7, #0x34]
 800ca84: 4413         	add	r3, r2
 800ca86: 637b         	str	r3, [r7, #0x34]
 800ca88: 4b0a         	ldr	r3, [pc, #0x28]         @ 0x800cab4 <sys_clock_cycle_get_32+0x7c>
 800ca8a: 633b         	str	r3, [r7, #0x30]
 800ca8c: 68fb         	ldr	r3, [r7, #0xc]
 800ca8e: 607b         	str	r3, [r7, #0x4]
; 	arch_irq_unlock(key.key);
 800ca90: 687b         	ldr	r3, [r7, #0x4]
 800ca92: 62fb         	str	r3, [r7, #0x2c]
 800ca94: 6afb         	ldr	r3, [r7, #0x2c]
 800ca96: 62bb         	str	r3, [r7, #0x28]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800ca98: 6abb         	ldr	r3, [r7, #0x28]
 800ca9a: f383 8811    	msr	basepri, r3
; }
 800ca9e: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800caa0: f3bf 8f6f    	isb	sy
; }
 800caa4: bf00         	nop
; }
 800caa6: bf00         	nop
; }
 800caa8: bf00         	nop
; 	return ret;
 800caaa: 6b7b         	ldr	r3, [r7, #0x34]
; }
 800caac: 4618         	mov	r0, r3
 800caae: 3738         	adds	r7, #0x38
 800cab0: 46bd         	mov	sp, r7
 800cab2: bd80         	pop	{r7, pc}

0800cab4 <$d>:
 800cab4: 60 1f 00 20  	.word	0x20001f60
 800cab8: e0 16 00 20  	.word	0x200016e0

0800cabc <sys_clock_driver_init>:
; {
 800cabc: b580         	push	{r7, lr}
 800cabe: af00         	add	r7, sp, #0x0
; 	NVIC_SetPriority(SysTick_IRQn, _IRQ_PRIO_OFFSET);
 800cac0: 2101         	movs	r1, #0x1
 800cac2: f04f 30ff    	mov.w	r0, #0xffffffff
 800cac6: f7ff fda5    	bl	0x800c614 <__NVIC_SetPriority> @ imm = #-0x4b6
; 	last_load = CYC_PER_TICK;
 800caca: 4b0c         	ldr	r3, [pc, #0x30]         @ 0x800cafc <sys_clock_driver_init+0x40>
 800cacc: f244 12a0    	movw	r2, #0x41a0
 800cad0: 601a         	str	r2, [r3]
; 	overflow_cyc = 0U;
 800cad2: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x800cb00 <sys_clock_driver_init+0x44>
 800cad4: 2200         	movs	r2, #0x0
 800cad6: 601a         	str	r2, [r3]
; 	SysTick->LOAD = last_load - 1;
 800cad8: 4b08         	ldr	r3, [pc, #0x20]         @ 0x800cafc <sys_clock_driver_init+0x40>
 800cada: 681b         	ldr	r3, [r3]
 800cadc: 4a09         	ldr	r2, [pc, #0x24]         @ 0x800cb04 <sys_clock_driver_init+0x48>
 800cade: 3b01         	subs	r3, #0x1
 800cae0: 6053         	str	r3, [r2, #0x4]
; 	SysTick->VAL = 0; /* resets timer to last_load */
 800cae2: 4b08         	ldr	r3, [pc, #0x20]         @ 0x800cb04 <sys_clock_driver_init+0x48>
 800cae4: 2200         	movs	r2, #0x0
 800cae6: 609a         	str	r2, [r3, #0x8]
; 	SysTick->CTRL |= (SysTick_CTRL_ENABLE_Msk |
 800cae8: 4b06         	ldr	r3, [pc, #0x18]         @ 0x800cb04 <sys_clock_driver_init+0x48>
 800caea: 681b         	ldr	r3, [r3]
 800caec: 4a05         	ldr	r2, [pc, #0x14]         @ 0x800cb04 <sys_clock_driver_init+0x48>
 800caee: f043 0307    	orr	r3, r3, #0x7
 800caf2: 6013         	str	r3, [r2]
; 	return 0;
 800caf4: 2300         	movs	r3, #0x0
; }
 800caf6: 4618         	mov	r0, r3
 800caf8: bd80         	pop	{r7, pc}
 800cafa: bf00         	nop

0800cafc <$d>:
 800cafc: 60 1f 00 20  	.word	0x20001f60
 800cb00: 64 1f 00 20  	.word	0x20001f64
 800cb04: 10 e0 00 e0  	.word	0xe000e010

0800cb08 <arm_mat_add_f32>:
; {
 800cb08: b5f8         	push	{r3, r4, r5, r6, r7, lr}
;     numSamples = (uint32_t) pSrcA->numRows * pSrcA->numCols;
 800cb0a: 8804         	ldrh	r4, [r0]
 800cb0c: 8843         	ldrh	r3, [r0, #0x2]
;   float32_t *pInA = pSrcA->pData;                /* input data matrix pointer A */
 800cb0e: 6847         	ldr	r7, [r0, #0x4]
;   float32_t *pInB = pSrcB->pData;                /* input data matrix pointer B */
 800cb10: 684e         	ldr	r6, [r1, #0x4]
;   float32_t *pOut = pDst->pData;                 /* output data matrix pointer */
 800cb12: 6855         	ldr	r5, [r2, #0x4]
;     numSamples = (uint32_t) pSrcA->numRows * pSrcA->numCols;
 800cb14: fb03 f404    	mul	r4, r3, r4
;     while (blkCnt > 0U)
 800cb18: b14c         	cbz	r4, 0x800cb2e <arm_mat_add_f32+0x26> @ imm = #0x12
;       *pOut++ = *pInA++ + *pInB++;
 800cb1a: f856 1b04    	ldr	r1, [r6], #4
 800cb1e: f857 0b04    	ldr	r0, [r7], #4
 800cb22: f7f3 fb37    	bl	0x8000194 <__aeabi_fadd> @ imm = #-0xc992
;     while (blkCnt > 0U)
 800cb26: 3c01         	subs	r4, #0x1
;       *pOut++ = *pInA++ + *pInB++;
 800cb28: f845 0b04    	str	r0, [r5], #4
;     while (blkCnt > 0U)
 800cb2c: d1f5         	bne	0x800cb1a <arm_mat_add_f32+0x12> @ imm = #-0x16
; }
 800cb2e: 2000         	movs	r0, #0x0
 800cb30: bdf8         	pop	{r3, r4, r5, r6, r7, pc}
 800cb32: bf00         	nop

0800cb34 <arm_mat_init_f32>:
;   S->numRows = nRows;
 800cb34: 8001         	strh	r1, [r0]
;   S->numCols = nColumns;
 800cb36: 8042         	strh	r2, [r0, #0x2]
;   S->pData = pData;
 800cb38: 6043         	str	r3, [r0, #0x4]
; }
 800cb3a: 4770         	bx	lr

0800cb3c <arm_mat_inverse_f32>:
; {
 800cb3c: e92d 4ff0    	push.w	{r4, r5, r6, r7, r8, r9, r10, r11, lr}
 800cb40: b08b         	sub	sp, #0x2c
;   uint32_t numRows = pSrc->numRows;              /* Number of rows in the matrix  */
 800cb42: 8805         	ldrh	r5, [r0]
;   uint32_t numCols = pSrc->numCols;              /* Number of Cols in the matrix  */
 800cb44: 8843         	ldrh	r3, [r0, #0x2]
;   float32_t *pOut = pDst->pData;                 /* output data matrix pointer */
 800cb46: 684c         	ldr	r4, [r1, #0x4]
;   uint32_t numRows = pSrc->numRows;              /* Number of rows in the matrix  */
 800cb48: 9501         	str	r5, [sp, #0x4]
; {
 800cb4a: 4682         	mov	r10, r0
 800cb4c: 4688         	mov	r8, r1
;   uint32_t numCols = pSrc->numCols;              /* Number of Cols in the matrix  */
 800cb4e: 9309         	str	r3, [sp, #0x24]
;     while (rowCnt > 0U)
 800cb50: b31d         	cbz	r5, 0x800cb9a <arm_mat_inverse_f32+0x5e> @ imm = #0x46
;       *pTmp++ = 1.0f;
 800cb52: f04f 567e    	mov.w	r6, #0x3f800000
;     while (rowCnt > 0U)
 800cb56: 2700         	movs	r7, #0x0
 800cb58: e012         	b	0x800cb80 <arm_mat_inverse_f32+0x44> @ imm = #0x24
;         *pTmp++ = 0.0f;
 800cb5a: f010 fe47    	bl	0x801d7ec <memset>      @ imm = #0x10c8e
 800cb5e: 44a1         	add	r9, r4
;       while (j > 0U)
 800cb60: 3d01         	subs	r5, #0x1
;       *pTmp++ = 1.0f;
 800cb62: f844 6027    	str.w	r6, [r4, r7, lsl #2]
 800cb66: f109 0404    	add.w	r4, r9, #0x4
;       while (j > 0U)
 800cb6a: f107 0701    	add.w	r7, r7, #0x1
 800cb6e: d014         	beq	0x800cb9a <arm_mat_inverse_f32+0x5e> @ imm = #0x28
 800cb70: ea4f 0985    	lsl.w	r9, r5, #0x2
;         *pTmp++ = 0.0f;
 800cb74: 4620         	mov	r0, r4
 800cb76: 464a         	mov	r2, r9
 800cb78: 2100         	movs	r1, #0x0
 800cb7a: f010 fe37    	bl	0x801d7ec <memset>      @ imm = #0x10c6e
 800cb7e: 444c         	add	r4, r9
;       while (j > 0U)
 800cb80: ea4f 0987    	lsl.w	r9, r7, #0x2
;         *pTmp++ = 0.0f;
 800cb84: 464a         	mov	r2, r9
 800cb86: 2100         	movs	r1, #0x0
 800cb88: 4620         	mov	r0, r4
;       while (j > 0U)
 800cb8a: 2f00         	cmp	r7, #0x0
 800cb8c: d1e5         	bne	0x800cb5a <arm_mat_inverse_f32+0x1e> @ imm = #-0x36
;       while (j > 0U)
 800cb8e: 3d01         	subs	r5, #0x1
;       *pTmp++ = 1.0f;
 800cb90: f844 6b04    	str	r6, [r4], #4
;       while (j > 0U)
 800cb94: f04f 0701    	mov.w	r7, #0x1
 800cb98: d1ea         	bne	0x800cb70 <arm_mat_inverse_f32+0x34> @ imm = #-0x2c
;     for(column = 0U; column < numCols; column++)
 800cb9a: 9b09         	ldr	r3, [sp, #0x24]
 800cb9c: 2b00         	cmp	r3, #0x0
 800cb9e: f000 812f    	beq.w	0x800ce00 <arm_mat_inverse_f32+0x2c4> @ imm = #0x25e
 800cba2: 2200         	movs	r2, #0x0
 800cba4: 9200         	str	r2, [sp]
 800cba6: 9202         	str	r2, [sp, #0x8]
;   uint32_t selectedRow,pivotRow,i, rowNb, rowCnt, flag = 0U, j,column;      /* loop counters */
 800cba8: 9208         	str	r2, [sp, #0x20]
;       pTmp = ELEM(pSrc,column,column) ;
 800cbaa: f8ba 1002    	ldrh.w	r1, [r10, #0x2]
 800cbae: 9b02         	ldr	r3, [sp, #0x8]
;       for (rowNb = column+1; rowNb < numRows; rowNb++)
 800cbb0: 9801         	ldr	r0, [sp, #0x4]
;       pTmp = ELEM(pSrc,column,column) ;
 800cbb2: f8da 2004    	ldr.w	r2, [r10, #0x4]
 800cbb6: 9103         	str	r1, [sp, #0xc]
 800cbb8: f101 0901    	add.w	r9, r1, #0x1
 800cbbc: ea4f 0989    	lsl.w	r9, r9, #0x2
 800cbc0: fb09 f503    	mul	r5, r9, r3
 800cbc4: 461c         	mov	r4, r3
;       for (rowNb = column+1; rowNb < numRows; rowNb++)
 800cbc6: 3301         	adds	r3, #0x1
 800cbc8: 4298         	cmp	r0, r3
;       pivot = *pTmp;
 800cbca: 5957         	ldr	r7, [r2, r5]
;       for (rowNb = column+1; rowNb < numRows; rowNb++)
 800cbcc: 9302         	str	r3, [sp, #0x8]
;       pTmp = ELEM(pSrc,column,column) ;
 800cbce: 4415         	add	r5, r2
;       for (rowNb = column+1; rowNb < numRows; rowNb++)
 800cbd0: 461e         	mov	r6, r3
 800cbd2: f240 8152    	bls.w	0x800ce7a <arm_mat_inverse_f32+0x33e> @ imm = #0x2a4
 800cbd6: fb03 4301    	mla	r3, r3, r1, r4
 800cbda: e9cd 8206    	strd	r8, r2, [sp, #24]
 800cbde: f1a9 0904    	sub.w	r9, r9, #0x4
 800cbe2: eb02 0b83    	add.w	r11, r2, r3, lsl #2
 800cbe6: e9cd 5404    	strd	r5, r4, [sp, #16]
 800cbea: 465d         	mov	r5, r11
 800cbec: 46cb         	mov	r11, r9
 800cbee: 4681         	mov	r9, r0
;           newPivot = *pTmp;
 800cbf0: f8d5 8000    	ldr.w	r8, [r5]
;           if (fabsf(newPivot) > fabsf(pivot))
 800cbf4: f027 4100    	bic	r1, r7, #0x80000000
 800cbf8: f028 4000    	bic	r0, r8, #0x80000000
 800cbfc: f7f3 fd8e    	bl	0x800071c <__aeabi_fcmpgt> @ imm = #-0xc4e4
;       for (rowNb = column+1; rowNb < numRows; rowNb++)
 800cc00: 445d         	add	r5, r11
;           if (fabsf(newPivot) > fabsf(pivot))
 800cc02: b108         	cbz	r0, 0x800cc08 <arm_mat_inverse_f32+0xcc> @ imm = #0x2
 800cc04: 4634         	mov	r4, r6
;           newPivot = *pTmp;
 800cc06: 4647         	mov	r7, r8
;       for (rowNb = column+1; rowNb < numRows; rowNb++)
 800cc08: 3601         	adds	r6, #0x1
 800cc0a: 45b1         	cmp	r9, r6
 800cc0c: d1f0         	bne	0x800cbf0 <arm_mat_inverse_f32+0xb4> @ imm = #-0x20
 800cc0e: 4626         	mov	r6, r4
 800cc10: e9dd 4805    	ldrd	r4, r8, [sp, #20]
 800cc14: 9d04         	ldr	r5, [sp, #0x10]
 800cc16: 9a07         	ldr	r2, [sp, #0x1c]
;       if ((pivot != 0.0f) && (selectedRow != column))
 800cc18: 9204         	str	r2, [sp, #0x10]
 800cc1a: 2100         	movs	r1, #0x0
 800cc1c: 4638         	mov	r0, r7
 800cc1e: f7f3 fd55    	bl	0x80006cc <__aeabi_fcmpeq> @ imm = #-0xc556
 800cc22: 2800         	cmp	r0, #0x0
 800cc24: f040 80f1    	bne.w	0x800ce0a <arm_mat_inverse_f32+0x2ce> @ imm = #0x1e2
 800cc28: 9a00         	ldr	r2, [sp]
 800cc2a: 4296         	cmp	r6, r2
 800cc2c: 9a04         	ldr	r2, [sp, #0x10]
 800cc2e: f040 80f1    	bne.w	0x800ce14 <arm_mat_inverse_f32+0x2d8> @ imm = #0x1e2
;       if ((flag != 1U) && (pivot == 0.0f))
 800cc32: 9b08         	ldr	r3, [sp, #0x20]
 800cc34: 2b01         	cmp	r3, #0x1
 800cc36: f000 8118    	beq.w	0x800ce6a <arm_mat_inverse_f32+0x32e> @ imm = #0x230
;       SCALE_ROW_F32(pSrc,column,pivot,pivotRow);
 800cc3a: 9b03         	ldr	r3, [sp, #0xc]
 800cc3c: fb03 4504    	mla	r5, r3, r4, r4
 800cc40: eb02 0585    	add.w	r5, r2, r5, lsl #2
;       pivot = 1.0f / pivot;
 800cc44: 4639         	mov	r1, r7
 800cc46: f04f 507e    	mov.w	r0, #0x3f800000
 800cc4a: f7f3 fc5f    	bl	0x800050c <__divsf3>    @ imm = #-0xc742
;       SCALE_ROW_F32(pSrc,column,pivot,pivotRow);
 800cc4e: 9b03         	ldr	r3, [sp, #0xc]
 800cc50: 1b1f         	subs	r7, r3, r4
 800cc52: 2f00         	cmp	r7, #0x0
;       pivot = 1.0f / pivot;
 800cc54: 4606         	mov	r6, r0
;       SCALE_ROW_F32(pSrc,column,pivot,pivotRow);
 800cc56: dd0a         	ble	0x800cc6e <arm_mat_inverse_f32+0x132> @ imm = #0x14
 800cc58: eb05 0787    	add.w	r7, r5, r7, lsl #2
 800cc5c: f855 0b04    	ldr	r0, [r5], #4
 800cc60: 4631         	mov	r1, r6
 800cc62: f7f3 fb9f    	bl	0x80003a4 <__mulsf3>    @ imm = #-0xc8c2
 800cc66: 42bd         	cmp	r5, r7
 800cc68: f845 0c04    	str	r0, [r5, #-4]
 800cc6c: d1f6         	bne	0x800cc5c <arm_mat_inverse_f32+0x120> @ imm = #-0x14
;       SCALE_ROW_F32(pDst,0,pivot,pivotRow);
 800cc6e: f8b8 3002    	ldrh.w	r3, [r8, #0x2]
 800cc72: f8d8 7004    	ldr.w	r7, [r8, #0x4]
 800cc76: 009d         	lsls	r5, r3, #0x2
 800cc78: fb05 7704    	mla	r7, r5, r4, r7
 800cc7c: 443d         	add	r5, r7
 800cc7e: b143         	cbz	r3, 0x800cc92 <arm_mat_inverse_f32+0x156> @ imm = #0x10
 800cc80: f857 0b04    	ldr	r0, [r7], #4
 800cc84: 4631         	mov	r1, r6
 800cc86: f7f3 fb8d    	bl	0x80003a4 <__mulsf3>    @ imm = #-0xc8e6
 800cc8a: 42af         	cmp	r7, r5
 800cc8c: f847 0c04    	str	r0, [r7, #-4]
 800cc90: d1f6         	bne	0x800cc80 <arm_mat_inverse_f32+0x144> @ imm = #-0x14
;       for (;rowNb < pivotRow; rowNb++)
 800cc92: 9b00         	ldr	r3, [sp]
 800cc94: 2b00         	cmp	r3, #0x0
 800cc96: d044         	beq	0x800cd22 <arm_mat_inverse_f32+0x1e6> @ imm = #0x88
;       rowNb = 0;
 800cc98: f04f 0b00    	mov.w	r11, #0x0
 800cc9c: 46d9         	mov	r9, r11
;            pTmp = ELEM(pSrc,rowNb,column) ;
 800cc9e: f8ba b002    	ldrh.w	r11, [r10, #0x2]
 800cca2: f8da 5004    	ldr.w	r5, [r10, #0x4]
 800cca6: fb09 420b    	mla	r2, r9, r11, r4
;            MAS_ROW_F32(column,pSrc,rowNb,pivot,pSrc,pivotRow);
 800ccaa: fb0b 4704    	mla	r7, r11, r4, r4
 800ccae: ebab 0b04    	sub.w	r11, r11, r4
 800ccb2: f1bb 0f00    	cmp.w	r11, #0x0
;            pivot = *pTmp;
 800ccb6: f855 6022    	ldr.w	r6, [r5, r2, lsl #2]
;            MAS_ROW_F32(column,pSrc,rowNb,pivot,pSrc,pivotRow);
 800ccba: eb05 0787    	add.w	r7, r5, r7, lsl #2
;            pTmp = ELEM(pSrc,rowNb,column) ;
 800ccbe: eb05 0582    	add.w	r5, r5, r2, lsl #2
;            MAS_ROW_F32(column,pSrc,rowNb,pivot,pSrc,pivotRow);
 800ccc2: dd0f         	ble	0x800cce4 <arm_mat_inverse_f32+0x1a8> @ imm = #0x1e
 800ccc4: eb05 0b8b    	add.w	r11, r5, r11, lsl #2
 800ccc8: f857 1b04    	ldr	r1, [r7], #4
 800cccc: 4630         	mov	r0, r6
 800ccce: f7f3 fb69    	bl	0x80003a4 <__mulsf3>    @ imm = #-0xc92e
 800ccd2: 4601         	mov	r1, r0
 800ccd4: f855 0b04    	ldr	r0, [r5], #4
 800ccd8: f7f3 fa5a    	bl	0x8000190 <__subsf3>    @ imm = #-0xcb4c
 800ccdc: 45ab         	cmp	r11, r5
 800ccde: f845 0c04    	str	r0, [r5, #-4]
 800cce2: d1f1         	bne	0x800ccc8 <arm_mat_inverse_f32+0x18c> @ imm = #-0x1e
;            MAS_ROW_F32(0     ,pDst,rowNb,pivot,pDst,pivotRow);
 800cce4: f8b8 2002    	ldrh.w	r2, [r8, #0x2]
 800cce8: f8d8 7004    	ldr.w	r7, [r8, #0x4]
 800ccec: ea4f 0b82    	lsl.w	r11, r2, #0x2
 800ccf0: fb0b 7509    	mla	r5, r11, r9, r7
 800ccf4: fb0b 7704    	mla	r7, r11, r4, r7
 800ccf8: 44ab         	add	r11, r5
 800ccfa: b16a         	cbz	r2, 0x800cd18 <arm_mat_inverse_f32+0x1dc> @ imm = #0x1a
 800ccfc: f857 1b04    	ldr	r1, [r7], #4
 800cd00: 4630         	mov	r0, r6
 800cd02: f7f3 fb4f    	bl	0x80003a4 <__mulsf3>    @ imm = #-0xc962
 800cd06: 4601         	mov	r1, r0
 800cd08: f855 0b04    	ldr	r0, [r5], #4
 800cd0c: f7f3 fa40    	bl	0x8000190 <__subsf3>    @ imm = #-0xcb80
 800cd10: 455d         	cmp	r5, r11
 800cd12: f845 0c04    	str	r0, [r5, #-4]
 800cd16: d1f1         	bne	0x800ccfc <arm_mat_inverse_f32+0x1c0> @ imm = #-0x1e
;       for (;rowNb < pivotRow; rowNb++)
 800cd18: 9b00         	ldr	r3, [sp]
 800cd1a: f109 0901    	add.w	r9, r9, #0x1
 800cd1e: 4599         	cmp	r9, r3
 800cd20: d1bd         	bne	0x800cc9e <arm_mat_inverse_f32+0x162> @ imm = #-0x86
;       for (rowNb = pivotRow + 1; rowNb < numRows; rowNb++)
 800cd22: e9dd 2301    	ldrd	r2, r3, [sp, #4]
 800cd26: 429a         	cmp	r2, r3
 800cd28: d941         	bls	0x800cdae <arm_mat_inverse_f32+0x272> @ imm = #0x82
;       for (rowNb = column+1; rowNb < numRows; rowNb++)
 800cd2a: 4699         	mov	r9, r3
 800cd2c: 46a3         	mov	r11, r4
;            pTmp = ELEM(pSrc,rowNb,column) ;
 800cd2e: f8ba 4002    	ldrh.w	r4, [r10, #0x2]
 800cd32: f8da 5004    	ldr.w	r5, [r10, #0x4]
 800cd36: fb09 b204    	mla	r2, r9, r4, r11
;            MAS_ROW_F32(column,pSrc,rowNb,pivot,pSrc,pivotRow);
 800cd3a: fb04 b70b    	mla	r7, r4, r11, r11
 800cd3e: eba4 040b    	sub.w	r4, r4, r11
 800cd42: 2c00         	cmp	r4, #0x0
;            pivot = *pTmp;
 800cd44: f855 6022    	ldr.w	r6, [r5, r2, lsl #2]
;            MAS_ROW_F32(column,pSrc,rowNb,pivot,pSrc,pivotRow);
 800cd48: eb05 0787    	add.w	r7, r5, r7, lsl #2
;            pTmp = ELEM(pSrc,rowNb,column) ;
 800cd4c: eb05 0582    	add.w	r5, r5, r2, lsl #2
;            MAS_ROW_F32(column,pSrc,rowNb,pivot,pSrc,pivotRow);
 800cd50: dd0f         	ble	0x800cd72 <arm_mat_inverse_f32+0x236> @ imm = #0x1e
 800cd52: eb05 0484    	add.w	r4, r5, r4, lsl #2
 800cd56: f857 1b04    	ldr	r1, [r7], #4
 800cd5a: 4630         	mov	r0, r6
 800cd5c: f7f3 fb22    	bl	0x80003a4 <__mulsf3>    @ imm = #-0xc9bc
 800cd60: 4601         	mov	r1, r0
 800cd62: f855 0b04    	ldr	r0, [r5], #4
 800cd66: f7f3 fa13    	bl	0x8000190 <__subsf3>    @ imm = #-0xcbda
 800cd6a: 42ac         	cmp	r4, r5
 800cd6c: f845 0c04    	str	r0, [r5, #-4]
 800cd70: d1f1         	bne	0x800cd56 <arm_mat_inverse_f32+0x21a> @ imm = #-0x1e
;            MAS_ROW_F32(0     ,pDst,rowNb,pivot,pDst,pivotRow);
 800cd72: f8b8 2002    	ldrh.w	r2, [r8, #0x2]
 800cd76: f8d8 7004    	ldr.w	r7, [r8, #0x4]
 800cd7a: 0094         	lsls	r4, r2, #0x2
 800cd7c: fb09 7504    	mla	r5, r9, r4, r7
 800cd80: fb0b 7704    	mla	r7, r11, r4, r7
 800cd84: 442c         	add	r4, r5
 800cd86: b16a         	cbz	r2, 0x800cda4 <arm_mat_inverse_f32+0x268> @ imm = #0x1a
 800cd88: f857 1b04    	ldr	r1, [r7], #4
 800cd8c: 4630         	mov	r0, r6
 800cd8e: f7f3 fb09    	bl	0x80003a4 <__mulsf3>    @ imm = #-0xc9ee
 800cd92: 4601         	mov	r1, r0
 800cd94: f855 0b04    	ldr	r0, [r5], #4
 800cd98: f7f3 f9fa    	bl	0x8000190 <__subsf3>    @ imm = #-0xcc0c
 800cd9c: 42a5         	cmp	r5, r4
 800cd9e: f845 0c04    	str	r0, [r5, #-4]
 800cda2: d1f1         	bne	0x800cd88 <arm_mat_inverse_f32+0x24c> @ imm = #-0x1e
;       for (rowNb = pivotRow + 1; rowNb < numRows; rowNb++)
 800cda4: 9b01         	ldr	r3, [sp, #0x4]
 800cda6: f109 0901    	add.w	r9, r9, #0x1
 800cdaa: 454b         	cmp	r3, r9
 800cdac: d1bf         	bne	0x800cd2e <arm_mat_inverse_f32+0x1f2> @ imm = #-0x82
;     for(column = 0U; column < numCols; column++)
 800cdae: 9b00         	ldr	r3, [sp]
 800cdb0: 9a02         	ldr	r2, [sp, #0x8]
 800cdb2: 3301         	adds	r3, #0x1
 800cdb4: 9300         	str	r3, [sp]
 800cdb6: 9b09         	ldr	r3, [sp, #0x24]
 800cdb8: 4293         	cmp	r3, r2
 800cdba: f47f aef6    	bne.w	0x800cbaa <arm_mat_inverse_f32+0x6e> @ imm = #-0x214
;     if ((flag != 1U) && (pivot == 0.0f))
 800cdbe: 9a08         	ldr	r2, [sp, #0x20]
 800cdc0: 9200         	str	r2, [sp]
 800cdc2: 2a01         	cmp	r2, #0x1
 800cdc4: d05b         	beq	0x800ce7e <arm_mat_inverse_f32+0x342> @ imm = #0xb6
 800cdc6: 4630         	mov	r0, r6
 800cdc8: 2100         	movs	r1, #0x0
 800cdca: f7f3 fc7f    	bl	0x80006cc <__aeabi_fcmpeq> @ imm = #-0xc702
 800cdce: 9a00         	ldr	r2, [sp]
 800cdd0: b1c0         	cbz	r0, 0x800ce04 <arm_mat_inverse_f32+0x2c8> @ imm = #0x30
;       for (i = 0; i < numRows * numCols; i++)
 800cdd2: 9c01         	ldr	r4, [sp, #0x4]
 800cdd4: 9b09         	ldr	r3, [sp, #0x24]
;       pIn = pSrc->pData;
 800cdd6: f8da 5004    	ldr.w	r5, [r10, #0x4]
;       for (i = 0; i < numRows * numCols; i++)
 800cdda: fb03 f404    	mul	r4, r3, r4
 800cdde: b17c         	cbz	r4, 0x800ce00 <arm_mat_inverse_f32+0x2c4> @ imm = #0x1e
;         if (pIn[i] != 0.0f)
 800cde0: 2600         	movs	r6, #0x0
 800cde2: 3d04         	subs	r5, #0x4
 800cde4: 4617         	mov	r7, r2
 800cde6: e002         	b	0x800cdee <arm_mat_inverse_f32+0x2b2> @ imm = #0x4
;       for (i = 0; i < numRows * numCols; i++)
 800cde8: 3701         	adds	r7, #0x1
 800cdea: 42a7         	cmp	r7, r4
 800cdec: d008         	beq	0x800ce00 <arm_mat_inverse_f32+0x2c4> @ imm = #0x10
;         if (pIn[i] != 0.0f)
 800cdee: f855 0f04    	ldr	r0, [r5, #4]!
 800cdf2: 4631         	mov	r1, r6
 800cdf4: f7f3 fc6a    	bl	0x80006cc <__aeabi_fcmpeq> @ imm = #-0xc72c
 800cdf8: 2800         	cmp	r0, #0x0
 800cdfa: d1f5         	bne	0x800cde8 <arm_mat_inverse_f32+0x2ac> @ imm = #-0x16
;       if (i == numRows * numCols)
 800cdfc: 42bc         	cmp	r4, r7
 800cdfe: d101         	bne	0x800ce04 <arm_mat_inverse_f32+0x2c8> @ imm = #0x2
;         return ARM_MATH_SINGULAR;
 800ce00: f06f 0004    	mvn	r0, #0x4
; }
 800ce04: b00b         	add	sp, #0x2c
 800ce06: e8bd 8ff0    	pop.w	{r4, r5, r6, r7, r8, r9, r10, r11, pc}
;       if ((flag != 1U) && (pivot == 0.0f))
 800ce0a: 9b08         	ldr	r3, [sp, #0x20]
 800ce0c: 2b01         	cmp	r3, #0x1
 800ce0e: f43f af19    	beq.w	0x800cc44 <arm_mat_inverse_f32+0x108> @ imm = #-0x1ce
 800ce12: e7f5         	b	0x800ce00 <arm_mat_inverse_f32+0x2c4> @ imm = #-0x16
;             SWAP_ROWS_F32(pSrc,column, pivotRow,selectedRow);
 800ce14: 9903         	ldr	r1, [sp, #0xc]
 800ce16: 1b08         	subs	r0, r1, r4
 800ce18: fb06 4301    	mla	r3, r6, r1, r4
 800ce1c: 2800         	cmp	r0, #0x0
 800ce1e: eb02 0383    	add.w	r3, r2, r3, lsl #2
 800ce22: dd09         	ble	0x800ce38 <arm_mat_inverse_f32+0x2fc> @ imm = #0x12
 800ce24: eb05 0080    	add.w	r0, r5, r0, lsl #2
 800ce28: 6819         	ldr	r1, [r3]
 800ce2a: 682a         	ldr	r2, [r5]
 800ce2c: f845 1b04    	str	r1, [r5], #4
 800ce30: 4285         	cmp	r5, r0
 800ce32: f843 2b04    	str	r2, [r3], #4
 800ce36: d1f7         	bne	0x800ce28 <arm_mat_inverse_f32+0x2ec> @ imm = #-0x12
;             SWAP_ROWS_F32(pDst,0, pivotRow,selectedRow);
 800ce38: f8b8 2002    	ldrh.w	r2, [r8, #0x2]
 800ce3c: f8d8 3004    	ldr.w	r3, [r8, #0x4]
 800ce40: 0090         	lsls	r0, r2, #0x2
 800ce42: fb00 3b06    	mla	r11, r0, r6, r3
 800ce46: fb00 3304    	mla	r3, r0, r4, r3
 800ce4a: b1e2         	cbz	r2, 0x800ce86 <arm_mat_inverse_f32+0x34a> @ imm = #0x38
 800ce4c: 4418         	add	r0, r3
 800ce4e: f8db 1000    	ldr.w	r1, [r11]
 800ce52: 681a         	ldr	r2, [r3]
 800ce54: f843 1b04    	str	r1, [r3], #4
 800ce58: 4283         	cmp	r3, r0
 800ce5a: f84b 2b04    	str	r2, [r11], #4
 800ce5e: d1f6         	bne	0x800ce4e <arm_mat_inverse_f32+0x312> @ imm = #-0x14
 800ce60: f8ba 3002    	ldrh.w	r3, [r10, #0x2]
 800ce64: f8da 2004    	ldr.w	r2, [r10, #0x4]
 800ce68: 9303         	str	r3, [sp, #0xc]
;       SCALE_ROW_F32(pSrc,column,pivot,pivotRow);
 800ce6a: 9b03         	ldr	r3, [sp, #0xc]
 800ce6c: fb03 4504    	mla	r5, r3, r4, r4
 800ce70: 2301         	movs	r3, #0x1
 800ce72: eb02 0585    	add.w	r5, r2, r5, lsl #2
 800ce76: 9308         	str	r3, [sp, #0x20]
 800ce78: e6e4         	b	0x800cc44 <arm_mat_inverse_f32+0x108> @ imm = #-0x238
;       for (rowNb = column+1; rowNb < numRows; rowNb++)
 800ce7a: 4626         	mov	r6, r4
 800ce7c: e6cc         	b	0x800cc18 <arm_mat_inverse_f32+0xdc> @ imm = #-0x268
;     status = ARM_MATH_SUCCESS;
 800ce7e: 2000         	movs	r0, #0x0
; }
 800ce80: b00b         	add	sp, #0x2c
 800ce82: e8bd 8ff0    	pop.w	{r4, r5, r6, r7, r8, r9, r10, r11, pc}
;       pivot = 1.0f / pivot;
 800ce86: 4639         	mov	r1, r7
;       SCALE_ROW_F32(pSrc,column,pivot,pivotRow);
 800ce88: f8ba 7002    	ldrh.w	r7, [r10, #0x2]
 800ce8c: f8da 5004    	ldr.w	r5, [r10, #0x4]
 800ce90: fb07 4304    	mla	r3, r7, r4, r4
;       pivot = 1.0f / pivot;
 800ce94: f04f 507e    	mov.w	r0, #0x3f800000
;       SCALE_ROW_F32(pSrc,column,pivot,pivotRow);
 800ce98: eb05 0583    	add.w	r5, r5, r3, lsl #2
;       pivot = 1.0f / pivot;
 800ce9c: f7f3 fb36    	bl	0x800050c <__divsf3>    @ imm = #-0xc994
;       SCALE_ROW_F32(pSrc,column,pivot,pivotRow);
 800cea0: 1b3f         	subs	r7, r7, r4
;             flag = 1U;
 800cea2: 2301         	movs	r3, #0x1
;       SCALE_ROW_F32(pSrc,column,pivot,pivotRow);
 800cea4: 2f00         	cmp	r7, #0x0
;       pivot = 1.0f / pivot;
 800cea6: 4606         	mov	r6, r0
;             flag = 1U;
 800cea8: 9308         	str	r3, [sp, #0x20]
;       SCALE_ROW_F32(pSrc,column,pivot,pivotRow);
 800ceaa: f73f aed5    	bgt.w	0x800cc58 <arm_mat_inverse_f32+0x11c> @ imm = #-0x256
 800ceae: e6f0         	b	0x800cc92 <arm_mat_inverse_f32+0x156> @ imm = #-0x220

0800ceb0 <arm_mat_mult_f32>:
; {
 800ceb0: e92d 4ff0    	push.w	{r4, r5, r6, r7, r8, r9, r10, r11, lr}
 800ceb4: 460f         	mov	r7, r1
;   float32_t *pOut = pDst->pData;                 /* Output data matrix pointer */
 800ceb6: 6853         	ldr	r3, [r2, #0x4]
;   float32_t *pIn2 = pSrcB->pData;                /* Input data matrix pointer B */
 800ceb8: 687d         	ldr	r5, [r7, #0x4]
;   uint16_t numColsB = pSrcB->numCols;            /* Number of columns of input matrix B */
 800ceba: 887a         	ldrh	r2, [r7, #0x2]
;         colCnt = numColsA;
 800cebc: f8b0 a002    	ldrh.w	r10, [r0, #0x2]
;   uint32_t col, i = 0U, row = numRowsA, colCnt;  /* Loop counters */
 800cec0: f8b0 8000    	ldrh.w	r8, [r0]
;   float32_t *pIn1 = pSrcA->pData;                /* Input data matrix pointer A */
 800cec4: 6841         	ldr	r1, [r0, #0x4]
; {
 800cec6: b087         	sub	sp, #0x1c
;           pIn2 += numColsB;
 800cec8: 0096         	lsls	r6, r2, #0x2
;       pInA = pInA + numColsA;
 800ceca: ea4f 008a    	lsl.w	r0, r10, #0x2
 800cece: 2a01         	cmp	r2, #0x1
 800ced0: f105 0204    	add.w	r2, r5, #0x4
 800ced4: 9004         	str	r0, [sp, #0x10]
 800ced6: 4433         	add	r3, r6
 800ced8: 9203         	str	r2, [sp, #0xc]
 800ceda: 46c3         	mov	r11, r8
 800cedc: 9705         	str	r7, [sp, #0x14]
 800cede: d158         	bne	0x800cf92 <arm_mat_mult_f32+0xe2> @ imm = #0xb0
 800cee0: 4657         	mov	r7, r10
;       px = pOut + i;
 800cee2: e9cd 3100    	strd	r3, r1, [sp]
 800cee6: eba3 0806    	sub.w	r8, r3, r6
;       pIn2 = pSrcB->pData;
 800ceea: f8dd a00c    	ldr.w	r10, [sp, #0xc]
 800ceee: f8cd b008    	str.w	r11, [sp, #0x8]
 800cef2: 46b9         	mov	r9, r7
 800cef4: 46c3         	mov	r11, r8
;         while (colCnt > 0U)
 800cef6: f1b9 0f00    	cmp.w	r9, #0x0
 800cefa: d057         	beq	0x800cfac <arm_mat_mult_f32+0xfc> @ imm = #0xae
 800cefc: f8dd 8004    	ldr.w	r8, [sp, #0x4]
;         colCnt = numColsA;
 800cf00: 464f         	mov	r7, r9
;         sum = 0.0f;
 800cf02: 2400         	movs	r4, #0x0
;           sum += *pIn1++ * *pIn2;
 800cf04: 6828         	ldr	r0, [r5]
 800cf06: f858 1b04    	ldr	r1, [r8], #4
 800cf0a: f7f3 fa4b    	bl	0x80003a4 <__mulsf3>    @ imm = #-0xcb6a
 800cf0e: 4601         	mov	r1, r0
 800cf10: 4620         	mov	r0, r4
 800cf12: f7f3 f93f    	bl	0x8000194 <__aeabi_fadd> @ imm = #-0xcd82
;         while (colCnt > 0U)
 800cf16: 3f01         	subs	r7, #0x1
;           pIn2 += numColsB;
 800cf18: 4435         	add	r5, r6
;           sum += *pIn1++ * *pIn2;
 800cf1a: 4604         	mov	r4, r0
;         while (colCnt > 0U)
 800cf1c: d1f2         	bne	0x800cf04 <arm_mat_mult_f32+0x54> @ imm = #-0x1c
;         *px++ = sum;
 800cf1e: f84b 4b04    	str	r4, [r11], #4
;       } while (col > 0U);
 800cf22: 9b00         	ldr	r3, [sp]
 800cf24: 459b         	cmp	r11, r3
;         pIn2 = pInB + (numColsB - col);
 800cf26: 4655         	mov	r5, r10
;       } while (col > 0U);
 800cf28: f10a 0a04    	add.w	r10, r10, #0x4
 800cf2c: d1e3         	bne	0x800cef6 <arm_mat_mult_f32+0x46> @ imm = #-0x3a
;       pInA = pInA + numColsA;
 800cf2e: e9dd 1b01    	ldrd	r1, r11, [sp, #4]
 800cf32: 9a04         	ldr	r2, [sp, #0x10]
;     } while (row > 0U);
 800cf34: f1bb 0b01    	subs.w	r11, r11, #0x1
;       pInA = pInA + numColsA;
 800cf38: 464f         	mov	r7, r9
 800cf3a: 4411         	add	r1, r2
;     } while (row > 0U);
 800cf3c: 4433         	add	r3, r6
 800cf3e: d037         	beq	0x800cfb0 <arm_mat_mult_f32+0x100> @ imm = #0x6e
;       pIn2 = pSrcB->pData;
 800cf40: 9a05         	ldr	r2, [sp, #0x14]
 800cf42: 6855         	ldr	r5, [r2, #0x4]
 800cf44: e7cd         	b	0x800cee2 <arm_mat_mult_f32+0x32> @ imm = #-0x66
;         while (colCnt > 0U)
 800cf46: f1ba 0f00    	cmp.w	r10, #0x0
 800cf4a: d02d         	beq	0x800cfa8 <arm_mat_mult_f32+0xf8> @ imm = #0x5a
 800cf4c: f8dd 8004    	ldr.w	r8, [sp, #0x4]
;         colCnt = numColsA;
 800cf50: 4657         	mov	r7, r10
;         sum = 0.0f;
 800cf52: 2400         	movs	r4, #0x0
;           sum += *pIn1++ * *pIn2;
 800cf54: 6829         	ldr	r1, [r5]
 800cf56: f858 0b04    	ldr	r0, [r8], #4
 800cf5a: f7f3 fa23    	bl	0x80003a4 <__mulsf3>    @ imm = #-0xcbba
 800cf5e: 4601         	mov	r1, r0
 800cf60: 4620         	mov	r0, r4
 800cf62: f7f3 f917    	bl	0x8000194 <__aeabi_fadd> @ imm = #-0xcdd2
;         while (colCnt > 0U)
 800cf66: 3f01         	subs	r7, #0x1
;           pIn2 += numColsB;
 800cf68: 4435         	add	r5, r6
;           sum += *pIn1++ * *pIn2;
 800cf6a: 4604         	mov	r4, r0
;         while (colCnt > 0U)
 800cf6c: d1f2         	bne	0x800cf54 <arm_mat_mult_f32+0xa4> @ imm = #-0x1c
;         *px++ = sum;
 800cf6e: f849 4b04    	str	r4, [r9], #4
;       } while (col > 0U);
 800cf72: 9b00         	ldr	r3, [sp]
 800cf74: 4599         	cmp	r9, r3
;         pIn2 = pInB + (numColsB - col);
 800cf76: 465d         	mov	r5, r11
;       } while (col > 0U);
 800cf78: f10b 0b04    	add.w	r11, r11, #0x4
 800cf7c: d1e3         	bne	0x800cf46 <arm_mat_mult_f32+0x96> @ imm = #-0x3a
;       pInA = pInA + numColsA;
 800cf7e: e9dd 1b01    	ldrd	r1, r11, [sp, #4]
 800cf82: 9a04         	ldr	r2, [sp, #0x10]
;     } while (row > 0U);
 800cf84: f1bb 0b01    	subs.w	r11, r11, #0x1
;       pInA = pInA + numColsA;
 800cf88: 4411         	add	r1, r2
;     } while (row > 0U);
 800cf8a: 4433         	add	r3, r6
 800cf8c: d010         	beq	0x800cfb0 <arm_mat_mult_f32+0x100> @ imm = #0x20
;       pIn2 = pSrcB->pData;
 800cf8e: 9a05         	ldr	r2, [sp, #0x14]
 800cf90: 6855         	ldr	r5, [r2, #0x4]
;       px = pOut + i;
 800cf92: f8dd 800c    	ldr.w	r8, [sp, #0xc]
 800cf96: 9300         	str	r3, [sp]
 800cf98: 1b9f         	subs	r7, r3, r6
;       pIn2 = pSrcB->pData;
 800cf9a: e9cd 1b01    	strd	r1, r11, [sp, #4]
 800cf9e: 46b9         	mov	r9, r7
;         while (colCnt > 0U)
 800cfa0: 46c3         	mov	r11, r8
 800cfa2: f1ba 0f00    	cmp.w	r10, #0x0
 800cfa6: d1d1         	bne	0x800cf4c <arm_mat_mult_f32+0x9c> @ imm = #-0x5e
;         sum = 0.0f;
 800cfa8: 2400         	movs	r4, #0x0
 800cfaa: e7e0         	b	0x800cf6e <arm_mat_mult_f32+0xbe> @ imm = #-0x40
 800cfac: 2400         	movs	r4, #0x0
 800cfae: e7b6         	b	0x800cf1e <arm_mat_mult_f32+0x6e> @ imm = #-0x94
; }
 800cfb0: 2000         	movs	r0, #0x0
 800cfb2: b007         	add	sp, #0x1c
 800cfb4: e8bd 8ff0    	pop.w	{r4, r5, r6, r7, r8, r9, r10, r11, pc}

0800cfb8 <arm_mat_sub_f32>:
; {
 800cfb8: b5f8         	push	{r3, r4, r5, r6, r7, lr}
;     numSamples = (uint32_t) pSrcA->numRows * pSrcA->numCols;
 800cfba: 8804         	ldrh	r4, [r0]
 800cfbc: 8843         	ldrh	r3, [r0, #0x2]
;   float32_t *pInA = pSrcA->pData;                /* input data matrix pointer A */
 800cfbe: 6847         	ldr	r7, [r0, #0x4]
;   float32_t *pInB = pSrcB->pData;                /* input data matrix pointer B */
 800cfc0: 684e         	ldr	r6, [r1, #0x4]
;   float32_t *pOut = pDst->pData;                 /* output data matrix pointer */
 800cfc2: 6855         	ldr	r5, [r2, #0x4]
;     numSamples = (uint32_t) pSrcA->numRows * pSrcA->numCols;
 800cfc4: fb03 f404    	mul	r4, r3, r4
;     while (blkCnt > 0U)
 800cfc8: b14c         	cbz	r4, 0x800cfde <arm_mat_sub_f32+0x26> @ imm = #0x12
;       *pOut++ = (*pInA++) - (*pInB++);
 800cfca: f856 1b04    	ldr	r1, [r6], #4
 800cfce: f857 0b04    	ldr	r0, [r7], #4
 800cfd2: f7f3 f8dd    	bl	0x8000190 <__subsf3>    @ imm = #-0xce46
;     while (blkCnt > 0U)
 800cfd6: 3c01         	subs	r4, #0x1
;       *pOut++ = (*pInA++) - (*pInB++);
 800cfd8: f845 0b04    	str	r0, [r5], #4
;     while (blkCnt > 0U)
 800cfdc: d1f5         	bne	0x800cfca <arm_mat_sub_f32+0x12> @ imm = #-0x16
; }
 800cfde: 2000         	movs	r0, #0x0
 800cfe0: bdf8         	pop	{r3, r4, r5, r6, r7, pc}
 800cfe2: bf00         	nop

0800cfe4 <arm_mat_trans_f32>:
; {
 800cfe4: b5f0         	push	{r4, r5, r6, r7, lr}
;       col = nCols;
 800cfe6: 8845         	ldrh	r5, [r0, #0x2]
;   uint16_t nRows = pSrc->numRows;                /* number of rows */
 800cfe8: 8802         	ldrh	r2, [r0]
;   float32_t *pIn = pSrc->pData;                  /* input data matrix pointer */
 800cfea: 6844         	ldr	r4, [r0, #0x4]
;   float32_t *pOut = pDst->pData;                 /* output data matrix pointer */
 800cfec: 684b         	ldr	r3, [r1, #0x4]
;   uint32_t col, row = nRows, i = 0U;             /* Loop counters */
 800cfee: b1b5         	cbz	r5, 0x800d01e <arm_mat_trans_f32+0x3a> @ imm = #0x2c
 800cff0: ea4f 0c82    	lsl.w	r12, r2, #0x2
 800cff4: 2a01         	cmp	r2, #0x1
 800cff6: 469e         	mov	lr, r3
 800cff8: eb03 070c    	add.w	r7, r3, r12
 800cffc: ea4f 0685    	lsl.w	r6, r5, #0x2
 800d000: d114         	bne	0x800d02c <arm_mat_trans_f32+0x48> @ imm = #0x28
;       px = pOut + i;
 800d002: 4672         	mov	r2, lr
;       col = nCols;
 800d004: 462b         	mov	r3, r5
;       px = pOut + i;
 800d006: 4621         	mov	r1, r4
;         *px = *pIn++;
 800d008: f851 0b04    	ldr	r0, [r1], #4
 800d00c: 6010         	str	r0, [r2]
;       while (col > 0U)
 800d00e: 3b01         	subs	r3, #0x1
;         px += nRows;
 800d010: 4462         	add	r2, r12
;       while (col > 0U)
 800d012: d1f9         	bne	0x800d008 <arm_mat_trans_f32+0x24> @ imm = #-0xe
;     } while (row > 0U);          /* row loop end */
 800d014: f10e 0e04    	add.w	lr, lr, #0x4
 800d018: 45be         	cmp	lr, r7
;         *px = *pIn++;
 800d01a: 4434         	add	r4, r6
;     } while (row > 0U);          /* row loop end */
 800d01c: d1f1         	bne	0x800d002 <arm_mat_trans_f32+0x1e> @ imm = #-0x1e
; }
 800d01e: 2000         	movs	r0, #0x0
 800d020: bdf0         	pop	{r4, r5, r6, r7, pc}
;     } while (row > 0U);          /* row loop end */
 800d022: f10e 0e04    	add.w	lr, lr, #0x4
 800d026: 45be         	cmp	lr, r7
;         *px = *pIn++;
 800d028: 4434         	add	r4, r6
;     } while (row > 0U);          /* row loop end */
 800d02a: d0f8         	beq	0x800d01e <arm_mat_trans_f32+0x3a> @ imm = #-0x10
;       px = pOut + i;
 800d02c: 4672         	mov	r2, lr
;       col = nCols;
 800d02e: 462b         	mov	r3, r5
;       px = pOut + i;
 800d030: 4621         	mov	r1, r4
;         *px = *pIn++;
 800d032: f851 0b04    	ldr	r0, [r1], #4
 800d036: 6010         	str	r0, [r2]
;       while (col > 0U)
 800d038: 3b01         	subs	r3, #0x1
;         px += nRows;
 800d03a: 4462         	add	r2, r12
;       while (col > 0U)
 800d03c: d1f9         	bne	0x800d032 <arm_mat_trans_f32+0x4e> @ imm = #-0xe
 800d03e: e7f0         	b	0x800d022 <arm_mat_trans_f32+0x3e> @ imm = #-0x20

0800d040 <HAL_RCC_GetSysClockFreq>:
; {
 800d040: e92d 4fb0    	push.w	{r4, r5, r7, r8, r9, r10, r11, lr}
 800d044: b090         	sub	sp, #0x40
 800d046: af00         	add	r7, sp, #0x0
;   uint32_t pllm = 0U;
 800d048: 2300         	movs	r3, #0x0
 800d04a: 637b         	str	r3, [r7, #0x34]
;   uint32_t pllvco = 0U;
 800d04c: 2300         	movs	r3, #0x0
 800d04e: 63fb         	str	r3, [r7, #0x3c]
;   uint32_t pllp = 0U;
 800d050: 2300         	movs	r3, #0x0
 800d052: 633b         	str	r3, [r7, #0x30]
;   uint32_t sysclockfreq = 0U;
 800d054: 2300         	movs	r3, #0x0
 800d056: 63bb         	str	r3, [r7, #0x38]
;   switch (RCC->CFGR & RCC_CFGR_SWS)
 800d058: 4b59         	ldr	r3, [pc, #0x164]        @ 0x800d1c0 <HAL_RCC_GetSysClockFreq+0x180>
 800d05a: 689b         	ldr	r3, [r3, #0x8]
 800d05c: f003 030c    	and	r3, r3, #0xc
 800d060: 2b08         	cmp	r3, #0x8
 800d062: d00d         	beq	0x800d080 <HAL_RCC_GetSysClockFreq+0x40> @ imm = #0x1a
 800d064: 2b08         	cmp	r3, #0x8
 800d066: f200 80a2    	bhi.w	0x800d1ae <HAL_RCC_GetSysClockFreq+0x16e> @ imm = #0x144
 800d06a: 2b00         	cmp	r3, #0x0
 800d06c: d002         	beq	0x800d074 <HAL_RCC_GetSysClockFreq+0x34> @ imm = #0x4
 800d06e: 2b04         	cmp	r3, #0x4
 800d070: d003         	beq	0x800d07a <HAL_RCC_GetSysClockFreq+0x3a> @ imm = #0x6
 800d072: e09c         	b	0x800d1ae <HAL_RCC_GetSysClockFreq+0x16e> @ imm = #0x138
;       sysclockfreq = HSI_VALUE;
 800d074: 4b53         	ldr	r3, [pc, #0x14c]        @ 0x800d1c4 <HAL_RCC_GetSysClockFreq+0x184>
 800d076: 63bb         	str	r3, [r7, #0x38]
;       break;
 800d078: e09c         	b	0x800d1b4 <HAL_RCC_GetSysClockFreq+0x174> @ imm = #0x138
;       sysclockfreq = HSE_VALUE;
 800d07a: 4b53         	ldr	r3, [pc, #0x14c]        @ 0x800d1c8 <HAL_RCC_GetSysClockFreq+0x188>
 800d07c: 63bb         	str	r3, [r7, #0x38]
;       break;
 800d07e: e099         	b	0x800d1b4 <HAL_RCC_GetSysClockFreq+0x174> @ imm = #0x132
;       pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
 800d080: 4b4f         	ldr	r3, [pc, #0x13c]        @ 0x800d1c0 <HAL_RCC_GetSysClockFreq+0x180>
 800d082: 685b         	ldr	r3, [r3, #0x4]
 800d084: f003 033f    	and	r3, r3, #0x3f
 800d088: 637b         	str	r3, [r7, #0x34]
;       if (__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLSOURCE_HSI)
 800d08a: 4b4d         	ldr	r3, [pc, #0x134]        @ 0x800d1c0 <HAL_RCC_GetSysClockFreq+0x180>
 800d08c: 685b         	ldr	r3, [r3, #0x4]
 800d08e: f403 0380    	and	r3, r3, #0x400000
 800d092: 2b00         	cmp	r3, #0x0
 800d094: d027         	beq	0x800d0e6 <HAL_RCC_GetSysClockFreq+0xa6> @ imm = #0x4e
;         pllvco = (uint32_t)((((uint64_t) HSE_VALUE * ((uint64_t)((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);
 800d096: 4b4a         	ldr	r3, [pc, #0x128]        @ 0x800d1c0 <HAL_RCC_GetSysClockFreq+0x180>
 800d098: 685b         	ldr	r3, [r3, #0x4]
 800d09a: 099b         	lsrs	r3, r3, #0x6
 800d09c: 2200         	movs	r2, #0x0
 800d09e: 623b         	str	r3, [r7, #0x20]
 800d0a0: 627a         	str	r2, [r7, #0x24]
 800d0a2: 6a3b         	ldr	r3, [r7, #0x20]
 800d0a4: f3c3 0008    	ubfx	r0, r3, #0x0, #0x9
 800d0a8: 2100         	movs	r1, #0x0
 800d0aa: 4b47         	ldr	r3, [pc, #0x11c]        @ 0x800d1c8 <HAL_RCC_GetSysClockFreq+0x188>
 800d0ac: fb03 f201    	mul	r2, r3, r1
 800d0b0: 2300         	movs	r3, #0x0
 800d0b2: fb00 f303    	mul	r3, r0, r3
 800d0b6: 4413         	add	r3, r2
 800d0b8: 4a43         	ldr	r2, [pc, #0x10c]        @ 0x800d1c8 <HAL_RCC_GetSysClockFreq+0x188>
 800d0ba: fba0 2102    	umull	r2, r1, r0, r2
 800d0be: 62f9         	str	r1, [r7, #0x2c]
 800d0c0: 62ba         	str	r2, [r7, #0x28]
 800d0c2: 6afa         	ldr	r2, [r7, #0x2c]
 800d0c4: 4413         	add	r3, r2
 800d0c6: 62fb         	str	r3, [r7, #0x2c]
 800d0c8: 6b7b         	ldr	r3, [r7, #0x34]
 800d0ca: 2200         	movs	r2, #0x0
 800d0cc: 61bb         	str	r3, [r7, #0x18]
 800d0ce: 61fa         	str	r2, [r7, #0x1c]
 800d0d0: e9d7 2306    	ldrd	r2, r3, [r7, #24]
 800d0d4: e9d7 010a    	ldrd	r0, r1, [r7, #40]
 800d0d8: f7f3 fba0    	bl	0x800081c <__aeabi_uldivmod> @ imm = #-0xc8c0
 800d0dc: 4602         	mov	r2, r0
 800d0de: 460b         	mov	r3, r1
 800d0e0: 4613         	mov	r3, r2
 800d0e2: 63fb         	str	r3, [r7, #0x3c]
 800d0e4: e055         	b	0x800d192 <HAL_RCC_GetSysClockFreq+0x152> @ imm = #0xaa
;         pllvco = (uint32_t)((((uint64_t) HSI_VALUE * ((uint64_t)((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);
 800d0e6: 4b36         	ldr	r3, [pc, #0xd8]         @ 0x800d1c0 <HAL_RCC_GetSysClockFreq+0x180>
 800d0e8: 685b         	ldr	r3, [r3, #0x4]
 800d0ea: 099b         	lsrs	r3, r3, #0x6
 800d0ec: 2200         	movs	r2, #0x0
 800d0ee: 613b         	str	r3, [r7, #0x10]
 800d0f0: 617a         	str	r2, [r7, #0x14]
 800d0f2: 693b         	ldr	r3, [r7, #0x10]
 800d0f4: f3c3 0a08    	ubfx	r10, r3, #0x0, #0x9
 800d0f8: f04f 0b00    	mov.w	r11, #0x0
 800d0fc: 4652         	mov	r2, r10
 800d0fe: 465b         	mov	r3, r11
 800d100: f04f 0000    	mov.w	r0, #0x0
 800d104: f04f 0100    	mov.w	r1, #0x0
 800d108: 0159         	lsls	r1, r3, #0x5
 800d10a: ea41 61d2    	orr.w	r1, r1, r2, lsr #27
 800d10e: 0150         	lsls	r0, r2, #0x5
 800d110: 4602         	mov	r2, r0
 800d112: 460b         	mov	r3, r1
 800d114: ebb2 080a    	subs.w	r8, r2, r10
 800d118: eb63 090b    	sbc.w	r9, r3, r11
 800d11c: f04f 0200    	mov.w	r2, #0x0
 800d120: f04f 0300    	mov.w	r3, #0x0
 800d124: ea4f 1389    	lsl.w	r3, r9, #0x6
 800d128: ea43 6398    	orr.w	r3, r3, r8, lsr #26
 800d12c: ea4f 1288    	lsl.w	r2, r8, #0x6
 800d130: ebb2 0408    	subs.w	r4, r2, r8
 800d134: eb63 0509    	sbc.w	r5, r3, r9
 800d138: f04f 0200    	mov.w	r2, #0x0
 800d13c: f04f 0300    	mov.w	r3, #0x0
 800d140: 00eb         	lsls	r3, r5, #0x3
 800d142: ea43 7354    	orr.w	r3, r3, r4, lsr #29
 800d146: 00e2         	lsls	r2, r4, #0x3
 800d148: 4614         	mov	r4, r2
 800d14a: 461d         	mov	r5, r3
 800d14c: eb14 030a    	adds.w	r3, r4, r10
 800d150: 603b         	str	r3, [r7]
 800d152: eb45 030b    	adc.w	r3, r5, r11
 800d156: 607b         	str	r3, [r7, #0x4]
 800d158: f04f 0200    	mov.w	r2, #0x0
 800d15c: f04f 0300    	mov.w	r3, #0x0
 800d160: e9d7 4500    	ldrd	r4, r5, [r7]
 800d164: 4629         	mov	r1, r5
 800d166: 028b         	lsls	r3, r1, #0xa
 800d168: 4620         	mov	r0, r4
 800d16a: 4629         	mov	r1, r5
 800d16c: 4604         	mov	r4, r0
 800d16e: ea43 5394    	orr.w	r3, r3, r4, lsr #22
 800d172: 4601         	mov	r1, r0
 800d174: 028a         	lsls	r2, r1, #0xa
 800d176: 4610         	mov	r0, r2
 800d178: 4619         	mov	r1, r3
 800d17a: 6b7b         	ldr	r3, [r7, #0x34]
 800d17c: 2200         	movs	r2, #0x0
 800d17e: 60bb         	str	r3, [r7, #0x8]
 800d180: 60fa         	str	r2, [r7, #0xc]
 800d182: e9d7 2302    	ldrd	r2, r3, [r7, #8]
 800d186: f7f3 fb49    	bl	0x800081c <__aeabi_uldivmod> @ imm = #-0xc96e
 800d18a: 4602         	mov	r2, r0
 800d18c: 460b         	mov	r3, r1
 800d18e: 4613         	mov	r3, r2
 800d190: 63fb         	str	r3, [r7, #0x3c]
;       pllp = ((((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >> RCC_PLLCFGR_PLLP_Pos) + 1U) * 2U);
 800d192: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x800d1c0 <HAL_RCC_GetSysClockFreq+0x180>
 800d194: 685b         	ldr	r3, [r3, #0x4]
 800d196: 0c1b         	lsrs	r3, r3, #0x10
 800d198: f003 0303    	and	r3, r3, #0x3
 800d19c: 3301         	adds	r3, #0x1
 800d19e: 005b         	lsls	r3, r3, #0x1
 800d1a0: 633b         	str	r3, [r7, #0x30]
;       sysclockfreq = pllvco / pllp;
 800d1a2: 6bfa         	ldr	r2, [r7, #0x3c]
 800d1a4: 6b3b         	ldr	r3, [r7, #0x30]
 800d1a6: fbb2 f3f3    	udiv	r3, r2, r3
 800d1aa: 63bb         	str	r3, [r7, #0x38]
;       break;
 800d1ac: e002         	b	0x800d1b4 <HAL_RCC_GetSysClockFreq+0x174> @ imm = #0x4
;       sysclockfreq = HSI_VALUE;
 800d1ae: 4b05         	ldr	r3, [pc, #0x14]         @ 0x800d1c4 <HAL_RCC_GetSysClockFreq+0x184>
 800d1b0: 63bb         	str	r3, [r7, #0x38]
;       break;
 800d1b2: bf00         	nop
;   return sysclockfreq;
 800d1b4: 6bbb         	ldr	r3, [r7, #0x38]
; }
 800d1b6: 4618         	mov	r0, r3
 800d1b8: 3740         	adds	r7, #0x40
 800d1ba: 46bd         	mov	sp, r7
 800d1bc: e8bd 8fb0    	pop.w	{r4, r5, r7, r8, r9, r10, r11, pc}

0800d1c0 <$d>:
 800d1c0: 00 38 02 40  	.word	0x40023800
 800d1c4: 00 24 f4 00  	.word	0x00f42400
 800d1c8: 00 1b b7 00  	.word	0x00b71b00

0800d1cc <LL_DMA_ConfigTransfer>:
; {
 800d1cc: b480         	push	{r7}
 800d1ce: b085         	sub	sp, #0x14
 800d1d0: af00         	add	r7, sp, #0x0
 800d1d2: 60f8         	str	r0, [r7, #0xc]
 800d1d4: 60b9         	str	r1, [r7, #0x8]
 800d1d6: 607a         	str	r2, [r7, #0x4]
;   MODIFY_REG(((DMA_Stream_TypeDef *)((uint32_t)((uint32_t)DMAx + STREAM_OFFSET_TAB[Stream])))->CR,
 800d1d8: 4a0d         	ldr	r2, [pc, #0x34]         @ 0x800d210 <LL_DMA_ConfigTransfer+0x44>
 800d1da: 68bb         	ldr	r3, [r7, #0x8]
 800d1dc: 4413         	add	r3, r2
 800d1de: 781b         	ldrb	r3, [r3]
 800d1e0: 461a         	mov	r2, r3
 800d1e2: 68fb         	ldr	r3, [r7, #0xc]
 800d1e4: 4413         	add	r3, r2
 800d1e6: 681b         	ldr	r3, [r3]
 800d1e8: f423 335f    	bic	r3, r3, #0x37c00
 800d1ec: f423 7378    	bic	r3, r3, #0x3e0
 800d1f0: 4907         	ldr	r1, [pc, #0x1c]         @ 0x800d210 <LL_DMA_ConfigTransfer+0x44>
 800d1f2: 68ba         	ldr	r2, [r7, #0x8]
 800d1f4: 440a         	add	r2, r1
 800d1f6: 7812         	ldrb	r2, [r2]
 800d1f8: 4611         	mov	r1, r2
 800d1fa: 68fa         	ldr	r2, [r7, #0xc]
 800d1fc: 440a         	add	r2, r1
 800d1fe: 4611         	mov	r1, r2
 800d200: 687a         	ldr	r2, [r7, #0x4]
 800d202: 4313         	orrs	r3, r2
 800d204: 600b         	str	r3, [r1]
; }
 800d206: bf00         	nop
 800d208: 3714         	adds	r7, #0x14
 800d20a: 46bd         	mov	sp, r7
 800d20c: bc80         	pop	{r7}
 800d20e: 4770         	bx	lr

0800d210 <$d>:
 800d210: ec 06 02 08  	.word	0x080206ec

0800d214 <LL_DMA_SetDataLength>:
; {
 800d214: b480         	push	{r7}
 800d216: b085         	sub	sp, #0x14
 800d218: af00         	add	r7, sp, #0x0
 800d21a: 60f8         	str	r0, [r7, #0xc]
 800d21c: 60b9         	str	r1, [r7, #0x8]
 800d21e: 607a         	str	r2, [r7, #0x4]
;   MODIFY_REG(((DMA_Stream_TypeDef*)((uint32_t)((uint32_t)DMAx + STREAM_OFFSET_TAB[Stream])))->NDTR, DMA_SxNDT, NbData);
 800d220: 4a0c         	ldr	r2, [pc, #0x30]         @ 0x800d254 <LL_DMA_SetDataLength+0x40>
 800d222: 68bb         	ldr	r3, [r7, #0x8]
 800d224: 4413         	add	r3, r2
 800d226: 781b         	ldrb	r3, [r3]
 800d228: 461a         	mov	r2, r3
 800d22a: 68fb         	ldr	r3, [r7, #0xc]
 800d22c: 4413         	add	r3, r2
 800d22e: 685b         	ldr	r3, [r3, #0x4]
 800d230: 0c1b         	lsrs	r3, r3, #0x10
 800d232: 041b         	lsls	r3, r3, #0x10
 800d234: 4907         	ldr	r1, [pc, #0x1c]         @ 0x800d254 <LL_DMA_SetDataLength+0x40>
 800d236: 68ba         	ldr	r2, [r7, #0x8]
 800d238: 440a         	add	r2, r1
 800d23a: 7812         	ldrb	r2, [r2]
 800d23c: 4611         	mov	r1, r2
 800d23e: 68fa         	ldr	r2, [r7, #0xc]
 800d240: 440a         	add	r2, r1
 800d242: 4611         	mov	r1, r2
 800d244: 687a         	ldr	r2, [r7, #0x4]
 800d246: 4313         	orrs	r3, r2
 800d248: 604b         	str	r3, [r1, #0x4]
; }
 800d24a: bf00         	nop
 800d24c: 3714         	adds	r7, #0x14
 800d24e: 46bd         	mov	sp, r7
 800d250: bc80         	pop	{r7}
 800d252: 4770         	bx	lr

0800d254 <$d>:
 800d254: ec 06 02 08  	.word	0x080206ec

0800d258 <LL_DMA_SetChannelSelection>:
; {
 800d258: b480         	push	{r7}
 800d25a: b085         	sub	sp, #0x14
 800d25c: af00         	add	r7, sp, #0x0
 800d25e: 60f8         	str	r0, [r7, #0xc]
 800d260: 60b9         	str	r1, [r7, #0x8]
 800d262: 607a         	str	r2, [r7, #0x4]
;   MODIFY_REG(((DMA_Stream_TypeDef*)((uint32_t)((uint32_t)DMAx + STREAM_OFFSET_TAB[Stream])))->CR, DMA_SxCR_CHSEL, Channel);
 800d264: 4a0c         	ldr	r2, [pc, #0x30]         @ 0x800d298 <LL_DMA_SetChannelSelection+0x40>
 800d266: 68bb         	ldr	r3, [r7, #0x8]
 800d268: 4413         	add	r3, r2
 800d26a: 781b         	ldrb	r3, [r3]
 800d26c: 461a         	mov	r2, r3
 800d26e: 68fb         	ldr	r3, [r7, #0xc]
 800d270: 4413         	add	r3, r2
 800d272: 681b         	ldr	r3, [r3]
 800d274: f023 6260    	bic	r2, r3, #0xe000000
 800d278: 4907         	ldr	r1, [pc, #0x1c]         @ 0x800d298 <LL_DMA_SetChannelSelection+0x40>
 800d27a: 68bb         	ldr	r3, [r7, #0x8]
 800d27c: 440b         	add	r3, r1
 800d27e: 781b         	ldrb	r3, [r3]
 800d280: 4619         	mov	r1, r3
 800d282: 68fb         	ldr	r3, [r7, #0xc]
 800d284: 440b         	add	r3, r1
 800d286: 4619         	mov	r1, r3
 800d288: 687b         	ldr	r3, [r7, #0x4]
 800d28a: 4313         	orrs	r3, r2
 800d28c: 600b         	str	r3, [r1]
; }
 800d28e: bf00         	nop
 800d290: 3714         	adds	r7, #0x14
 800d292: 46bd         	mov	sp, r7
 800d294: bc80         	pop	{r7}
 800d296: 4770         	bx	lr

0800d298 <$d>:
 800d298: ec 06 02 08  	.word	0x080206ec

0800d29c <LL_DMA_SetMemoryBurstxfer>:
; {
 800d29c: b480         	push	{r7}
 800d29e: b085         	sub	sp, #0x14
 800d2a0: af00         	add	r7, sp, #0x0
 800d2a2: 60f8         	str	r0, [r7, #0xc]
 800d2a4: 60b9         	str	r1, [r7, #0x8]
 800d2a6: 607a         	str	r2, [r7, #0x4]
;   MODIFY_REG(((DMA_Stream_TypeDef*)((uint32_t)((uint32_t)DMAx + STREAM_OFFSET_TAB[Stream])))->CR, DMA_SxCR_MBURST, Mburst);
 800d2a8: 4a0c         	ldr	r2, [pc, #0x30]         @ 0x800d2dc <LL_DMA_SetMemoryBurstxfer+0x40>
 800d2aa: 68bb         	ldr	r3, [r7, #0x8]
 800d2ac: 4413         	add	r3, r2
 800d2ae: 781b         	ldrb	r3, [r3]
 800d2b0: 461a         	mov	r2, r3
 800d2b2: 68fb         	ldr	r3, [r7, #0xc]
 800d2b4: 4413         	add	r3, r2
 800d2b6: 681b         	ldr	r3, [r3]
 800d2b8: f023 72c0    	bic	r2, r3, #0x1800000
 800d2bc: 4907         	ldr	r1, [pc, #0x1c]         @ 0x800d2dc <LL_DMA_SetMemoryBurstxfer+0x40>
 800d2be: 68bb         	ldr	r3, [r7, #0x8]
 800d2c0: 440b         	add	r3, r1
 800d2c2: 781b         	ldrb	r3, [r3]
 800d2c4: 4619         	mov	r1, r3
 800d2c6: 68fb         	ldr	r3, [r7, #0xc]
 800d2c8: 440b         	add	r3, r1
 800d2ca: 4619         	mov	r1, r3
 800d2cc: 687b         	ldr	r3, [r7, #0x4]
 800d2ce: 4313         	orrs	r3, r2
 800d2d0: 600b         	str	r3, [r1]
; }
 800d2d2: bf00         	nop
 800d2d4: 3714         	adds	r7, #0x14
 800d2d6: 46bd         	mov	sp, r7
 800d2d8: bc80         	pop	{r7}
 800d2da: 4770         	bx	lr

0800d2dc <$d>:
 800d2dc: ec 06 02 08  	.word	0x080206ec

0800d2e0 <LL_DMA_SetPeriphBurstxfer>:
; {
 800d2e0: b480         	push	{r7}
 800d2e2: b085         	sub	sp, #0x14
 800d2e4: af00         	add	r7, sp, #0x0
 800d2e6: 60f8         	str	r0, [r7, #0xc]
 800d2e8: 60b9         	str	r1, [r7, #0x8]
 800d2ea: 607a         	str	r2, [r7, #0x4]
;   MODIFY_REG(((DMA_Stream_TypeDef*)((uint32_t)((uint32_t)DMAx + STREAM_OFFSET_TAB[Stream])))->CR, DMA_SxCR_PBURST, Pburst);
 800d2ec: 4a0c         	ldr	r2, [pc, #0x30]         @ 0x800d320 <LL_DMA_SetPeriphBurstxfer+0x40>
 800d2ee: 68bb         	ldr	r3, [r7, #0x8]
 800d2f0: 4413         	add	r3, r2
 800d2f2: 781b         	ldrb	r3, [r3]
 800d2f4: 461a         	mov	r2, r3
 800d2f6: 68fb         	ldr	r3, [r7, #0xc]
 800d2f8: 4413         	add	r3, r2
 800d2fa: 681b         	ldr	r3, [r3]
 800d2fc: f423 02c0    	bic	r2, r3, #0x600000
 800d300: 4907         	ldr	r1, [pc, #0x1c]         @ 0x800d320 <LL_DMA_SetPeriphBurstxfer+0x40>
 800d302: 68bb         	ldr	r3, [r7, #0x8]
 800d304: 440b         	add	r3, r1
 800d306: 781b         	ldrb	r3, [r3]
 800d308: 4619         	mov	r1, r3
 800d30a: 68fb         	ldr	r3, [r7, #0xc]
 800d30c: 440b         	add	r3, r1
 800d30e: 4619         	mov	r1, r3
 800d310: 687b         	ldr	r3, [r7, #0x4]
 800d312: 4313         	orrs	r3, r2
 800d314: 600b         	str	r3, [r1]
; }
 800d316: bf00         	nop
 800d318: 3714         	adds	r7, #0x14
 800d31a: 46bd         	mov	sp, r7
 800d31c: bc80         	pop	{r7}
 800d31e: 4770         	bx	lr

0800d320 <$d>:
 800d320: ec 06 02 08  	.word	0x080206ec

0800d324 <LL_DMA_ConfigFifo>:
; {
 800d324: b480         	push	{r7}
 800d326: b085         	sub	sp, #0x14
 800d328: af00         	add	r7, sp, #0x0
 800d32a: 60f8         	str	r0, [r7, #0xc]
 800d32c: 60b9         	str	r1, [r7, #0x8]
 800d32e: 607a         	str	r2, [r7, #0x4]
 800d330: 603b         	str	r3, [r7]
;   MODIFY_REG(((DMA_Stream_TypeDef*)((uint32_t)((uint32_t)DMAx + STREAM_OFFSET_TAB[Stream])))->FCR, DMA_SxFCR_FTH|DMA_SxFCR_DMDIS, FifoMode|FifoThreshold);
 800d332: 4a0d         	ldr	r2, [pc, #0x34]         @ 0x800d368 <LL_DMA_ConfigFifo+0x44>
 800d334: 68bb         	ldr	r3, [r7, #0x8]
 800d336: 4413         	add	r3, r2
 800d338: 781b         	ldrb	r3, [r3]
 800d33a: 461a         	mov	r2, r3
 800d33c: 68fb         	ldr	r3, [r7, #0xc]
 800d33e: 4413         	add	r3, r2
 800d340: 695b         	ldr	r3, [r3, #0x14]
 800d342: f023 0207    	bic	r2, r3, #0x7
 800d346: 6879         	ldr	r1, [r7, #0x4]
 800d348: 683b         	ldr	r3, [r7]
 800d34a: 430b         	orrs	r3, r1
 800d34c: 4806         	ldr	r0, [pc, #0x18]         @ 0x800d368 <LL_DMA_ConfigFifo+0x44>
 800d34e: 68b9         	ldr	r1, [r7, #0x8]
 800d350: 4401         	add	r1, r0
 800d352: 7809         	ldrb	r1, [r1]
 800d354: 4608         	mov	r0, r1
 800d356: 68f9         	ldr	r1, [r7, #0xc]
 800d358: 4401         	add	r1, r0
 800d35a: 4313         	orrs	r3, r2
 800d35c: 614b         	str	r3, [r1, #0x14]
; }
 800d35e: bf00         	nop
 800d360: 3714         	adds	r7, #0x14
 800d362: 46bd         	mov	sp, r7
 800d364: bc80         	pop	{r7}
 800d366: 4770         	bx	lr

0800d368 <$d>:
 800d368: ec 06 02 08  	.word	0x080206ec

0800d36c <LL_DMA_SetMemoryAddress>:
; {
 800d36c: b480         	push	{r7}
 800d36e: b085         	sub	sp, #0x14
 800d370: af00         	add	r7, sp, #0x0
 800d372: 60f8         	str	r0, [r7, #0xc]
 800d374: 60b9         	str	r1, [r7, #0x8]
 800d376: 607a         	str	r2, [r7, #0x4]
;   WRITE_REG(((DMA_Stream_TypeDef*)((uint32_t)((uint32_t)DMAx + STREAM_OFFSET_TAB[Stream])))->M0AR, MemoryAddress);
 800d378: 4a07         	ldr	r2, [pc, #0x1c]         @ 0x800d398 <LL_DMA_SetMemoryAddress+0x2c>
 800d37a: 68bb         	ldr	r3, [r7, #0x8]
 800d37c: 4413         	add	r3, r2
 800d37e: 781b         	ldrb	r3, [r3]
 800d380: 461a         	mov	r2, r3
 800d382: 68fb         	ldr	r3, [r7, #0xc]
 800d384: 4413         	add	r3, r2
 800d386: 461a         	mov	r2, r3
 800d388: 687b         	ldr	r3, [r7, #0x4]
 800d38a: 60d3         	str	r3, [r2, #0xc]
; }
 800d38c: bf00         	nop
 800d38e: 3714         	adds	r7, #0x14
 800d390: 46bd         	mov	sp, r7
 800d392: bc80         	pop	{r7}
 800d394: 4770         	bx	lr
 800d396: bf00         	nop

0800d398 <$d>:
 800d398: ec 06 02 08  	.word	0x080206ec

0800d39c <LL_DMA_SetPeriphAddress>:
; {
 800d39c: b480         	push	{r7}
 800d39e: b085         	sub	sp, #0x14
 800d3a0: af00         	add	r7, sp, #0x0
 800d3a2: 60f8         	str	r0, [r7, #0xc]
 800d3a4: 60b9         	str	r1, [r7, #0x8]
 800d3a6: 607a         	str	r2, [r7, #0x4]
;   WRITE_REG(((DMA_Stream_TypeDef*)((uint32_t)((uint32_t)DMAx + STREAM_OFFSET_TAB[Stream])))->PAR, PeriphAddress);
 800d3a8: 4a07         	ldr	r2, [pc, #0x1c]         @ 0x800d3c8 <LL_DMA_SetPeriphAddress+0x2c>
 800d3aa: 68bb         	ldr	r3, [r7, #0x8]
 800d3ac: 4413         	add	r3, r2
 800d3ae: 781b         	ldrb	r3, [r3]
 800d3b0: 461a         	mov	r2, r3
 800d3b2: 68fb         	ldr	r3, [r7, #0xc]
 800d3b4: 4413         	add	r3, r2
 800d3b6: 461a         	mov	r2, r3
 800d3b8: 687b         	ldr	r3, [r7, #0x4]
 800d3ba: 6093         	str	r3, [r2, #0x8]
; }
 800d3bc: bf00         	nop
 800d3be: 3714         	adds	r7, #0x14
 800d3c0: 46bd         	mov	sp, r7
 800d3c2: bc80         	pop	{r7}
 800d3c4: 4770         	bx	lr
 800d3c6: bf00         	nop

0800d3c8 <$d>:
 800d3c8: ec 06 02 08  	.word	0x080206ec

0800d3cc <LL_FLASH_SetLatency>:
; {
 800d3cc: b480         	push	{r7}
 800d3ce: b083         	sub	sp, #0xc
 800d3d0: af00         	add	r7, sp, #0x0
 800d3d2: 6078         	str	r0, [r7, #0x4]
;   MODIFY_REG(FLASH->ACR, FLASH_ACR_LATENCY, Latency);
 800d3d4: 4b06         	ldr	r3, [pc, #0x18]         @ 0x800d3f0 <LL_FLASH_SetLatency+0x24>
 800d3d6: 681b         	ldr	r3, [r3]
 800d3d8: f023 0207    	bic	r2, r3, #0x7
 800d3dc: 4904         	ldr	r1, [pc, #0x10]         @ 0x800d3f0 <LL_FLASH_SetLatency+0x24>
 800d3de: 687b         	ldr	r3, [r7, #0x4]
 800d3e0: 4313         	orrs	r3, r2
 800d3e2: 600b         	str	r3, [r1]
; }
 800d3e4: bf00         	nop
 800d3e6: 370c         	adds	r7, #0xc
 800d3e8: 46bd         	mov	sp, r7
 800d3ea: bc80         	pop	{r7}
 800d3ec: 4770         	bx	lr
 800d3ee: bf00         	nop

0800d3f0 <$d>:
 800d3f0: 00 3c 02 40  	.word	0x40023c00

0800d3f4 <LL_FLASH_GetLatency>:
; {
 800d3f4: b480         	push	{r7}
 800d3f6: af00         	add	r7, sp, #0x0
;   return (uint32_t)(READ_BIT(FLASH->ACR, FLASH_ACR_LATENCY));
 800d3f8: 4b03         	ldr	r3, [pc, #0xc]          @ 0x800d408 <LL_FLASH_GetLatency+0x14>
 800d3fa: 681b         	ldr	r3, [r3]
 800d3fc: f003 0307    	and	r3, r3, #0x7
; }
 800d400: 4618         	mov	r0, r3
 800d402: 46bd         	mov	sp, r7
 800d404: bc80         	pop	{r7}
 800d406: 4770         	bx	lr

0800d408 <$d>:
 800d408: 00 3c 02 40  	.word	0x40023c00

0800d40c <LL_PWR_GetRegulVoltageScaling>:
; {
 800d40c: b480         	push	{r7}
 800d40e: af00         	add	r7, sp, #0x0
;   return (uint32_t)(READ_BIT(PWR->CR, PWR_CR_VOS));
 800d410: 4b03         	ldr	r3, [pc, #0xc]          @ 0x800d420 <LL_PWR_GetRegulVoltageScaling+0x14>
 800d412: 681b         	ldr	r3, [r3]
 800d414: f403 4380    	and	r3, r3, #0x4000
; }
 800d418: 4618         	mov	r0, r3
 800d41a: 46bd         	mov	sp, r7
 800d41c: bc80         	pop	{r7}
 800d41e: 4770         	bx	lr

0800d420 <$d>:
 800d420: 00 70 00 40  	.word	0x40007000

0800d424 <LL_SetFlashLatency>:
; {
 800d424: b580         	push	{r7, lr}
 800d426: b086         	sub	sp, #0x18
 800d428: af00         	add	r7, sp, #0x0
 800d42a: 6078         	str	r0, [r7, #0x4]
;   uint32_t latency = LL_FLASH_LATENCY_0;  /* default value 0WS */
 800d42c: 2300         	movs	r3, #0x0
 800d42e: 613b         	str	r3, [r7, #0x10]
;   ErrorStatus status = SUCCESS;
 800d430: 2300         	movs	r3, #0x0
 800d432: 73fb         	strb	r3, [r7, #0xf]
;   if(HCLK_Frequency == 0U)
 800d434: 687b         	ldr	r3, [r7, #0x4]
 800d436: 2b00         	cmp	r3, #0x0
 800d438: d102         	bne	0x800d440 <LL_SetFlashLatency+0x1c> @ imm = #0x4
;     status = ERROR;
 800d43a: 2301         	movs	r3, #0x1
 800d43c: 73fb         	strb	r3, [r7, #0xf]
 800d43e: e078         	b	0x800d532 <LL_SetFlashLatency+0x10e> @ imm = #0xf0
;     if(LL_PWR_GetRegulVoltageScaling() == LL_PWR_REGU_VOLTAGE_SCALE1)
 800d440: f7ff ffe4    	bl	0x800d40c <LL_PWR_GetRegulVoltageScaling> @ imm = #-0x38
 800d444: 4603         	mov	r3, r0
 800d446: f5b3 4f80    	cmp.w	r3, #0x4000
 800d44a: d12d         	bne	0x800d4a8 <LL_SetFlashLatency+0x84> @ imm = #0x5a
;       if((HCLK_Frequency > UTILS_SCALE1_LATENCY5_FREQ)&&(latency == LL_FLASH_LATENCY_0))
 800d44c: 687b         	ldr	r3, [r7, #0x4]
 800d44e: 4a3b         	ldr	r2, [pc, #0xec]         @ 0x800d53c <LL_SetFlashLatency+0x118>
 800d450: 4293         	cmp	r3, r2
 800d452: d904         	bls	0x800d45e <LL_SetFlashLatency+0x3a> @ imm = #0x8
 800d454: 693b         	ldr	r3, [r7, #0x10]
 800d456: 2b00         	cmp	r3, #0x0
 800d458: d101         	bne	0x800d45e <LL_SetFlashLatency+0x3a> @ imm = #0x2
;         latency = LL_FLASH_LATENCY_5;
 800d45a: 2305         	movs	r3, #0x5
 800d45c: 613b         	str	r3, [r7, #0x10]
;       if((HCLK_Frequency > UTILS_SCALE1_LATENCY4_FREQ)&&(latency == LL_FLASH_LATENCY_0))
 800d45e: 687b         	ldr	r3, [r7, #0x4]
 800d460: 4a37         	ldr	r2, [pc, #0xdc]         @ 0x800d540 <LL_SetFlashLatency+0x11c>
 800d462: 4293         	cmp	r3, r2
 800d464: d904         	bls	0x800d470 <LL_SetFlashLatency+0x4c> @ imm = #0x8
 800d466: 693b         	ldr	r3, [r7, #0x10]
 800d468: 2b00         	cmp	r3, #0x0
 800d46a: d101         	bne	0x800d470 <LL_SetFlashLatency+0x4c> @ imm = #0x2
;         latency = LL_FLASH_LATENCY_4;
 800d46c: 2304         	movs	r3, #0x4
 800d46e: 613b         	str	r3, [r7, #0x10]
;       if((HCLK_Frequency > UTILS_SCALE1_LATENCY3_FREQ)&&(latency == LL_FLASH_LATENCY_0))
 800d470: 687b         	ldr	r3, [r7, #0x4]
 800d472: 4a34         	ldr	r2, [pc, #0xd0]         @ 0x800d544 <LL_SetFlashLatency+0x120>
 800d474: 4293         	cmp	r3, r2
 800d476: d904         	bls	0x800d482 <LL_SetFlashLatency+0x5e> @ imm = #0x8
 800d478: 693b         	ldr	r3, [r7, #0x10]
 800d47a: 2b00         	cmp	r3, #0x0
 800d47c: d101         	bne	0x800d482 <LL_SetFlashLatency+0x5e> @ imm = #0x2
;         latency = LL_FLASH_LATENCY_3;
 800d47e: 2303         	movs	r3, #0x3
 800d480: 613b         	str	r3, [r7, #0x10]
;       if((HCLK_Frequency > UTILS_SCALE1_LATENCY2_FREQ)&&(latency == LL_FLASH_LATENCY_0))
 800d482: 687b         	ldr	r3, [r7, #0x4]
 800d484: 4a30         	ldr	r2, [pc, #0xc0]         @ 0x800d548 <LL_SetFlashLatency+0x124>
 800d486: 4293         	cmp	r3, r2
 800d488: d905         	bls	0x800d496 <LL_SetFlashLatency+0x72> @ imm = #0xa
 800d48a: 693b         	ldr	r3, [r7, #0x10]
 800d48c: 2b00         	cmp	r3, #0x0
 800d48e: d102         	bne	0x800d496 <LL_SetFlashLatency+0x72> @ imm = #0x4
;         latency = LL_FLASH_LATENCY_2;
 800d490: 2302         	movs	r3, #0x2
 800d492: 613b         	str	r3, [r7, #0x10]
 800d494: e008         	b	0x800d4a8 <LL_SetFlashLatency+0x84> @ imm = #0x10
;         if((HCLK_Frequency > UTILS_SCALE1_LATENCY1_FREQ)&&(latency == LL_FLASH_LATENCY_0))
 800d496: 687b         	ldr	r3, [r7, #0x4]
 800d498: 4a2c         	ldr	r2, [pc, #0xb0]         @ 0x800d54c <LL_SetFlashLatency+0x128>
 800d49a: 4293         	cmp	r3, r2
 800d49c: d904         	bls	0x800d4a8 <LL_SetFlashLatency+0x84> @ imm = #0x8
 800d49e: 693b         	ldr	r3, [r7, #0x10]
 800d4a0: 2b00         	cmp	r3, #0x0
 800d4a2: d101         	bne	0x800d4a8 <LL_SetFlashLatency+0x84> @ imm = #0x2
;           latency = LL_FLASH_LATENCY_1;
 800d4a4: 2301         	movs	r3, #0x1
 800d4a6: 613b         	str	r3, [r7, #0x10]
;     if(LL_PWR_GetRegulVoltageScaling() == LL_PWR_REGU_VOLTAGE_SCALE2)
 800d4a8: f7ff ffb0    	bl	0x800d40c <LL_PWR_GetRegulVoltageScaling> @ imm = #-0xa0
 800d4ac: 4603         	mov	r3, r0
 800d4ae: 2b00         	cmp	r3, #0x0
 800d4b0: d124         	bne	0x800d4fc <LL_SetFlashLatency+0xd8> @ imm = #0x48
;       if((HCLK_Frequency > UTILS_SCALE2_LATENCY4_FREQ)&&(latency == LL_FLASH_LATENCY_0))
 800d4b2: 687b         	ldr	r3, [r7, #0x4]
 800d4b4: 4a22         	ldr	r2, [pc, #0x88]         @ 0x800d540 <LL_SetFlashLatency+0x11c>
 800d4b6: 4293         	cmp	r3, r2
 800d4b8: d904         	bls	0x800d4c4 <LL_SetFlashLatency+0xa0> @ imm = #0x8
 800d4ba: 693b         	ldr	r3, [r7, #0x10]
 800d4bc: 2b00         	cmp	r3, #0x0
 800d4be: d101         	bne	0x800d4c4 <LL_SetFlashLatency+0xa0> @ imm = #0x2
;         latency = LL_FLASH_LATENCY_4;
 800d4c0: 2304         	movs	r3, #0x4
 800d4c2: 613b         	str	r3, [r7, #0x10]
;       if((HCLK_Frequency > UTILS_SCALE2_LATENCY3_FREQ)&&(latency == LL_FLASH_LATENCY_0))
 800d4c4: 687b         	ldr	r3, [r7, #0x4]
 800d4c6: 4a1f         	ldr	r2, [pc, #0x7c]         @ 0x800d544 <LL_SetFlashLatency+0x120>
 800d4c8: 4293         	cmp	r3, r2
 800d4ca: d904         	bls	0x800d4d6 <LL_SetFlashLatency+0xb2> @ imm = #0x8
 800d4cc: 693b         	ldr	r3, [r7, #0x10]
 800d4ce: 2b00         	cmp	r3, #0x0
 800d4d0: d101         	bne	0x800d4d6 <LL_SetFlashLatency+0xb2> @ imm = #0x2
;         latency = LL_FLASH_LATENCY_3;
 800d4d2: 2303         	movs	r3, #0x3
 800d4d4: 613b         	str	r3, [r7, #0x10]
;       if((HCLK_Frequency > UTILS_SCALE2_LATENCY2_FREQ)&&(latency == LL_FLASH_LATENCY_0))
 800d4d6: 687b         	ldr	r3, [r7, #0x4]
 800d4d8: 4a1b         	ldr	r2, [pc, #0x6c]         @ 0x800d548 <LL_SetFlashLatency+0x124>
 800d4da: 4293         	cmp	r3, r2
 800d4dc: d905         	bls	0x800d4ea <LL_SetFlashLatency+0xc6> @ imm = #0xa
 800d4de: 693b         	ldr	r3, [r7, #0x10]
 800d4e0: 2b00         	cmp	r3, #0x0
 800d4e2: d102         	bne	0x800d4ea <LL_SetFlashLatency+0xc6> @ imm = #0x4
;         latency = LL_FLASH_LATENCY_2;
 800d4e4: 2302         	movs	r3, #0x2
 800d4e6: 613b         	str	r3, [r7, #0x10]
 800d4e8: e008         	b	0x800d4fc <LL_SetFlashLatency+0xd8> @ imm = #0x10
;         if((HCLK_Frequency > UTILS_SCALE2_LATENCY1_FREQ)&&(latency == LL_FLASH_LATENCY_0))
 800d4ea: 687b         	ldr	r3, [r7, #0x4]
 800d4ec: 4a17         	ldr	r2, [pc, #0x5c]         @ 0x800d54c <LL_SetFlashLatency+0x128>
 800d4ee: 4293         	cmp	r3, r2
 800d4f0: d904         	bls	0x800d4fc <LL_SetFlashLatency+0xd8> @ imm = #0x8
 800d4f2: 693b         	ldr	r3, [r7, #0x10]
 800d4f4: 2b00         	cmp	r3, #0x0
 800d4f6: d101         	bne	0x800d4fc <LL_SetFlashLatency+0xd8> @ imm = #0x2
;           latency = LL_FLASH_LATENCY_1;
 800d4f8: 2301         	movs	r3, #0x1
 800d4fa: 613b         	str	r3, [r7, #0x10]
;     LL_FLASH_SetLatency(latency);
 800d4fc: 6938         	ldr	r0, [r7, #0x10]
 800d4fe: f7ff ff65    	bl	0x800d3cc <LL_FLASH_SetLatency> @ imm = #-0x136
;     timeout = 2;
 800d502: 2302         	movs	r3, #0x2
 800d504: 617b         	str	r3, [r7, #0x14]
;     getlatency = LL_FLASH_GetLatency();
 800d506: f7ff ff75    	bl	0x800d3f4 <LL_FLASH_GetLatency> @ imm = #-0x116
 800d50a: 60b8         	str	r0, [r7, #0x8]
;     timeout--;
 800d50c: 697b         	ldr	r3, [r7, #0x14]
 800d50e: 3b01         	subs	r3, #0x1
 800d510: 617b         	str	r3, [r7, #0x14]
;     } while ((getlatency != latency) && (timeout > 0));
 800d512: 68ba         	ldr	r2, [r7, #0x8]
 800d514: 693b         	ldr	r3, [r7, #0x10]
 800d516: 429a         	cmp	r2, r3
 800d518: d002         	beq	0x800d520 <LL_SetFlashLatency+0xfc> @ imm = #0x4
 800d51a: 697b         	ldr	r3, [r7, #0x14]
 800d51c: 2b00         	cmp	r3, #0x0
 800d51e: d1f2         	bne	0x800d506 <LL_SetFlashLatency+0xe2> @ imm = #-0x1c
;     if(getlatency != latency)
 800d520: 68ba         	ldr	r2, [r7, #0x8]
 800d522: 693b         	ldr	r3, [r7, #0x10]
 800d524: 429a         	cmp	r2, r3
 800d526: d002         	beq	0x800d52e <LL_SetFlashLatency+0x10a> @ imm = #0x4
;       status = ERROR;
 800d528: 2301         	movs	r3, #0x1
 800d52a: 73fb         	strb	r3, [r7, #0xf]
 800d52c: e001         	b	0x800d532 <LL_SetFlashLatency+0x10e> @ imm = #0x2
;       status = SUCCESS;
 800d52e: 2300         	movs	r3, #0x0
 800d530: 73fb         	strb	r3, [r7, #0xf]
;   return status;
 800d532: 7bfb         	ldrb	r3, [r7, #0xf]
; }
 800d534: 4618         	mov	r0, r3
 800d536: 3718         	adds	r7, #0x18
 800d538: 46bd         	mov	sp, r7
 800d53a: bd80         	pop	{r7, pc}

0800d53c <$d>:
 800d53c: 80 d1 f0 08  	.word	0x08f0d180
 800d540: 00 0e 27 07  	.word	0x07270e00
 800d544: 80 4a 5d 05  	.word	0x055d4a80
 800d548: 00 87 93 03  	.word	0x03938700
 800d54c: 80 c3 c9 01  	.word	0x01c9c380

0800d550 <z_device_state_init>:
; {
 800d550: b580         	push	{r7, lr}
 800d552: b082         	sub	sp, #0x8
 800d554: af00         	add	r7, sp, #0x0
; 	STRUCT_SECTION_FOREACH(device, dev) {
 800d556: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x800d584 <z_device_state_init+0x34>
 800d558: 607b         	str	r3, [r7, #0x4]
 800d55a: e005         	b	0x800d568 <z_device_state_init+0x18> @ imm = #0xa
; 		k_object_init(dev);
 800d55c: 6878         	ldr	r0, [r7, #0x4]
 800d55e: f00e fb05    	bl	0x801bb6c <k_object_init> @ imm = #0xe60a
; 	STRUCT_SECTION_FOREACH(device, dev) {
 800d562: 687b         	ldr	r3, [r7, #0x4]
 800d564: 3314         	adds	r3, #0x14
 800d566: 607b         	str	r3, [r7, #0x4]
 800d568: 687b         	ldr	r3, [r7, #0x4]
 800d56a: 4a07         	ldr	r2, [pc, #0x1c]         @ 0x800d588 <z_device_state_init+0x38>
 800d56c: 4293         	cmp	r3, r2
 800d56e: bf34         	ite	lo
 800d570: 2301         	movlo	r3, #0x1
 800d572: 2300         	movhs	r3, #0x0
 800d574: b2db         	uxtb	r3, r3
 800d576: 2b00         	cmp	r3, #0x0
 800d578: d1f0         	bne	0x800d55c <z_device_state_init+0xc> @ imm = #-0x20
; }
 800d57a: bf00         	nop
 800d57c: bf00         	nop
 800d57e: 3708         	adds	r7, #0x8
 800d580: 46bd         	mov	sp, r7
 800d582: bd80         	pop	{r7, pc}

0800d584 <$d>:
 800d584: 28 dd 01 08  	.word	0x0801dd28
 800d588: b8 de 01 08  	.word	0x0801deb8

0800d58c <k_sys_fatal_error_handler>:
; {
 800d58c: b580         	push	{r7, lr}
 800d58e: b088         	sub	sp, #0x20
 800d590: af04         	add	r7, sp, #0x10
 800d592: 6078         	str	r0, [r7, #0x4]
 800d594: 6039         	str	r1, [r7]
; 	LOG_PANIC();
 800d596: f00e fb3c    	bl	0x801bc12 <log_panic>   @ imm = #0xe678
; 	LOG_ERR("Halting system");
 800d59a: 2303         	movs	r3, #0x3
 800d59c: 2b00         	cmp	r3, #0x0
 800d59e: d016         	beq	0x800d5ce <k_sys_fatal_error_handler+0x42> @ imm = #0x2c
 800d5a0: 2301         	movs	r3, #0x1
 800d5a2: 73fb         	strb	r3, [r7, #0xf]
 800d5a4: 7bfb         	ldrb	r3, [r7, #0xf]
 800d5a6: f083 0301    	eor	r3, r3, #0x1
 800d5aa: b2db         	uxtb	r3, r3
 800d5ac: 2b00         	cmp	r3, #0x0
 800d5ae: d10e         	bne	0x800d5ce <k_sys_fatal_error_handler+0x42> @ imm = #0x1c
 800d5b0: 4b08         	ldr	r3, [pc, #0x20]         @ 0x800d5d4 <k_sys_fatal_error_handler+0x48>
 800d5b2: 6819         	ldr	r1, [r3]
 800d5b4: 4b08         	ldr	r3, [pc, #0x20]         @ 0x800d5d8 <k_sys_fatal_error_handler+0x4c>
 800d5b6: 9302         	str	r3, [sp, #0x8]
 800d5b8: 2300         	movs	r3, #0x0
 800d5ba: 9301         	str	r3, [sp, #0x4]
 800d5bc: 2300         	movs	r3, #0x0
 800d5be: 9300         	str	r3, [sp]
 800d5c0: 2300         	movs	r3, #0x0
 800d5c2: 2201         	movs	r2, #0x1
 800d5c4: 2000         	movs	r0, #0x0
 800d5c6: f00e fb06    	bl	0x801bbd6 <z_log_msg_runtime_create> @ imm = #0xe60c
 800d5ca: 2300         	movs	r3, #0x0
 800d5cc: 60bb         	str	r3, [r7, #0x8]
; 	arch_system_halt(reason);
 800d5ce: 6878         	ldr	r0, [r7, #0x4]
 800d5d0: f00e fb30    	bl	0x801bc34 <arch_system_halt> @ imm = #0xe660

0800d5d4 <$d>:
 800d5d4: 94 05 00 20  	.word	0x20000594
 800d5d8: 48 f8 01 08  	.word	0x0801f848

0800d5dc <thread_name_get>:
; {
 800d5dc: b580         	push	{r7, lr}
 800d5de: b084         	sub	sp, #0x10
 800d5e0: af00         	add	r7, sp, #0x0
 800d5e2: 6078         	str	r0, [r7, #0x4]
; 	const char *thread_name = (thread != NULL) ? k_thread_name_get(thread) : NULL;
 800d5e4: 687b         	ldr	r3, [r7, #0x4]
 800d5e6: 2b00         	cmp	r3, #0x0
 800d5e8: d004         	beq	0x800d5f4 <thread_name_get+0x18> @ imm = #0x8
 800d5ea: 6878         	ldr	r0, [r7, #0x4]
 800d5ec: f00f fa99    	bl	0x801cb22 <k_thread_name_get> @ imm = #0xf532
 800d5f0: 4603         	mov	r3, r0
 800d5f2: e000         	b	0x800d5f6 <thread_name_get+0x1a> @ imm = #0x0
 800d5f4: 2300         	movs	r3, #0x0
 800d5f6: 60fb         	str	r3, [r7, #0xc]
; 	if ((thread_name == NULL) || (thread_name[0] == '\0')) {
 800d5f8: 68fb         	ldr	r3, [r7, #0xc]
 800d5fa: 2b00         	cmp	r3, #0x0
 800d5fc: d003         	beq	0x800d606 <thread_name_get+0x2a> @ imm = #0x6
 800d5fe: 68fb         	ldr	r3, [r7, #0xc]
 800d600: 781b         	ldrb	r3, [r3]
 800d602: 2b00         	cmp	r3, #0x0
 800d604: d101         	bne	0x800d60a <thread_name_get+0x2e> @ imm = #0x2
; 		thread_name = "unknown";
 800d606: 4b03         	ldr	r3, [pc, #0xc]          @ 0x800d614 <thread_name_get+0x38>
 800d608: 60fb         	str	r3, [r7, #0xc]
; 	return thread_name;
 800d60a: 68fb         	ldr	r3, [r7, #0xc]
; }
 800d60c: 4618         	mov	r0, r3
 800d60e: 3710         	adds	r7, #0x10
 800d610: 46bd         	mov	sp, r7
 800d612: bd80         	pop	{r7, pc}

0800d614 <$d>:
 800d614: 58 f8 01 08  	.word	0x0801f858

0800d618 <reason_to_str>:
; {
 800d618: b480         	push	{r7}
 800d61a: b083         	sub	sp, #0xc
 800d61c: af00         	add	r7, sp, #0x0
 800d61e: 6078         	str	r0, [r7, #0x4]
; 	switch (reason) {
 800d620: 687b         	ldr	r3, [r7, #0x4]
 800d622: 2b04         	cmp	r3, #0x4
 800d624: d816         	bhi	0x800d654 <reason_to_str+0x3c> @ imm = #0x2c
 800d626: a201         	adr	r2, #4 <reason_to_str+0x13>
 800d628: f852 f023    	ldr.w	pc, [r2, r3, lsl #2]

0800d62c <$d>:
 800d62c: 41 d6 00 08  	.word	0x0800d641
 800d630: 45 d6 00 08  	.word	0x0800d645
 800d634: 49 d6 00 08  	.word	0x0800d649
 800d638: 4d d6 00 08  	.word	0x0800d64d
 800d63c: 51 d6 00 08  	.word	0x0800d651

0800d640 <$t>:
; 		return "CPU exception";
 800d640: 4b07         	ldr	r3, [pc, #0x1c]         @ 0x800d660 <reason_to_str+0x48>
 800d642: e008         	b	0x800d656 <reason_to_str+0x3e> @ imm = #0x10
; 		return "Unhandled interrupt";
 800d644: 4b07         	ldr	r3, [pc, #0x1c]         @ 0x800d664 <reason_to_str+0x4c>
 800d646: e006         	b	0x800d656 <reason_to_str+0x3e> @ imm = #0xc
; 		return "Stack overflow";
 800d648: 4b07         	ldr	r3, [pc, #0x1c]         @ 0x800d668 <reason_to_str+0x50>
 800d64a: e004         	b	0x800d656 <reason_to_str+0x3e> @ imm = #0x8
; 		return "Kernel oops";
 800d64c: 4b07         	ldr	r3, [pc, #0x1c]         @ 0x800d66c <reason_to_str+0x54>
 800d64e: e002         	b	0x800d656 <reason_to_str+0x3e> @ imm = #0x4
; 		return "Kernel panic";
 800d650: 4b07         	ldr	r3, [pc, #0x1c]         @ 0x800d670 <reason_to_str+0x58>
 800d652: e000         	b	0x800d656 <reason_to_str+0x3e> @ imm = #0x0
; 		return "Unknown error";
 800d654: 4b07         	ldr	r3, [pc, #0x1c]         @ 0x800d674 <reason_to_str+0x5c>
; }
 800d656: 4618         	mov	r0, r3
 800d658: 370c         	adds	r7, #0xc
 800d65a: 46bd         	mov	sp, r7
 800d65c: bc80         	pop	{r7}
 800d65e: 4770         	bx	lr

0800d660 <$d>:
 800d660: 60 f8 01 08  	.word	0x0801f860
 800d664: 70 f8 01 08  	.word	0x0801f870
 800d668: 84 f8 01 08  	.word	0x0801f884
 800d66c: 94 f8 01 08  	.word	0x0801f894
 800d670: a0 f8 01 08  	.word	0x0801f8a0
 800d674: b0 f8 01 08  	.word	0x0801f8b0

0800d678 <z_fatal_error>:
; {
 800d678: b590         	push	{r4, r7, lr}
 800d67a: b099         	sub	sp, #0x64
 800d67c: af06         	add	r7, sp, #0x18
 800d67e: 6078         	str	r0, [r7, #0x4]
 800d680: 6039         	str	r1, [r7]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800d682: f3ef 8311    	mrs	r3, basepri
 800d686: 623b         	str	r3, [r7, #0x20]
;   return(result);
 800d688: 6a3b         	ldr	r3, [r7, #0x20]
; 	key = __get_BASEPRI();
 800d68a: 61fb         	str	r3, [r7, #0x1c]
 800d68c: 2310         	movs	r3, #0x10
 800d68e: 61bb         	str	r3, [r7, #0x18]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 800d690: 69bb         	ldr	r3, [r7, #0x18]
 800d692: f383 8812    	msr	basepri_max, r3
; }
 800d696: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800d698: f3bf 8f6f    	isb	sy
; }
 800d69c: bf00         	nop
; 	return key;
 800d69e: 69fb         	ldr	r3, [r7, #0x1c]
; 	unsigned int key = arch_irq_lock();
 800d6a0: 63bb         	str	r3, [r7, #0x38]
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800d6a2: 4b50         	ldr	r3, [pc, #0x140]        @ 0x800d7e4 <z_fatal_error+0x16c>
 800d6a4: 689b         	ldr	r3, [r3, #0x8]
 800d6a6: 627b         	str	r3, [r7, #0x24]
; 	return ret;
 800d6a8: 6a7b         	ldr	r3, [r7, #0x24]
; 			arch_current_thread() : NULL;
 800d6aa: 643b         	str	r3, [r7, #0x40]
; 	LOG_ERR(">>> ZEPHYR FATAL ERROR %d: %s on CPU %d", reason,
 800d6ac: 2303         	movs	r3, #0x3
 800d6ae: 2b00         	cmp	r3, #0x0
 800d6b0: d023         	beq	0x800d6fa <z_fatal_error+0x82> @ imm = #0x46
 800d6b2: 2301         	movs	r3, #0x1
 800d6b4: f887 303f    	strb.w	r3, [r7, #0x3f]
 800d6b8: f897 303f    	ldrb.w	r3, [r7, #0x3f]
 800d6bc: f083 0301    	eor	r3, r3, #0x1
 800d6c0: b2db         	uxtb	r3, r3
 800d6c2: 2b00         	cmp	r3, #0x0
 800d6c4: d119         	bne	0x800d6fa <z_fatal_error+0x82> @ imm = #0x32
 800d6c6: 4b48         	ldr	r3, [pc, #0x120]        @ 0x800d7e8 <z_fatal_error+0x170>
 800d6c8: 681c         	ldr	r4, [r3]
 800d6ca: 6878         	ldr	r0, [r7, #0x4]
 800d6cc: f7ff ffa4    	bl	0x800d618 <reason_to_str> @ imm = #-0xb8
 800d6d0: 4603         	mov	r3, r0
 800d6d2: 4a44         	ldr	r2, [pc, #0x110]        @ 0x800d7e4 <z_fatal_error+0x16c>
 800d6d4: 7c12         	ldrb	r2, [r2, #0x10]
 800d6d6: 9205         	str	r2, [sp, #0x14]
 800d6d8: 9304         	str	r3, [sp, #0x10]
 800d6da: 687b         	ldr	r3, [r7, #0x4]
 800d6dc: 9303         	str	r3, [sp, #0xc]
 800d6de: 4b43         	ldr	r3, [pc, #0x10c]        @ 0x800d7ec <z_fatal_error+0x174>
 800d6e0: 9302         	str	r3, [sp, #0x8]
 800d6e2: 2300         	movs	r3, #0x0
 800d6e4: 9301         	str	r3, [sp, #0x4]
 800d6e6: 2300         	movs	r3, #0x0
 800d6e8: 9300         	str	r3, [sp]
 800d6ea: 2300         	movs	r3, #0x0
 800d6ec: 2201         	movs	r2, #0x1
 800d6ee: 4621         	mov	r1, r4
 800d6f0: 2000         	movs	r0, #0x0
 800d6f2: f00e fa70    	bl	0x801bbd6 <z_log_msg_runtime_create> @ imm = #0xe4e0
 800d6f6: 2300         	movs	r3, #0x0
 800d6f8: 647b         	str	r3, [r7, #0x44]
; 	if ((esf != NULL) && arch_is_in_nested_exception(esf)) {
 800d6fa: 683b         	ldr	r3, [r7]
 800d6fc: 2b00         	cmp	r3, #0x0
 800d6fe: d028         	beq	0x800d752 <z_fatal_error+0xda> @ imm = #0x50
 800d700: 683b         	ldr	r3, [r7]
 800d702: 617b         	str	r3, [r7, #0x14]
; 	return (esf->basic.xpsr & IPSR_ISR_Msk) ? (true) : (false);
 800d704: 697b         	ldr	r3, [r7, #0x14]
 800d706: 69db         	ldr	r3, [r3, #0x1c]
 800d708: f3c3 0308    	ubfx	r3, r3, #0x0, #0x9
 800d70c: 2b00         	cmp	r3, #0x0
 800d70e: bf14         	ite	ne
 800d710: 2301         	movne	r3, #0x1
 800d712: 2300         	moveq	r3, #0x0
 800d714: b2db         	uxtb	r3, r3
; 	if ((esf != NULL) && arch_is_in_nested_exception(esf)) {
 800d716: 2b00         	cmp	r3, #0x0
 800d718: d01b         	beq	0x800d752 <z_fatal_error+0xda> @ imm = #0x36
; 		LOG_ERR("Fault during interrupt handling\n");
 800d71a: 2303         	movs	r3, #0x3
 800d71c: 2b00         	cmp	r3, #0x0
 800d71e: d018         	beq	0x800d752 <z_fatal_error+0xda> @ imm = #0x30
 800d720: 2301         	movs	r3, #0x1
 800d722: f887 3037    	strb.w	r3, [r7, #0x37]
 800d726: f897 3037    	ldrb.w	r3, [r7, #0x37]
 800d72a: f083 0301    	eor	r3, r3, #0x1
 800d72e: b2db         	uxtb	r3, r3
 800d730: 2b00         	cmp	r3, #0x0
 800d732: d10e         	bne	0x800d752 <z_fatal_error+0xda> @ imm = #0x1c
 800d734: 4b2c         	ldr	r3, [pc, #0xb0]         @ 0x800d7e8 <z_fatal_error+0x170>
 800d736: 6819         	ldr	r1, [r3]
 800d738: 4b2d         	ldr	r3, [pc, #0xb4]         @ 0x800d7f0 <z_fatal_error+0x178>
 800d73a: 9302         	str	r3, [sp, #0x8]
 800d73c: 2300         	movs	r3, #0x0
 800d73e: 9301         	str	r3, [sp, #0x4]
 800d740: 2300         	movs	r3, #0x0
 800d742: 9300         	str	r3, [sp]
 800d744: 2300         	movs	r3, #0x0
 800d746: 2201         	movs	r2, #0x1
 800d748: 2000         	movs	r0, #0x0
 800d74a: f00e fa44    	bl	0x801bbd6 <z_log_msg_runtime_create> @ imm = #0xe488
 800d74e: 2300         	movs	r3, #0x0
 800d750: 633b         	str	r3, [r7, #0x30]
; 		LOG_ERR("Current thread: %p (%s)", thread, thread_name_get(thread));
 800d752: 2303         	movs	r3, #0x3
 800d754: 2b00         	cmp	r3, #0x0
 800d756: d020         	beq	0x800d79a <z_fatal_error+0x122> @ imm = #0x40
 800d758: 2301         	movs	r3, #0x1
 800d75a: f887 302f    	strb.w	r3, [r7, #0x2f]
 800d75e: f897 302f    	ldrb.w	r3, [r7, #0x2f]
 800d762: f083 0301    	eor	r3, r3, #0x1
 800d766: b2db         	uxtb	r3, r3
 800d768: 2b00         	cmp	r3, #0x0
 800d76a: d116         	bne	0x800d79a <z_fatal_error+0x122> @ imm = #0x2c
 800d76c: 4b1e         	ldr	r3, [pc, #0x78]         @ 0x800d7e8 <z_fatal_error+0x170>
 800d76e: 681c         	ldr	r4, [r3]
 800d770: 6c38         	ldr	r0, [r7, #0x40]
 800d772: f7ff ff33    	bl	0x800d5dc <thread_name_get> @ imm = #-0x19a
 800d776: 4603         	mov	r3, r0
 800d778: 9304         	str	r3, [sp, #0x10]
 800d77a: 6c3b         	ldr	r3, [r7, #0x40]
 800d77c: 9303         	str	r3, [sp, #0xc]
 800d77e: 4b1d         	ldr	r3, [pc, #0x74]         @ 0x800d7f4 <z_fatal_error+0x17c>
 800d780: 9302         	str	r3, [sp, #0x8]
 800d782: 2300         	movs	r3, #0x0
 800d784: 9301         	str	r3, [sp, #0x4]
 800d786: 2300         	movs	r3, #0x0
 800d788: 9300         	str	r3, [sp]
 800d78a: 2300         	movs	r3, #0x0
 800d78c: 2201         	movs	r2, #0x1
 800d78e: 4621         	mov	r1, r4
 800d790: 2000         	movs	r0, #0x0
 800d792: f00e fa20    	bl	0x801bbd6 <z_log_msg_runtime_create> @ imm = #0xe440
 800d796: 2300         	movs	r3, #0x0
 800d798: 62bb         	str	r3, [r7, #0x28]
; 	coredump(reason, esf, thread);
 800d79a: 6c3a         	ldr	r2, [r7, #0x40]
 800d79c: 6839         	ldr	r1, [r7]
 800d79e: 6878         	ldr	r0, [r7, #0x4]
 800d7a0: f00e fa3d    	bl	0x801bc1e <coredump>    @ imm = #0xe47a
; 	k_sys_fatal_error_handler(reason, esf);
 800d7a4: 6839         	ldr	r1, [r7]
 800d7a6: 6878         	ldr	r0, [r7, #0x4]
 800d7a8: f7ff fef0    	bl	0x800d58c <k_sys_fatal_error_handler> @ imm = #-0x220
; 		if ((esf != NULL) && arch_is_in_nested_exception(esf)) {
 800d7ac: 683b         	ldr	r3, [r7]
 800d7ae: 2b00         	cmp	r3, #0x0
 800d7b0: d006         	beq	0x800d7c0 <z_fatal_error+0x148> @ imm = #0xc
 800d7b2: 683b         	ldr	r3, [r7]
 800d7b4: 613b         	str	r3, [r7, #0x10]
; 	return (esf->basic.xpsr & IPSR_ISR_Msk) ? (true) : (false);
 800d7b6: 693b         	ldr	r3, [r7, #0x10]
 800d7b8: 69db         	ldr	r3, [r3, #0x1c]
 800d7ba: f3c3 0308    	ubfx	r3, r3, #0x0, #0x9
 800d7be: 2b00         	cmp	r3, #0x0
 800d7c0: 6bbb         	ldr	r3, [r7, #0x38]
 800d7c2: 60fb         	str	r3, [r7, #0xc]
 800d7c4: 68fb         	ldr	r3, [r7, #0xc]
 800d7c6: 60bb         	str	r3, [r7, #0x8]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800d7c8: 68bb         	ldr	r3, [r7, #0x8]
 800d7ca: f383 8811    	msr	basepri, r3
; }
 800d7ce: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800d7d0: f3bf 8f6f    	isb	sy
; }
 800d7d4: bf00         	nop
; }
 800d7d6: bf00         	nop
; 		k_thread_abort(thread);
 800d7d8: 6c38         	ldr	r0, [r7, #0x40]
 800d7da: f00e f9f1    	bl	0x801bbc0 <k_thread_abort> @ imm = #0xe3e2
; }
 800d7de: 374c         	adds	r7, #0x4c
 800d7e0: 46bd         	mov	sp, r7
 800d7e2: bd90         	pop	{r4, r7, pc}

0800d7e4 <$d>:
 800d7e4: f0 16 00 20  	.word	0x200016f0
 800d7e8: 94 05 00 20  	.word	0x20000594
 800d7ec: c0 f8 01 08  	.word	0x0801f8c0
 800d7f0: e8 f8 01 08  	.word	0x0801f8e8
 800d7f4: 0c f9 01 08  	.word	0x0801f90c

0800d7f8 <__NVIC_SetPriority>:
; {
 800d7f8: b480         	push	{r7}
 800d7fa: b083         	sub	sp, #0xc
 800d7fc: af00         	add	r7, sp, #0x0
 800d7fe: 4603         	mov	r3, r0
 800d800: 6039         	str	r1, [r7]
 800d802: 71fb         	strb	r3, [r7, #0x7]
;   if ((int32_t)(IRQn) >= 0)
 800d804: f997 3007    	ldrsb.w	r3, [r7, #0x7]
 800d808: 2b00         	cmp	r3, #0x0
 800d80a: db0a         	blt	0x800d822 <__NVIC_SetPriority+0x2a> @ imm = #0x14
;     NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800d80c: 683b         	ldr	r3, [r7]
 800d80e: b2da         	uxtb	r2, r3
 800d810: 490c         	ldr	r1, [pc, #0x30]         @ 0x800d844 <__NVIC_SetPriority+0x4c>
 800d812: f997 3007    	ldrsb.w	r3, [r7, #0x7]
 800d816: 0112         	lsls	r2, r2, #0x4
 800d818: b2d2         	uxtb	r2, r2
 800d81a: 440b         	add	r3, r1
 800d81c: f883 2300    	strb.w	r2, [r3, #0x300]
; }
 800d820: e00a         	b	0x800d838 <__NVIC_SetPriority+0x40> @ imm = #0x14
;     SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800d822: 683b         	ldr	r3, [r7]
 800d824: b2da         	uxtb	r2, r3
 800d826: 4908         	ldr	r1, [pc, #0x20]         @ 0x800d848 <__NVIC_SetPriority+0x50>
 800d828: 79fb         	ldrb	r3, [r7, #0x7]
 800d82a: f003 030f    	and	r3, r3, #0xf
 800d82e: 3b04         	subs	r3, #0x4
 800d830: 0112         	lsls	r2, r2, #0x4
 800d832: b2d2         	uxtb	r2, r2
 800d834: 440b         	add	r3, r1
 800d836: 761a         	strb	r2, [r3, #0x18]
; }
 800d838: bf00         	nop
 800d83a: 370c         	adds	r7, #0xc
 800d83c: 46bd         	mov	sp, r7
 800d83e: bc80         	pop	{r7}
 800d840: 4770         	bx	lr
 800d842: bf00         	nop

0800d844 <$d>:
 800d844: 00 e1 00 e0  	.word	0xe000e100
 800d848: 00 ed 00 e0  	.word	0xe000ed00

0800d84c <z_add_thread_timeout>:
; {
 800d84c: b580         	push	{r7, lr}
 800d84e: b084         	sub	sp, #0x10
 800d850: af00         	add	r7, sp, #0x0
 800d852: 60f8         	str	r0, [r7, #0xc]
 800d854: e9c7 2300    	strd	r2, r3, [r7]
; 	z_add_timeout(&thread->base.timeout, z_thread_timeout, ticks);
 800d858: 68fb         	ldr	r3, [r7, #0xc]
 800d85a: f103 0018    	add.w	r0, r3, #0x18
 800d85e: e9d7 2300    	ldrd	r2, r3, [r7]
 800d862: 4903         	ldr	r1, [pc, #0xc]          @ 0x800d870 <z_add_thread_timeout+0x24>
 800d864: f003 f9e2    	bl	0x8010c2c <z_add_timeout> @ imm = #0x33c4
; }
 800d868: bf00         	nop
 800d86a: 3710         	adds	r7, #0x10
 800d86c: 46bd         	mov	sp, r7
 800d86e: bd80         	pop	{r7, pc}

0800d870 <$d>:
 800d870: 5f d2 01 08  	.word	0x0801d25f

0800d874 <z_dummy_thread_init>:
; {
 800d874: b480         	push	{r7}
 800d876: b085         	sub	sp, #0x14
 800d878: af00         	add	r7, sp, #0x0
 800d87a: 6078         	str	r0, [r7, #0x4]
; 	dummy_thread->base.thread_state = _THREAD_DUMMY;
 800d87c: 687b         	ldr	r3, [r7, #0x4]
 800d87e: 2201         	movs	r2, #0x1
 800d880: 735a         	strb	r2, [r3, #0xd]
; 	dummy_thread->base.user_options = K_ESSENTIAL;
 800d882: 687b         	ldr	r3, [r7, #0x4]
 800d884: 2201         	movs	r2, #0x1
 800d886: 731a         	strb	r2, [r3, #0xc]
; 	dummy_thread->stack_info.start = 0U;
 800d888: 687b         	ldr	r3, [r7, #0x4]
 800d88a: 2200         	movs	r2, #0x0
 800d88c: f8c3 20b4    	str.w	r2, [r3, #0xb4]
; 	dummy_thread->stack_info.size = 0U;
 800d890: 687b         	ldr	r3, [r7, #0x4]
 800d892: 2200         	movs	r2, #0x0
 800d894: f8c3 20b8    	str.w	r2, [r3, #0xb8]
; 	dummy_thread->resource_pool = NULL;
 800d898: 687b         	ldr	r3, [r7, #0x4]
 800d89a: 2200         	movs	r2, #0x0
 800d89c: f8c3 20c0    	str.w	r2, [r3, #0xc0]
 800d8a0: 687b         	ldr	r3, [r7, #0x4]
 800d8a2: 60fb         	str	r3, [r7, #0xc]
; 	_current_cpu->current = thread;
 800d8a4: 4a04         	ldr	r2, [pc, #0x10]         @ 0x800d8b8 <z_dummy_thread_init+0x44>
 800d8a6: 68fb         	ldr	r3, [r7, #0xc]
 800d8a8: 6093         	str	r3, [r2, #0x8]
; }
 800d8aa: bf00         	nop
; }
 800d8ac: bf00         	nop
 800d8ae: 3714         	adds	r7, #0x14
 800d8b0: 46bd         	mov	sp, r7
 800d8b2: bc80         	pop	{r7}
 800d8b4: 4770         	bx	lr
 800d8b6: bf00         	nop

0800d8b8 <$d>:
 800d8b8: f0 16 00 20  	.word	0x200016f0

0800d8bc <z_init_static_threads>:
; {
 800d8bc: b5f0         	push	{r4, r5, r6, r7, lr}
 800d8be: b08f         	sub	sp, #0x3c
 800d8c0: af06         	add	r7, sp, #0x18
; 	STRUCT_SECTION_FOREACH(_static_thread_data, thread_data) {
 800d8c2: 4b31         	ldr	r3, [pc, #0xc4]         @ 0x800d988 <z_init_static_threads+0xcc>
 800d8c4: 61fb         	str	r3, [r7, #0x1c]
 800d8c6: e029         	b	0x800d91c <z_init_static_threads+0x60> @ imm = #0x52
; 		z_setup_new_thread(
 800d8c8: 69fb         	ldr	r3, [r7, #0x1c]
 800d8ca: 681e         	ldr	r6, [r3]
 800d8cc: 69fb         	ldr	r3, [r7, #0x1c]
 800d8ce: 685b         	ldr	r3, [r3, #0x4]
 800d8d0: 60fb         	str	r3, [r7, #0xc]
 800d8d2: 69fb         	ldr	r3, [r7, #0x1c]
 800d8d4: 689a         	ldr	r2, [r3, #0x8]
 800d8d6: 60ba         	str	r2, [r7, #0x8]
 800d8d8: 69fb         	ldr	r3, [r7, #0x1c]
 800d8da: 68d8         	ldr	r0, [r3, #0xc]
 800d8dc: 6078         	str	r0, [r7, #0x4]
 800d8de: 69fb         	ldr	r3, [r7, #0x1c]
 800d8e0: 691b         	ldr	r3, [r3, #0x10]
 800d8e2: 69fa         	ldr	r2, [r7, #0x1c]
 800d8e4: 6952         	ldr	r2, [r2, #0x14]
 800d8e6: 69f9         	ldr	r1, [r7, #0x1c]
 800d8e8: 6989         	ldr	r1, [r1, #0x18]
 800d8ea: 69f8         	ldr	r0, [r7, #0x1c]
 800d8ec: 69c0         	ldr	r0, [r0, #0x1c]
 800d8ee: 69fc         	ldr	r4, [r7, #0x1c]
 800d8f0: 6a24         	ldr	r4, [r4, #0x20]
 800d8f2: 69fd         	ldr	r5, [r7, #0x1c]
 800d8f4: 6a6d         	ldr	r5, [r5, #0x24]
 800d8f6: 9505         	str	r5, [sp, #0x14]
 800d8f8: 9404         	str	r4, [sp, #0x10]
 800d8fa: 9003         	str	r0, [sp, #0xc]
 800d8fc: 9102         	str	r1, [sp, #0x8]
 800d8fe: 9201         	str	r2, [sp, #0x4]
 800d900: 9300         	str	r3, [sp]
 800d902: 687b         	ldr	r3, [r7, #0x4]
 800d904: 68ba         	ldr	r2, [r7, #0x8]
 800d906: 68f9         	ldr	r1, [r7, #0xc]
 800d908: 4630         	mov	r0, r6
 800d90a: f001 fa5f    	bl	0x800edcc <z_setup_new_thread> @ imm = #0x14be
; 		thread_data->init_thread->init_data = thread_data;
 800d90e: 69fb         	ldr	r3, [r7, #0x1c]
 800d910: 681b         	ldr	r3, [r3]
 800d912: 69fa         	ldr	r2, [r7, #0x1c]
 800d914: 665a         	str	r2, [r3, #0x64]
; 	STRUCT_SECTION_FOREACH(_static_thread_data, thread_data) {
 800d916: 69fb         	ldr	r3, [r7, #0x1c]
 800d918: 3330         	adds	r3, #0x30
 800d91a: 61fb         	str	r3, [r7, #0x1c]
 800d91c: 69fb         	ldr	r3, [r7, #0x1c]
 800d91e: 4a1b         	ldr	r2, [pc, #0x6c]         @ 0x800d98c <z_init_static_threads+0xd0>
 800d920: 4293         	cmp	r3, r2
 800d922: bf34         	ite	lo
 800d924: 2301         	movlo	r3, #0x1
 800d926: 2300         	movhs	r3, #0x0
 800d928: b2db         	uxtb	r3, r3
 800d92a: 2b00         	cmp	r3, #0x0
 800d92c: d1cc         	bne	0x800d8c8 <z_init_static_threads+0xc> @ imm = #-0x68
; 	k_sched_lock();
 800d92e: f002 fa6f    	bl	0x800fe10 <k_sched_lock> @ imm = #0x24de
; 	STRUCT_SECTION_FOREACH(_static_thread_data, thread_data) {
 800d932: 4b15         	ldr	r3, [pc, #0x54]         @ 0x800d988 <z_init_static_threads+0xcc>
 800d934: 61bb         	str	r3, [r7, #0x18]
 800d936: e018         	b	0x800d96a <z_init_static_threads+0xae> @ imm = #0x30
; 		k_timeout_t init_delay = Z_THREAD_INIT_DELAY(thread_data);
 800d938: 69bb         	ldr	r3, [r7, #0x18]
 800d93a: e9d3 230a    	ldrd	r2, r3, [r3, #40]
 800d93e: e9c7 2304    	strd	r2, r3, [r7, #16]
; 		if (!K_TIMEOUT_EQ(init_delay, K_FOREVER)) {
 800d942: e9d7 2304    	ldrd	r2, r3, [r7, #16]
 800d946: f04f 30ff    	mov.w	r0, #0xffffffff
 800d94a: f04f 31ff    	mov.w	r1, #0xffffffff
 800d94e: 428b         	cmp	r3, r1
 800d950: bf08         	it	eq
 800d952: 4282         	cmpeq	r2, r0
 800d954: d006         	beq	0x800d964 <z_init_static_threads+0xa8> @ imm = #0xc
; 			thread_schedule_new(thread_data->init_thread,
 800d956: 69bb         	ldr	r3, [r7, #0x18]
 800d958: 6819         	ldr	r1, [r3]
 800d95a: e9d7 2304    	ldrd	r2, r3, [r7, #16]
 800d95e: 4608         	mov	r0, r1
 800d960: f00e f99c    	bl	0x801bc9c <thread_schedule_new> @ imm = #0xe338
; 	STRUCT_SECTION_FOREACH(_static_thread_data, thread_data) {
 800d964: 69bb         	ldr	r3, [r7, #0x18]
 800d966: 3330         	adds	r3, #0x30
 800d968: 61bb         	str	r3, [r7, #0x18]
 800d96a: 69bb         	ldr	r3, [r7, #0x18]
 800d96c: 4a07         	ldr	r2, [pc, #0x1c]         @ 0x800d98c <z_init_static_threads+0xd0>
 800d96e: 4293         	cmp	r3, r2
 800d970: bf34         	ite	lo
 800d972: 2301         	movlo	r3, #0x1
 800d974: 2300         	movhs	r3, #0x0
 800d976: b2db         	uxtb	r3, r3
 800d978: 2b00         	cmp	r3, #0x0
 800d97a: d1dd         	bne	0x800d938 <z_init_static_threads+0x7c> @ imm = #-0x46
; 	k_sched_unlock();
 800d97c: f002 fa88    	bl	0x800fe90 <k_sched_unlock> @ imm = #0x2510
; }
 800d980: bf00         	nop
 800d982: 3724         	adds	r7, #0x24
 800d984: 46bd         	mov	sp, r7
 800d986: bdf0         	pop	{r4, r5, r6, r7, pc}

0800d988 <$d>:
 800d988: 48 e1 01 08  	.word	0x0801e148
 800d98c: 48 e1 01 08  	.word	0x0801e148

0800d990 <z_bss_zero>:
; {
 800d990: b580         	push	{r7, lr}
 800d992: af00         	add	r7, sp, #0x0
; 	z_early_memset(__bss_start, 0, __bss_end - __bss_start);
 800d994: 4a04         	ldr	r2, [pc, #0x10]         @ 0x800d9a8 <z_bss_zero+0x18>
 800d996: 4b05         	ldr	r3, [pc, #0x14]         @ 0x800d9ac <z_bss_zero+0x1c>
 800d998: 1ad3         	subs	r3, r2, r3
 800d99a: 461a         	mov	r2, r3
 800d99c: 2100         	movs	r1, #0x0
 800d99e: 4803         	ldr	r0, [pc, #0xc]          @ 0x800d9ac <z_bss_zero+0x1c>
 800d9a0: f00e f9c9    	bl	0x801bd36 <z_early_memset> @ imm = #0xe392
; }
 800d9a4: bd80         	pop	{r7, pc}
 800d9a6: bf00         	nop

0800d9a8 <$d>:
 800d9a8: 8c 1f 00 20  	.word	0x20001f8c
 800d9ac: 28 06 00 20  	.word	0x20000628

0800d9b0 <z_sys_init_run_level>:
; {
 800d9b0: b580         	push	{r7, lr}
 800d9b2: b086         	sub	sp, #0x18
 800d9b4: af00         	add	r7, sp, #0x0
 800d9b6: 4603         	mov	r3, r0
 800d9b8: 71fb         	strb	r3, [r7, #0x7]
; 	for (entry = levels[level]; entry < levels[level+1]; entry++) {
 800d9ba: 79fb         	ldrb	r3, [r7, #0x7]
 800d9bc: 4a11         	ldr	r2, [pc, #0x44]         @ 0x800da04 <z_sys_init_run_level+0x54>
 800d9be: f852 3023    	ldr.w	r3, [r2, r3, lsl #2]
 800d9c2: 617b         	str	r3, [r7, #0x14]
 800d9c4: e011         	b	0x800d9ea <z_sys_init_run_level+0x3a> @ imm = #0x22
; 		const struct device *dev = entry->dev;
 800d9c6: 697b         	ldr	r3, [r7, #0x14]
 800d9c8: 685b         	ldr	r3, [r3, #0x4]
 800d9ca: 613b         	str	r3, [r7, #0x10]
; 		if (dev != NULL) {
 800d9cc: 693b         	ldr	r3, [r7, #0x10]
 800d9ce: 2b00         	cmp	r3, #0x0
 800d9d0: d004         	beq	0x800d9dc <z_sys_init_run_level+0x2c> @ imm = #0x8
; 			result = do_device_init(entry);
 800d9d2: 6978         	ldr	r0, [r7, #0x14]
 800d9d4: f00e f9cd    	bl	0x801bd72 <do_device_init> @ imm = #0xe39a
 800d9d8: 60f8         	str	r0, [r7, #0xc]
 800d9da: e003         	b	0x800d9e4 <z_sys_init_run_level+0x34> @ imm = #0x6
; 			result = entry->init_fn.sys();
 800d9dc: 697b         	ldr	r3, [r7, #0x14]
 800d9de: 681b         	ldr	r3, [r3]
 800d9e0: 4798         	blx	r3
 800d9e2: 60f8         	str	r0, [r7, #0xc]
; 	for (entry = levels[level]; entry < levels[level+1]; entry++) {
 800d9e4: 697b         	ldr	r3, [r7, #0x14]
 800d9e6: 3308         	adds	r3, #0x8
 800d9e8: 617b         	str	r3, [r7, #0x14]
 800d9ea: 79fb         	ldrb	r3, [r7, #0x7]
 800d9ec: 3301         	adds	r3, #0x1
 800d9ee: 4a05         	ldr	r2, [pc, #0x14]         @ 0x800da04 <z_sys_init_run_level+0x54>
 800d9f0: f852 3023    	ldr.w	r3, [r2, r3, lsl #2]
 800d9f4: 697a         	ldr	r2, [r7, #0x14]
 800d9f6: 429a         	cmp	r2, r3
 800d9f8: d3e5         	blo	0x800d9c6 <z_sys_init_run_level+0x16> @ imm = #-0x36
; }
 800d9fa: bf00         	nop
 800d9fc: bf00         	nop
 800d9fe: 3718         	adds	r7, #0x18
 800da00: 46bd         	mov	sp, r7
 800da02: bd80         	pop	{r7, pc}

0800da04 <$d>:
 800da04: 98 05 00 20  	.word	0x20000598

0800da08 <bg_thread_main>:
; {
 800da08: b580         	push	{r7, lr}
 800da0a: b084         	sub	sp, #0x10
 800da0c: af00         	add	r7, sp, #0x0
 800da0e: 60f8         	str	r0, [r7, #0xc]
 800da10: 60b9         	str	r1, [r7, #0x8]
 800da12: 607a         	str	r2, [r7, #0x4]
; 	z_sys_post_kernel = true;
 800da14: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x800da44 <bg_thread_main+0x3c>
 800da16: 2201         	movs	r2, #0x1
 800da18: 701a         	strb	r2, [r3]
; 	z_sys_init_run_level(INIT_LEVEL_POST_KERNEL);
 800da1a: 2003         	movs	r0, #0x3
 800da1c: f7ff ffc8    	bl	0x800d9b0 <z_sys_init_run_level> @ imm = #-0x70
; 	boot_banner();
 800da20: f003 fbfe    	bl	0x8011220 <boot_banner> @ imm = #0x37fc
; 	z_init_static();
 800da24: f00e f9db    	bl	0x801bdde <z_init_static> @ imm = #0xe3b6
; 	z_sys_init_run_level(INIT_LEVEL_APPLICATION);
 800da28: 2004         	movs	r0, #0x4
 800da2a: f7ff ffc1    	bl	0x800d9b0 <z_sys_init_run_level> @ imm = #-0x7e
; 	z_init_static_threads();
 800da2e: f7ff ff45    	bl	0x800d8bc <z_init_static_threads> @ imm = #-0x176
; 	(void)main();
 800da32: f7f5 fe9d    	bl	0x8003770 <main>        @ imm = #-0xa2c6
; 	z_thread_essential_clear(&z_main_thread);
 800da36: 4804         	ldr	r0, [pc, #0x10]         @ 0x800da48 <bg_thread_main+0x40>
 800da38: f00e f95d    	bl	0x801bcf6 <z_thread_essential_clear> @ imm = #0xe2ba
; } /* LCOV_EXCL_LINE ... because we just dumped final coverage data */
 800da3c: bf00         	nop
 800da3e: 3710         	adds	r7, #0x10
 800da40: 46bd         	mov	sp, r7
 800da42: bd80         	pop	{r7, pc}

0800da44 <$d>:
 800da44: 8a 1f 00 20  	.word	0x20001f8a
 800da48: 30 17 00 20  	.word	0x20001730

0800da4c <init_idle_thread>:
; {
 800da4c: b580         	push	{r7, lr}
 800da4e: b08c         	sub	sp, #0x30
 800da50: af06         	add	r7, sp, #0x18
 800da52: 6078         	str	r0, [r7, #0x4]
; 	struct k_thread *thread = &z_idle_threads[i];
 800da54: 687b         	ldr	r3, [r7, #0x4]
 800da56: 22d0         	movs	r2, #0xd0
 800da58: fb02 f303    	mul	r3, r2, r3
 800da5c: 4a17         	ldr	r2, [pc, #0x5c]         @ 0x800dabc <init_idle_thread+0x70>
 800da5e: 4413         	add	r3, r2
 800da60: 617b         	str	r3, [r7, #0x14]
; 	k_thread_stack_t *stack = z_idle_stacks[i];
 800da62: 687a         	ldr	r2, [r7, #0x4]
 800da64: 4613         	mov	r3, r2
 800da66: 009b         	lsls	r3, r3, #0x2
 800da68: 4413         	add	r3, r2
 800da6a: 019b         	lsls	r3, r3, #0x6
 800da6c: 4a14         	ldr	r2, [pc, #0x50]         @ 0x800dac0 <init_idle_thread+0x74>
 800da6e: 4413         	add	r3, r2
 800da70: 613b         	str	r3, [r7, #0x10]
; 	size_t stack_size = K_KERNEL_STACK_SIZEOF(z_idle_stacks[i]);
 800da72: f44f 73a0    	mov.w	r3, #0x140
 800da76: 60fb         	str	r3, [r7, #0xc]
; 	char *tname = "idle";
 800da78: 4b12         	ldr	r3, [pc, #0x48]         @ 0x800dac4 <init_idle_thread+0x78>
 800da7a: 60bb         	str	r3, [r7, #0x8]
; 			  stack_size, idle, &_kernel.cpus[i],
 800da7c: 687a         	ldr	r2, [r7, #0x4]
 800da7e: 4613         	mov	r3, r2
 800da80: 00db         	lsls	r3, r3, #0x3
 800da82: 1a9b         	subs	r3, r3, r2
 800da84: 009b         	lsls	r3, r3, #0x2
 800da86: 4a10         	ldr	r2, [pc, #0x40]         @ 0x800dac8 <init_idle_thread+0x7c>
 800da88: 4413         	add	r3, r2
; 	z_setup_new_thread(thread, stack,
 800da8a: 68ba         	ldr	r2, [r7, #0x8]
 800da8c: 9205         	str	r2, [sp, #0x14]
 800da8e: 2201         	movs	r2, #0x1
 800da90: 9204         	str	r2, [sp, #0x10]
 800da92: 220f         	movs	r2, #0xf
 800da94: 9203         	str	r2, [sp, #0xc]
 800da96: 2200         	movs	r2, #0x0
 800da98: 9202         	str	r2, [sp, #0x8]
 800da9a: 2200         	movs	r2, #0x0
 800da9c: 9201         	str	r2, [sp, #0x4]
 800da9e: 9300         	str	r3, [sp]
 800daa0: 4b0a         	ldr	r3, [pc, #0x28]         @ 0x800dacc <init_idle_thread+0x80>
 800daa2: 68fa         	ldr	r2, [r7, #0xc]
 800daa4: 6939         	ldr	r1, [r7, #0x10]
 800daa6: 6978         	ldr	r0, [r7, #0x14]
 800daa8: f001 f990    	bl	0x800edcc <z_setup_new_thread> @ imm = #0x1320
; 	z_mark_thread_as_not_suspended(thread);
 800daac: 6978         	ldr	r0, [r7, #0x14]
 800daae: f00e f912    	bl	0x801bcd6 <z_mark_thread_as_not_suspended> @ imm = #0xe224
; }
 800dab2: bf00         	nop
 800dab4: 3718         	adds	r7, #0x18
 800dab6: 46bd         	mov	sp, r7
 800dab8: bd80         	pop	{r7, pc}
 800daba: bf00         	nop

0800dabc <$d>:
 800dabc: 00 18 00 20  	.word	0x20001800
 800dac0: 90 36 00 20  	.word	0x20003690
 800dac4: 28 f9 01 08  	.word	0x0801f928
 800dac8: f0 16 00 20  	.word	0x200016f0
 800dacc: f7 bd 01 08  	.word	0x0801bdf7

0800dad0 <z_init_cpu>:
; {
 800dad0: b580         	push	{r7, lr}
 800dad2: b082         	sub	sp, #0x8
 800dad4: af00         	add	r7, sp, #0x0
 800dad6: 6078         	str	r0, [r7, #0x4]
; 	init_idle_thread(id);
 800dad8: 6878         	ldr	r0, [r7, #0x4]
 800dada: f7ff ffb7    	bl	0x800da4c <init_idle_thread> @ imm = #-0x92
; 	_kernel.cpus[id].idle_thread = &z_idle_threads[id];
 800dade: 687b         	ldr	r3, [r7, #0x4]
 800dae0: 22d0         	movs	r2, #0xd0
 800dae2: fb02 f303    	mul	r3, r2, r3
 800dae6: 4a23         	ldr	r2, [pc, #0x8c]         @ 0x800db74 <z_init_cpu+0xa4>
 800dae8: 1899         	adds	r1, r3, r2
 800daea: 4823         	ldr	r0, [pc, #0x8c]         @ 0x800db78 <z_init_cpu+0xa8>
 800daec: 687a         	ldr	r2, [r7, #0x4]
 800daee: 4613         	mov	r3, r2
 800daf0: 00db         	lsls	r3, r3, #0x3
 800daf2: 1a9b         	subs	r3, r3, r2
 800daf4: 009b         	lsls	r3, r3, #0x2
 800daf6: 4403         	add	r3, r0
 800daf8: 330c         	adds	r3, #0xc
 800dafa: 6019         	str	r1, [r3]
; 	_kernel.cpus[id].id = id;
 800dafc: 687b         	ldr	r3, [r7, #0x4]
 800dafe: b2d8         	uxtb	r0, r3
 800db00: 491d         	ldr	r1, [pc, #0x74]         @ 0x800db78 <z_init_cpu+0xa8>
 800db02: 687a         	ldr	r2, [r7, #0x4]
 800db04: 4613         	mov	r3, r2
 800db06: 00db         	lsls	r3, r3, #0x3
 800db08: 1a9b         	subs	r3, r3, r2
 800db0a: 009b         	lsls	r3, r3, #0x2
 800db0c: 440b         	add	r3, r1
 800db0e: 3310         	adds	r3, #0x10
 800db10: 4602         	mov	r2, r0
 800db12: 701a         	strb	r2, [r3]
; 		(K_KERNEL_STACK_BUFFER(z_interrupt_stacks[id]) +
 800db14: 687b         	ldr	r3, [r7, #0x4]
 800db16: 02db         	lsls	r3, r3, #0xb
 800db18: 4a18         	ldr	r2, [pc, #0x60]         @ 0x800db7c <z_init_cpu+0xac>
 800db1a: 4413         	add	r3, r2
 800db1c: 4618         	mov	r0, r3
 800db1e: f00e f89d    	bl	0x801bc5c <K_KERNEL_STACK_BUFFER> @ imm = #0xe13a
 800db22: 4603         	mov	r3, r0
 800db24: f503 6100    	add.w	r1, r3, #0x800
; 	_kernel.cpus[id].irq_stack =
 800db28: 4813         	ldr	r0, [pc, #0x4c]         @ 0x800db78 <z_init_cpu+0xa8>
 800db2a: 687a         	ldr	r2, [r7, #0x4]
 800db2c: 4613         	mov	r3, r2
 800db2e: 00db         	lsls	r3, r3, #0x3
 800db30: 1a9b         	subs	r3, r3, r2
 800db32: 009b         	lsls	r3, r3, #0x2
 800db34: 4403         	add	r3, r0
 800db36: 3304         	adds	r3, #0x4
 800db38: 6019         	str	r1, [r3]
; 	_kernel.cpus[id].usage = &_kernel.usage[id];
 800db3a: 687b         	ldr	r3, [r7, #0x4]
 800db3c: 3303         	adds	r3, #0x3
 800db3e: 011b         	lsls	r3, r3, #0x4
 800db40: 4a0d         	ldr	r2, [pc, #0x34]         @ 0x800db78 <z_init_cpu+0xa8>
 800db42: 1899         	adds	r1, r3, r2
 800db44: 480c         	ldr	r0, [pc, #0x30]         @ 0x800db78 <z_init_cpu+0xa8>
 800db46: 687a         	ldr	r2, [r7, #0x4]
 800db48: 4613         	mov	r3, r2
 800db4a: 00db         	lsls	r3, r3, #0x3
 800db4c: 1a9b         	subs	r3, r3, r2
 800db4e: 009b         	lsls	r3, r3, #0x2
 800db50: 4403         	add	r3, r0
 800db52: 3318         	adds	r3, #0x18
 800db54: 6019         	str	r1, [r3]
; 	_kernel.cpus[id].usage->track_usage =
 800db56: 4908         	ldr	r1, [pc, #0x20]         @ 0x800db78 <z_init_cpu+0xa8>
 800db58: 687a         	ldr	r2, [r7, #0x4]
 800db5a: 4613         	mov	r3, r2
 800db5c: 00db         	lsls	r3, r3, #0x3
 800db5e: 1a9b         	subs	r3, r3, r2
 800db60: 009b         	lsls	r3, r3, #0x2
 800db62: 440b         	add	r3, r1
 800db64: 3318         	adds	r3, #0x18
 800db66: 681b         	ldr	r3, [r3]
 800db68: 2201         	movs	r2, #0x1
 800db6a: 721a         	strb	r2, [r3, #0x8]
; }
 800db6c: bf00         	nop
 800db6e: 3708         	adds	r7, #0x8
 800db70: 46bd         	mov	sp, r7
 800db72: bd80         	pop	{r7, pc}

0800db74 <$d>:
 800db74: 00 18 00 20  	.word	0x20001800
 800db78: f0 16 00 20  	.word	0x200016f0
 800db7c: d0 37 00 20  	.word	0x200037d0

0800db80 <prepare_multithreading>:
; {
 800db80: b580         	push	{r7, lr}
 800db82: b088         	sub	sp, #0x20
 800db84: af06         	add	r7, sp, #0x18
; 	z_sched_init();
 800db86: f002 fa61    	bl	0x801004c <z_sched_init> @ imm = #0x24c2
; 	_kernel.ready_q.cache = &z_main_thread;
 800db8a: 4b12         	ldr	r3, [pc, #0x48]         @ 0x800dbd4 <prepare_multithreading+0x54>
 800db8c: 4a12         	ldr	r2, [pc, #0x48]         @ 0x800dbd8 <prepare_multithreading+0x58>
 800db8e: 61da         	str	r2, [r3, #0x1c]
; 	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
 800db90: 4b12         	ldr	r3, [pc, #0x48]         @ 0x800dbdc <prepare_multithreading+0x5c>
 800db92: 9305         	str	r3, [sp, #0x14]
 800db94: 2301         	movs	r3, #0x1
 800db96: 9304         	str	r3, [sp, #0x10]
 800db98: 2300         	movs	r3, #0x0
 800db9a: 9303         	str	r3, [sp, #0xc]
 800db9c: 2300         	movs	r3, #0x0
 800db9e: 9302         	str	r3, [sp, #0x8]
 800dba0: 2300         	movs	r3, #0x0
 800dba2: 9301         	str	r3, [sp, #0x4]
 800dba4: 2300         	movs	r3, #0x0
 800dba6: 9300         	str	r3, [sp]
 800dba8: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x800dbe0 <prepare_multithreading+0x60>
 800dbaa: f44f 6280    	mov.w	r2, #0x400
 800dbae: 490d         	ldr	r1, [pc, #0x34]         @ 0x800dbe4 <prepare_multithreading+0x64>
 800dbb0: 4809         	ldr	r0, [pc, #0x24]         @ 0x800dbd8 <prepare_multithreading+0x58>
 800dbb2: f001 f90b    	bl	0x800edcc <z_setup_new_thread> @ imm = #0x1216
 800dbb6: 6078         	str	r0, [r7, #0x4]
; 	z_mark_thread_as_not_suspended(&z_main_thread);
 800dbb8: 4807         	ldr	r0, [pc, #0x1c]         @ 0x800dbd8 <prepare_multithreading+0x58>
 800dbba: f00e f88c    	bl	0x801bcd6 <z_mark_thread_as_not_suspended> @ imm = #0xe118
; 	z_ready_thread(&z_main_thread);
 800dbbe: 4806         	ldr	r0, [pc, #0x18]         @ 0x800dbd8 <prepare_multithreading+0x58>
 800dbc0: f001 fbcc    	bl	0x800f35c <z_ready_thread> @ imm = #0x1798
; 	z_init_cpu(0);
 800dbc4: 2000         	movs	r0, #0x0
 800dbc6: f7ff ff83    	bl	0x800dad0 <z_init_cpu>  @ imm = #-0xfa
; 	return stack_ptr;
 800dbca: 687b         	ldr	r3, [r7, #0x4]
; }
 800dbcc: 4618         	mov	r0, r3
 800dbce: 3708         	adds	r7, #0x8
 800dbd0: 46bd         	mov	sp, r7
 800dbd2: bd80         	pop	{r7, pc}

0800dbd4 <$d>:
 800dbd4: f0 16 00 20  	.word	0x200016f0
 800dbd8: 30 17 00 20  	.word	0x20001730
 800dbdc: 30 f9 01 08  	.word	0x0801f930
 800dbe0: 09 da 00 08  	.word	0x0800da09
 800dbe4: 90 32 00 20  	.word	0x20003290

0800dbe8 <switch_to_main_thread>:
; {
 800dbe8: b580         	push	{r7, lr}
 800dbea: b082         	sub	sp, #0x8
 800dbec: af00         	add	r7, sp, #0x0
 800dbee: 6078         	str	r0, [r7, #0x4]
; 	arch_switch_to_main_thread(&z_main_thread, stack_ptr, bg_thread_main);
 800dbf0: 4a02         	ldr	r2, [pc, #0x8]          @ 0x800dbfc <switch_to_main_thread+0x14>
 800dbf2: 6879         	ldr	r1, [r7, #0x4]
 800dbf4: 4802         	ldr	r0, [pc, #0x8]          @ 0x800dc00 <switch_to_main_thread+0x18>
 800dbf6: f7f8 f9b7    	bl	0x8005f68 <arch_switch_to_main_thread> @ imm = #-0x7c92
 800dbfa: bf00         	nop

0800dbfc <$d>:
 800dbfc: 09 da 00 08  	.word	0x0800da09
 800dc00: 30 17 00 20  	.word	0x20001730

0800dc04 <z_cstart>:
; {
 800dc04: b580         	push	{r7, lr}
 800dc06: b082         	sub	sp, #0x8
 800dc08: af00         	add	r7, sp, #0x0
; 	gcov_static_init();
 800dc0a: f00e f884    	bl	0x801bd16 <gcov_static_init> @ imm = #0xe108
; 	z_sys_init_run_level(INIT_LEVEL_EARLY);
 800dc0e: 2000         	movs	r0, #0x0
 800dc10: f7ff fece    	bl	0x800d9b0 <z_sys_init_run_level> @ imm = #-0x264
; 		(uint32_t)(K_KERNEL_STACK_BUFFER(z_interrupt_stacks[0])) +
 800dc14: 482d         	ldr	r0, [pc, #0xb4]         @ 0x800dccc <z_cstart+0xc8>
 800dc16: f00e f821    	bl	0x801bc5c <K_KERNEL_STACK_BUFFER> @ imm = #0xe042
 800dc1a: 4603         	mov	r3, r0
; 	uint32_t msp =
 800dc1c: f503 6300    	add.w	r3, r3, #0x800
 800dc20: 607b         	str	r3, [r7, #0x4]
 800dc22: 687b         	ldr	r3, [r7, #0x4]
 800dc24: 603b         	str	r3, [r7]
;   __ASM volatile ("MSR msp, %0" : : "r" (topOfMainStack) : );
 800dc26: 683b         	ldr	r3, [r7]
 800dc28: f383 8808    	msr	msp, r3
; }
 800dc2c: bf00         	nop
; 	SCB->CCR |= SCB_CCR_STKALIGN_Msk;
 800dc2e: 4b28         	ldr	r3, [pc, #0xa0]         @ 0x800dcd0 <z_cstart+0xcc>
 800dc30: 695b         	ldr	r3, [r3, #0x14]
 800dc32: 4a27         	ldr	r2, [pc, #0x9c]         @ 0x800dcd0 <z_cstart+0xcc>
 800dc34: f443 7300    	orr	r3, r3, #0x200
 800dc38: 6153         	str	r3, [r2, #0x14]
; }
 800dc3a: bf00         	nop
; 	NVIC_SetPriority(PendSV_IRQn, _EXC_PENDSV_PRIO);
 800dc3c: 21ff         	movs	r1, #0xff
 800dc3e: f06f 0001    	mvn	r0, #0x1
 800dc42: f7ff fdd9    	bl	0x800d7f8 <__NVIC_SetPriority> @ imm = #-0x44e
; 	NVIC_SetPriority(SVCall_IRQn, _EXC_SVC_PRIO);
 800dc46: 2100         	movs	r1, #0x0
 800dc48: f06f 0004    	mvn	r0, #0x4
 800dc4c: f7ff fdd4    	bl	0x800d7f8 <__NVIC_SetPriority> @ imm = #-0x458
; 	NVIC_SetPriority(MemoryManagement_IRQn, _EXC_FAULT_PRIO);
 800dc50: 2100         	movs	r1, #0x0
 800dc52: f06f 000b    	mvn	r0, #0xb
 800dc56: f7ff fdcf    	bl	0x800d7f8 <__NVIC_SetPriority> @ imm = #-0x462
; 	NVIC_SetPriority(BusFault_IRQn, _EXC_FAULT_PRIO);
 800dc5a: 2100         	movs	r1, #0x0
 800dc5c: f06f 000a    	mvn	r0, #0xa
 800dc60: f7ff fdca    	bl	0x800d7f8 <__NVIC_SetPriority> @ imm = #-0x46c
; 	NVIC_SetPriority(UsageFault_IRQn, _EXC_FAULT_PRIO);
 800dc64: 2100         	movs	r1, #0x0
 800dc66: f06f 0009    	mvn	r0, #0x9
 800dc6a: f7ff fdc5    	bl	0x800d7f8 <__NVIC_SetPriority> @ imm = #-0x476
; 	NVIC_SetPriority(DebugMonitor_IRQn, _EXC_FAULT_PRIO);
 800dc6e: 2100         	movs	r1, #0x0
 800dc70: f06f 0003    	mvn	r0, #0x3
 800dc74: f7ff fdc0    	bl	0x800d7f8 <__NVIC_SetPriority> @ imm = #-0x480
; 	SCB->SHCSR |= SCB_SHCSR_USGFAULTENA_Msk | SCB_SHCSR_MEMFAULTENA_Msk |
 800dc78: 4b15         	ldr	r3, [pc, #0x54]         @ 0x800dcd0 <z_cstart+0xcc>
 800dc7a: 6a5b         	ldr	r3, [r3, #0x24]
 800dc7c: 4a14         	ldr	r2, [pc, #0x50]         @ 0x800dcd0 <z_cstart+0xcc>
 800dc7e: f443 23e0    	orr	r3, r3, #0x70000
 800dc82: 6253         	str	r3, [r2, #0x24]
; }
 800dc84: bf00         	nop
; 	z_arm_fault_init();
 800dc86: f7f7 ffd7    	bl	0x8005c38 <z_arm_fault_init> @ imm = #-0x8052
; 	z_arm_cpu_idle_init();
 800dc8a: f7f8 f99d    	bl	0x8005fc8 <z_arm_cpu_idle_init> @ imm = #-0x7cc6
; 	SCB->CFSR = SCB_CFSR_USGFAULTSR_Msk |
 800dc8e: 4b10         	ldr	r3, [pc, #0x40]         @ 0x800dcd0 <z_cstart+0xcc>
 800dc90: f04f 32ff    	mov.w	r2, #0xffffffff
 800dc94: 629a         	str	r2, [r3, #0x28]
; 	SCB->HFSR = 0xffffffff;
 800dc96: 4b0e         	ldr	r3, [pc, #0x38]         @ 0x800dcd0 <z_cstart+0xcc>
 800dc98: f04f 32ff    	mov.w	r2, #0xffffffff
 800dc9c: 62da         	str	r2, [r3, #0x2c]
; }
 800dc9e: bf00         	nop
; }
 800dca0: bf00         	nop
; 	LOG_CORE_INIT();
 800dca2: f7f6 fa53    	bl	0x800414c <log_core_init> @ imm = #-0x9b5a
; 	z_dummy_thread_init(&_thread_dummy);
 800dca6: 480b         	ldr	r0, [pc, #0x2c]         @ 0x800dcd4 <z_cstart+0xd0>
 800dca8: f7ff fde4    	bl	0x800d874 <z_dummy_thread_init> @ imm = #-0x438
; 	z_device_state_init();
 800dcac: f7ff fc50    	bl	0x800d550 <z_device_state_init> @ imm = #-0x760
; 	soc_early_init_hook();
 800dcb0: f7f6 fa18    	bl	0x80040e4 <soc_early_init_hook> @ imm = #-0x9bd0
; 	z_sys_init_run_level(INIT_LEVEL_PRE_KERNEL_1);
 800dcb4: 2001         	movs	r0, #0x1
 800dcb6: f7ff fe7b    	bl	0x800d9b0 <z_sys_init_run_level> @ imm = #-0x30a
; 	z_sys_init_run_level(INIT_LEVEL_PRE_KERNEL_2);
 800dcba: 2002         	movs	r0, #0x2
 800dcbc: f7ff fe78    	bl	0x800d9b0 <z_sys_init_run_level> @ imm = #-0x310
; 	switch_to_main_thread(prepare_multithreading());
 800dcc0: f7ff ff5e    	bl	0x800db80 <prepare_multithreading> @ imm = #-0x144
 800dcc4: 4603         	mov	r3, r0
 800dcc6: 4618         	mov	r0, r3
 800dcc8: f7ff ff8e    	bl	0x800dbe8 <switch_to_main_thread> @ imm = #-0xe4

0800dccc <$d>:
 800dccc: d0 37 00 20  	.word	0x200037d0
 800dcd0: 00 ed 00 e0  	.word	0xe000ed00
 800dcd4: d0 18 00 20  	.word	0x200018d0

0800dcd8 <adjust_owner_prio>:
; {
 800dcd8: b5b0         	push	{r4, r5, r7, lr}
 800dcda: b08c         	sub	sp, #0x30
 800dcdc: af08         	add	r7, sp, #0x20
 800dcde: 6078         	str	r0, [r7, #0x4]
 800dce0: 6039         	str	r1, [r7]
; 	if (mutex->owner->base.prio != new_prio) {
 800dce2: 687b         	ldr	r3, [r7, #0x4]
 800dce4: 689b         	ldr	r3, [r3, #0x8]
 800dce6: f993 300e    	ldrsb.w	r3, [r3, #0xe]
 800dcea: 461a         	mov	r2, r3
 800dcec: 683b         	ldr	r3, [r7]
 800dcee: 4293         	cmp	r3, r2
 800dcf0: d03a         	beq	0x800dd68 <adjust_owner_prio+0x90> @ imm = #0x74
; 		LOG_DBG("%p (ready (y/n): %c) prio changed to %d (was %d)",
 800dcf2: 2303         	movs	r3, #0x3
 800dcf4: 2b03         	cmp	r3, #0x3
 800dcf6: d92f         	bls	0x800dd58 <adjust_owner_prio+0x80> @ imm = #0x5e
 800dcf8: 2301         	movs	r3, #0x1
 800dcfa: 72fb         	strb	r3, [r7, #0xb]
 800dcfc: 7afb         	ldrb	r3, [r7, #0xb]
 800dcfe: f083 0301    	eor	r3, r3, #0x1
 800dd02: b2db         	uxtb	r3, r3
 800dd04: 2b00         	cmp	r3, #0x0
 800dd06: d127         	bne	0x800dd58 <adjust_owner_prio+0x80> @ imm = #0x4e
 800dd08: 4b1a         	ldr	r3, [pc, #0x68]         @ 0x800dd74 <adjust_owner_prio+0x9c>
 800dd0a: 681d         	ldr	r5, [r3]
 800dd0c: 687b         	ldr	r3, [r7, #0x4]
 800dd0e: 689c         	ldr	r4, [r3, #0x8]
 800dd10: 687b         	ldr	r3, [r7, #0x4]
 800dd12: 689b         	ldr	r3, [r3, #0x8]
 800dd14: 4618         	mov	r0, r3
 800dd16: f00e f93a    	bl	0x801bf8e <z_is_thread_ready> @ imm = #0xe274
 800dd1a: 4603         	mov	r3, r0
 800dd1c: 2b00         	cmp	r3, #0x0
 800dd1e: d001         	beq	0x800dd24 <adjust_owner_prio+0x4c> @ imm = #0x2
 800dd20: 2379         	movs	r3, #0x79
 800dd22: e000         	b	0x800dd26 <adjust_owner_prio+0x4e> @ imm = #0x0
 800dd24: 236e         	movs	r3, #0x6e
 800dd26: 687a         	ldr	r2, [r7, #0x4]
 800dd28: 6892         	ldr	r2, [r2, #0x8]
 800dd2a: f992 200e    	ldrsb.w	r2, [r2, #0xe]
 800dd2e: 9207         	str	r2, [sp, #0x1c]
 800dd30: 683a         	ldr	r2, [r7]
 800dd32: 9206         	str	r2, [sp, #0x18]
 800dd34: 9305         	str	r3, [sp, #0x14]
 800dd36: 9404         	str	r4, [sp, #0x10]
 800dd38: 4b0f         	ldr	r3, [pc, #0x3c]         @ 0x800dd78 <adjust_owner_prio+0xa0>
 800dd3a: 9303         	str	r3, [sp, #0xc]
 800dd3c: 4b0f         	ldr	r3, [pc, #0x3c]         @ 0x800dd7c <adjust_owner_prio+0xa4>
 800dd3e: 9302         	str	r3, [sp, #0x8]
 800dd40: 2308         	movs	r3, #0x8
 800dd42: 9301         	str	r3, [sp, #0x4]
 800dd44: 2300         	movs	r3, #0x0
 800dd46: 9300         	str	r3, [sp]
 800dd48: 2300         	movs	r3, #0x0
 800dd4a: 2204         	movs	r2, #0x4
 800dd4c: 4629         	mov	r1, r5
 800dd4e: 2000         	movs	r0, #0x0
 800dd50: f00e f9b5    	bl	0x801c0be <z_log_msg_runtime_create> @ imm = #0xe36a
 800dd54: 2300         	movs	r3, #0x0
 800dd56: 60fb         	str	r3, [r7, #0xc]
; 		return z_thread_prio_set(mutex->owner, new_prio);
 800dd58: 687b         	ldr	r3, [r7, #0x4]
 800dd5a: 689b         	ldr	r3, [r3, #0x8]
 800dd5c: 6839         	ldr	r1, [r7]
 800dd5e: 4618         	mov	r0, r3
 800dd60: f001 fefe    	bl	0x800fb60 <z_thread_prio_set> @ imm = #0x1dfc
 800dd64: 4603         	mov	r3, r0
 800dd66: e000         	b	0x800dd6a <adjust_owner_prio+0x92> @ imm = #0x0
; 	return false;
 800dd68: 2300         	movs	r3, #0x0
; }
 800dd6a: 4618         	mov	r0, r3
 800dd6c: 3710         	adds	r7, #0x10
 800dd6e: 46bd         	mov	sp, r7
 800dd70: bdb0         	pop	{r4, r5, r7, pc}
 800dd72: bf00         	nop

0800dd74 <$d>:
 800dd74: b0 05 00 20  	.word	0x200005b0
 800dd78: f4 06 02 08  	.word	0x080206f4
 800dd7c: 38 f9 01 08  	.word	0x0801f938

0800dd80 <z_impl_k_mutex_lock>:
; {
 800dd80: b580         	push	{r7, lr}
 800dd82: b0be         	sub	sp, #0xf8
 800dd84: af08         	add	r7, sp, #0x20
 800dd86: 60f8         	str	r0, [r7, #0xc]
 800dd88: e9c7 2300    	strd	r2, r3, [r7]
; 	bool resched = false;
 800dd8c: 2300         	movs	r3, #0x0
 800dd8e: f887 30d7    	strb.w	r3, [r7, #0xd7]
 800dd92: 4ba6         	ldr	r3, [pc, #0x298]        @ 0x800e02c <z_impl_k_mutex_lock+0x2ac>
 800dd94: f8c7 3094    	str.w	r3, [r7, #0x94]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800dd98: f3ef 8311    	mrs	r3, basepri
 800dd9c: f8c7 3090    	str.w	r3, [r7, #0x90]
;   return(result);
 800dda0: f8d7 3090    	ldr.w	r3, [r7, #0x90]
; 	key = __get_BASEPRI();
 800dda4: f8c7 308c    	str.w	r3, [r7, #0x8c]
 800dda8: 2310         	movs	r3, #0x10
 800ddaa: f8c7 3088    	str.w	r3, [r7, #0x88]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 800ddae: f8d7 3088    	ldr.w	r3, [r7, #0x88]
 800ddb2: f383 8812    	msr	basepri_max, r3
; }
 800ddb6: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800ddb8: f3bf 8f6f    	isb	sy
; }
 800ddbc: bf00         	nop
; 	return key;
 800ddbe: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
; 	k.key = arch_irq_lock();
 800ddc2: 617b         	str	r3, [r7, #0x14]
 800ddc4: f8d7 3094    	ldr.w	r3, [r7, #0x94]
 800ddc8: f8c7 3084    	str.w	r3, [r7, #0x84]
; }
 800ddcc: bf00         	nop
 800ddce: f8d7 3094    	ldr.w	r3, [r7, #0x94]
 800ddd2: f8c7 3080    	str.w	r3, [r7, #0x80]
; }
 800ddd6: bf00         	nop
; 	return k;
 800ddd8: 697b         	ldr	r3, [r7, #0x14]
 800ddda: 627b         	str	r3, [r7, #0x24]
; 	if (likely((mutex->lock_count == 0U) || (mutex->owner == arch_current_thread()))) {
 800dddc: 68fb         	ldr	r3, [r7, #0xc]
 800ddde: 68db         	ldr	r3, [r3, #0xc]
 800dde0: 2b00         	cmp	r3, #0x0
 800dde2: bf0c         	ite	eq
 800dde4: 2301         	moveq	r3, #0x1
 800dde6: 2300         	movne	r3, #0x0
 800dde8: b2db         	uxtb	r3, r3
 800ddea: 2b00         	cmp	r3, #0x0
 800ddec: d10c         	bne	0x800de08 <z_impl_k_mutex_lock+0x88> @ imm = #0x18
 800ddee: 68fb         	ldr	r3, [r7, #0xc]
 800ddf0: 689a         	ldr	r2, [r3, #0x8]
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800ddf2: 4b8f         	ldr	r3, [pc, #0x23c]        @ 0x800e030 <z_impl_k_mutex_lock+0x2b0>
 800ddf4: 689b         	ldr	r3, [r3, #0x8]
 800ddf6: 67fb         	str	r3, [r7, #0x7c]
; 	return ret;
 800ddf8: 6ffb         	ldr	r3, [r7, #0x7c]
; 	if (likely((mutex->lock_count == 0U) || (mutex->owner == arch_current_thread()))) {
 800ddfa: 429a         	cmp	r2, r3
 800ddfc: bf0c         	ite	eq
 800ddfe: 2301         	moveq	r3, #0x1
 800de00: 2300         	movne	r3, #0x0
 800de02: b2db         	uxtb	r3, r3
 800de04: 2b00         	cmp	r3, #0x0
 800de06: d001         	beq	0x800de0c <z_impl_k_mutex_lock+0x8c> @ imm = #0x2
 800de08: 2301         	movs	r3, #0x1
 800de0a: e000         	b	0x800de0e <z_impl_k_mutex_lock+0x8e> @ imm = #0x0
 800de0c: 2300         	movs	r3, #0x0
 800de0e: 2b00         	cmp	r3, #0x0
 800de10: d059         	beq	0x800dec6 <z_impl_k_mutex_lock+0x146> @ imm = #0xb2
; 		mutex->owner_orig_prio = (mutex->lock_count == 0U) ?
 800de12: 68fb         	ldr	r3, [r7, #0xc]
 800de14: 68db         	ldr	r3, [r3, #0xc]
; 					arch_current_thread()->base.prio :
 800de16: 2b00         	cmp	r3, #0x0
 800de18: d106         	bne	0x800de28 <z_impl_k_mutex_lock+0xa8> @ imm = #0xc
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800de1a: 4b85         	ldr	r3, [pc, #0x214]        @ 0x800e030 <z_impl_k_mutex_lock+0x2b0>
 800de1c: 689b         	ldr	r3, [r3, #0x8]
 800de1e: 67bb         	str	r3, [r7, #0x78]
; 	return ret;
 800de20: 6fbb         	ldr	r3, [r7, #0x78]
; 					arch_current_thread()->base.prio :
 800de22: f993 300e    	ldrsb.w	r3, [r3, #0xe]
 800de26: e001         	b	0x800de2c <z_impl_k_mutex_lock+0xac> @ imm = #0x2
 800de28: 68fb         	ldr	r3, [r7, #0xc]
 800de2a: 691b         	ldr	r3, [r3, #0x10]
; 		mutex->owner_orig_prio = (mutex->lock_count == 0U) ?
 800de2c: 68fa         	ldr	r2, [r7, #0xc]
 800de2e: 6113         	str	r3, [r2, #0x10]
; 		mutex->lock_count++;
 800de30: 68fb         	ldr	r3, [r7, #0xc]
 800de32: 68db         	ldr	r3, [r3, #0xc]
 800de34: 1c5a         	adds	r2, r3, #0x1
 800de36: 68fb         	ldr	r3, [r7, #0xc]
 800de38: 60da         	str	r2, [r3, #0xc]
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800de3a: 4b7d         	ldr	r3, [pc, #0x1f4]        @ 0x800e030 <z_impl_k_mutex_lock+0x2b0>
 800de3c: 689b         	ldr	r3, [r3, #0x8]
 800de3e: 677b         	str	r3, [r7, #0x74]
; 	return ret;
 800de40: 6f7a         	ldr	r2, [r7, #0x74]
; 		mutex->owner = arch_current_thread();
 800de42: 68fb         	ldr	r3, [r7, #0xc]
 800de44: 609a         	str	r2, [r3, #0x8]
; 		LOG_DBG("%p took mutex %p, count: %d, orig prio: %d",
 800de46: 2303         	movs	r3, #0x3
 800de48: 2b03         	cmp	r3, #0x3
 800de4a: d929         	bls	0x800dea0 <z_impl_k_mutex_lock+0x120> @ imm = #0x52
 800de4c: 2301         	movs	r3, #0x1
 800de4e: f887 309f    	strb.w	r3, [r7, #0x9f]
 800de52: f897 309f    	ldrb.w	r3, [r7, #0x9f]
 800de56: f083 0301    	eor	r3, r3, #0x1
 800de5a: b2db         	uxtb	r3, r3
 800de5c: 2b00         	cmp	r3, #0x0
 800de5e: d11f         	bne	0x800dea0 <z_impl_k_mutex_lock+0x120> @ imm = #0x3e
 800de60: 4b74         	ldr	r3, [pc, #0x1d0]        @ 0x800e034 <z_impl_k_mutex_lock+0x2b4>
 800de62: 6818         	ldr	r0, [r3]
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800de64: 4b72         	ldr	r3, [pc, #0x1c8]        @ 0x800e030 <z_impl_k_mutex_lock+0x2b0>
 800de66: 689b         	ldr	r3, [r3, #0x8]
 800de68: 673b         	str	r3, [r7, #0x70]
; 	return ret;
 800de6a: 6f3b         	ldr	r3, [r7, #0x70]
; 		LOG_DBG("%p took mutex %p, count: %d, orig prio: %d",
 800de6c: 68fa         	ldr	r2, [r7, #0xc]
 800de6e: 68d2         	ldr	r2, [r2, #0xc]
 800de70: 68f9         	ldr	r1, [r7, #0xc]
 800de72: 6909         	ldr	r1, [r1, #0x10]
 800de74: 9107         	str	r1, [sp, #0x1c]
 800de76: 9206         	str	r2, [sp, #0x18]
 800de78: 68fa         	ldr	r2, [r7, #0xc]
 800de7a: 9205         	str	r2, [sp, #0x14]
 800de7c: 9304         	str	r3, [sp, #0x10]
 800de7e: 4b6e         	ldr	r3, [pc, #0x1b8]        @ 0x800e038 <z_impl_k_mutex_lock+0x2b8>
 800de80: 9303         	str	r3, [sp, #0xc]
 800de82: 4b6e         	ldr	r3, [pc, #0x1b8]        @ 0x800e03c <z_impl_k_mutex_lock+0x2bc>
 800de84: 9302         	str	r3, [sp, #0x8]
 800de86: 2308         	movs	r3, #0x8
 800de88: 9301         	str	r3, [sp, #0x4]
 800de8a: 2300         	movs	r3, #0x0
 800de8c: 9300         	str	r3, [sp]
 800de8e: 2300         	movs	r3, #0x0
 800de90: 2204         	movs	r2, #0x4
 800de92: 4601         	mov	r1, r0
 800de94: 2000         	movs	r0, #0x0
 800de96: f00e f912    	bl	0x801c0be <z_log_msg_runtime_create> @ imm = #0xe224
 800de9a: 2300         	movs	r3, #0x0
 800de9c: f8c7 3098    	str.w	r3, [r7, #0x98]
 800dea0: 4b62         	ldr	r3, [pc, #0x188]        @ 0x800e02c <z_impl_k_mutex_lock+0x2ac>
 800dea2: 66fb         	str	r3, [r7, #0x6c]
 800dea4: 6a7b         	ldr	r3, [r7, #0x24]
 800dea6: 61bb         	str	r3, [r7, #0x18]
; 	arch_irq_unlock(key.key);
 800dea8: 69bb         	ldr	r3, [r7, #0x18]
 800deaa: 66bb         	str	r3, [r7, #0x68]
 800deac: 6ebb         	ldr	r3, [r7, #0x68]
 800deae: 667b         	str	r3, [r7, #0x64]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800deb0: 6e7b         	ldr	r3, [r7, #0x64]
 800deb2: f383 8811    	msr	basepri, r3
; }
 800deb6: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800deb8: f3bf 8f6f    	isb	sy
; }
 800debc: bf00         	nop
; }
 800debe: bf00         	nop
; }
 800dec0: bf00         	nop
; 		return 0;
 800dec2: 2300         	movs	r3, #0x0
 800dec4: e193         	b	0x800e1ee <z_impl_k_mutex_lock+0x46e> @ imm = #0x326
; 	if (unlikely(K_TIMEOUT_EQ(timeout, K_NO_WAIT))) {
 800dec6: e9d7 2300    	ldrd	r2, r3, [r7]
 800deca: f04f 0000    	mov.w	r0, #0x0
 800dece: f04f 0100    	mov.w	r1, #0x0
 800ded2: 428b         	cmp	r3, r1
 800ded4: bf08         	it	eq
 800ded6: 4282         	cmpeq	r2, r0
 800ded8: bf0c         	ite	eq
 800deda: 2301         	moveq	r3, #0x1
 800dedc: 2300         	movne	r3, #0x0
 800dede: b2db         	uxtb	r3, r3
 800dee0: 2b00         	cmp	r3, #0x0
 800dee2: d013         	beq	0x800df0c <z_impl_k_mutex_lock+0x18c> @ imm = #0x26
 800dee4: 4b51         	ldr	r3, [pc, #0x144]        @ 0x800e02c <z_impl_k_mutex_lock+0x2ac>
 800dee6: 663b         	str	r3, [r7, #0x60]
 800dee8: 6a7b         	ldr	r3, [r7, #0x24]
 800deea: 613b         	str	r3, [r7, #0x10]
; 	arch_irq_unlock(key.key);
 800deec: 693b         	ldr	r3, [r7, #0x10]
 800deee: 65fb         	str	r3, [r7, #0x5c]
 800def0: 6dfb         	ldr	r3, [r7, #0x5c]
 800def2: 65bb         	str	r3, [r7, #0x58]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800def4: 6dbb         	ldr	r3, [r7, #0x58]
 800def6: f383 8811    	msr	basepri, r3
; }
 800defa: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800defc: f3bf 8f6f    	isb	sy
; }
 800df00: bf00         	nop
; }
 800df02: bf00         	nop
; }
 800df04: bf00         	nop
; 		return -EBUSY;
 800df06: f06f 030f    	mvn	r3, #0xf
 800df0a: e170         	b	0x800e1ee <z_impl_k_mutex_lock+0x46e> @ imm = #0x2e0
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800df0c: 4b48         	ldr	r3, [pc, #0x120]        @ 0x800e030 <z_impl_k_mutex_lock+0x2b0>
 800df0e: 689b         	ldr	r3, [r3, #0x8]
 800df10: 657b         	str	r3, [r7, #0x54]
; 	return ret;
 800df12: 6d7b         	ldr	r3, [r7, #0x54]
; 	new_prio = new_prio_for_inheritance(arch_current_thread()->base.prio,
 800df14: f993 300e    	ldrsb.w	r3, [r3, #0xe]
 800df18: 461a         	mov	r2, r3
; 					    mutex->owner->base.prio);
 800df1a: 68fb         	ldr	r3, [r7, #0xc]
 800df1c: 689b         	ldr	r3, [r3, #0x8]
 800df1e: f993 300e    	ldrsb.w	r3, [r3, #0xe]
; 	new_prio = new_prio_for_inheritance(arch_current_thread()->base.prio,
 800df22: 4619         	mov	r1, r3
 800df24: 4610         	mov	r0, r2
 800df26: f00e f8e8    	bl	0x801c0fa <new_prio_for_inheritance> @ imm = #0xe1d0
 800df2a: f8c7 00d0    	str.w	r0, [r7, #0xd0]
; 	LOG_DBG("adjusting prio up on mutex %p", mutex);
 800df2e: 2303         	movs	r3, #0x3
 800df30: 2b03         	cmp	r3, #0x3
 800df32: d91d         	bls	0x800df70 <z_impl_k_mutex_lock+0x1f0> @ imm = #0x3a
 800df34: 2301         	movs	r3, #0x1
 800df36: f887 30cf    	strb.w	r3, [r7, #0xcf]
 800df3a: f897 30cf    	ldrb.w	r3, [r7, #0xcf]
 800df3e: f083 0301    	eor	r3, r3, #0x1
 800df42: b2db         	uxtb	r3, r3
 800df44: 2b00         	cmp	r3, #0x0
 800df46: d113         	bne	0x800df70 <z_impl_k_mutex_lock+0x1f0> @ imm = #0x26
 800df48: 4b3a         	ldr	r3, [pc, #0xe8]         @ 0x800e034 <z_impl_k_mutex_lock+0x2b4>
 800df4a: 6819         	ldr	r1, [r3]
 800df4c: 68fb         	ldr	r3, [r7, #0xc]
 800df4e: 9304         	str	r3, [sp, #0x10]
 800df50: 4b39         	ldr	r3, [pc, #0xe4]         @ 0x800e038 <z_impl_k_mutex_lock+0x2b8>
 800df52: 9303         	str	r3, [sp, #0xc]
 800df54: 4b3a         	ldr	r3, [pc, #0xe8]         @ 0x800e040 <z_impl_k_mutex_lock+0x2c0>
 800df56: 9302         	str	r3, [sp, #0x8]
 800df58: 2308         	movs	r3, #0x8
 800df5a: 9301         	str	r3, [sp, #0x4]
 800df5c: 2300         	movs	r3, #0x0
 800df5e: 9300         	str	r3, [sp]
 800df60: 2300         	movs	r3, #0x0
 800df62: 2204         	movs	r2, #0x4
 800df64: 2000         	movs	r0, #0x0
 800df66: f00e f8aa    	bl	0x801c0be <z_log_msg_runtime_create> @ imm = #0xe154
 800df6a: 2300         	movs	r3, #0x0
 800df6c: f8c7 30c8    	str.w	r3, [r7, #0xc8]
; 	if (z_is_prio_higher(new_prio, mutex->owner->base.prio)) {
 800df70: 68fb         	ldr	r3, [r7, #0xc]
 800df72: 689b         	ldr	r3, [r3, #0x8]
 800df74: f993 300e    	ldrsb.w	r3, [r3, #0xe]
 800df78: 4619         	mov	r1, r3
 800df7a: f8d7 00d0    	ldr.w	r0, [r7, #0xd0]
 800df7e: f00e f869    	bl	0x801c054 <z_is_prio_higher> @ imm = #0xe0d2
 800df82: 4603         	mov	r3, r0
 800df84: 2b00         	cmp	r3, #0x0
 800df86: d007         	beq	0x800df98 <z_impl_k_mutex_lock+0x218> @ imm = #0xe
; 		resched = adjust_owner_prio(mutex, new_prio);
 800df88: f8d7 10d0    	ldr.w	r1, [r7, #0xd0]
 800df8c: 68f8         	ldr	r0, [r7, #0xc]
 800df8e: f7ff fea3    	bl	0x800dcd8 <adjust_owner_prio> @ imm = #-0x2ba
 800df92: 4603         	mov	r3, r0
 800df94: f887 30d7    	strb.w	r3, [r7, #0xd7]
; 	int got_mutex = z_pend_curr(&lock, key, &mutex->wait_q, timeout);
 800df98: 68f9         	ldr	r1, [r7, #0xc]
 800df9a: e9d7 2300    	ldrd	r2, r3, [r7]
 800df9e: e9cd 2300    	strd	r2, r3, [sp]
 800dfa2: 460a         	mov	r2, r1
 800dfa4: 6a79         	ldr	r1, [r7, #0x24]
 800dfa6: 4821         	ldr	r0, [pc, #0x84]         @ 0x800e02c <z_impl_k_mutex_lock+0x2ac>
 800dfa8: f001 fd94    	bl	0x800fad4 <z_pend_curr> @ imm = #0x1b28
 800dfac: f8c7 00c4    	str.w	r0, [r7, #0xc4]
; 	LOG_DBG("on mutex %p got_mutex value: %d", mutex, got_mutex);
 800dfb0: 2303         	movs	r3, #0x3
 800dfb2: 2b03         	cmp	r3, #0x3
 800dfb4: d920         	bls	0x800dff8 <z_impl_k_mutex_lock+0x278> @ imm = #0x40
 800dfb6: 2301         	movs	r3, #0x1
 800dfb8: f887 30c3    	strb.w	r3, [r7, #0xc3]
 800dfbc: f897 30c3    	ldrb.w	r3, [r7, #0xc3]
 800dfc0: f083 0301    	eor	r3, r3, #0x1
 800dfc4: b2db         	uxtb	r3, r3
 800dfc6: 2b00         	cmp	r3, #0x0
 800dfc8: d116         	bne	0x800dff8 <z_impl_k_mutex_lock+0x278> @ imm = #0x2c
 800dfca: 4b1a         	ldr	r3, [pc, #0x68]         @ 0x800e034 <z_impl_k_mutex_lock+0x2b4>
 800dfcc: 6819         	ldr	r1, [r3]
 800dfce: f8d7 30c4    	ldr.w	r3, [r7, #0xc4]
 800dfd2: 9305         	str	r3, [sp, #0x14]
 800dfd4: 68fb         	ldr	r3, [r7, #0xc]
 800dfd6: 9304         	str	r3, [sp, #0x10]
 800dfd8: 4b17         	ldr	r3, [pc, #0x5c]         @ 0x800e038 <z_impl_k_mutex_lock+0x2b8>
 800dfda: 9303         	str	r3, [sp, #0xc]
 800dfdc: 4b19         	ldr	r3, [pc, #0x64]         @ 0x800e044 <z_impl_k_mutex_lock+0x2c4>
 800dfde: 9302         	str	r3, [sp, #0x8]
 800dfe0: 2308         	movs	r3, #0x8
 800dfe2: 9301         	str	r3, [sp, #0x4]
 800dfe4: 2300         	movs	r3, #0x0
 800dfe6: 9300         	str	r3, [sp]
 800dfe8: 2300         	movs	r3, #0x0
 800dfea: 2204         	movs	r2, #0x4
 800dfec: 2000         	movs	r0, #0x0
 800dfee: f00e f866    	bl	0x801c0be <z_log_msg_runtime_create> @ imm = #0xe0cc
 800dff2: 2300         	movs	r3, #0x0
 800dff4: f8c7 30bc    	str.w	r3, [r7, #0xbc]
; 	LOG_DBG("%p got mutex %p (y/n): %c", arch_current_thread(), mutex,
 800dff8: 2303         	movs	r3, #0x3
 800dffa: 2b03         	cmp	r3, #0x3
 800dffc: d939         	bls	0x800e072 <z_impl_k_mutex_lock+0x2f2> @ imm = #0x72
 800dffe: 2301         	movs	r3, #0x1
 800e000: f887 30bb    	strb.w	r3, [r7, #0xbb]
 800e004: f897 30bb    	ldrb.w	r3, [r7, #0xbb]
 800e008: f083 0301    	eor	r3, r3, #0x1
 800e00c: b2db         	uxtb	r3, r3
 800e00e: 2b00         	cmp	r3, #0x0
 800e010: d12f         	bne	0x800e072 <z_impl_k_mutex_lock+0x2f2> @ imm = #0x5e
 800e012: 4b08         	ldr	r3, [pc, #0x20]         @ 0x800e034 <z_impl_k_mutex_lock+0x2b4>
 800e014: 6819         	ldr	r1, [r3]
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800e016: 4b06         	ldr	r3, [pc, #0x18]         @ 0x800e030 <z_impl_k_mutex_lock+0x2b0>
 800e018: 689b         	ldr	r3, [r3, #0x8]
 800e01a: 653b         	str	r3, [r7, #0x50]
; 	return ret;
 800e01c: 6d3b         	ldr	r3, [r7, #0x50]
; 	LOG_DBG("%p got mutex %p (y/n): %c", arch_current_thread(), mutex,
 800e01e: f8d7 20c4    	ldr.w	r2, [r7, #0xc4]
 800e022: 2a00         	cmp	r2, #0x0
 800e024: d010         	beq	0x800e048 <z_impl_k_mutex_lock+0x2c8> @ imm = #0x20
 800e026: 2279         	movs	r2, #0x79
 800e028: e00f         	b	0x800e04a <z_impl_k_mutex_lock+0x2ca> @ imm = #0x1e
 800e02a: bf00         	nop

0800e02c <$d>:
 800e02c: 68 1f 00 20  	.word	0x20001f68
 800e030: f0 16 00 20  	.word	0x200016f0
 800e034: b0 05 00 20  	.word	0x200005b0
 800e038: 08 07 02 08  	.word	0x08020708
 800e03c: 70 f9 01 08  	.word	0x0801f970
 800e040: a0 f9 01 08  	.word	0x0801f9a0
 800e044: c4 f9 01 08  	.word	0x0801f9c4

0800e048 <$t>:
 800e048: 226e         	movs	r2, #0x6e
 800e04a: 9206         	str	r2, [sp, #0x18]
 800e04c: 68fa         	ldr	r2, [r7, #0xc]
 800e04e: 9205         	str	r2, [sp, #0x14]
 800e050: 9304         	str	r3, [sp, #0x10]
 800e052: 4b69         	ldr	r3, [pc, #0x1a4]        @ 0x800e1f8 <z_impl_k_mutex_lock+0x478>
 800e054: 9303         	str	r3, [sp, #0xc]
 800e056: 4b69         	ldr	r3, [pc, #0x1a4]        @ 0x800e1fc <z_impl_k_mutex_lock+0x47c>
 800e058: 9302         	str	r3, [sp, #0x8]
 800e05a: 2308         	movs	r3, #0x8
 800e05c: 9301         	str	r3, [sp, #0x4]
 800e05e: 2300         	movs	r3, #0x0
 800e060: 9300         	str	r3, [sp]
 800e062: 2300         	movs	r3, #0x0
 800e064: 2204         	movs	r2, #0x4
 800e066: 2000         	movs	r0, #0x0
 800e068: f00e f829    	bl	0x801c0be <z_log_msg_runtime_create> @ imm = #0xe052
 800e06c: 2300         	movs	r3, #0x0
 800e06e: f8c7 30b4    	str.w	r3, [r7, #0xb4]
; 	if (got_mutex == 0) {
 800e072: f8d7 30c4    	ldr.w	r3, [r7, #0xc4]
 800e076: 2b00         	cmp	r3, #0x0
 800e078: d101         	bne	0x800e07e <z_impl_k_mutex_lock+0x2fe> @ imm = #0x2
; 		return 0;
 800e07a: 2300         	movs	r3, #0x0
 800e07c: e0b7         	b	0x800e1ee <z_impl_k_mutex_lock+0x46e> @ imm = #0x16e
; 	LOG_DBG("%p timeout on mutex %p", arch_current_thread(), mutex);
 800e07e: 2303         	movs	r3, #0x3
 800e080: 2b03         	cmp	r3, #0x3
 800e082: d922         	bls	0x800e0ca <z_impl_k_mutex_lock+0x34a> @ imm = #0x44
 800e084: 2301         	movs	r3, #0x1
 800e086: f887 30b3    	strb.w	r3, [r7, #0xb3]
 800e08a: f897 30b3    	ldrb.w	r3, [r7, #0xb3]
 800e08e: f083 0301    	eor	r3, r3, #0x1
 800e092: b2db         	uxtb	r3, r3
 800e094: 2b00         	cmp	r3, #0x0
 800e096: d118         	bne	0x800e0ca <z_impl_k_mutex_lock+0x34a> @ imm = #0x30
 800e098: 4b59         	ldr	r3, [pc, #0x164]        @ 0x800e200 <z_impl_k_mutex_lock+0x480>
 800e09a: 6819         	ldr	r1, [r3]
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800e09c: 4b59         	ldr	r3, [pc, #0x164]        @ 0x800e204 <z_impl_k_mutex_lock+0x484>
 800e09e: 689b         	ldr	r3, [r3, #0x8]
 800e0a0: 64fb         	str	r3, [r7, #0x4c]
; 	return ret;
 800e0a2: 6cfb         	ldr	r3, [r7, #0x4c]
; 	LOG_DBG("%p timeout on mutex %p", arch_current_thread(), mutex);
 800e0a4: 68fa         	ldr	r2, [r7, #0xc]
 800e0a6: 9205         	str	r2, [sp, #0x14]
 800e0a8: 9304         	str	r3, [sp, #0x10]
 800e0aa: 4b53         	ldr	r3, [pc, #0x14c]        @ 0x800e1f8 <z_impl_k_mutex_lock+0x478>
 800e0ac: 9303         	str	r3, [sp, #0xc]
 800e0ae: 4b56         	ldr	r3, [pc, #0x158]        @ 0x800e208 <z_impl_k_mutex_lock+0x488>
 800e0b0: 9302         	str	r3, [sp, #0x8]
 800e0b2: 2308         	movs	r3, #0x8
 800e0b4: 9301         	str	r3, [sp, #0x4]
 800e0b6: 2300         	movs	r3, #0x0
 800e0b8: 9300         	str	r3, [sp]
 800e0ba: 2300         	movs	r3, #0x0
 800e0bc: 2204         	movs	r2, #0x4
 800e0be: 2000         	movs	r0, #0x0
 800e0c0: f00d fffd    	bl	0x801c0be <z_log_msg_runtime_create> @ imm = #0xdffa
 800e0c4: 2300         	movs	r3, #0x0
 800e0c6: f8c7 30ac    	str.w	r3, [r7, #0xac]
 800e0ca: 4b50         	ldr	r3, [pc, #0x140]        @ 0x800e20c <z_impl_k_mutex_lock+0x48c>
 800e0cc: 64bb         	str	r3, [r7, #0x48]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800e0ce: f3ef 8311    	mrs	r3, basepri
 800e0d2: 647b         	str	r3, [r7, #0x44]
;   return(result);
 800e0d4: 6c7b         	ldr	r3, [r7, #0x44]
; 	key = __get_BASEPRI();
 800e0d6: 643b         	str	r3, [r7, #0x40]
 800e0d8: 2310         	movs	r3, #0x10
 800e0da: 63fb         	str	r3, [r7, #0x3c]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 800e0dc: 6bfb         	ldr	r3, [r7, #0x3c]
 800e0de: f383 8812    	msr	basepri_max, r3
; }
 800e0e2: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800e0e4: f3bf 8f6f    	isb	sy
; }
 800e0e8: bf00         	nop
; 	return key;
 800e0ea: 6c3b         	ldr	r3, [r7, #0x40]
; 	k.key = arch_irq_lock();
 800e0ec: 61fb         	str	r3, [r7, #0x1c]
 800e0ee: 6cbb         	ldr	r3, [r7, #0x48]
 800e0f0: 63bb         	str	r3, [r7, #0x38]
; }
 800e0f2: bf00         	nop
 800e0f4: 6cbb         	ldr	r3, [r7, #0x48]
 800e0f6: 637b         	str	r3, [r7, #0x34]
; }
 800e0f8: bf00         	nop
; 	return k;
 800e0fa: 69fb         	ldr	r3, [r7, #0x1c]
 800e0fc: 627b         	str	r3, [r7, #0x24]
; 	if (likely(mutex->owner != NULL)) {
 800e0fe: 68fb         	ldr	r3, [r7, #0xc]
 800e100: 689b         	ldr	r3, [r3, #0x8]
 800e102: 2b00         	cmp	r3, #0x0
 800e104: bf14         	ite	ne
 800e106: 2301         	movne	r3, #0x1
 800e108: 2300         	moveq	r3, #0x0
 800e10a: b2db         	uxtb	r3, r3
 800e10c: 2b00         	cmp	r3, #0x0
 800e10e: d052         	beq	0x800e1b6 <z_impl_k_mutex_lock+0x436> @ imm = #0xa4
; 		struct k_thread *waiter = z_waitq_head(&mutex->wait_q);
 800e110: 68fb         	ldr	r3, [r7, #0xc]
 800e112: 4618         	mov	r0, r3
 800e114: f00d ffc6    	bl	0x801c0a4 <z_waitq_head> @ imm = #0xdf8c
 800e118: f8c7 00a8    	str.w	r0, [r7, #0xa8]
; 			new_prio_for_inheritance(waiter->base.prio, mutex->owner_orig_prio) :
 800e11c: f8d7 30a8    	ldr.w	r3, [r7, #0xa8]
 800e120: 2b00         	cmp	r3, #0x0
 800e122: d00c         	beq	0x800e13e <z_impl_k_mutex_lock+0x3be> @ imm = #0x18
 800e124: f8d7 30a8    	ldr.w	r3, [r7, #0xa8]
 800e128: f993 300e    	ldrsb.w	r3, [r3, #0xe]
 800e12c: 461a         	mov	r2, r3
 800e12e: 68fb         	ldr	r3, [r7, #0xc]
 800e130: 691b         	ldr	r3, [r3, #0x10]
 800e132: 4619         	mov	r1, r3
 800e134: 4610         	mov	r0, r2
 800e136: f00d ffe0    	bl	0x801c0fa <new_prio_for_inheritance> @ imm = #0xdfc0
 800e13a: 4603         	mov	r3, r0
 800e13c: e001         	b	0x800e142 <z_impl_k_mutex_lock+0x3c2> @ imm = #0x2
 800e13e: 68fb         	ldr	r3, [r7, #0xc]
 800e140: 691b         	ldr	r3, [r3, #0x10]
; 		new_prio = (waiter != NULL) ?
 800e142: f8c7 30d0    	str.w	r3, [r7, #0xd0]
; 		LOG_DBG("adjusting prio down on mutex %p", mutex);
 800e146: 2303         	movs	r3, #0x3
 800e148: 2b03         	cmp	r3, #0x3
 800e14a: d91d         	bls	0x800e188 <z_impl_k_mutex_lock+0x408> @ imm = #0x3a
 800e14c: 2301         	movs	r3, #0x1
 800e14e: f887 30a7    	strb.w	r3, [r7, #0xa7]
 800e152: f897 30a7    	ldrb.w	r3, [r7, #0xa7]
 800e156: f083 0301    	eor	r3, r3, #0x1
 800e15a: b2db         	uxtb	r3, r3
 800e15c: 2b00         	cmp	r3, #0x0
 800e15e: d113         	bne	0x800e188 <z_impl_k_mutex_lock+0x408> @ imm = #0x26
 800e160: 4b27         	ldr	r3, [pc, #0x9c]         @ 0x800e200 <z_impl_k_mutex_lock+0x480>
 800e162: 6819         	ldr	r1, [r3]
 800e164: 68fb         	ldr	r3, [r7, #0xc]
 800e166: 9304         	str	r3, [sp, #0x10]
 800e168: 4b23         	ldr	r3, [pc, #0x8c]         @ 0x800e1f8 <z_impl_k_mutex_lock+0x478>
 800e16a: 9303         	str	r3, [sp, #0xc]
 800e16c: 4b28         	ldr	r3, [pc, #0xa0]         @ 0x800e210 <z_impl_k_mutex_lock+0x490>
 800e16e: 9302         	str	r3, [sp, #0x8]
 800e170: 2308         	movs	r3, #0x8
 800e172: 9301         	str	r3, [sp, #0x4]
 800e174: 2300         	movs	r3, #0x0
 800e176: 9300         	str	r3, [sp]
 800e178: 2300         	movs	r3, #0x0
 800e17a: 2204         	movs	r2, #0x4
 800e17c: 2000         	movs	r0, #0x0
 800e17e: f00d ff9e    	bl	0x801c0be <z_log_msg_runtime_create> @ imm = #0xdf3c
 800e182: 2300         	movs	r3, #0x0
 800e184: f8c7 30a0    	str.w	r3, [r7, #0xa0]
; 		resched = adjust_owner_prio(mutex, new_prio) || resched;
 800e188: f8d7 10d0    	ldr.w	r1, [r7, #0xd0]
 800e18c: 68f8         	ldr	r0, [r7, #0xc]
 800e18e: f7ff fda3    	bl	0x800dcd8 <adjust_owner_prio> @ imm = #-0x4ba
 800e192: 4603         	mov	r3, r0
 800e194: 2b00         	cmp	r3, #0x0
 800e196: d103         	bne	0x800e1a0 <z_impl_k_mutex_lock+0x420> @ imm = #0x6
 800e198: f897 30d7    	ldrb.w	r3, [r7, #0xd7]
 800e19c: 2b00         	cmp	r3, #0x0
 800e19e: d001         	beq	0x800e1a4 <z_impl_k_mutex_lock+0x424> @ imm = #0x2
 800e1a0: 2301         	movs	r3, #0x1
 800e1a2: e000         	b	0x800e1a6 <z_impl_k_mutex_lock+0x426> @ imm = #0x0
 800e1a4: 2300         	movs	r3, #0x0
 800e1a6: f887 30d7    	strb.w	r3, [r7, #0xd7]
 800e1aa: f897 30d7    	ldrb.w	r3, [r7, #0xd7]
 800e1ae: f003 0301    	and	r3, r3, #0x1
 800e1b2: f887 30d7    	strb.w	r3, [r7, #0xd7]
; 	if (resched) {
 800e1b6: f897 30d7    	ldrb.w	r3, [r7, #0xd7]
 800e1ba: 2b00         	cmp	r3, #0x0
 800e1bc: d004         	beq	0x800e1c8 <z_impl_k_mutex_lock+0x448> @ imm = #0x8
; 		z_reschedule(&lock, key);
 800e1be: 6a79         	ldr	r1, [r7, #0x24]
 800e1c0: 4812         	ldr	r0, [pc, #0x48]         @ 0x800e20c <z_impl_k_mutex_lock+0x48c>
 800e1c2: f00f f882    	bl	0x801d2ca <z_reschedule> @ imm = #0xf104
 800e1c6: e010         	b	0x800e1ea <z_impl_k_mutex_lock+0x46a> @ imm = #0x20
 800e1c8: 4b10         	ldr	r3, [pc, #0x40]         @ 0x800e20c <z_impl_k_mutex_lock+0x48c>
 800e1ca: 633b         	str	r3, [r7, #0x30]
 800e1cc: 6a7b         	ldr	r3, [r7, #0x24]
 800e1ce: 623b         	str	r3, [r7, #0x20]
; 	arch_irq_unlock(key.key);
 800e1d0: 6a3b         	ldr	r3, [r7, #0x20]
 800e1d2: 62fb         	str	r3, [r7, #0x2c]
 800e1d4: 6afb         	ldr	r3, [r7, #0x2c]
 800e1d6: 62bb         	str	r3, [r7, #0x28]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800e1d8: 6abb         	ldr	r3, [r7, #0x28]
 800e1da: f383 8811    	msr	basepri, r3
; }
 800e1de: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800e1e0: f3bf 8f6f    	isb	sy
; }
 800e1e4: bf00         	nop
; }
 800e1e6: bf00         	nop
; }
 800e1e8: bf00         	nop
; 	return -EAGAIN;
 800e1ea: f06f 030a    	mvn	r3, #0xa
; }
 800e1ee: 4618         	mov	r0, r3
 800e1f0: 37d8         	adds	r7, #0xd8
 800e1f2: 46bd         	mov	sp, r7
 800e1f4: bd80         	pop	{r7, pc}
 800e1f6: bf00         	nop

0800e1f8 <$d>:
 800e1f8: 08 07 02 08  	.word	0x08020708
 800e1fc: e8 f9 01 08  	.word	0x0801f9e8
 800e200: b0 05 00 20  	.word	0x200005b0
 800e204: f0 16 00 20  	.word	0x200016f0
 800e208: 08 fa 01 08  	.word	0x0801fa08
 800e20c: 68 1f 00 20  	.word	0x20001f68
 800e210: 24 fa 01 08  	.word	0x0801fa24

0800e214 <z_impl_k_mutex_unlock>:
; {
 800e214: b580         	push	{r7, lr}
 800e216: b0a4         	sub	sp, #0x90
 800e218: af08         	add	r7, sp, #0x20
 800e21a: 6078         	str	r0, [r7, #0x4]
; 	CHECKIF(mutex->owner == NULL) {
 800e21c: 687b         	ldr	r3, [r7, #0x4]
 800e21e: 689b         	ldr	r3, [r3, #0x8]
 800e220: 2b00         	cmp	r3, #0x0
 800e222: d102         	bne	0x800e22a <z_impl_k_mutex_unlock+0x16> @ imm = #0x4
; 		return -EINVAL;
 800e224: f06f 0315    	mvn	r3, #0x15
 800e228: e0dc         	b	0x800e3e4 <z_impl_k_mutex_unlock+0x1d0> @ imm = #0x1b8
; 	CHECKIF(mutex->owner != arch_current_thread()) {
 800e22a: 687b         	ldr	r3, [r7, #0x4]
 800e22c: 689a         	ldr	r2, [r3, #0x8]
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800e22e: 4b6f         	ldr	r3, [pc, #0x1bc]        @ 0x800e3ec <z_impl_k_mutex_unlock+0x1d8>
 800e230: 689b         	ldr	r3, [r3, #0x8]
 800e232: 65bb         	str	r3, [r7, #0x58]
; 	return ret;
 800e234: 6dbb         	ldr	r3, [r7, #0x58]
; 	CHECKIF(mutex->owner != arch_current_thread()) {
 800e236: 429a         	cmp	r2, r3
 800e238: d002         	beq	0x800e240 <z_impl_k_mutex_unlock+0x2c> @ imm = #0x4
; 		return -EPERM;
 800e23a: f04f 33ff    	mov.w	r3, #0xffffffff
 800e23e: e0d1         	b	0x800e3e4 <z_impl_k_mutex_unlock+0x1d0> @ imm = #0x1a2
; 	LOG_DBG("mutex %p lock_count: %d", mutex, mutex->lock_count);
 800e240: 2303         	movs	r3, #0x3
 800e242: 2b03         	cmp	r3, #0x3
 800e244: d91f         	bls	0x800e286 <z_impl_k_mutex_unlock+0x72> @ imm = #0x3e
 800e246: 2301         	movs	r3, #0x1
 800e248: f887 306f    	strb.w	r3, [r7, #0x6f]
 800e24c: f897 306f    	ldrb.w	r3, [r7, #0x6f]
 800e250: f083 0301    	eor	r3, r3, #0x1
 800e254: b2db         	uxtb	r3, r3
 800e256: 2b00         	cmp	r3, #0x0
 800e258: d115         	bne	0x800e286 <z_impl_k_mutex_unlock+0x72> @ imm = #0x2a
 800e25a: 4b65         	ldr	r3, [pc, #0x194]        @ 0x800e3f0 <z_impl_k_mutex_unlock+0x1dc>
 800e25c: 6819         	ldr	r1, [r3]
 800e25e: 687b         	ldr	r3, [r7, #0x4]
 800e260: 68db         	ldr	r3, [r3, #0xc]
 800e262: 9305         	str	r3, [sp, #0x14]
 800e264: 687b         	ldr	r3, [r7, #0x4]
 800e266: 9304         	str	r3, [sp, #0x10]
 800e268: 4b62         	ldr	r3, [pc, #0x188]        @ 0x800e3f4 <z_impl_k_mutex_unlock+0x1e0>
 800e26a: 9303         	str	r3, [sp, #0xc]
 800e26c: 4b62         	ldr	r3, [pc, #0x188]        @ 0x800e3f8 <z_impl_k_mutex_unlock+0x1e4>
 800e26e: 9302         	str	r3, [sp, #0x8]
 800e270: 2308         	movs	r3, #0x8
 800e272: 9301         	str	r3, [sp, #0x4]
 800e274: 2300         	movs	r3, #0x0
 800e276: 9300         	str	r3, [sp]
 800e278: 2300         	movs	r3, #0x0
 800e27a: 2204         	movs	r2, #0x4
 800e27c: 2000         	movs	r0, #0x0
 800e27e: f00d ff1e    	bl	0x801c0be <z_log_msg_runtime_create> @ imm = #0xde3c
 800e282: 2300         	movs	r3, #0x0
 800e284: 66bb         	str	r3, [r7, #0x68]
; 	if (mutex->lock_count > 1U) {
 800e286: 687b         	ldr	r3, [r7, #0x4]
 800e288: 68db         	ldr	r3, [r3, #0xc]
 800e28a: 2b01         	cmp	r3, #0x1
 800e28c: d905         	bls	0x800e29a <z_impl_k_mutex_unlock+0x86> @ imm = #0xa
; 		mutex->lock_count--;
 800e28e: 687b         	ldr	r3, [r7, #0x4]
 800e290: 68db         	ldr	r3, [r3, #0xc]
 800e292: 1e5a         	subs	r2, r3, #0x1
 800e294: 687b         	ldr	r3, [r7, #0x4]
 800e296: 60da         	str	r2, [r3, #0xc]
; 		goto k_mutex_unlock_return;
 800e298: e0a3         	b	0x800e3e2 <z_impl_k_mutex_unlock+0x1ce> @ imm = #0x146
 800e29a: 4b58         	ldr	r3, [pc, #0x160]        @ 0x800e3fc <z_impl_k_mutex_unlock+0x1e8>
 800e29c: 643b         	str	r3, [r7, #0x40]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800e29e: f3ef 8311    	mrs	r3, basepri
 800e2a2: 63fb         	str	r3, [r7, #0x3c]
;   return(result);
 800e2a4: 6bfb         	ldr	r3, [r7, #0x3c]
; 	key = __get_BASEPRI();
 800e2a6: 63bb         	str	r3, [r7, #0x38]
 800e2a8: 2310         	movs	r3, #0x10
 800e2aa: 637b         	str	r3, [r7, #0x34]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 800e2ac: 6b7b         	ldr	r3, [r7, #0x34]
 800e2ae: f383 8812    	msr	basepri_max, r3
; }
 800e2b2: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800e2b4: f3bf 8f6f    	isb	sy
; }
 800e2b8: bf00         	nop
; 	return key;
 800e2ba: 6bbb         	ldr	r3, [r7, #0x38]
; 	k.key = arch_irq_lock();
 800e2bc: 60fb         	str	r3, [r7, #0xc]
 800e2be: 6c3b         	ldr	r3, [r7, #0x40]
 800e2c0: 633b         	str	r3, [r7, #0x30]
; }
 800e2c2: bf00         	nop
 800e2c4: 6c3b         	ldr	r3, [r7, #0x40]
 800e2c6: 62fb         	str	r3, [r7, #0x2c]
; }
 800e2c8: bf00         	nop
; 	return k;
 800e2ca: 68fb         	ldr	r3, [r7, #0xc]
 800e2cc: 617b         	str	r3, [r7, #0x14]
; 	adjust_owner_prio(mutex, mutex->owner_orig_prio);
 800e2ce: 687b         	ldr	r3, [r7, #0x4]
 800e2d0: 691b         	ldr	r3, [r3, #0x10]
 800e2d2: 4619         	mov	r1, r3
 800e2d4: 6878         	ldr	r0, [r7, #0x4]
 800e2d6: f7ff fcff    	bl	0x800dcd8 <adjust_owner_prio> @ imm = #-0x602
; 	new_owner = z_unpend_first_thread(&mutex->wait_q);
 800e2da: 687b         	ldr	r3, [r7, #0x4]
 800e2dc: 657b         	str	r3, [r7, #0x54]
; 	struct k_thread *thread = NULL;
 800e2de: 2300         	movs	r3, #0x0
 800e2e0: 653b         	str	r3, [r7, #0x50]
; 		thread = _priq_wait_best(&wait_q->waitq);
 800e2e2: 6d7b         	ldr	r3, [r7, #0x54]
 800e2e4: 64fb         	str	r3, [r7, #0x4c]
; 	struct k_thread *thread = NULL;
 800e2e6: 2300         	movs	r3, #0x0
 800e2e8: 64bb         	str	r3, [r7, #0x48]
; 	sys_dnode_t *n = sys_dlist_peek_head(pq);
 800e2ea: 6cf8         	ldr	r0, [r7, #0x4c]
 800e2ec: f00d fdd3    	bl	0x801be96 <sys_dlist_peek_head> @ imm = #0xdba6
 800e2f0: 6478         	str	r0, [r7, #0x44]
; 	if (n != NULL) {
 800e2f2: 6c7b         	ldr	r3, [r7, #0x44]
 800e2f4: 2b00         	cmp	r3, #0x0
 800e2f6: d001         	beq	0x800e2fc <z_impl_k_mutex_unlock+0xe8> @ imm = #0x2
; 		thread = CONTAINER_OF(n, struct k_thread, base.qnode_dlist);
 800e2f8: 6c7b         	ldr	r3, [r7, #0x44]
 800e2fa: 64bb         	str	r3, [r7, #0x48]
; 	return thread;
 800e2fc: 6cbb         	ldr	r3, [r7, #0x48]
; 		thread = _priq_wait_best(&wait_q->waitq);
 800e2fe: 653b         	str	r3, [r7, #0x50]
; 		if (unlikely(thread != NULL)) {
 800e300: 6d3b         	ldr	r3, [r7, #0x50]
 800e302: 2b00         	cmp	r3, #0x0
 800e304: bf14         	ite	ne
 800e306: 2301         	movne	r3, #0x1
 800e308: 2300         	moveq	r3, #0x0
 800e30a: b2db         	uxtb	r3, r3
 800e30c: 2b00         	cmp	r3, #0x0
 800e30e: d005         	beq	0x800e31c <z_impl_k_mutex_unlock+0x108> @ imm = #0xa
; 			unpend_thread_no_timeout(thread);
 800e310: 6d38         	ldr	r0, [r7, #0x50]
 800e312: f00d fead    	bl	0x801c070 <unpend_thread_no_timeout> @ imm = #0xdd5a
; 			(void)z_abort_thread_timeout(thread);
 800e316: 6d38         	ldr	r0, [r7, #0x50]
 800e318: f00d fdfe    	bl	0x801bf18 <z_abort_thread_timeout> @ imm = #0xdbfc
; 	return thread;
 800e31c: 6d3b         	ldr	r3, [r7, #0x50]
; 	new_owner = z_unpend_first_thread(&mutex->wait_q);
 800e31e: 667b         	str	r3, [r7, #0x64]
; 	mutex->owner = new_owner;
 800e320: 687b         	ldr	r3, [r7, #0x4]
 800e322: 6e7a         	ldr	r2, [r7, #0x64]
 800e324: 609a         	str	r2, [r3, #0x8]
; 	LOG_DBG("new owner of mutex %p: %p (prio: %d)",
 800e326: 2303         	movs	r3, #0x3
 800e328: 2b03         	cmp	r3, #0x3
 800e32a: d927         	bls	0x800e37c <z_impl_k_mutex_unlock+0x168> @ imm = #0x4e
 800e32c: 2301         	movs	r3, #0x1
 800e32e: f887 3063    	strb.w	r3, [r7, #0x63]
 800e332: f897 3063    	ldrb.w	r3, [r7, #0x63]
 800e336: f083 0301    	eor	r3, r3, #0x1
 800e33a: b2db         	uxtb	r3, r3
 800e33c: 2b00         	cmp	r3, #0x0
 800e33e: d11d         	bne	0x800e37c <z_impl_k_mutex_unlock+0x168> @ imm = #0x3a
 800e340: 4b2b         	ldr	r3, [pc, #0xac]         @ 0x800e3f0 <z_impl_k_mutex_unlock+0x1dc>
 800e342: 6819         	ldr	r1, [r3]
 800e344: 6e7b         	ldr	r3, [r7, #0x64]
 800e346: 2b00         	cmp	r3, #0x0
 800e348: d003         	beq	0x800e352 <z_impl_k_mutex_unlock+0x13e> @ imm = #0x6
 800e34a: 6e7b         	ldr	r3, [r7, #0x64]
 800e34c: f993 300e    	ldrsb.w	r3, [r3, #0xe]
 800e350: e000         	b	0x800e354 <z_impl_k_mutex_unlock+0x140> @ imm = #0x0
 800e352: 4b2b         	ldr	r3, [pc, #0xac]         @ 0x800e400 <z_impl_k_mutex_unlock+0x1ec>
 800e354: 9306         	str	r3, [sp, #0x18]
 800e356: 6e7b         	ldr	r3, [r7, #0x64]
 800e358: 9305         	str	r3, [sp, #0x14]
 800e35a: 687b         	ldr	r3, [r7, #0x4]
 800e35c: 9304         	str	r3, [sp, #0x10]
 800e35e: 4b25         	ldr	r3, [pc, #0x94]         @ 0x800e3f4 <z_impl_k_mutex_unlock+0x1e0>
 800e360: 9303         	str	r3, [sp, #0xc]
 800e362: 4b28         	ldr	r3, [pc, #0xa0]         @ 0x800e404 <z_impl_k_mutex_unlock+0x1f0>
 800e364: 9302         	str	r3, [sp, #0x8]
 800e366: 2308         	movs	r3, #0x8
 800e368: 9301         	str	r3, [sp, #0x4]
 800e36a: 2300         	movs	r3, #0x0
 800e36c: 9300         	str	r3, [sp]
 800e36e: 2300         	movs	r3, #0x0
 800e370: 2204         	movs	r2, #0x4
 800e372: 2000         	movs	r0, #0x0
 800e374: f00d fea3    	bl	0x801c0be <z_log_msg_runtime_create> @ imm = #0xdd46
 800e378: 2300         	movs	r3, #0x0
 800e37a: 65fb         	str	r3, [r7, #0x5c]
; 	if (unlikely(new_owner != NULL)) {
 800e37c: 6e7b         	ldr	r3, [r7, #0x64]
 800e37e: 2b00         	cmp	r3, #0x0
 800e380: bf14         	ite	ne
 800e382: 2301         	movne	r3, #0x1
 800e384: 2300         	moveq	r3, #0x0
 800e386: b2db         	uxtb	r3, r3
 800e388: 2b00         	cmp	r3, #0x0
 800e38a: d016         	beq	0x800e3ba <z_impl_k_mutex_unlock+0x1a6> @ imm = #0x2c
; 		mutex->owner_orig_prio = new_owner->base.prio;
 800e38c: 6e7b         	ldr	r3, [r7, #0x64]
 800e38e: f993 300e    	ldrsb.w	r3, [r3, #0xe]
 800e392: 461a         	mov	r2, r3
 800e394: 687b         	ldr	r3, [r7, #0x4]
 800e396: 611a         	str	r2, [r3, #0x10]
 800e398: 6e7b         	ldr	r3, [r7, #0x64]
 800e39a: 62bb         	str	r3, [r7, #0x28]
 800e39c: 2300         	movs	r3, #0x0
 800e39e: 627b         	str	r3, [r7, #0x24]
; 	thread->arch.swap_return_value = value;
 800e3a0: 6abb         	ldr	r3, [r7, #0x28]
 800e3a2: 6a7a         	ldr	r2, [r7, #0x24]
 800e3a4: f8c3 20cc    	str.w	r2, [r3, #0xcc]
; }
 800e3a8: bf00         	nop
; 		z_ready_thread(new_owner);
 800e3aa: 6e78         	ldr	r0, [r7, #0x64]
 800e3ac: f000 ffd6    	bl	0x800f35c <z_ready_thread> @ imm = #0xfac
; 		z_reschedule(&lock, key);
 800e3b0: 6979         	ldr	r1, [r7, #0x14]
 800e3b2: 4812         	ldr	r0, [pc, #0x48]         @ 0x800e3fc <z_impl_k_mutex_unlock+0x1e8>
 800e3b4: f00e ff89    	bl	0x801d2ca <z_reschedule> @ imm = #0xef12
 800e3b8: e013         	b	0x800e3e2 <z_impl_k_mutex_unlock+0x1ce> @ imm = #0x26
; 		mutex->lock_count = 0U;
 800e3ba: 687b         	ldr	r3, [r7, #0x4]
 800e3bc: 2200         	movs	r2, #0x0
 800e3be: 60da         	str	r2, [r3, #0xc]
 800e3c0: 4b0e         	ldr	r3, [pc, #0x38]         @ 0x800e3fc <z_impl_k_mutex_unlock+0x1e8>
 800e3c2: 623b         	str	r3, [r7, #0x20]
 800e3c4: 697b         	ldr	r3, [r7, #0x14]
 800e3c6: 613b         	str	r3, [r7, #0x10]
; 	arch_irq_unlock(key.key);
 800e3c8: 693b         	ldr	r3, [r7, #0x10]
 800e3ca: 61fb         	str	r3, [r7, #0x1c]
 800e3cc: 69fb         	ldr	r3, [r7, #0x1c]
 800e3ce: 61bb         	str	r3, [r7, #0x18]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800e3d0: 69bb         	ldr	r3, [r7, #0x18]
 800e3d2: f383 8811    	msr	basepri, r3
; }
 800e3d6: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800e3d8: f3bf 8f6f    	isb	sy
; }
 800e3dc: bf00         	nop
; }
 800e3de: bf00         	nop
; }
 800e3e0: bf00         	nop
; 	return 0;
 800e3e2: 2300         	movs	r3, #0x0
; }
 800e3e4: 4618         	mov	r0, r3
 800e3e6: 3770         	adds	r7, #0x70
 800e3e8: 46bd         	mov	sp, r7
 800e3ea: bd80         	pop	{r7, pc}

0800e3ec <$d>:
 800e3ec: f0 16 00 20  	.word	0x200016f0
 800e3f0: b0 05 00 20  	.word	0x200005b0
 800e3f4: 1c 07 02 08  	.word	0x0802071c
 800e3f8: 48 fa 01 08  	.word	0x0801fa48
 800e3fc: 68 1f 00 20  	.word	0x20001f68
 800e400: 18 fc ff ff  	.word	0xfffffc18
 800e404: 64 fa 01 08  	.word	0x0801fa64

0800e408 <z_impl_k_sem_give>:
; {
 800e408: b580         	push	{r7, lr}
 800e40a: b098         	sub	sp, #0x60
 800e40c: af00         	add	r7, sp, #0x0
 800e40e: 6078         	str	r0, [r7, #0x4]
 800e410: 4b43         	ldr	r3, [pc, #0x10c]        @ 0x800e520 <z_impl_k_sem_give+0x118>
 800e412: 643b         	str	r3, [r7, #0x40]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800e414: f3ef 8311    	mrs	r3, basepri
 800e418: 63fb         	str	r3, [r7, #0x3c]
;   return(result);
 800e41a: 6bfb         	ldr	r3, [r7, #0x3c]
; 	key = __get_BASEPRI();
 800e41c: 63bb         	str	r3, [r7, #0x38]
 800e41e: 2310         	movs	r3, #0x10
 800e420: 637b         	str	r3, [r7, #0x34]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 800e422: 6b7b         	ldr	r3, [r7, #0x34]
 800e424: f383 8812    	msr	basepri_max, r3
; }
 800e428: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800e42a: f3bf 8f6f    	isb	sy
; }
 800e42e: bf00         	nop
; 	return key;
 800e430: 6bbb         	ldr	r3, [r7, #0x38]
; 	k.key = arch_irq_lock();
 800e432: 60fb         	str	r3, [r7, #0xc]
 800e434: 6c3b         	ldr	r3, [r7, #0x40]
 800e436: 633b         	str	r3, [r7, #0x30]
; }
 800e438: bf00         	nop
 800e43a: 6c3b         	ldr	r3, [r7, #0x40]
 800e43c: 62fb         	str	r3, [r7, #0x2c]
; }
 800e43e: bf00         	nop
; 	return k;
 800e440: 68fb         	ldr	r3, [r7, #0xc]
 800e442: 617b         	str	r3, [r7, #0x14]
; 	bool resched = true;
 800e444: 2301         	movs	r3, #0x1
 800e446: f887 305f    	strb.w	r3, [r7, #0x5f]
; 	thread = z_unpend_first_thread(&sem->wait_q);
 800e44a: 687b         	ldr	r3, [r7, #0x4]
 800e44c: 657b         	str	r3, [r7, #0x54]
; 	struct k_thread *thread = NULL;
 800e44e: 2300         	movs	r3, #0x0
 800e450: 653b         	str	r3, [r7, #0x50]
; 		thread = _priq_wait_best(&wait_q->waitq);
 800e452: 6d7b         	ldr	r3, [r7, #0x54]
 800e454: 64fb         	str	r3, [r7, #0x4c]
; 	struct k_thread *thread = NULL;
 800e456: 2300         	movs	r3, #0x0
 800e458: 64bb         	str	r3, [r7, #0x48]
; 	sys_dnode_t *n = sys_dlist_peek_head(pq);
 800e45a: 6cf8         	ldr	r0, [r7, #0x4c]
 800e45c: f00d fe95    	bl	0x801c18a <sys_dlist_peek_head> @ imm = #0xdd2a
 800e460: 6478         	str	r0, [r7, #0x44]
; 	if (n != NULL) {
 800e462: 6c7b         	ldr	r3, [r7, #0x44]
 800e464: 2b00         	cmp	r3, #0x0
 800e466: d001         	beq	0x800e46c <z_impl_k_sem_give+0x64> @ imm = #0x2
; 		thread = CONTAINER_OF(n, struct k_thread, base.qnode_dlist);
 800e468: 6c7b         	ldr	r3, [r7, #0x44]
 800e46a: 64bb         	str	r3, [r7, #0x48]
; 	return thread;
 800e46c: 6cbb         	ldr	r3, [r7, #0x48]
; 		thread = _priq_wait_best(&wait_q->waitq);
 800e46e: 653b         	str	r3, [r7, #0x50]
; 		if (unlikely(thread != NULL)) {
 800e470: 6d3b         	ldr	r3, [r7, #0x50]
 800e472: 2b00         	cmp	r3, #0x0
 800e474: bf14         	ite	ne
 800e476: 2301         	movne	r3, #0x1
 800e478: 2300         	moveq	r3, #0x0
 800e47a: b2db         	uxtb	r3, r3
 800e47c: 2b00         	cmp	r3, #0x0
 800e47e: d005         	beq	0x800e48c <z_impl_k_sem_give+0x84> @ imm = #0xa
; 			unpend_thread_no_timeout(thread);
 800e480: 6d38         	ldr	r0, [r7, #0x50]
 800e482: f00d fede    	bl	0x801c242 <unpend_thread_no_timeout> @ imm = #0xddbc
; 			(void)z_abort_thread_timeout(thread);
 800e486: 6d38         	ldr	r0, [r7, #0x50]
 800e488: f00d feb1    	bl	0x801c1ee <z_abort_thread_timeout> @ imm = #0xdd62
; 	return thread;
 800e48c: 6d3b         	ldr	r3, [r7, #0x50]
; 	thread = z_unpend_first_thread(&sem->wait_q);
 800e48e: 65bb         	str	r3, [r7, #0x58]
; 	if (unlikely(thread != NULL)) {
 800e490: 6dbb         	ldr	r3, [r7, #0x58]
 800e492: 2b00         	cmp	r3, #0x0
 800e494: bf14         	ite	ne
 800e496: 2301         	movne	r3, #0x1
 800e498: 2300         	moveq	r3, #0x0
 800e49a: b2db         	uxtb	r3, r3
 800e49c: 2b00         	cmp	r3, #0x0
 800e49e: d00c         	beq	0x800e4ba <z_impl_k_sem_give+0xb2> @ imm = #0x18
 800e4a0: 6dbb         	ldr	r3, [r7, #0x58]
 800e4a2: 62bb         	str	r3, [r7, #0x28]
 800e4a4: 2300         	movs	r3, #0x0
 800e4a6: 627b         	str	r3, [r7, #0x24]
; 	thread->arch.swap_return_value = value;
 800e4a8: 6abb         	ldr	r3, [r7, #0x28]
 800e4aa: 6a7a         	ldr	r2, [r7, #0x24]
 800e4ac: f8c3 20cc    	str.w	r2, [r3, #0xcc]
; }
 800e4b0: bf00         	nop
; 		z_ready_thread(thread);
 800e4b2: 6db8         	ldr	r0, [r7, #0x58]
 800e4b4: f000 ff52    	bl	0x800f35c <z_ready_thread> @ imm = #0xea4
 800e4b8: e013         	b	0x800e4e2 <z_impl_k_sem_give+0xda> @ imm = #0x26
; 		sem->count += (sem->count != sem->limit) ? 1U : 0U;
 800e4ba: 687b         	ldr	r3, [r7, #0x4]
 800e4bc: 689b         	ldr	r3, [r3, #0x8]
 800e4be: 687a         	ldr	r2, [r7, #0x4]
 800e4c0: 6891         	ldr	r1, [r2, #0x8]
 800e4c2: 687a         	ldr	r2, [r7, #0x4]
 800e4c4: 68d2         	ldr	r2, [r2, #0xc]
 800e4c6: 4291         	cmp	r1, r2
 800e4c8: d001         	beq	0x800e4ce <z_impl_k_sem_give+0xc6> @ imm = #0x2
 800e4ca: 2201         	movs	r2, #0x1
 800e4cc: e000         	b	0x800e4d0 <z_impl_k_sem_give+0xc8> @ imm = #0x0
 800e4ce: 2200         	movs	r2, #0x0
 800e4d0: 441a         	add	r2, r3
 800e4d2: 687b         	ldr	r3, [r7, #0x4]
 800e4d4: 609a         	str	r2, [r3, #0x8]
; 		resched = handle_poll_events(sem);
 800e4d6: 6878         	ldr	r0, [r7, #0x4]
 800e4d8: f00d feef    	bl	0x801c2ba <handle_poll_events> @ imm = #0xddde
 800e4dc: 4603         	mov	r3, r0
 800e4de: f887 305f    	strb.w	r3, [r7, #0x5f]
; 	if (unlikely(resched)) {
 800e4e2: f897 305f    	ldrb.w	r3, [r7, #0x5f]
 800e4e6: 2b00         	cmp	r3, #0x0
 800e4e8: d004         	beq	0x800e4f4 <z_impl_k_sem_give+0xec> @ imm = #0x8
; 		z_reschedule(&lock, key);
 800e4ea: 6979         	ldr	r1, [r7, #0x14]
 800e4ec: 480c         	ldr	r0, [pc, #0x30]         @ 0x800e520 <z_impl_k_sem_give+0x118>
 800e4ee: f00e feec    	bl	0x801d2ca <z_reschedule> @ imm = #0xedd8
; }
 800e4f2: e010         	b	0x800e516 <z_impl_k_sem_give+0x10e> @ imm = #0x20
 800e4f4: 4b0a         	ldr	r3, [pc, #0x28]         @ 0x800e520 <z_impl_k_sem_give+0x118>
 800e4f6: 623b         	str	r3, [r7, #0x20]
 800e4f8: 697b         	ldr	r3, [r7, #0x14]
 800e4fa: 613b         	str	r3, [r7, #0x10]
; 	arch_irq_unlock(key.key);
 800e4fc: 693b         	ldr	r3, [r7, #0x10]
 800e4fe: 61fb         	str	r3, [r7, #0x1c]
 800e500: 69fb         	ldr	r3, [r7, #0x1c]
 800e502: 61bb         	str	r3, [r7, #0x18]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800e504: 69bb         	ldr	r3, [r7, #0x18]
 800e506: f383 8811    	msr	basepri, r3
; }
 800e50a: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800e50c: f3bf 8f6f    	isb	sy
; }
 800e510: bf00         	nop
; }
 800e512: bf00         	nop
; }
 800e514: bf00         	nop
; }
 800e516: bf00         	nop
 800e518: 3760         	adds	r7, #0x60
 800e51a: 46bd         	mov	sp, r7
 800e51c: bd80         	pop	{r7, pc}
 800e51e: bf00         	nop

0800e520 <$d>:
 800e520: 68 1f 00 20  	.word	0x20001f68

0800e524 <z_impl_k_sem_take>:
; {
 800e524: b580         	push	{r7, lr}
 800e526: b098         	sub	sp, #0x60
 800e528: af02         	add	r7, sp, #0x8
 800e52a: 60f8         	str	r0, [r7, #0xc]
 800e52c: e9c7 2300    	strd	r2, r3, [r7]
 800e530: 4b35         	ldr	r3, [pc, #0xd4]         @ 0x800e608 <z_impl_k_sem_take+0xe4>
 800e532: 653b         	str	r3, [r7, #0x50]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800e534: f3ef 8311    	mrs	r3, basepri
 800e538: 64fb         	str	r3, [r7, #0x4c]
;   return(result);
 800e53a: 6cfb         	ldr	r3, [r7, #0x4c]
; 	key = __get_BASEPRI();
 800e53c: 64bb         	str	r3, [r7, #0x48]
 800e53e: 2310         	movs	r3, #0x10
 800e540: 647b         	str	r3, [r7, #0x44]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 800e542: 6c7b         	ldr	r3, [r7, #0x44]
 800e544: f383 8812    	msr	basepri_max, r3
; }
 800e548: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800e54a: f3bf 8f6f    	isb	sy
; }
 800e54e: bf00         	nop
; 	return key;
 800e550: 6cbb         	ldr	r3, [r7, #0x48]
; 	k.key = arch_irq_lock();
 800e552: 61bb         	str	r3, [r7, #0x18]
 800e554: 6d3b         	ldr	r3, [r7, #0x50]
 800e556: 643b         	str	r3, [r7, #0x40]
; }
 800e558: bf00         	nop
 800e55a: 6d3b         	ldr	r3, [r7, #0x50]
 800e55c: 63fb         	str	r3, [r7, #0x3c]
; }
 800e55e: bf00         	nop
; 	return k;
 800e560: 69bb         	ldr	r3, [r7, #0x18]
 800e562: 623b         	str	r3, [r7, #0x20]
; 	if (likely(sem->count > 0U)) {
 800e564: 68fb         	ldr	r3, [r7, #0xc]
 800e566: 689b         	ldr	r3, [r3, #0x8]
 800e568: 2b00         	cmp	r3, #0x0
 800e56a: bf14         	ite	ne
 800e56c: 2301         	movne	r3, #0x1
 800e56e: 2300         	moveq	r3, #0x0
 800e570: b2db         	uxtb	r3, r3
 800e572: 2b00         	cmp	r3, #0x0
 800e574: d018         	beq	0x800e5a8 <z_impl_k_sem_take+0x84> @ imm = #0x30
; 		sem->count--;
 800e576: 68fb         	ldr	r3, [r7, #0xc]
 800e578: 689b         	ldr	r3, [r3, #0x8]
 800e57a: 1e5a         	subs	r2, r3, #0x1
 800e57c: 68fb         	ldr	r3, [r7, #0xc]
 800e57e: 609a         	str	r2, [r3, #0x8]
 800e580: 4b21         	ldr	r3, [pc, #0x84]         @ 0x800e608 <z_impl_k_sem_take+0xe4>
 800e582: 63bb         	str	r3, [r7, #0x38]
 800e584: 6a3b         	ldr	r3, [r7, #0x20]
 800e586: 61fb         	str	r3, [r7, #0x1c]
; 	arch_irq_unlock(key.key);
 800e588: 69fb         	ldr	r3, [r7, #0x1c]
 800e58a: 637b         	str	r3, [r7, #0x34]
 800e58c: 6b7b         	ldr	r3, [r7, #0x34]
 800e58e: 633b         	str	r3, [r7, #0x30]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800e590: 6b3b         	ldr	r3, [r7, #0x30]
 800e592: f383 8811    	msr	basepri, r3
; }
 800e596: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800e598: f3bf 8f6f    	isb	sy
; }
 800e59c: bf00         	nop
; }
 800e59e: bf00         	nop
; }
 800e5a0: bf00         	nop
; 		ret = 0;
 800e5a2: 2300         	movs	r3, #0x0
 800e5a4: 657b         	str	r3, [r7, #0x54]
; 		goto out;
 800e5a6: e029         	b	0x800e5fc <z_impl_k_sem_take+0xd8> @ imm = #0x52
; 	if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
 800e5a8: e9d7 2300    	ldrd	r2, r3, [r7]
 800e5ac: f04f 0000    	mov.w	r0, #0x0
 800e5b0: f04f 0100    	mov.w	r1, #0x0
 800e5b4: 428b         	cmp	r3, r1
 800e5b6: bf08         	it	eq
 800e5b8: 4282         	cmpeq	r2, r0
 800e5ba: d114         	bne	0x800e5e6 <z_impl_k_sem_take+0xc2> @ imm = #0x28
 800e5bc: 4b12         	ldr	r3, [pc, #0x48]         @ 0x800e608 <z_impl_k_sem_take+0xe4>
 800e5be: 62fb         	str	r3, [r7, #0x2c]
 800e5c0: 6a3b         	ldr	r3, [r7, #0x20]
 800e5c2: 617b         	str	r3, [r7, #0x14]
; 	arch_irq_unlock(key.key);
 800e5c4: 697b         	ldr	r3, [r7, #0x14]
 800e5c6: 62bb         	str	r3, [r7, #0x28]
 800e5c8: 6abb         	ldr	r3, [r7, #0x28]
 800e5ca: 627b         	str	r3, [r7, #0x24]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800e5cc: 6a7b         	ldr	r3, [r7, #0x24]
 800e5ce: f383 8811    	msr	basepri, r3
; }
 800e5d2: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800e5d4: f3bf 8f6f    	isb	sy
; }
 800e5d8: bf00         	nop
; }
 800e5da: bf00         	nop
; }
 800e5dc: bf00         	nop
; 		ret = -EBUSY;
 800e5de: f06f 030f    	mvn	r3, #0xf
 800e5e2: 657b         	str	r3, [r7, #0x54]
 800e5e4: e00a         	b	0x800e5fc <z_impl_k_sem_take+0xd8> @ imm = #0x14
; 	ret = z_pend_curr(&lock, key, &sem->wait_q, timeout);
 800e5e6: 68f9         	ldr	r1, [r7, #0xc]
 800e5e8: e9d7 2300    	ldrd	r2, r3, [r7]
 800e5ec: e9cd 2300    	strd	r2, r3, [sp]
 800e5f0: 460a         	mov	r2, r1
 800e5f2: 6a39         	ldr	r1, [r7, #0x20]
 800e5f4: 4804         	ldr	r0, [pc, #0x10]         @ 0x800e608 <z_impl_k_sem_take+0xe4>
 800e5f6: f001 fa6d    	bl	0x800fad4 <z_pend_curr> @ imm = #0x14da
 800e5fa: 6578         	str	r0, [r7, #0x54]
; 	return ret;
 800e5fc: 6d7b         	ldr	r3, [r7, #0x54]
; }
 800e5fe: 4618         	mov	r0, r3
 800e600: 3758         	adds	r7, #0x58
 800e602: 46bd         	mov	sp, r7
 800e604: bd80         	pop	{r7, pc}
 800e606: bf00         	nop

0800e608 <$d>:
 800e608: 68 1f 00 20  	.word	0x20001f68

0800e60c <finalize_cancel_locked>:
; {
 800e60c: b580         	push	{r7, lr}
 800e60e: b086         	sub	sp, #0x18
 800e610: af00         	add	r7, sp, #0x0
 800e612: 6078         	str	r0, [r7, #0x4]
; 	sys_snode_t *prev = NULL;
 800e614: 2300         	movs	r3, #0x0
 800e616: 60fb         	str	r3, [r7, #0xc]
; 	flag_clear(&work->flags, K_WORK_CANCELING_BIT);
 800e618: 687b         	ldr	r3, [r7, #0x4]
 800e61a: 330c         	adds	r3, #0xc
 800e61c: 2101         	movs	r1, #0x1
 800e61e: 4618         	mov	r0, r3
 800e620: f00e f83c    	bl	0x801c69c <flag_clear>  @ imm = #0xe078
; 	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&pending_cancels, wc, tmp, node) {
 800e624: 4829         	ldr	r0, [pc, #0xa4]         @ 0x800e6cc <finalize_cancel_locked+0xc0>
 800e626: f00d feb1    	bl	0x801c38c <sys_slist_peek_head> @ imm = #0xdd62
 800e62a: 4603         	mov	r3, r0
 800e62c: 2b00         	cmp	r3, #0x0
 800e62e: d004         	beq	0x800e63a <finalize_cancel_locked+0x2e> @ imm = #0x8
 800e630: 4826         	ldr	r0, [pc, #0x98]         @ 0x800e6cc <finalize_cancel_locked+0xc0>
 800e632: f00d feab    	bl	0x801c38c <sys_slist_peek_head> @ imm = #0xdd56
 800e636: 4603         	mov	r3, r0
 800e638: e000         	b	0x800e63c <finalize_cancel_locked+0x30> @ imm = #0x0
 800e63a: 2300         	movs	r3, #0x0
 800e63c: 617b         	str	r3, [r7, #0x14]
 800e63e: 697b         	ldr	r3, [r7, #0x14]
 800e640: 2b00         	cmp	r3, #0x0
 800e642: d00e         	beq	0x800e662 <finalize_cancel_locked+0x56> @ imm = #0x1c
 800e644: 697b         	ldr	r3, [r7, #0x14]
 800e646: 4618         	mov	r0, r3
 800e648: f00d fed3    	bl	0x801c3f2 <sys_slist_peek_next> @ imm = #0xdda6
 800e64c: 4603         	mov	r3, r0
 800e64e: 2b00         	cmp	r3, #0x0
 800e650: d005         	beq	0x800e65e <finalize_cancel_locked+0x52> @ imm = #0xa
 800e652: 697b         	ldr	r3, [r7, #0x14]
 800e654: 4618         	mov	r0, r3
 800e656: f00d fecc    	bl	0x801c3f2 <sys_slist_peek_next> @ imm = #0xdd98
 800e65a: 4603         	mov	r3, r0
 800e65c: e002         	b	0x800e664 <finalize_cancel_locked+0x58> @ imm = #0x4
 800e65e: 2300         	movs	r3, #0x0
 800e660: e000         	b	0x800e664 <finalize_cancel_locked+0x58> @ imm = #0x0
 800e662: 2300         	movs	r3, #0x0
 800e664: 613b         	str	r3, [r7, #0x10]
 800e666: e028         	b	0x800e6ba <finalize_cancel_locked+0xae> @ imm = #0x50
; 		if (wc->work == work) {
 800e668: 697b         	ldr	r3, [r7, #0x14]
 800e66a: 685b         	ldr	r3, [r3, #0x4]
 800e66c: 687a         	ldr	r2, [r7, #0x4]
 800e66e: 429a         	cmp	r2, r3
 800e670: d10b         	bne	0x800e68a <finalize_cancel_locked+0x7e> @ imm = #0x16
; 			sys_slist_remove(&pending_cancels, prev, &wc->node);
 800e672: 697b         	ldr	r3, [r7, #0x14]
 800e674: 461a         	mov	r2, r3
 800e676: 68f9         	ldr	r1, [r7, #0xc]
 800e678: 4814         	ldr	r0, [pc, #0x50]         @ 0x800e6cc <finalize_cancel_locked+0xc0>
 800e67a: f00d ff2a    	bl	0x801c4d2 <sys_slist_remove> @ imm = #0xde54
; 			k_sem_give(&wc->sem);
 800e67e: 697b         	ldr	r3, [r7, #0x14]
 800e680: 3308         	adds	r3, #0x8
 800e682: 4618         	mov	r0, r3
 800e684: f00d ffcf    	bl	0x801c626 <k_sem_give>  @ imm = #0xdf9e
; 			break;
 800e688: e01b         	b	0x800e6c2 <finalize_cancel_locked+0xb6> @ imm = #0x36
; 		prev = &wc->node;
 800e68a: 697b         	ldr	r3, [r7, #0x14]
 800e68c: 60fb         	str	r3, [r7, #0xc]
; 	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&pending_cancels, wc, tmp, node) {
 800e68e: 693b         	ldr	r3, [r7, #0x10]
 800e690: 617b         	str	r3, [r7, #0x14]
 800e692: 697b         	ldr	r3, [r7, #0x14]
 800e694: 2b00         	cmp	r3, #0x0
 800e696: d00e         	beq	0x800e6b6 <finalize_cancel_locked+0xaa> @ imm = #0x1c
 800e698: 697b         	ldr	r3, [r7, #0x14]
 800e69a: 4618         	mov	r0, r3
 800e69c: f00d fea9    	bl	0x801c3f2 <sys_slist_peek_next> @ imm = #0xdd52
 800e6a0: 4603         	mov	r3, r0
 800e6a2: 2b00         	cmp	r3, #0x0
 800e6a4: d005         	beq	0x800e6b2 <finalize_cancel_locked+0xa6> @ imm = #0xa
 800e6a6: 697b         	ldr	r3, [r7, #0x14]
 800e6a8: 4618         	mov	r0, r3
 800e6aa: f00d fea2    	bl	0x801c3f2 <sys_slist_peek_next> @ imm = #0xdd44
 800e6ae: 4603         	mov	r3, r0
 800e6b0: e002         	b	0x800e6b8 <finalize_cancel_locked+0xac> @ imm = #0x4
 800e6b2: 2300         	movs	r3, #0x0
 800e6b4: e000         	b	0x800e6b8 <finalize_cancel_locked+0xac> @ imm = #0x0
 800e6b6: 2300         	movs	r3, #0x0
 800e6b8: 613b         	str	r3, [r7, #0x10]
 800e6ba: 697b         	ldr	r3, [r7, #0x14]
 800e6bc: 2b00         	cmp	r3, #0x0
 800e6be: d1d3         	bne	0x800e668 <finalize_cancel_locked+0x5c> @ imm = #-0x5a
; }
 800e6c0: bf00         	nop
 800e6c2: bf00         	nop
 800e6c4: 3718         	adds	r7, #0x18
 800e6c6: 46bd         	mov	sp, r7
 800e6c8: bd80         	pop	{r7, pc}
 800e6ca: bf00         	nop

0800e6cc <$d>:
 800e6cc: 68 1f 00 20  	.word	0x20001f68

0800e6d0 <queue_submit_locked>:
; {
 800e6d0: b580         	push	{r7, lr}
 800e6d2: b086         	sub	sp, #0x18
 800e6d4: af00         	add	r7, sp, #0x0
 800e6d6: 6078         	str	r0, [r7, #0x4]
 800e6d8: 6039         	str	r1, [r7]
; 	if (queue == NULL) {
 800e6da: 687b         	ldr	r3, [r7, #0x4]
 800e6dc: 2b00         	cmp	r3, #0x0
 800e6de: d102         	bne	0x800e6e6 <queue_submit_locked+0x16> @ imm = #0x4
; 		return -EINVAL;
 800e6e0: f06f 0315    	mvn	r3, #0x15
 800e6e4: e05d         	b	0x800e7a2 <queue_submit_locked+0xd2> @ imm = #0xba
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800e6e6: 4b31         	ldr	r3, [pc, #0xc4]         @ 0x800e7ac <queue_submit_locked+0xdc>
 800e6e8: 689b         	ldr	r3, [r3, #0x8]
 800e6ea: 60fb         	str	r3, [r7, #0xc]
; 	return ret;
 800e6ec: 68fa         	ldr	r2, [r7, #0xc]
; 	bool chained = (arch_current_thread() == &queue->thread) && !k_is_in_isr();
 800e6ee: 687b         	ldr	r3, [r7, #0x4]
 800e6f0: 429a         	cmp	r2, r3
 800e6f2: d109         	bne	0x800e708 <queue_submit_locked+0x38> @ imm = #0x12
 800e6f4: f00e fa04    	bl	0x801cb00 <k_is_in_isr> @ imm = #0xe408
 800e6f8: 4603         	mov	r3, r0
 800e6fa: f083 0301    	eor	r3, r3, #0x1
 800e6fe: b2db         	uxtb	r3, r3
 800e700: 2b00         	cmp	r3, #0x0
 800e702: d001         	beq	0x800e708 <queue_submit_locked+0x38> @ imm = #0x2
 800e704: 2301         	movs	r3, #0x1
 800e706: e000         	b	0x800e70a <queue_submit_locked+0x3a> @ imm = #0x0
 800e708: 2300         	movs	r3, #0x0
 800e70a: 74fb         	strb	r3, [r7, #0x13]
 800e70c: 7cfb         	ldrb	r3, [r7, #0x13]
 800e70e: f003 0301    	and	r3, r3, #0x1
 800e712: 74fb         	strb	r3, [r7, #0x13]
; 	bool draining = flag_test(&queue->flags, K_WORK_QUEUE_DRAIN_BIT);
 800e714: 687b         	ldr	r3, [r7, #0x4]
 800e716: 33e8         	adds	r3, #0xe8
 800e718: 2102         	movs	r1, #0x2
 800e71a: 4618         	mov	r0, r3
 800e71c: f00d ffe5    	bl	0x801c6ea <flag_test>   @ imm = #0xdfca
 800e720: 4603         	mov	r3, r0
 800e722: 74bb         	strb	r3, [r7, #0x12]
; 	bool plugged = flag_test(&queue->flags, K_WORK_QUEUE_PLUGGED_BIT);
 800e724: 687b         	ldr	r3, [r7, #0x4]
 800e726: 33e8         	adds	r3, #0xe8
 800e728: 2103         	movs	r1, #0x3
 800e72a: 4618         	mov	r0, r3
 800e72c: f00d ffdd    	bl	0x801c6ea <flag_test>   @ imm = #0xdfba
 800e730: 4603         	mov	r3, r0
 800e732: 747b         	strb	r3, [r7, #0x11]
; 	if (!flag_test(&queue->flags, K_WORK_QUEUE_STARTED_BIT)) {
 800e734: 687b         	ldr	r3, [r7, #0x4]
 800e736: 33e8         	adds	r3, #0xe8
 800e738: 2100         	movs	r1, #0x0
 800e73a: 4618         	mov	r0, r3
 800e73c: f00d ffd5    	bl	0x801c6ea <flag_test>   @ imm = #0xdfaa
 800e740: 4603         	mov	r3, r0
 800e742: f083 0301    	eor	r3, r3, #0x1
 800e746: b2db         	uxtb	r3, r3
 800e748: 2b00         	cmp	r3, #0x0
 800e74a: d003         	beq	0x800e754 <queue_submit_locked+0x84> @ imm = #0x6
; 		ret = -ENODEV;
 800e74c: f06f 0312    	mvn	r3, #0x12
 800e750: 617b         	str	r3, [r7, #0x14]
 800e752: e025         	b	0x800e7a0 <queue_submit_locked+0xd0> @ imm = #0x4a
; 	} else if (draining && !chained) {
 800e754: 7cbb         	ldrb	r3, [r7, #0x12]
 800e756: 2b00         	cmp	r3, #0x0
 800e758: d009         	beq	0x800e76e <queue_submit_locked+0x9e> @ imm = #0x12
 800e75a: 7cfb         	ldrb	r3, [r7, #0x13]
 800e75c: f083 0301    	eor	r3, r3, #0x1
 800e760: b2db         	uxtb	r3, r3
 800e762: 2b00         	cmp	r3, #0x0
 800e764: d003         	beq	0x800e76e <queue_submit_locked+0x9e> @ imm = #0x6
; 		ret = -EBUSY;
 800e766: f06f 030f    	mvn	r3, #0xf
 800e76a: 617b         	str	r3, [r7, #0x14]
 800e76c: e018         	b	0x800e7a0 <queue_submit_locked+0xd0> @ imm = #0x30
; 	} else if (plugged && !draining) {
 800e76e: 7c7b         	ldrb	r3, [r7, #0x11]
 800e770: 2b00         	cmp	r3, #0x0
 800e772: d009         	beq	0x800e788 <queue_submit_locked+0xb8> @ imm = #0x12
 800e774: 7cbb         	ldrb	r3, [r7, #0x12]
 800e776: f083 0301    	eor	r3, r3, #0x1
 800e77a: b2db         	uxtb	r3, r3
 800e77c: 2b00         	cmp	r3, #0x0
 800e77e: d003         	beq	0x800e788 <queue_submit_locked+0xb8> @ imm = #0x6
; 		ret = -EBUSY;
 800e780: f06f 030f    	mvn	r3, #0xf
 800e784: 617b         	str	r3, [r7, #0x14]
 800e786: e00b         	b	0x800e7a0 <queue_submit_locked+0xd0> @ imm = #0x16
; 		sys_slist_append(&queue->pending, &work->node);
 800e788: 687b         	ldr	r3, [r7, #0x4]
 800e78a: 33d0         	adds	r3, #0xd0
 800e78c: 683a         	ldr	r2, [r7]
 800e78e: 4611         	mov	r1, r2
 800e790: 4618         	mov	r0, r3
 800e792: f00d fe3f    	bl	0x801c414 <sys_slist_append> @ imm = #0xdc7e
; 		ret = 1;
 800e796: 2301         	movs	r3, #0x1
 800e798: 617b         	str	r3, [r7, #0x14]
; 		(void)notify_queue_locked(queue);
 800e79a: 6878         	ldr	r0, [r7, #0x4]
 800e79c: f00e f827    	bl	0x801c7ee <notify_queue_locked> @ imm = #0xe04e
; 	return ret;
 800e7a0: 697b         	ldr	r3, [r7, #0x14]
; }
 800e7a2: 4618         	mov	r0, r3
 800e7a4: 3718         	adds	r7, #0x18
 800e7a6: 46bd         	mov	sp, r7
 800e7a8: bd80         	pop	{r7, pc}
 800e7aa: bf00         	nop

0800e7ac <$d>:
 800e7ac: f0 16 00 20  	.word	0x200016f0

0800e7b0 <work_queue_main>:
; {
 800e7b0: b580         	push	{r7, lr}
 800e7b2: b0a4         	sub	sp, #0x90
 800e7b4: af04         	add	r7, sp, #0x10
 800e7b6: 60f8         	str	r0, [r7, #0xc]
 800e7b8: 60b9         	str	r1, [r7, #0x8]
 800e7ba: 607a         	str	r2, [r7, #0x4]
; 	struct k_work_q *queue = (struct k_work_q *)workq_ptr;
 800e7bc: 68fb         	ldr	r3, [r7, #0xc]
 800e7be: 677b         	str	r3, [r7, #0x74]
; 		struct k_work *work = NULL;
 800e7c0: 2300         	movs	r3, #0x0
 800e7c2: 67fb         	str	r3, [r7, #0x7c]
; 		k_work_handler_t handler = NULL;
 800e7c4: 2300         	movs	r3, #0x0
 800e7c6: 67bb         	str	r3, [r7, #0x78]
 800e7c8: 4b70         	ldr	r3, [pc, #0x1c0]        @ 0x800e98c <work_queue_main+0x1dc>
 800e7ca: 66bb         	str	r3, [r7, #0x68]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800e7cc: f3ef 8311    	mrs	r3, basepri
 800e7d0: 667b         	str	r3, [r7, #0x64]
;   return(result);
 800e7d2: 6e7b         	ldr	r3, [r7, #0x64]
; 	key = __get_BASEPRI();
 800e7d4: 663b         	str	r3, [r7, #0x60]
 800e7d6: 2310         	movs	r3, #0x10
 800e7d8: 65fb         	str	r3, [r7, #0x5c]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 800e7da: 6dfb         	ldr	r3, [r7, #0x5c]
 800e7dc: f383 8812    	msr	basepri_max, r3
; }
 800e7e0: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800e7e2: f3bf 8f6f    	isb	sy
; }
 800e7e6: bf00         	nop
; 	return key;
 800e7e8: 6e3b         	ldr	r3, [r7, #0x60]
; 	k.key = arch_irq_lock();
 800e7ea: 613b         	str	r3, [r7, #0x10]
 800e7ec: 6ebb         	ldr	r3, [r7, #0x68]
 800e7ee: 65bb         	str	r3, [r7, #0x58]
; }
 800e7f0: bf00         	nop
 800e7f2: 6ebb         	ldr	r3, [r7, #0x68]
 800e7f4: 657b         	str	r3, [r7, #0x54]
; }
 800e7f6: bf00         	nop
; 	return k;
 800e7f8: 693b         	ldr	r3, [r7, #0x10]
 800e7fa: 623b         	str	r3, [r7, #0x20]
; 		node = sys_slist_get(&queue->pending);
 800e7fc: 6f7b         	ldr	r3, [r7, #0x74]
 800e7fe: 33d0         	adds	r3, #0xd0
 800e800: 4618         	mov	r0, r3
 800e802: f00d fe52    	bl	0x801c4aa <sys_slist_get> @ imm = #0xdca4
 800e806: 6738         	str	r0, [r7, #0x70]
; 		if (node != NULL) {
 800e808: 6f3b         	ldr	r3, [r7, #0x70]
 800e80a: 2b00         	cmp	r3, #0x0
 800e80c: d017         	beq	0x800e83e <work_queue_main+0x8e> @ imm = #0x2e
; 			flag_set(&queue->flags, K_WORK_QUEUE_BUSY_BIT);
 800e80e: 6f7b         	ldr	r3, [r7, #0x74]
 800e810: 33e8         	adds	r3, #0xe8
 800e812: 2101         	movs	r1, #0x1
 800e814: 4618         	mov	r0, r3
 800e816: f00d ff55    	bl	0x801c6c4 <flag_set>    @ imm = #0xdeaa
; 			work = CONTAINER_OF(node, struct k_work, node);
 800e81a: 6f3b         	ldr	r3, [r7, #0x70]
 800e81c: 67fb         	str	r3, [r7, #0x7c]
; 			flag_set(&work->flags, K_WORK_RUNNING_BIT);
 800e81e: 6ffb         	ldr	r3, [r7, #0x7c]
 800e820: 330c         	adds	r3, #0xc
 800e822: 2100         	movs	r1, #0x0
 800e824: 4618         	mov	r0, r3
 800e826: f00d ff4d    	bl	0x801c6c4 <flag_set>    @ imm = #0xde9a
; 			flag_clear(&work->flags, K_WORK_QUEUED_BIT);
 800e82a: 6ffb         	ldr	r3, [r7, #0x7c]
 800e82c: 330c         	adds	r3, #0xc
 800e82e: 2102         	movs	r1, #0x2
 800e830: 4618         	mov	r0, r3
 800e832: f00d ff33    	bl	0x801c69c <flag_clear>  @ imm = #0xde66
; 			handler = work->handler;
 800e836: 6ffb         	ldr	r3, [r7, #0x7c]
 800e838: 685b         	ldr	r3, [r3, #0x4]
 800e83a: 67bb         	str	r3, [r7, #0x78]
 800e83c: e00f         	b	0x800e85e <work_queue_main+0xae> @ imm = #0x1e
; 		} else if (flag_test_and_clear(&queue->flags, K_WORK_QUEUE_DRAIN_BIT)) {
 800e83e: 6f7b         	ldr	r3, [r7, #0x74]
 800e840: 33e8         	adds	r3, #0xe8
 800e842: 2102         	movs	r1, #0x2
 800e844: 4618         	mov	r0, r3
 800e846: f00d ff66    	bl	0x801c716 <flag_test_and_clear> @ imm = #0xdecc
 800e84a: 4603         	mov	r3, r0
 800e84c: 2b00         	cmp	r3, #0x0
 800e84e: d006         	beq	0x800e85e <work_queue_main+0xae> @ imm = #0xc
; 			(void)z_sched_wake_all(&queue->drainq, 1, NULL);
 800e850: 6f7b         	ldr	r3, [r7, #0x74]
 800e852: 33e0         	adds	r3, #0xe0
 800e854: 2200         	movs	r2, #0x0
 800e856: 2101         	movs	r1, #0x1
 800e858: 4618         	mov	r0, r3
 800e85a: f00d ff07    	bl	0x801c66c <z_sched_wake_all> @ imm = #0xde0e
; 		if (work == NULL) {
 800e85e: 6ffb         	ldr	r3, [r7, #0x7c]
 800e860: 2b00         	cmp	r3, #0x0
 800e862: d111         	bne	0x800e888 <work_queue_main+0xd8> @ imm = #0x22
; 			(void)z_sched_wait(&lock, key, &queue->notifyq, K_FOREVER, NULL);
 800e864: 6f7b         	ldr	r3, [r7, #0x74]
 800e866: f103 01d8    	add.w	r1, r3, #0xd8
 800e86a: f04f 32ff    	mov.w	r2, #0xffffffff
 800e86e: f04f 33ff    	mov.w	r3, #0xffffffff
 800e872: 2000         	movs	r0, #0x0
 800e874: 9002         	str	r0, [sp, #0x8]
 800e876: e9cd 2300    	strd	r2, r3, [sp]
 800e87a: 460a         	mov	r2, r1
 800e87c: 6a39         	ldr	r1, [r7, #0x20]
 800e87e: 4843         	ldr	r0, [pc, #0x10c]        @ 0x800e98c <work_queue_main+0x1dc>
 800e880: f001 ffce    	bl	0x8010820 <z_sched_wait> @ imm = #0x1f9c
; 			continue;
 800e884: bf00         	nop
 800e886: e79b         	b	0x800e7c0 <work_queue_main+0x10> @ imm = #-0xca
 800e888: 4b40         	ldr	r3, [pc, #0x100]        @ 0x800e98c <work_queue_main+0x1dc>
 800e88a: 63bb         	str	r3, [r7, #0x38]
 800e88c: 6a3b         	ldr	r3, [r7, #0x20]
 800e88e: 61bb         	str	r3, [r7, #0x18]
; 	arch_irq_unlock(key.key);
 800e890: 69bb         	ldr	r3, [r7, #0x18]
 800e892: 637b         	str	r3, [r7, #0x34]
 800e894: 6b7b         	ldr	r3, [r7, #0x34]
 800e896: 633b         	str	r3, [r7, #0x30]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800e898: 6b3b         	ldr	r3, [r7, #0x30]
 800e89a: f383 8811    	msr	basepri, r3
; }
 800e89e: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800e8a0: f3bf 8f6f    	isb	sy
; }
 800e8a4: bf00         	nop
; }
 800e8a6: bf00         	nop
; }
 800e8a8: bf00         	nop
; 		handler(work);
 800e8aa: 6fbb         	ldr	r3, [r7, #0x78]
 800e8ac: 6ff8         	ldr	r0, [r7, #0x7c]
 800e8ae: 4798         	blx	r3
 800e8b0: 4b36         	ldr	r3, [pc, #0xd8]         @ 0x800e98c <work_queue_main+0x1dc>
 800e8b2: 653b         	str	r3, [r7, #0x50]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800e8b4: f3ef 8311    	mrs	r3, basepri
 800e8b8: 64fb         	str	r3, [r7, #0x4c]
;   return(result);
 800e8ba: 6cfb         	ldr	r3, [r7, #0x4c]
; 	key = __get_BASEPRI();
 800e8bc: 64bb         	str	r3, [r7, #0x48]
 800e8be: 2310         	movs	r3, #0x10
 800e8c0: 647b         	str	r3, [r7, #0x44]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 800e8c2: 6c7b         	ldr	r3, [r7, #0x44]
 800e8c4: f383 8812    	msr	basepri_max, r3
; }
 800e8c8: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800e8ca: f3bf 8f6f    	isb	sy
; }
 800e8ce: bf00         	nop
; 	return key;
 800e8d0: 6cbb         	ldr	r3, [r7, #0x48]
; 	k.key = arch_irq_lock();
 800e8d2: 617b         	str	r3, [r7, #0x14]
 800e8d4: 6d3b         	ldr	r3, [r7, #0x50]
 800e8d6: 643b         	str	r3, [r7, #0x40]
; }
 800e8d8: bf00         	nop
 800e8da: 6d3b         	ldr	r3, [r7, #0x50]
 800e8dc: 63fb         	str	r3, [r7, #0x3c]
; }
 800e8de: bf00         	nop
; 	return k;
 800e8e0: 697b         	ldr	r3, [r7, #0x14]
 800e8e2: 623b         	str	r3, [r7, #0x20]
; 		flag_clear(&work->flags, K_WORK_RUNNING_BIT);
 800e8e4: 6ffb         	ldr	r3, [r7, #0x7c]
 800e8e6: 330c         	adds	r3, #0xc
 800e8e8: 2100         	movs	r1, #0x0
 800e8ea: 4618         	mov	r0, r3
 800e8ec: f00d fed6    	bl	0x801c69c <flag_clear>  @ imm = #0xddac
; 		if (flag_test(&work->flags, K_WORK_FLUSHING_BIT)) {
 800e8f0: 6ffb         	ldr	r3, [r7, #0x7c]
 800e8f2: 330c         	adds	r3, #0xc
 800e8f4: 2104         	movs	r1, #0x4
 800e8f6: 4618         	mov	r0, r3
 800e8f8: f00d fef7    	bl	0x801c6ea <flag_test>   @ imm = #0xddee
 800e8fc: 4603         	mov	r3, r0
 800e8fe: 2b00         	cmp	r3, #0x0
 800e900: d002         	beq	0x800e908 <work_queue_main+0x158> @ imm = #0x4
; 			finalize_flush_locked(work);
 800e902: 6ff8         	ldr	r0, [r7, #0x7c]
 800e904: f00d ff35    	bl	0x801c772 <finalize_flush_locked> @ imm = #0xde6a
; 		if (flag_test(&work->flags, K_WORK_CANCELING_BIT)) {
 800e908: 6ffb         	ldr	r3, [r7, #0x7c]
 800e90a: 330c         	adds	r3, #0xc
 800e90c: 2101         	movs	r1, #0x1
 800e90e: 4618         	mov	r0, r3
 800e910: f00d feeb    	bl	0x801c6ea <flag_test>   @ imm = #0xddd6
 800e914: 4603         	mov	r3, r0
 800e916: 2b00         	cmp	r3, #0x0
 800e918: d002         	beq	0x800e920 <work_queue_main+0x170> @ imm = #0x4
; 			finalize_cancel_locked(work);
 800e91a: 6ff8         	ldr	r0, [r7, #0x7c]
 800e91c: f7ff fe76    	bl	0x800e60c <finalize_cancel_locked> @ imm = #-0x314
; 		flag_clear(&queue->flags, K_WORK_QUEUE_BUSY_BIT);
 800e920: 6f7b         	ldr	r3, [r7, #0x74]
 800e922: 33e8         	adds	r3, #0xe8
 800e924: 2101         	movs	r1, #0x1
 800e926: 4618         	mov	r0, r3
 800e928: f00d feb8    	bl	0x801c69c <flag_clear>  @ imm = #0xdd70
; 		yield = !flag_test(&queue->flags, K_WORK_QUEUE_NO_YIELD_BIT);
 800e92c: 6f7b         	ldr	r3, [r7, #0x74]
 800e92e: 33e8         	adds	r3, #0xe8
 800e930: 2108         	movs	r1, #0x8
 800e932: 4618         	mov	r0, r3
 800e934: f00d fed9    	bl	0x801c6ea <flag_test>   @ imm = #0xddb2
 800e938: 4603         	mov	r3, r0
 800e93a: 2b00         	cmp	r3, #0x0
 800e93c: bf14         	ite	ne
 800e93e: 2301         	movne	r3, #0x1
 800e940: 2300         	moveq	r3, #0x0
 800e942: b2db         	uxtb	r3, r3
 800e944: f083 0301    	eor	r3, r3, #0x1
 800e948: b2db         	uxtb	r3, r3
 800e94a: f887 306f    	strb.w	r3, [r7, #0x6f]
 800e94e: f897 306f    	ldrb.w	r3, [r7, #0x6f]
 800e952: f003 0301    	and	r3, r3, #0x1
 800e956: f887 306f    	strb.w	r3, [r7, #0x6f]
 800e95a: 4b0c         	ldr	r3, [pc, #0x30]         @ 0x800e98c <work_queue_main+0x1dc>
 800e95c: 62fb         	str	r3, [r7, #0x2c]
 800e95e: 6a3b         	ldr	r3, [r7, #0x20]
 800e960: 61fb         	str	r3, [r7, #0x1c]
; 	arch_irq_unlock(key.key);
 800e962: 69fb         	ldr	r3, [r7, #0x1c]
 800e964: 62bb         	str	r3, [r7, #0x28]
 800e966: 6abb         	ldr	r3, [r7, #0x28]
 800e968: 627b         	str	r3, [r7, #0x24]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800e96a: 6a7b         	ldr	r3, [r7, #0x24]
 800e96c: f383 8811    	msr	basepri, r3
; }
 800e970: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800e972: f3bf 8f6f    	isb	sy
; }
 800e976: bf00         	nop
; }
 800e978: bf00         	nop
; }
 800e97a: bf00         	nop
; 		if (yield) {
 800e97c: f897 306f    	ldrb.w	r3, [r7, #0x6f]
 800e980: 2b00         	cmp	r3, #0x0
 800e982: f43f af1d    	beq.w	0x800e7c0 <work_queue_main+0x10> @ imm = #-0x1c6
; 			k_yield();
 800e986: f00d fe2f    	bl	0x801c5e8 <k_yield>     @ imm = #0xdc5e
; 	while (true) {
 800e98a: e719         	b	0x800e7c0 <work_queue_main+0x10> @ imm = #-0x1ce

0800e98c <$d>:
 800e98c: 68 1f 00 20  	.word	0x20001f68

0800e990 <k_work_queue_start>:
; {
 800e990: b580         	push	{r7, lr}
 800e992: b08e         	sub	sp, #0x38
 800e994: af08         	add	r7, sp, #0x20
 800e996: 60f8         	str	r0, [r7, #0xc]
 800e998: 60b9         	str	r1, [r7, #0x8]
 800e99a: 607a         	str	r2, [r7, #0x4]
 800e99c: 603b         	str	r3, [r7]
; 	uint32_t flags = K_WORK_QUEUE_STARTED;
 800e99e: 2301         	movs	r3, #0x1
 800e9a0: 617b         	str	r3, [r7, #0x14]
; 	sys_slist_init(&queue->pending);
 800e9a2: 68fb         	ldr	r3, [r7, #0xc]
 800e9a4: 33d0         	adds	r3, #0xd0
 800e9a6: 4618         	mov	r0, r3
 800e9a8: f00d fcaf    	bl	0x801c30a <sys_slist_init> @ imm = #0xd95e
; 	z_waitq_init(&queue->notifyq);
 800e9ac: 68fb         	ldr	r3, [r7, #0xc]
 800e9ae: 33d8         	adds	r3, #0xd8
 800e9b0: 4618         	mov	r0, r3
 800e9b2: f00d fe4f    	bl	0x801c654 <z_waitq_init> @ imm = #0xdc9e
; 	z_waitq_init(&queue->drainq);
 800e9b6: 68fb         	ldr	r3, [r7, #0xc]
 800e9b8: 33e0         	adds	r3, #0xe0
 800e9ba: 4618         	mov	r0, r3
 800e9bc: f00d fe4a    	bl	0x801c654 <z_waitq_init> @ imm = #0xdc94
; 	if ((cfg != NULL) && cfg->no_yield) {
 800e9c0: 6a3b         	ldr	r3, [r7, #0x20]
 800e9c2: 2b00         	cmp	r3, #0x0
 800e9c4: d007         	beq	0x800e9d6 <k_work_queue_start+0x46> @ imm = #0xe
 800e9c6: 6a3b         	ldr	r3, [r7, #0x20]
 800e9c8: 791b         	ldrb	r3, [r3, #0x4]
 800e9ca: 2b00         	cmp	r3, #0x0
 800e9cc: d003         	beq	0x800e9d6 <k_work_queue_start+0x46> @ imm = #0x6
; 		flags |= K_WORK_QUEUE_NO_YIELD;
 800e9ce: 697b         	ldr	r3, [r7, #0x14]
 800e9d0: f443 7380    	orr	r3, r3, #0x100
 800e9d4: 617b         	str	r3, [r7, #0x14]
; 	flags_set(&queue->flags, flags);
 800e9d6: 68fb         	ldr	r3, [r7, #0xc]
 800e9d8: 33e8         	adds	r3, #0xe8
 800e9da: 6979         	ldr	r1, [r7, #0x14]
 800e9dc: 4618         	mov	r0, r3
 800e9de: f00d feb0    	bl	0x801c742 <flags_set>   @ imm = #0xdd60
; 	(void)k_thread_create(&queue->thread, stack, stack_size, work_queue_main, queue, NULL, NULL,
 800e9e2: 68f8         	ldr	r0, [r7, #0xc]
; 			      prio, 0, K_FOREVER);
 800e9e4: f04f 32ff    	mov.w	r2, #0xffffffff
 800e9e8: f04f 33ff    	mov.w	r3, #0xffffffff
; 	(void)k_thread_create(&queue->thread, stack, stack_size, work_queue_main, queue, NULL, NULL,
 800e9ec: e9cd 2306    	strd	r2, r3, [sp, #24]
 800e9f0: 2300         	movs	r3, #0x0
 800e9f2: 9304         	str	r3, [sp, #0x10]
 800e9f4: 683b         	ldr	r3, [r7]
 800e9f6: 9303         	str	r3, [sp, #0xc]
 800e9f8: 2300         	movs	r3, #0x0
 800e9fa: 9302         	str	r3, [sp, #0x8]
 800e9fc: 2300         	movs	r3, #0x0
 800e9fe: 9301         	str	r3, [sp, #0x4]
 800ea00: 68fb         	ldr	r3, [r7, #0xc]
 800ea02: 9300         	str	r3, [sp]
 800ea04: 4b14         	ldr	r3, [pc, #0x50]         @ 0x800ea58 <k_work_queue_start+0xc8>
 800ea06: 687a         	ldr	r2, [r7, #0x4]
 800ea08: 68b9         	ldr	r1, [r7, #0x8]
 800ea0a: f00d fdcd    	bl	0x801c5a8 <k_thread_create> @ imm = #0xdb9a
; 	if ((cfg != NULL) && (cfg->name != NULL)) {
 800ea0e: 6a3b         	ldr	r3, [r7, #0x20]
 800ea10: 2b00         	cmp	r3, #0x0
 800ea12: d00a         	beq	0x800ea2a <k_work_queue_start+0x9a> @ imm = #0x14
 800ea14: 6a3b         	ldr	r3, [r7, #0x20]
 800ea16: 681b         	ldr	r3, [r3]
 800ea18: 2b00         	cmp	r3, #0x0
 800ea1a: d006         	beq	0x800ea2a <k_work_queue_start+0x9a> @ imm = #0xc
; 		k_thread_name_set(&queue->thread, cfg->name);
 800ea1c: 68fa         	ldr	r2, [r7, #0xc]
 800ea1e: 6a3b         	ldr	r3, [r7, #0x20]
 800ea20: 681b         	ldr	r3, [r3]
 800ea22: 4619         	mov	r1, r3
 800ea24: 4610         	mov	r0, r2
 800ea26: f00d fdf0    	bl	0x801c60a <k_thread_name_set> @ imm = #0xdbe0
; 	if ((cfg != NULL) && (cfg->essential)) {
 800ea2a: 6a3b         	ldr	r3, [r7, #0x20]
 800ea2c: 2b00         	cmp	r3, #0x0
 800ea2e: d00a         	beq	0x800ea46 <k_work_queue_start+0xb6> @ imm = #0x14
 800ea30: 6a3b         	ldr	r3, [r7, #0x20]
 800ea32: 795b         	ldrb	r3, [r3, #0x5]
 800ea34: 2b00         	cmp	r3, #0x0
 800ea36: d006         	beq	0x800ea46 <k_work_queue_start+0xb6> @ imm = #0xc
; 		queue->thread.base.user_options |= K_ESSENTIAL;
 800ea38: 68fb         	ldr	r3, [r7, #0xc]
 800ea3a: 7b1b         	ldrb	r3, [r3, #0xc]
 800ea3c: f043 0301    	orr	r3, r3, #0x1
 800ea40: b2da         	uxtb	r2, r3
 800ea42: 68fb         	ldr	r3, [r7, #0xc]
 800ea44: 731a         	strb	r2, [r3, #0xc]
; 	k_thread_start(&queue->thread);
 800ea46: 68fb         	ldr	r3, [r7, #0xc]
 800ea48: 4618         	mov	r0, r3
 800ea4a: f00d fda2    	bl	0x801c592 <k_thread_start> @ imm = #0xdb44
; }
 800ea4e: bf00         	nop
 800ea50: 3718         	adds	r7, #0x18
 800ea52: 46bd         	mov	sp, r7
 800ea54: bd80         	pop	{r7, pc}
 800ea56: bf00         	nop

0800ea58 <$d>:
 800ea58: b1 e7 00 08  	.word	0x0800e7b1

0800ea5c <work_timeout>:
; {
 800ea5c: b580         	push	{r7, lr}
 800ea5e: b092         	sub	sp, #0x48
 800ea60: af00         	add	r7, sp, #0x0
 800ea62: 6078         	str	r0, [r7, #0x4]
; 	struct k_work_delayable *dw = CONTAINER_OF(to, struct k_work_delayable, timeout);
 800ea64: 687b         	ldr	r3, [r7, #0x4]
 800ea66: 3b10         	subs	r3, #0x10
 800ea68: 647b         	str	r3, [r7, #0x44]
; 	struct k_work *wp = &dw->work;
 800ea6a: 6c7b         	ldr	r3, [r7, #0x44]
 800ea6c: 643b         	str	r3, [r7, #0x40]
 800ea6e: 4b21         	ldr	r3, [pc, #0x84]         @ 0x800eaf4 <work_timeout+0x98>
 800ea70: 63fb         	str	r3, [r7, #0x3c]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800ea72: f3ef 8311    	mrs	r3, basepri
 800ea76: 63bb         	str	r3, [r7, #0x38]
;   return(result);
 800ea78: 6bbb         	ldr	r3, [r7, #0x38]
; 	key = __get_BASEPRI();
 800ea7a: 637b         	str	r3, [r7, #0x34]
 800ea7c: 2310         	movs	r3, #0x10
 800ea7e: 633b         	str	r3, [r7, #0x30]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 800ea80: 6b3b         	ldr	r3, [r7, #0x30]
 800ea82: f383 8812    	msr	basepri_max, r3
; }
 800ea86: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800ea88: f3bf 8f6f    	isb	sy
; }
 800ea8c: bf00         	nop
; 	return key;
 800ea8e: 6b7b         	ldr	r3, [r7, #0x34]
; 	k.key = arch_irq_lock();
 800ea90: 60fb         	str	r3, [r7, #0xc]
 800ea92: 6bfb         	ldr	r3, [r7, #0x3c]
 800ea94: 62fb         	str	r3, [r7, #0x2c]
; }
 800ea96: bf00         	nop
 800ea98: 6bfb         	ldr	r3, [r7, #0x3c]
 800ea9a: 62bb         	str	r3, [r7, #0x28]
; }
 800ea9c: bf00         	nop
; 	return k;
 800ea9e: 68fb         	ldr	r3, [r7, #0xc]
 800eaa0: 61bb         	str	r3, [r7, #0x18]
; 	struct k_work_q *queue = NULL;
 800eaa2: 2300         	movs	r3, #0x0
 800eaa4: 617b         	str	r3, [r7, #0x14]
; 	if (flag_test_and_clear(&wp->flags, K_WORK_DELAYED_BIT)) {
 800eaa6: 6c3b         	ldr	r3, [r7, #0x40]
 800eaa8: 330c         	adds	r3, #0xc
 800eaaa: 2103         	movs	r1, #0x3
 800eaac: 4618         	mov	r0, r3
 800eaae: f00d fe32    	bl	0x801c716 <flag_test_and_clear> @ imm = #0xdc64
 800eab2: 4603         	mov	r3, r0
 800eab4: 2b00         	cmp	r3, #0x0
 800eab6: d008         	beq	0x800eaca <work_timeout+0x6e> @ imm = #0x10
; 		queue = dw->queue;
 800eab8: 6c7b         	ldr	r3, [r7, #0x44]
 800eaba: 6a9b         	ldr	r3, [r3, #0x28]
 800eabc: 617b         	str	r3, [r7, #0x14]
; 		(void)submit_to_queue_locked(wp, &queue);
 800eabe: f107 0314    	add.w	r3, r7, #0x14
 800eac2: 4619         	mov	r1, r3
 800eac4: 6c38         	ldr	r0, [r7, #0x40]
 800eac6: f00d fea9    	bl	0x801c81c <submit_to_queue_locked> @ imm = #0xdd52
 800eaca: 4b0a         	ldr	r3, [pc, #0x28]         @ 0x800eaf4 <work_timeout+0x98>
 800eacc: 627b         	str	r3, [r7, #0x24]
 800eace: 69bb         	ldr	r3, [r7, #0x18]
 800ead0: 613b         	str	r3, [r7, #0x10]
; 	arch_irq_unlock(key.key);
 800ead2: 693b         	ldr	r3, [r7, #0x10]
 800ead4: 623b         	str	r3, [r7, #0x20]
 800ead6: 6a3b         	ldr	r3, [r7, #0x20]
 800ead8: 61fb         	str	r3, [r7, #0x1c]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800eada: 69fb         	ldr	r3, [r7, #0x1c]
 800eadc: f383 8811    	msr	basepri, r3
; }
 800eae0: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800eae2: f3bf 8f6f    	isb	sy
; }
 800eae6: bf00         	nop
; }
 800eae8: bf00         	nop
; }
 800eaea: bf00         	nop
; }
 800eaec: bf00         	nop
 800eaee: 3748         	adds	r7, #0x48
 800eaf0: 46bd         	mov	sp, r7
 800eaf2: bd80         	pop	{r7, pc}

0800eaf4 <$d>:
 800eaf4: 68 1f 00 20  	.word	0x20001f68

0800eaf8 <schedule_for_queue_locked>:
; {
 800eaf8: b580         	push	{r7, lr}
 800eafa: b086         	sub	sp, #0x18
 800eafc: af00         	add	r7, sp, #0x0
 800eafe: 60f8         	str	r0, [r7, #0xc]
 800eb00: 60b9         	str	r1, [r7, #0x8]
 800eb02: e9c7 2300    	strd	r2, r3, [r7]
; 	int ret = 1;
 800eb06: 2301         	movs	r3, #0x1
 800eb08: 617b         	str	r3, [r7, #0x14]
; 	struct k_work *work = &dwork->work;
 800eb0a: 68bb         	ldr	r3, [r7, #0x8]
 800eb0c: 613b         	str	r3, [r7, #0x10]
; 	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
 800eb0e: e9d7 2300    	ldrd	r2, r3, [r7]
 800eb12: f04f 0000    	mov.w	r0, #0x0
 800eb16: f04f 0100    	mov.w	r1, #0x0
 800eb1a: 428b         	cmp	r3, r1
 800eb1c: bf08         	it	eq
 800eb1e: 4282         	cmpeq	r2, r0
 800eb20: d105         	bne	0x800eb2e <schedule_for_queue_locked+0x36> @ imm = #0xa
; 		return submit_to_queue_locked(work, queuep);
 800eb22: 68f9         	ldr	r1, [r7, #0xc]
 800eb24: 6938         	ldr	r0, [r7, #0x10]
 800eb26: f00d fe79    	bl	0x801c81c <submit_to_queue_locked> @ imm = #0xdcf2
 800eb2a: 4603         	mov	r3, r0
 800eb2c: e012         	b	0x800eb54 <schedule_for_queue_locked+0x5c> @ imm = #0x24
; 	flag_set(&work->flags, K_WORK_DELAYED_BIT);
 800eb2e: 693b         	ldr	r3, [r7, #0x10]
 800eb30: 330c         	adds	r3, #0xc
 800eb32: 2103         	movs	r1, #0x3
 800eb34: 4618         	mov	r0, r3
 800eb36: f00d fdc5    	bl	0x801c6c4 <flag_set>    @ imm = #0xdb8a
; 	dwork->queue = *queuep;
 800eb3a: 68fb         	ldr	r3, [r7, #0xc]
 800eb3c: 681a         	ldr	r2, [r3]
 800eb3e: 68bb         	ldr	r3, [r7, #0x8]
 800eb40: 629a         	str	r2, [r3, #0x28]
; 	z_add_timeout(&dwork->timeout, work_timeout, delay);
 800eb42: 68bb         	ldr	r3, [r7, #0x8]
 800eb44: f103 0010    	add.w	r0, r3, #0x10
 800eb48: e9d7 2300    	ldrd	r2, r3, [r7]
 800eb4c: 4903         	ldr	r1, [pc, #0xc]          @ 0x800eb5c <schedule_for_queue_locked+0x64>
 800eb4e: f002 f86d    	bl	0x8010c2c <z_add_timeout> @ imm = #0x20da
; 	return ret;
 800eb52: 697b         	ldr	r3, [r7, #0x14]
; }
 800eb54: 4618         	mov	r0, r3
 800eb56: 3718         	adds	r7, #0x18
 800eb58: 46bd         	mov	sp, r7
 800eb5a: bd80         	pop	{r7, pc}

0800eb5c <$d>:
 800eb5c: 5d ea 00 08  	.word	0x0800ea5d

0800eb60 <k_work_reschedule_for_queue>:
; {
 800eb60: b580         	push	{r7, lr}
 800eb62: b092         	sub	sp, #0x48
 800eb64: af00         	add	r7, sp, #0x0
 800eb66: 60f8         	str	r0, [r7, #0xc]
 800eb68: 60b9         	str	r1, [r7, #0x8]
 800eb6a: e9c7 2300    	strd	r2, r3, [r7]
 800eb6e: 4b1d         	ldr	r3, [pc, #0x74]         @ 0x800ebe4 <k_work_reschedule_for_queue+0x84>
 800eb70: 637b         	str	r3, [r7, #0x34]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800eb72: f3ef 8311    	mrs	r3, basepri
 800eb76: 633b         	str	r3, [r7, #0x30]
;   return(result);
 800eb78: 6b3b         	ldr	r3, [r7, #0x30]
; 	key = __get_BASEPRI();
 800eb7a: 62fb         	str	r3, [r7, #0x2c]
 800eb7c: 2310         	movs	r3, #0x10
 800eb7e: 62bb         	str	r3, [r7, #0x28]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 800eb80: 6abb         	ldr	r3, [r7, #0x28]
 800eb82: f383 8812    	msr	basepri_max, r3
; }
 800eb86: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800eb88: f3bf 8f6f    	isb	sy
; }
 800eb8c: bf00         	nop
; 	return key;
 800eb8e: 6afb         	ldr	r3, [r7, #0x2c]
; 	k.key = arch_irq_lock();
 800eb90: 61bb         	str	r3, [r7, #0x18]
 800eb92: 6b7b         	ldr	r3, [r7, #0x34]
 800eb94: 627b         	str	r3, [r7, #0x24]
; }
 800eb96: bf00         	nop
 800eb98: 6b7b         	ldr	r3, [r7, #0x34]
 800eb9a: 623b         	str	r3, [r7, #0x20]
; }
 800eb9c: bf00         	nop
; 	return k;
 800eb9e: 69bb         	ldr	r3, [r7, #0x18]
 800eba0: 61fb         	str	r3, [r7, #0x1c]
; 	(void)unschedule_locked(dwork);
 800eba2: 68b8         	ldr	r0, [r7, #0x8]
 800eba4: f00d fedd    	bl	0x801c962 <unschedule_locked> @ imm = #0xddba
; 	ret = schedule_for_queue_locked(&queue, dwork, delay);
 800eba8: f107 000c    	add.w	r0, r7, #0xc
 800ebac: e9d7 2300    	ldrd	r2, r3, [r7]
 800ebb0: 68b9         	ldr	r1, [r7, #0x8]
 800ebb2: f7ff ffa1    	bl	0x800eaf8 <schedule_for_queue_locked> @ imm = #-0xbe
 800ebb6: 6478         	str	r0, [r7, #0x44]
 800ebb8: 4b0a         	ldr	r3, [pc, #0x28]         @ 0x800ebe4 <k_work_reschedule_for_queue+0x84>
 800ebba: 643b         	str	r3, [r7, #0x40]
 800ebbc: 69fb         	ldr	r3, [r7, #0x1c]
 800ebbe: 617b         	str	r3, [r7, #0x14]
; 	arch_irq_unlock(key.key);
 800ebc0: 697b         	ldr	r3, [r7, #0x14]
 800ebc2: 63fb         	str	r3, [r7, #0x3c]
 800ebc4: 6bfb         	ldr	r3, [r7, #0x3c]
 800ebc6: 63bb         	str	r3, [r7, #0x38]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800ebc8: 6bbb         	ldr	r3, [r7, #0x38]
 800ebca: f383 8811    	msr	basepri, r3
; }
 800ebce: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800ebd0: f3bf 8f6f    	isb	sy
; }
 800ebd4: bf00         	nop
; }
 800ebd6: bf00         	nop
; }
 800ebd8: bf00         	nop
; 	return ret;
 800ebda: 6c7b         	ldr	r3, [r7, #0x44]
; }
 800ebdc: 4618         	mov	r0, r3
 800ebde: 3748         	adds	r7, #0x48
 800ebe0: 46bd         	mov	sp, r7
 800ebe2: bd80         	pop	{r7, pc}

0800ebe4 <$d>:
 800ebe4: 68 1f 00 20  	.word	0x20001f68

0800ebe8 <k_work_reschedule>:
; {
 800ebe8: b580         	push	{r7, lr}
 800ebea: b086         	sub	sp, #0x18
 800ebec: af00         	add	r7, sp, #0x0
 800ebee: 60f8         	str	r0, [r7, #0xc]
 800ebf0: e9c7 2300    	strd	r2, r3, [r7]
; 	int ret = k_work_reschedule_for_queue(&k_sys_work_q, dwork, delay);
 800ebf4: e9d7 2300    	ldrd	r2, r3, [r7]
 800ebf8: 68f9         	ldr	r1, [r7, #0xc]
 800ebfa: 4804         	ldr	r0, [pc, #0x10]         @ 0x800ec0c <k_work_reschedule+0x24>
 800ebfc: f7ff ffb0    	bl	0x800eb60 <k_work_reschedule_for_queue> @ imm = #-0xa0
 800ec00: 6178         	str	r0, [r7, #0x14]
; 	return ret;
 800ec02: 697b         	ldr	r3, [r7, #0x14]
; }
 800ec04: 4618         	mov	r0, r3
 800ec06: 3718         	adds	r7, #0x18
 800ec08: 46bd         	mov	sp, r7
 800ec0a: bd80         	pop	{r7, pc}

0800ec0c <$d>:
 800ec0c: c0 19 00 20  	.word	0x200019c0

0800ec10 <k_work_cancel_delayable>:
; {
 800ec10: b580         	push	{r7, lr}
 800ec12: b090         	sub	sp, #0x40
 800ec14: af00         	add	r7, sp, #0x0
 800ec16: 6078         	str	r0, [r7, #0x4]
 800ec18: 4b19         	ldr	r3, [pc, #0x64]         @ 0x800ec80 <k_work_cancel_delayable+0x70>
 800ec1a: 62fb         	str	r3, [r7, #0x2c]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800ec1c: f3ef 8311    	mrs	r3, basepri
 800ec20: 62bb         	str	r3, [r7, #0x28]
;   return(result);
 800ec22: 6abb         	ldr	r3, [r7, #0x28]
; 	key = __get_BASEPRI();
 800ec24: 627b         	str	r3, [r7, #0x24]
 800ec26: 2310         	movs	r3, #0x10
 800ec28: 623b         	str	r3, [r7, #0x20]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 800ec2a: 6a3b         	ldr	r3, [r7, #0x20]
 800ec2c: f383 8812    	msr	basepri_max, r3
; }
 800ec30: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800ec32: f3bf 8f6f    	isb	sy
; }
 800ec36: bf00         	nop
; 	return key;
 800ec38: 6a7b         	ldr	r3, [r7, #0x24]
; 	k.key = arch_irq_lock();
 800ec3a: 613b         	str	r3, [r7, #0x10]
 800ec3c: 6afb         	ldr	r3, [r7, #0x2c]
 800ec3e: 61fb         	str	r3, [r7, #0x1c]
; }
 800ec40: bf00         	nop
 800ec42: 6afb         	ldr	r3, [r7, #0x2c]
 800ec44: 61bb         	str	r3, [r7, #0x18]
; }
 800ec46: bf00         	nop
; 	return k;
 800ec48: 693b         	ldr	r3, [r7, #0x10]
 800ec4a: 617b         	str	r3, [r7, #0x14]
; 	int ret = cancel_delayable_async_locked(dwork);
 800ec4c: 6878         	ldr	r0, [r7, #0x4]
 800ec4e: f00d fea9    	bl	0x801c9a4 <cancel_delayable_async_locked> @ imm = #0xdd52
 800ec52: 63f8         	str	r0, [r7, #0x3c]
 800ec54: 4b0a         	ldr	r3, [pc, #0x28]         @ 0x800ec80 <k_work_cancel_delayable+0x70>
 800ec56: 63bb         	str	r3, [r7, #0x38]
 800ec58: 697b         	ldr	r3, [r7, #0x14]
 800ec5a: 60fb         	str	r3, [r7, #0xc]
; 	arch_irq_unlock(key.key);
 800ec5c: 68fb         	ldr	r3, [r7, #0xc]
 800ec5e: 637b         	str	r3, [r7, #0x34]
 800ec60: 6b7b         	ldr	r3, [r7, #0x34]
 800ec62: 633b         	str	r3, [r7, #0x30]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800ec64: 6b3b         	ldr	r3, [r7, #0x30]
 800ec66: f383 8811    	msr	basepri, r3
; }
 800ec6a: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800ec6c: f3bf 8f6f    	isb	sy
; }
 800ec70: bf00         	nop
; }
 800ec72: bf00         	nop
; }
 800ec74: bf00         	nop
; 	return ret;
 800ec76: 6bfb         	ldr	r3, [r7, #0x3c]
; }
 800ec78: 4618         	mov	r0, r3
 800ec7a: 3740         	adds	r7, #0x40
 800ec7c: 46bd         	mov	sp, r7
 800ec7e: bd80         	pop	{r7, pc}

0800ec80 <$d>:
 800ec80: 68 1f 00 20  	.word	0x20001f68

0800ec84 <z_add_thread_timeout>:
; {
 800ec84: b580         	push	{r7, lr}
 800ec86: b084         	sub	sp, #0x10
 800ec88: af00         	add	r7, sp, #0x0
 800ec8a: 60f8         	str	r0, [r7, #0xc]
 800ec8c: e9c7 2300    	strd	r2, r3, [r7]
; 	z_add_timeout(&thread->base.timeout, z_thread_timeout, ticks);
 800ec90: 68fb         	ldr	r3, [r7, #0xc]
 800ec92: f103 0018    	add.w	r0, r3, #0x18
 800ec96: e9d7 2300    	ldrd	r2, r3, [r7]
 800ec9a: 4903         	ldr	r1, [pc, #0xc]          @ 0x800eca8 <z_add_thread_timeout+0x24>
 800ec9c: f001 ffc6    	bl	0x8010c2c <z_add_timeout> @ imm = #0x1f8c
; }
 800eca0: bf00         	nop
 800eca2: 3710         	adds	r7, #0x10
 800eca4: 46bd         	mov	sp, r7
 800eca6: bd80         	pop	{r7, pc}

0800eca8 <$d>:
 800eca8: 5f d2 01 08  	.word	0x0801d25f

0800ecac <z_impl_k_thread_name_set>:
; {
 800ecac: b580         	push	{r7, lr}
 800ecae: b084         	sub	sp, #0x10
 800ecb0: af00         	add	r7, sp, #0x0
 800ecb2: 6078         	str	r0, [r7, #0x4]
 800ecb4: 6039         	str	r1, [r7]
; 	if (thread == NULL) {
 800ecb6: 687b         	ldr	r3, [r7, #0x4]
 800ecb8: 2b00         	cmp	r3, #0x0
 800ecba: d104         	bne	0x800ecc6 <z_impl_k_thread_name_set+0x1a> @ imm = #0x8
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800ecbc: 4b0a         	ldr	r3, [pc, #0x28]         @ 0x800ece8 <z_impl_k_thread_name_set+0x3c>
 800ecbe: 689b         	ldr	r3, [r3, #0x8]
 800ecc0: 60fb         	str	r3, [r7, #0xc]
; 	return ret;
 800ecc2: 68fb         	ldr	r3, [r7, #0xc]
; 		thread = arch_current_thread();
 800ecc4: 607b         	str	r3, [r7, #0x4]
; 	strncpy(thread->name, str, CONFIG_THREAD_MAX_NAME_LEN - 1);
 800ecc6: 687b         	ldr	r3, [r7, #0x4]
 800ecc8: 3394         	adds	r3, #0x94
 800ecca: 221f         	movs	r2, #0x1f
 800eccc: 6839         	ldr	r1, [r7]
 800ecce: 4618         	mov	r0, r3
 800ecd0: f00e fd94    	bl	0x801d7fc <strncpy>     @ imm = #0xeb28
; 	thread->name[CONFIG_THREAD_MAX_NAME_LEN - 1] = '\0';
 800ecd4: 687b         	ldr	r3, [r7, #0x4]
 800ecd6: 2200         	movs	r2, #0x0
 800ecd8: f883 20b3    	strb.w	r2, [r3, #0xb3]
; 	return 0;
 800ecdc: 2300         	movs	r3, #0x0
; }
 800ecde: 4618         	mov	r0, r3
 800ece0: 3710         	adds	r7, #0x10
 800ece2: 46bd         	mov	sp, r7
 800ece4: bd80         	pop	{r7, pc}
 800ece6: bf00         	nop

0800ece8 <$d>:
 800ece8: f0 16 00 20  	.word	0x200016f0

0800ecec <setup_thread_stack>:
; {
 800ecec: b580         	push	{r7, lr}
 800ecee: b096         	sub	sp, #0x58
 800ecf0: af0a         	add	r7, sp, #0x28
 800ecf2: 60f8         	str	r0, [r7, #0xc]
 800ecf4: 60b9         	str	r1, [r7, #0x8]
 800ecf6: 607a         	str	r2, [r7, #0x4]
; 	size_t delta = 0;
 800ecf8: 2300         	movs	r3, #0x0
 800ecfa: 62fb         	str	r3, [r7, #0x2c]
; 		stack_obj_size = K_KERNEL_STACK_LEN(stack_size);
 800ecfc: 687b         	ldr	r3, [r7, #0x4]
 800ecfe: 3307         	adds	r3, #0x7
 800ed00: f023 0307    	bic	r3, r3, #0x7
 800ed04: 3307         	adds	r3, #0x7
 800ed06: f023 0307    	bic	r3, r3, #0x7
 800ed0a: 62bb         	str	r3, [r7, #0x28]
; 		stack_buf_start = K_KERNEL_STACK_BUFFER(stack);
 800ed0c: 68b8         	ldr	r0, [r7, #0x8]
 800ed0e: f00d fe77    	bl	0x801ca00 <K_KERNEL_STACK_BUFFER> @ imm = #0xdcee
 800ed12: 6278         	str	r0, [r7, #0x24]
; 		stack_buf_size = stack_obj_size - K_KERNEL_STACK_RESERVED;
 800ed14: 6abb         	ldr	r3, [r7, #0x28]
 800ed16: 623b         	str	r3, [r7, #0x20]
; 	stack_ptr = (char *)stack + stack_obj_size;
 800ed18: 68ba         	ldr	r2, [r7, #0x8]
 800ed1a: 6abb         	ldr	r3, [r7, #0x28]
 800ed1c: 4413         	add	r3, r2
 800ed1e: 61fb         	str	r3, [r7, #0x1c]
; 	LOG_DBG("stack %p for thread %p: obj_size=%zu buf_start=%p "
 800ed20: 2303         	movs	r3, #0x3
 800ed22: 2b03         	cmp	r3, #0x3
 800ed24: d924         	bls	0x800ed70 <setup_thread_stack+0x84> @ imm = #0x48
 800ed26: 2301         	movs	r3, #0x1
 800ed28: 76fb         	strb	r3, [r7, #0x1b]
 800ed2a: 7efb         	ldrb	r3, [r7, #0x1b]
 800ed2c: f083 0301    	eor	r3, r3, #0x1
 800ed30: b2db         	uxtb	r3, r3
 800ed32: 2b00         	cmp	r3, #0x0
 800ed34: d11c         	bne	0x800ed70 <setup_thread_stack+0x84> @ imm = #0x38
 800ed36: 4b22         	ldr	r3, [pc, #0x88]         @ 0x800edc0 <setup_thread_stack+0xd4>
 800ed38: 6819         	ldr	r1, [r3]
 800ed3a: 69fb         	ldr	r3, [r7, #0x1c]
 800ed3c: 9309         	str	r3, [sp, #0x24]
 800ed3e: 6a3b         	ldr	r3, [r7, #0x20]
 800ed40: 9308         	str	r3, [sp, #0x20]
 800ed42: 6a7b         	ldr	r3, [r7, #0x24]
 800ed44: 9307         	str	r3, [sp, #0x1c]
 800ed46: 6abb         	ldr	r3, [r7, #0x28]
 800ed48: 9306         	str	r3, [sp, #0x18]
 800ed4a: 68fb         	ldr	r3, [r7, #0xc]
 800ed4c: 9305         	str	r3, [sp, #0x14]
 800ed4e: 68bb         	ldr	r3, [r7, #0x8]
 800ed50: 9304         	str	r3, [sp, #0x10]
 800ed52: 4b1c         	ldr	r3, [pc, #0x70]         @ 0x800edc4 <setup_thread_stack+0xd8>
 800ed54: 9303         	str	r3, [sp, #0xc]
 800ed56: 4b1c         	ldr	r3, [pc, #0x70]         @ 0x800edc8 <setup_thread_stack+0xdc>
 800ed58: 9302         	str	r3, [sp, #0x8]
 800ed5a: 2308         	movs	r3, #0x8
 800ed5c: 9301         	str	r3, [sp, #0x4]
 800ed5e: 2300         	movs	r3, #0x0
 800ed60: 9300         	str	r3, [sp]
 800ed62: 2300         	movs	r3, #0x0
 800ed64: 2204         	movs	r2, #0x4
 800ed66: 2000         	movs	r0, #0x0
 800ed68: f00d feac    	bl	0x801cac4 <z_log_msg_runtime_create> @ imm = #0xdd58
 800ed6c: 2300         	movs	r3, #0x0
 800ed6e: 617b         	str	r3, [r7, #0x14]
; 	memset(stack_buf_start, 0xaa, stack_buf_size);
 800ed70: 6a3a         	ldr	r2, [r7, #0x20]
 800ed72: 21aa         	movs	r1, #0xaa
 800ed74: 6a78         	ldr	r0, [r7, #0x24]
 800ed76: f00e fd39    	bl	0x801d7ec <memset>      @ imm = #0xea72
; 	delta += arch_tls_stack_setup(new_thread, stack_ptr);
 800ed7a: 69f9         	ldr	r1, [r7, #0x1c]
 800ed7c: 68f8         	ldr	r0, [r7, #0xc]
 800ed7e: f006 fe9b    	bl	0x8015ab8 <arch_tls_stack_setup> @ imm = #0x6d36
 800ed82: 4602         	mov	r2, r0
 800ed84: 6afb         	ldr	r3, [r7, #0x2c]
 800ed86: 4413         	add	r3, r2
 800ed88: 62fb         	str	r3, [r7, #0x2c]
; 	delta = ROUND_UP(delta, ARCH_STACK_PTR_ALIGN);
 800ed8a: 6afb         	ldr	r3, [r7, #0x2c]
 800ed8c: 3307         	adds	r3, #0x7
 800ed8e: f023 0307    	bic	r3, r3, #0x7
 800ed92: 62fb         	str	r3, [r7, #0x2c]
; 	new_thread->stack_info.start = (uintptr_t)stack_buf_start;
 800ed94: 6a7a         	ldr	r2, [r7, #0x24]
 800ed96: 68fb         	ldr	r3, [r7, #0xc]
 800ed98: f8c3 20b4    	str.w	r2, [r3, #0xb4]
; 	new_thread->stack_info.size = stack_buf_size;
 800ed9c: 68fb         	ldr	r3, [r7, #0xc]
 800ed9e: 6a3a         	ldr	r2, [r7, #0x20]
 800eda0: f8c3 20b8    	str.w	r2, [r3, #0xb8]
; 	new_thread->stack_info.delta = delta;
 800eda4: 68fb         	ldr	r3, [r7, #0xc]
 800eda6: 6afa         	ldr	r2, [r7, #0x2c]
 800eda8: f8c3 20bc    	str.w	r2, [r3, #0xbc]
; 	stack_ptr -= delta;
 800edac: 6afb         	ldr	r3, [r7, #0x2c]
 800edae: 425b         	rsbs	r3, r3, #0
 800edb0: 69fa         	ldr	r2, [r7, #0x1c]
 800edb2: 4413         	add	r3, r2
 800edb4: 61fb         	str	r3, [r7, #0x1c]
; 	return stack_ptr;
 800edb6: 69fb         	ldr	r3, [r7, #0x1c]
; }
 800edb8: 4618         	mov	r0, r3
 800edba: 3730         	adds	r7, #0x30
 800edbc: 46bd         	mov	sp, r7
 800edbe: bd80         	pop	{r7, pc}

0800edc0 <$d>:
 800edc0: b4 05 00 20  	.word	0x200005b4
 800edc4: 34 07 02 08  	.word	0x08020734
 800edc8: 98 fa 01 08  	.word	0x0801fa98

0800edcc <z_setup_new_thread>:
; {
 800edcc: b580         	push	{r7, lr}
 800edce: b09c         	sub	sp, #0x70
 800edd0: af04         	add	r7, sp, #0x10
 800edd2: 60f8         	str	r0, [r7, #0xc]
 800edd4: 60b9         	str	r1, [r7, #0x8]
 800edd6: 607a         	str	r2, [r7, #0x4]
 800edd8: 603b         	str	r3, [r7]
; 	z_waitq_init(&new_thread->join_queue);
 800edda: 68fb         	ldr	r3, [r7, #0xc]
 800eddc: 3368         	adds	r3, #0x68
 800edde: 4618         	mov	r0, r3
 800ede0: f00d fe64    	bl	0x801caac <z_waitq_init> @ imm = #0xdcc8
; 	z_init_thread_base(&new_thread->base, prio, _THREAD_SUSPENDED, options);
 800ede4: 68f8         	ldr	r0, [r7, #0xc]
 800ede6: 6fbb         	ldr	r3, [r7, #0x78]
 800ede8: 2210         	movs	r2, #0x10
 800edea: 6f79         	ldr	r1, [r7, #0x74]
 800edec: f00d fed1    	bl	0x801cb92 <z_init_thread_base> @ imm = #0xdda2
; 	stack_ptr = setup_thread_stack(new_thread, stack, stack_size);
 800edf0: 687a         	ldr	r2, [r7, #0x4]
 800edf2: 68b9         	ldr	r1, [r7, #0x8]
 800edf4: 68f8         	ldr	r0, [r7, #0xc]
 800edf6: f7ff ff79    	bl	0x800ecec <setup_thread_stack> @ imm = #-0x10e
 800edfa: 65f8         	str	r0, [r7, #0x5c]
; 	arch_new_thread(new_thread, stack, stack_ptr, entry, p1, p2, p3);
 800edfc: 6f3b         	ldr	r3, [r7, #0x70]
 800edfe: 9302         	str	r3, [sp, #0x8]
 800ee00: 6efb         	ldr	r3, [r7, #0x6c]
 800ee02: 9301         	str	r3, [sp, #0x4]
 800ee04: 6ebb         	ldr	r3, [r7, #0x68]
 800ee06: 9300         	str	r3, [sp]
 800ee08: 683b         	ldr	r3, [r7]
 800ee0a: 6dfa         	ldr	r2, [r7, #0x5c]
 800ee0c: 68b9         	ldr	r1, [r7, #0x8]
 800ee0e: 68f8         	ldr	r0, [r7, #0xc]
 800ee10: f7f7 f878    	bl	0x8005f04 <arch_new_thread> @ imm = #-0x8f10
; 	new_thread->init_data = NULL;
 800ee14: 68fb         	ldr	r3, [r7, #0xc]
 800ee16: 2200         	movs	r2, #0x0
 800ee18: 665a         	str	r2, [r3, #0x64]
; 	new_thread->no_wake_on_timeout = false;
 800ee1a: 68fb         	ldr	r3, [r7, #0xc]
 800ee1c: 2200         	movs	r2, #0x0
 800ee1e: f883 207c    	strb.w	r2, [r3, #0x7c]
; 	new_thread->entry.pEntry = entry;
 800ee22: 68fb         	ldr	r3, [r7, #0xc]
 800ee24: 683a         	ldr	r2, [r7]
 800ee26: f8c3 2080    	str.w	r2, [r3, #0x80]
; 	new_thread->entry.parameter1 = p1;
 800ee2a: 68fb         	ldr	r3, [r7, #0xc]
 800ee2c: 6eba         	ldr	r2, [r7, #0x68]
 800ee2e: f8c3 2084    	str.w	r2, [r3, #0x84]
; 	new_thread->entry.parameter2 = p2;
 800ee32: 68fb         	ldr	r3, [r7, #0xc]
 800ee34: 6efa         	ldr	r2, [r7, #0x6c]
 800ee36: f8c3 2088    	str.w	r2, [r3, #0x88]
; 	new_thread->entry.parameter3 = p3;
 800ee3a: 68fb         	ldr	r3, [r7, #0xc]
 800ee3c: 6f3a         	ldr	r2, [r7, #0x70]
 800ee3e: f8c3 208c    	str.w	r2, [r3, #0x8c]
 800ee42: 4b35         	ldr	r3, [pc, #0xd4]         @ 0x800ef18 <z_setup_new_thread+0x14c>
 800ee44: 64fb         	str	r3, [r7, #0x4c]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800ee46: f3ef 8311    	mrs	r3, basepri
 800ee4a: 64bb         	str	r3, [r7, #0x48]
;   return(result);
 800ee4c: 6cbb         	ldr	r3, [r7, #0x48]
; 	key = __get_BASEPRI();
 800ee4e: 647b         	str	r3, [r7, #0x44]
 800ee50: 2310         	movs	r3, #0x10
 800ee52: 643b         	str	r3, [r7, #0x40]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 800ee54: 6c3b         	ldr	r3, [r7, #0x40]
 800ee56: f383 8812    	msr	basepri_max, r3
; }
 800ee5a: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800ee5c: f3bf 8f6f    	isb	sy
; }
 800ee60: bf00         	nop
; 	return key;
 800ee62: 6c7b         	ldr	r3, [r7, #0x44]
; 	k.key = arch_irq_lock();
 800ee64: 617b         	str	r3, [r7, #0x14]
 800ee66: 6cfb         	ldr	r3, [r7, #0x4c]
 800ee68: 63fb         	str	r3, [r7, #0x3c]
; }
 800ee6a: bf00         	nop
 800ee6c: 6cfb         	ldr	r3, [r7, #0x4c]
 800ee6e: 63bb         	str	r3, [r7, #0x38]
; }
 800ee70: bf00         	nop
; 	return k;
 800ee72: 697b         	ldr	r3, [r7, #0x14]
 800ee74: 62fb         	str	r3, [r7, #0x2c]
; 	new_thread->next_thread = _kernel.threads;
 800ee76: 4b29         	ldr	r3, [pc, #0xa4]         @ 0x800ef1c <z_setup_new_thread+0x150>
 800ee78: 6a9a         	ldr	r2, [r3, #0x28]
 800ee7a: 68fb         	ldr	r3, [r7, #0xc]
 800ee7c: f8c3 2090    	str.w	r2, [r3, #0x90]
; 	_kernel.threads = new_thread;
 800ee80: 4a26         	ldr	r2, [pc, #0x98]         @ 0x800ef1c <z_setup_new_thread+0x150>
 800ee82: 68fb         	ldr	r3, [r7, #0xc]
 800ee84: 6293         	str	r3, [r2, #0x28]
 800ee86: 4b24         	ldr	r3, [pc, #0x90]         @ 0x800ef18 <z_setup_new_thread+0x14c>
 800ee88: 65bb         	str	r3, [r7, #0x58]
 800ee8a: 6afb         	ldr	r3, [r7, #0x2c]
 800ee8c: 613b         	str	r3, [r7, #0x10]
; 	arch_irq_unlock(key.key);
 800ee8e: 693b         	ldr	r3, [r7, #0x10]
 800ee90: 657b         	str	r3, [r7, #0x54]
 800ee92: 6d7b         	ldr	r3, [r7, #0x54]
 800ee94: 653b         	str	r3, [r7, #0x50]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800ee96: 6d3b         	ldr	r3, [r7, #0x50]
 800ee98: f383 8811    	msr	basepri, r3
; }
 800ee9c: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800ee9e: f3bf 8f6f    	isb	sy
; }
 800eea2: bf00         	nop
; }
 800eea4: bf00         	nop
; }
 800eea6: bf00         	nop
; 	if (name != NULL) {
 800eea8: 6ffb         	ldr	r3, [r7, #0x7c]
 800eeaa: 2b00         	cmp	r3, #0x0
 800eeac: d00b         	beq	0x800eec6 <z_setup_new_thread+0xfa> @ imm = #0x16
; 		strncpy(new_thread->name, name,
 800eeae: 68fb         	ldr	r3, [r7, #0xc]
 800eeb0: 3394         	adds	r3, #0x94
 800eeb2: 221f         	movs	r2, #0x1f
 800eeb4: 6ff9         	ldr	r1, [r7, #0x7c]
 800eeb6: 4618         	mov	r0, r3
 800eeb8: f00e fca0    	bl	0x801d7fc <strncpy>     @ imm = #0xe940
; 		new_thread->name[CONFIG_THREAD_MAX_NAME_LEN - 1] = '\0';
 800eebc: 68fb         	ldr	r3, [r7, #0xc]
 800eebe: 2200         	movs	r2, #0x0
 800eec0: f883 20b3    	strb.w	r2, [r3, #0xb3]
 800eec4: e003         	b	0x800eece <z_setup_new_thread+0x102> @ imm = #0x6
; 		new_thread->name[0] = '\0';
 800eec6: 68fb         	ldr	r3, [r7, #0xc]
 800eec8: 2200         	movs	r2, #0x0
 800eeca: f883 2094    	strb.w	r2, [r3, #0x94]
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800eece: 4b13         	ldr	r3, [pc, #0x4c]         @ 0x800ef1c <z_setup_new_thread+0x150>
 800eed0: 689b         	ldr	r3, [r3, #0x8]
 800eed2: 637b         	str	r3, [r7, #0x34]
; 	return ret;
 800eed4: 6b7b         	ldr	r3, [r7, #0x34]
; 	if (!arch_current_thread()) {
 800eed6: 2b00         	cmp	r3, #0x0
 800eed8: d105         	bne	0x800eee6 <z_setup_new_thread+0x11a> @ imm = #0xa
; 		new_thread->resource_pool = NULL;
 800eeda: 68fb         	ldr	r3, [r7, #0xc]
 800eedc: 2200         	movs	r2, #0x0
 800eede: f8c3 20c0    	str.w	r2, [r3, #0xc0]
; 		return stack_ptr;
 800eee2: 6dfb         	ldr	r3, [r7, #0x5c]
 800eee4: e014         	b	0x800ef10 <z_setup_new_thread+0x144> @ imm = #0x28
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800eee6: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x800ef1c <z_setup_new_thread+0x150>
 800eee8: 689b         	ldr	r3, [r3, #0x8]
 800eeea: 633b         	str	r3, [r7, #0x30]
; 	return ret;
 800eeec: 6b3b         	ldr	r3, [r7, #0x30]
; 	new_thread->resource_pool = arch_current_thread()->resource_pool;
 800eeee: f8d3 20c0    	ldr.w	r2, [r3, #0xc0]
 800eef2: 68fb         	ldr	r3, [r7, #0xc]
 800eef4: f8c3 20c0    	str.w	r2, [r3, #0xc0]
; 	new_thread->base.usage = (struct k_cycle_stats) {};
 800eef8: 68fb         	ldr	r3, [r7, #0xc]
 800eefa: 3330         	adds	r3, #0x30
 800eefc: 2200         	movs	r2, #0x0
 800eefe: 601a         	str	r2, [r3]
 800ef00: 605a         	str	r2, [r3, #0x4]
 800ef02: 609a         	str	r2, [r3, #0x8]
 800ef04: 60da         	str	r2, [r3, #0xc]
; 	new_thread->base.usage.track_usage =
 800ef06: 68fb         	ldr	r3, [r7, #0xc]
 800ef08: 2201         	movs	r2, #0x1
 800ef0a: f883 2038    	strb.w	r2, [r3, #0x38]
; 	return stack_ptr;
 800ef0e: 6dfb         	ldr	r3, [r7, #0x5c]
; }
 800ef10: 4618         	mov	r0, r3
 800ef12: 3760         	adds	r7, #0x60
 800ef14: 46bd         	mov	sp, r7
 800ef16: bd80         	pop	{r7, pc}

0800ef18 <$d>:
 800ef18: 80 1f 00 20  	.word	0x20001f80
 800ef1c: f0 16 00 20  	.word	0x200016f0

0800ef20 <z_thread_mark_switched_in>:
; {
 800ef20: b580         	push	{r7, lr}
 800ef22: b082         	sub	sp, #0x8
 800ef24: af00         	add	r7, sp, #0x0
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800ef26: 4b05         	ldr	r3, [pc, #0x14]         @ 0x800ef3c <z_thread_mark_switched_in+0x1c>
 800ef28: 689b         	ldr	r3, [r3, #0x8]
 800ef2a: 607b         	str	r3, [r7, #0x4]
; 	return ret;
 800ef2c: 687b         	ldr	r3, [r7, #0x4]
; 	z_sched_usage_start(arch_current_thread());
 800ef2e: 4618         	mov	r0, r3
 800ef30: f002 f90e    	bl	0x8011150 <z_sched_usage_start> @ imm = #0x221c
; }
 800ef34: bf00         	nop
 800ef36: 3708         	adds	r7, #0x8
 800ef38: 46bd         	mov	sp, r7
 800ef3a: bd80         	pop	{r7, pc}

0800ef3c <$d>:
 800ef3c: f0 16 00 20  	.word	0x200016f0

0800ef40 <z_add_thread_timeout>:
; {
 800ef40: b580         	push	{r7, lr}
 800ef42: b084         	sub	sp, #0x10
 800ef44: af00         	add	r7, sp, #0x0
 800ef46: 60f8         	str	r0, [r7, #0xc]
 800ef48: e9c7 2300    	strd	r2, r3, [r7]
; 	z_add_timeout(&thread->base.timeout, z_thread_timeout, ticks);
 800ef4c: 68fb         	ldr	r3, [r7, #0xc]
 800ef4e: f103 0018    	add.w	r0, r3, #0x18
 800ef52: e9d7 2300    	ldrd	r2, r3, [r7]
 800ef56: 4903         	ldr	r1, [pc, #0xc]          @ 0x800ef64 <z_add_thread_timeout+0x24>
 800ef58: f001 fe68    	bl	0x8010c2c <z_add_timeout> @ imm = #0x1cd0
; }
 800ef5c: bf00         	nop
 800ef5e: 3710         	adds	r7, #0x10
 800ef60: 46bd         	mov	sp, r7
 800ef62: bd80         	pop	{r7, pc}

0800ef64 <$d>:
 800ef64: 5f d2 01 08  	.word	0x0801d25f

0800ef68 <z_sched_lock>:
; {
 800ef68: b480         	push	{r7}
 800ef6a: b083         	sub	sp, #0xc
 800ef6c: af00         	add	r7, sp, #0x0
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800ef6e: 4b06         	ldr	r3, [pc, #0x18]         @ 0x800ef88 <z_sched_lock+0x20>
 800ef70: 689b         	ldr	r3, [r3, #0x8]
 800ef72: 607b         	str	r3, [r7, #0x4]
; 	return ret;
 800ef74: 687b         	ldr	r3, [r7, #0x4]
; 	--arch_current_thread()->base.sched_locked;
 800ef76: 7bda         	ldrb	r2, [r3, #0xf]
 800ef78: 3a01         	subs	r2, #0x1
 800ef7a: b2d2         	uxtb	r2, r2
 800ef7c: 73da         	strb	r2, [r3, #0xf]
; }
 800ef7e: bf00         	nop
 800ef80: 370c         	adds	r7, #0xc
 800ef82: 46bd         	mov	sp, r7
 800ef84: bc80         	pop	{r7}
 800ef86: 4770         	bx	lr

0800ef88 <$d>:
 800ef88: f0 16 00 20  	.word	0x200016f0

0800ef8c <z_dummy_thread_init>:
; {
 800ef8c: b480         	push	{r7}
 800ef8e: b085         	sub	sp, #0x14
 800ef90: af00         	add	r7, sp, #0x0
 800ef92: 6078         	str	r0, [r7, #0x4]
; 	dummy_thread->base.thread_state = _THREAD_DUMMY;
 800ef94: 687b         	ldr	r3, [r7, #0x4]
 800ef96: 2201         	movs	r2, #0x1
 800ef98: 735a         	strb	r2, [r3, #0xd]
; 	dummy_thread->base.user_options = K_ESSENTIAL;
 800ef9a: 687b         	ldr	r3, [r7, #0x4]
 800ef9c: 2201         	movs	r2, #0x1
 800ef9e: 731a         	strb	r2, [r3, #0xc]
; 	dummy_thread->stack_info.start = 0U;
 800efa0: 687b         	ldr	r3, [r7, #0x4]
 800efa2: 2200         	movs	r2, #0x0
 800efa4: f8c3 20b4    	str.w	r2, [r3, #0xb4]
; 	dummy_thread->stack_info.size = 0U;
 800efa8: 687b         	ldr	r3, [r7, #0x4]
 800efaa: 2200         	movs	r2, #0x0
 800efac: f8c3 20b8    	str.w	r2, [r3, #0xb8]
; 	dummy_thread->resource_pool = NULL;
 800efb0: 687b         	ldr	r3, [r7, #0x4]
 800efb2: 2200         	movs	r2, #0x0
 800efb4: f8c3 20c0    	str.w	r2, [r3, #0xc0]
 800efb8: 687b         	ldr	r3, [r7, #0x4]
 800efba: 60fb         	str	r3, [r7, #0xc]
; 	_current_cpu->current = thread;
 800efbc: 4a04         	ldr	r2, [pc, #0x10]         @ 0x800efd0 <z_dummy_thread_init+0x44>
 800efbe: 68fb         	ldr	r3, [r7, #0xc]
 800efc0: 6093         	str	r3, [r2, #0x8]
; }
 800efc2: bf00         	nop
; }
 800efc4: bf00         	nop
 800efc6: 3714         	adds	r7, #0x14
 800efc8: 46bd         	mov	sp, r7
 800efca: bc80         	pop	{r7}
 800efcc: 4770         	bx	lr
 800efce: bf00         	nop

0800efd0 <$d>:
 800efd0: f0 16 00 20  	.word	0x200016f0

0800efd4 <move_thread_to_end_of_prio_q>:
; {
 800efd4: b580         	push	{r7, lr}
 800efd6: b09a         	sub	sp, #0x68
 800efd8: af00         	add	r7, sp, #0x0
 800efda: 6078         	str	r0, [r7, #0x4]
; 	if (z_is_thread_queued(thread)) {
 800efdc: 6878         	ldr	r0, [r7, #0x4]
 800efde: f00d ff82    	bl	0x801cee6 <z_is_thread_queued> @ imm = #0xdf04
 800efe2: 4603         	mov	r3, r0
 800efe4: 2b00         	cmp	r3, #0x0
 800efe6: d01d         	beq	0x800f024 <move_thread_to_end_of_prio_q+0x50> @ imm = #0x3a
 800efe8: 687b         	ldr	r3, [r7, #0x4]
 800efea: 667b         	str	r3, [r7, #0x64]
; 	thread->base.thread_state &= ~_THREAD_QUEUED;
 800efec: 6e7b         	ldr	r3, [r7, #0x64]
 800efee: 7b5b         	ldrb	r3, [r3, #0xd]
 800eff0: f003 037f    	and	r3, r3, #0x7f
 800eff4: b2da         	uxtb	r2, r3
 800eff6: 6e7b         	ldr	r3, [r7, #0x64]
 800eff8: 735a         	strb	r2, [r3, #0xd]
; 	if (should_queue_thread(thread)) {
 800effa: 6e78         	ldr	r0, [r7, #0x64]
 800effc: f00e f858    	bl	0x801d0b0 <should_queue_thread> @ imm = #0xe0b0
 800f000: 4603         	mov	r3, r0
 800f002: 2b00         	cmp	r3, #0x0
 800f004: d00d         	beq	0x800f022 <move_thread_to_end_of_prio_q+0x4e> @ imm = #0x1a
 800f006: 6e7b         	ldr	r3, [r7, #0x64]
 800f008: 663b         	str	r3, [r7, #0x60]
 800f00a: 6e3b         	ldr	r3, [r7, #0x60]
 800f00c: 65fb         	str	r3, [r7, #0x5c]
; 	return &_kernel.ready_q.runq;
 800f00e: 4b67         	ldr	r3, [pc, #0x19c]        @ 0x800f1ac <move_thread_to_end_of_prio_q+0x1d8>
 800f010: 65bb         	str	r3, [r7, #0x58]
 800f012: 6e3b         	ldr	r3, [r7, #0x60]
 800f014: 657b         	str	r3, [r7, #0x54]
; 	sys_dlist_remove(&thread->base.qnode_dlist);
 800f016: 6d7b         	ldr	r3, [r7, #0x54]
 800f018: 4618         	mov	r0, r3
 800f01a: f00d fe89    	bl	0x801cd30 <sys_dlist_remove> @ imm = #0xdd12
; }
 800f01e: bf00         	nop
; }
 800f020: bf00         	nop
; }
 800f022: bf00         	nop
 800f024: 687b         	ldr	r3, [r7, #0x4]
 800f026: 61fb         	str	r3, [r7, #0x1c]
; 	thread->base.thread_state |= _THREAD_QUEUED;
 800f028: 69fb         	ldr	r3, [r7, #0x1c]
 800f02a: 7b5b         	ldrb	r3, [r3, #0xd]
 800f02c: f063 037f    	orn	r3, r3, #0x7f
 800f030: b2da         	uxtb	r2, r3
 800f032: 69fb         	ldr	r3, [r7, #0x1c]
 800f034: 735a         	strb	r2, [r3, #0xd]
; 	if (should_queue_thread(thread)) {
 800f036: 69f8         	ldr	r0, [r7, #0x1c]
 800f038: f00e f83a    	bl	0x801d0b0 <should_queue_thread> @ imm = #0xe074
 800f03c: 4603         	mov	r3, r0
 800f03e: 2b00         	cmp	r3, #0x0
 800f040: d042         	beq	0x800f0c8 <move_thread_to_end_of_prio_q+0xf4> @ imm = #0x84
 800f042: 69fb         	ldr	r3, [r7, #0x1c]
 800f044: 61bb         	str	r3, [r7, #0x18]
 800f046: 69bb         	ldr	r3, [r7, #0x18]
 800f048: 617b         	str	r3, [r7, #0x14]
; 	return &_kernel.ready_q.runq;
 800f04a: 4b58         	ldr	r3, [pc, #0x160]        @ 0x800f1ac <move_thread_to_end_of_prio_q+0x1d8>
 800f04c: 613b         	str	r3, [r7, #0x10]
 800f04e: 69bb         	ldr	r3, [r7, #0x18]
 800f050: 60fb         	str	r3, [r7, #0xc]
; 	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
 800f052: 6938         	ldr	r0, [r7, #0x10]
 800f054: f00d fe02    	bl	0x801cc5c <sys_dlist_peek_head> @ imm = #0xdc04
 800f058: 4603         	mov	r3, r0
 800f05a: 2b00         	cmp	r3, #0x0
 800f05c: d004         	beq	0x800f068 <move_thread_to_end_of_prio_q+0x94> @ imm = #0x8
 800f05e: 6938         	ldr	r0, [r7, #0x10]
 800f060: f00d fdfc    	bl	0x801cc5c <sys_dlist_peek_head> @ imm = #0xdbf8
 800f064: 4603         	mov	r3, r0
 800f066: e000         	b	0x800f06a <move_thread_to_end_of_prio_q+0x96> @ imm = #0x0
 800f068: 2300         	movs	r3, #0x0
 800f06a: 60bb         	str	r3, [r7, #0x8]
 800f06c: e023         	b	0x800f0b6 <move_thread_to_end_of_prio_q+0xe2> @ imm = #0x46
; 		if (z_sched_prio_cmp(thread, t) > 0) {
 800f06e: 68b9         	ldr	r1, [r7, #0x8]
 800f070: 68f8         	ldr	r0, [r7, #0xc]
 800f072: f00e f802    	bl	0x801d07a <z_sched_prio_cmp> @ imm = #0xe004
 800f076: 4603         	mov	r3, r0
 800f078: 2b00         	cmp	r3, #0x0
 800f07a: dd06         	ble	0x800f08a <move_thread_to_end_of_prio_q+0xb6> @ imm = #0xc
; 			sys_dlist_insert(&t->base.qnode_dlist,
 800f07c: 68bb         	ldr	r3, [r7, #0x8]
 800f07e: 68fa         	ldr	r2, [r7, #0xc]
 800f080: 4611         	mov	r1, r2
 800f082: 4618         	mov	r0, r3
 800f084: f00d fe3b    	bl	0x801ccfe <sys_dlist_insert> @ imm = #0xdc76
; 			return;
 800f088: e01d         	b	0x800f0c6 <move_thread_to_end_of_prio_q+0xf2> @ imm = #0x3a
; 	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
 800f08a: 68bb         	ldr	r3, [r7, #0x8]
 800f08c: 2b00         	cmp	r3, #0x0
 800f08e: d010         	beq	0x800f0b2 <move_thread_to_end_of_prio_q+0xde> @ imm = #0x20
 800f090: 68bb         	ldr	r3, [r7, #0x8]
 800f092: 4619         	mov	r1, r3
 800f094: 6938         	ldr	r0, [r7, #0x10]
 800f096: f00d fe06    	bl	0x801cca6 <sys_dlist_peek_next> @ imm = #0xdc0c
 800f09a: 4603         	mov	r3, r0
 800f09c: 2b00         	cmp	r3, #0x0
 800f09e: d006         	beq	0x800f0ae <move_thread_to_end_of_prio_q+0xda> @ imm = #0xc
 800f0a0: 68bb         	ldr	r3, [r7, #0x8]
 800f0a2: 4619         	mov	r1, r3
 800f0a4: 6938         	ldr	r0, [r7, #0x10]
 800f0a6: f00d fdfe    	bl	0x801cca6 <sys_dlist_peek_next> @ imm = #0xdbfc
 800f0aa: 4603         	mov	r3, r0
 800f0ac: e002         	b	0x800f0b4 <move_thread_to_end_of_prio_q+0xe0> @ imm = #0x4
 800f0ae: 2300         	movs	r3, #0x0
 800f0b0: e000         	b	0x800f0b4 <move_thread_to_end_of_prio_q+0xe0> @ imm = #0x0
 800f0b2: 2300         	movs	r3, #0x0
 800f0b4: 60bb         	str	r3, [r7, #0x8]
 800f0b6: 68bb         	ldr	r3, [r7, #0x8]
 800f0b8: 2b00         	cmp	r3, #0x0
 800f0ba: d1d8         	bne	0x800f06e <move_thread_to_end_of_prio_q+0x9a> @ imm = #-0x50
; 	sys_dlist_append(pq, &thread->base.qnode_dlist);
 800f0bc: 68fb         	ldr	r3, [r7, #0xc]
 800f0be: 4619         	mov	r1, r3
 800f0c0: 6938         	ldr	r0, [r7, #0x10]
 800f0c2: f00d fe03    	bl	0x801cccc <sys_dlist_append> @ imm = #0xdc06
; }
 800f0c6: bf00         	nop
; }
 800f0c8: bf00         	nop
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800f0ca: 4b39         	ldr	r3, [pc, #0xe4]         @ 0x800f1b0 <move_thread_to_end_of_prio_q+0x1dc>
 800f0cc: 689b         	ldr	r3, [r3, #0x8]
 800f0ce: 623b         	str	r3, [r7, #0x20]
; 	return ret;
 800f0d0: 6a3b         	ldr	r3, [r7, #0x20]
; 	update_cache(thread == arch_current_thread());
 800f0d2: 687a         	ldr	r2, [r7, #0x4]
 800f0d4: 429a         	cmp	r2, r3
 800f0d6: bf0c         	ite	eq
 800f0d8: 2301         	moveq	r3, #0x1
 800f0da: 2300         	movne	r3, #0x0
 800f0dc: b2db         	uxtb	r3, r3
 800f0de: 653b         	str	r3, [r7, #0x50]
; 	return &_kernel.ready_q.runq;
 800f0e0: 4b32         	ldr	r3, [pc, #0xc8]         @ 0x800f1ac <move_thread_to_end_of_prio_q+0x1d8>
 800f0e2: 64fb         	str	r3, [r7, #0x4c]
; 	struct k_thread *thread = NULL;
 800f0e4: 2300         	movs	r3, #0x0
 800f0e6: 64bb         	str	r3, [r7, #0x48]
; 	sys_dnode_t *n = sys_dlist_peek_head(pq);
 800f0e8: 6cf8         	ldr	r0, [r7, #0x4c]
 800f0ea: f00d fdb7    	bl	0x801cc5c <sys_dlist_peek_head> @ imm = #0xdb6e
 800f0ee: 6478         	str	r0, [r7, #0x44]
; 	if (n != NULL) {
 800f0f0: 6c7b         	ldr	r3, [r7, #0x44]
 800f0f2: 2b00         	cmp	r3, #0x0
 800f0f4: d001         	beq	0x800f0fa <move_thread_to_end_of_prio_q+0x126> @ imm = #0x2
; 		thread = CONTAINER_OF(n, struct k_thread, base.qnode_dlist);
 800f0f6: 6c7b         	ldr	r3, [r7, #0x44]
 800f0f8: 64bb         	str	r3, [r7, #0x48]
; 	return thread;
 800f0fa: 6cbb         	ldr	r3, [r7, #0x48]
; 	return _priq_run_best(curr_cpu_runq());
 800f0fc: bf00         	nop
; 	struct k_thread *thread = runq_best();
 800f0fe: 643b         	str	r3, [r7, #0x40]
; 	return (thread != NULL) ? thread : _current_cpu->idle_thread;
 800f100: 6c3b         	ldr	r3, [r7, #0x40]
 800f102: 2b00         	cmp	r3, #0x0
 800f104: d102         	bne	0x800f10c <move_thread_to_end_of_prio_q+0x138> @ imm = #0x4
 800f106: 4b2a         	ldr	r3, [pc, #0xa8]         @ 0x800f1b0 <move_thread_to_end_of_prio_q+0x1dc>
 800f108: 68db         	ldr	r3, [r3, #0xc]
 800f10a: e000         	b	0x800f10e <move_thread_to_end_of_prio_q+0x13a> @ imm = #0x0
 800f10c: 6c3b         	ldr	r3, [r7, #0x40]
; 	struct k_thread *thread = next_up();
 800f10e: 63fb         	str	r3, [r7, #0x3c]
 800f110: 6bfb         	ldr	r3, [r7, #0x3c]
 800f112: 63bb         	str	r3, [r7, #0x38]
 800f114: 6d3b         	ldr	r3, [r7, #0x50]
 800f116: 637b         	str	r3, [r7, #0x34]
; 	if (preempt_ok != 0) {
 800f118: 6b7b         	ldr	r3, [r7, #0x34]
 800f11a: 2b00         	cmp	r3, #0x0
 800f11c: d001         	beq	0x800f122 <move_thread_to_end_of_prio_q+0x14e> @ imm = #0x2
; 		return true;
 800f11e: 2301         	movs	r3, #0x1
 800f120: e026         	b	0x800f170 <move_thread_to_end_of_prio_q+0x19c> @ imm = #0x4c
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800f122: 4b23         	ldr	r3, [pc, #0x8c]         @ 0x800f1b0 <move_thread_to_end_of_prio_q+0x1dc>
 800f124: 689b         	ldr	r3, [r3, #0x8]
 800f126: 633b         	str	r3, [r7, #0x30]
; 	return ret;
 800f128: 6b3b         	ldr	r3, [r7, #0x30]
; 	if (z_is_thread_prevented_from_running(arch_current_thread())) {
 800f12a: 4618         	mov	r0, r3
 800f12c: f00d fe7a    	bl	0x801ce24 <z_is_thread_prevented_from_running> @ imm = #0xdcf4
 800f130: 4603         	mov	r3, r0
 800f132: 2b00         	cmp	r3, #0x0
 800f134: d001         	beq	0x800f13a <move_thread_to_end_of_prio_q+0x166> @ imm = #0x2
; 		return true;
 800f136: 2301         	movs	r3, #0x1
 800f138: e01a         	b	0x800f170 <move_thread_to_end_of_prio_q+0x19c> @ imm = #0x34
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800f13a: 4b1d         	ldr	r3, [pc, #0x74]         @ 0x800f1b0 <move_thread_to_end_of_prio_q+0x1dc>
 800f13c: 689b         	ldr	r3, [r3, #0x8]
 800f13e: 62fb         	str	r3, [r7, #0x2c]
; 	return ret;
 800f140: 6afb         	ldr	r3, [r7, #0x2c]
; 	if (thread_is_preemptible(arch_current_thread()) || thread_is_metairq(thread)) {
 800f142: 4618         	mov	r0, r3
 800f144: f00d fe42    	bl	0x801cdcc <thread_is_preemptible> @ imm = #0xdc84
 800f148: 4603         	mov	r3, r0
 800f14a: 2b00         	cmp	r3, #0x0
 800f14c: d105         	bne	0x800f15a <move_thread_to_end_of_prio_q+0x186> @ imm = #0xa
 800f14e: 6bb8         	ldr	r0, [r7, #0x38]
 800f150: f00d fe4c    	bl	0x801cdec <thread_is_metairq> @ imm = #0xdc98
 800f154: 4603         	mov	r3, r0
 800f156: 2b00         	cmp	r3, #0x0
 800f158: d001         	beq	0x800f15e <move_thread_to_end_of_prio_q+0x18a> @ imm = #0x2
; 		return true;
 800f15a: 2301         	movs	r3, #0x1
 800f15c: e008         	b	0x800f170 <move_thread_to_end_of_prio_q+0x19c> @ imm = #0x10
; 	    && z_is_thread_timeout_active(thread)) {
 800f15e: 6bb8         	ldr	r0, [r7, #0x38]
 800f160: f00d fe74    	bl	0x801ce4c <z_is_thread_timeout_active> @ imm = #0xdce8
 800f164: 4603         	mov	r3, r0
; 	if (IS_ENABLED(CONFIG_SWAP_NONATOMIC)
 800f166: 2b00         	cmp	r3, #0x0
 800f168: d001         	beq	0x800f16e <move_thread_to_end_of_prio_q+0x19a> @ imm = #0x2
; 		return true;
 800f16a: 2301         	movs	r3, #0x1
 800f16c: e000         	b	0x800f170 <move_thread_to_end_of_prio_q+0x19c> @ imm = #0x0
; 	return false;
 800f16e: 2300         	movs	r3, #0x0
; 	if (should_preempt(thread, preempt_ok)) {
 800f170: 2b00         	cmp	r3, #0x0
 800f172: d010         	beq	0x800f196 <move_thread_to_end_of_prio_q+0x1c2> @ imm = #0x20
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800f174: 4b0e         	ldr	r3, [pc, #0x38]         @ 0x800f1b0 <move_thread_to_end_of_prio_q+0x1dc>
 800f176: 689b         	ldr	r3, [r3, #0x8]
 800f178: 62bb         	str	r3, [r7, #0x28]
; 	return ret;
 800f17a: 6abb         	ldr	r3, [r7, #0x28]
; 		if (thread != arch_current_thread()) {
 800f17c: 6bfa         	ldr	r2, [r7, #0x3c]
 800f17e: 429a         	cmp	r2, r3
 800f180: d002         	beq	0x800f188 <move_thread_to_end_of_prio_q+0x1b4> @ imm = #0x4
; 			z_reset_time_slice(thread);
 800f182: 6bf8         	ldr	r0, [r7, #0x3c]
 800f184: f001 fbee    	bl	0x8010964 <z_reset_time_slice> @ imm = #0x17dc
; 		update_metairq_preempt(thread);
 800f188: 6bf8         	ldr	r0, [r7, #0x3c]
 800f18a: f00d ffd4    	bl	0x801d136 <update_metairq_preempt> @ imm = #0xdfa8
; 		_kernel.ready_q.cache = thread;
 800f18e: 4a08         	ldr	r2, [pc, #0x20]         @ 0x800f1b0 <move_thread_to_end_of_prio_q+0x1dc>
 800f190: 6bfb         	ldr	r3, [r7, #0x3c]
 800f192: 61d3         	str	r3, [r2, #0x1c]
; }
 800f194: e005         	b	0x800f1a2 <move_thread_to_end_of_prio_q+0x1ce> @ imm = #0xa
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800f196: 4b06         	ldr	r3, [pc, #0x18]         @ 0x800f1b0 <move_thread_to_end_of_prio_q+0x1dc>
 800f198: 689b         	ldr	r3, [r3, #0x8]
 800f19a: 627b         	str	r3, [r7, #0x24]
; 	return ret;
 800f19c: 6a7b         	ldr	r3, [r7, #0x24]
; 		_kernel.ready_q.cache = arch_current_thread();
 800f19e: 4a04         	ldr	r2, [pc, #0x10]         @ 0x800f1b0 <move_thread_to_end_of_prio_q+0x1dc>
 800f1a0: 61d3         	str	r3, [r2, #0x1c]
; }
 800f1a2: bf00         	nop
; }
 800f1a4: bf00         	nop
 800f1a6: 3768         	adds	r7, #0x68
 800f1a8: 46bd         	mov	sp, r7
 800f1aa: bd80         	pop	{r7, pc}

0800f1ac <$d>:
 800f1ac: 10 17 00 20  	.word	0x20001710
 800f1b0: f0 16 00 20  	.word	0x200016f0

0800f1b4 <ready_thread>:
; {
 800f1b4: b580         	push	{r7, lr}
 800f1b6: b094         	sub	sp, #0x50
 800f1b8: af00         	add	r7, sp, #0x0
 800f1ba: 6078         	str	r0, [r7, #0x4]
; 	if (!z_is_thread_queued(thread) && z_is_thread_ready(thread)) {
 800f1bc: 6878         	ldr	r0, [r7, #0x4]
 800f1be: f00d fe92    	bl	0x801cee6 <z_is_thread_queued> @ imm = #0xdd24
 800f1c2: 4603         	mov	r3, r0
 800f1c4: f083 0301    	eor	r3, r3, #0x1
 800f1c8: b2db         	uxtb	r3, r3
 800f1ca: 2b00         	cmp	r3, #0x0
 800f1cc: f000 80be    	beq.w	0x800f34c <ready_thread+0x198> @ imm = #0x17c
 800f1d0: 6878         	ldr	r0, [r7, #0x4]
 800f1d2: f00d fe54    	bl	0x801ce7e <z_is_thread_ready> @ imm = #0xdca8
 800f1d6: 4603         	mov	r3, r0
 800f1d8: 2b00         	cmp	r3, #0x0
 800f1da: f000 80b7    	beq.w	0x800f34c <ready_thread+0x198> @ imm = #0x16e
 800f1de: 687b         	ldr	r3, [r7, #0x4]
 800f1e0: 61fb         	str	r3, [r7, #0x1c]
; 	thread->base.thread_state |= _THREAD_QUEUED;
 800f1e2: 69fb         	ldr	r3, [r7, #0x1c]
 800f1e4: 7b5b         	ldrb	r3, [r3, #0xd]
 800f1e6: f063 037f    	orn	r3, r3, #0x7f
 800f1ea: b2da         	uxtb	r2, r3
 800f1ec: 69fb         	ldr	r3, [r7, #0x1c]
 800f1ee: 735a         	strb	r2, [r3, #0xd]
; 	if (should_queue_thread(thread)) {
 800f1f0: 69f8         	ldr	r0, [r7, #0x1c]
 800f1f2: f00d ff5d    	bl	0x801d0b0 <should_queue_thread> @ imm = #0xdeba
 800f1f6: 4603         	mov	r3, r0
 800f1f8: 2b00         	cmp	r3, #0x0
 800f1fa: d042         	beq	0x800f282 <ready_thread+0xce> @ imm = #0x84
 800f1fc: 69fb         	ldr	r3, [r7, #0x1c]
 800f1fe: 61bb         	str	r3, [r7, #0x18]
 800f200: 69bb         	ldr	r3, [r7, #0x18]
 800f202: 617b         	str	r3, [r7, #0x14]
; 	return &_kernel.ready_q.runq;
 800f204: 4b53         	ldr	r3, [pc, #0x14c]        @ 0x800f354 <ready_thread+0x1a0>
 800f206: 613b         	str	r3, [r7, #0x10]
 800f208: 69bb         	ldr	r3, [r7, #0x18]
 800f20a: 60fb         	str	r3, [r7, #0xc]
; 	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
 800f20c: 6938         	ldr	r0, [r7, #0x10]
 800f20e: f00d fd25    	bl	0x801cc5c <sys_dlist_peek_head> @ imm = #0xda4a
 800f212: 4603         	mov	r3, r0
 800f214: 2b00         	cmp	r3, #0x0
 800f216: d004         	beq	0x800f222 <ready_thread+0x6e> @ imm = #0x8
 800f218: 6938         	ldr	r0, [r7, #0x10]
 800f21a: f00d fd1f    	bl	0x801cc5c <sys_dlist_peek_head> @ imm = #0xda3e
 800f21e: 4603         	mov	r3, r0
 800f220: e000         	b	0x800f224 <ready_thread+0x70> @ imm = #0x0
 800f222: 2300         	movs	r3, #0x0
 800f224: 60bb         	str	r3, [r7, #0x8]
 800f226: e023         	b	0x800f270 <ready_thread+0xbc> @ imm = #0x46
; 		if (z_sched_prio_cmp(thread, t) > 0) {
 800f228: 68b9         	ldr	r1, [r7, #0x8]
 800f22a: 68f8         	ldr	r0, [r7, #0xc]
 800f22c: f00d ff25    	bl	0x801d07a <z_sched_prio_cmp> @ imm = #0xde4a
 800f230: 4603         	mov	r3, r0
 800f232: 2b00         	cmp	r3, #0x0
 800f234: dd06         	ble	0x800f244 <ready_thread+0x90> @ imm = #0xc
; 			sys_dlist_insert(&t->base.qnode_dlist,
 800f236: 68bb         	ldr	r3, [r7, #0x8]
 800f238: 68fa         	ldr	r2, [r7, #0xc]
 800f23a: 4611         	mov	r1, r2
 800f23c: 4618         	mov	r0, r3
 800f23e: f00d fd5e    	bl	0x801ccfe <sys_dlist_insert> @ imm = #0xdabc
; 			return;
 800f242: e01d         	b	0x800f280 <ready_thread+0xcc> @ imm = #0x3a
; 	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
 800f244: 68bb         	ldr	r3, [r7, #0x8]
 800f246: 2b00         	cmp	r3, #0x0
 800f248: d010         	beq	0x800f26c <ready_thread+0xb8> @ imm = #0x20
 800f24a: 68bb         	ldr	r3, [r7, #0x8]
 800f24c: 4619         	mov	r1, r3
 800f24e: 6938         	ldr	r0, [r7, #0x10]
 800f250: f00d fd29    	bl	0x801cca6 <sys_dlist_peek_next> @ imm = #0xda52
 800f254: 4603         	mov	r3, r0
 800f256: 2b00         	cmp	r3, #0x0
 800f258: d006         	beq	0x800f268 <ready_thread+0xb4> @ imm = #0xc
 800f25a: 68bb         	ldr	r3, [r7, #0x8]
 800f25c: 4619         	mov	r1, r3
 800f25e: 6938         	ldr	r0, [r7, #0x10]
 800f260: f00d fd21    	bl	0x801cca6 <sys_dlist_peek_next> @ imm = #0xda42
 800f264: 4603         	mov	r3, r0
 800f266: e002         	b	0x800f26e <ready_thread+0xba> @ imm = #0x4
 800f268: 2300         	movs	r3, #0x0
 800f26a: e000         	b	0x800f26e <ready_thread+0xba> @ imm = #0x0
 800f26c: 2300         	movs	r3, #0x0
 800f26e: 60bb         	str	r3, [r7, #0x8]
 800f270: 68bb         	ldr	r3, [r7, #0x8]
 800f272: 2b00         	cmp	r3, #0x0
 800f274: d1d8         	bne	0x800f228 <ready_thread+0x74> @ imm = #-0x50
; 	sys_dlist_append(pq, &thread->base.qnode_dlist);
 800f276: 68fb         	ldr	r3, [r7, #0xc]
 800f278: 4619         	mov	r1, r3
 800f27a: 6938         	ldr	r0, [r7, #0x10]
 800f27c: f00d fd26    	bl	0x801cccc <sys_dlist_append> @ imm = #0xda4c
; }
 800f280: bf00         	nop
; }
 800f282: bf00         	nop
 800f284: 2300         	movs	r3, #0x0
 800f286: 64fb         	str	r3, [r7, #0x4c]
; 	return &_kernel.ready_q.runq;
 800f288: 4b32         	ldr	r3, [pc, #0xc8]         @ 0x800f354 <ready_thread+0x1a0>
 800f28a: 64bb         	str	r3, [r7, #0x48]
; 	struct k_thread *thread = NULL;
 800f28c: 2300         	movs	r3, #0x0
 800f28e: 647b         	str	r3, [r7, #0x44]
; 	sys_dnode_t *n = sys_dlist_peek_head(pq);
 800f290: 6cb8         	ldr	r0, [r7, #0x48]
 800f292: f00d fce3    	bl	0x801cc5c <sys_dlist_peek_head> @ imm = #0xd9c6
 800f296: 6438         	str	r0, [r7, #0x40]
; 	if (n != NULL) {
 800f298: 6c3b         	ldr	r3, [r7, #0x40]
 800f29a: 2b00         	cmp	r3, #0x0
 800f29c: d001         	beq	0x800f2a2 <ready_thread+0xee> @ imm = #0x2
; 		thread = CONTAINER_OF(n, struct k_thread, base.qnode_dlist);
 800f29e: 6c3b         	ldr	r3, [r7, #0x40]
 800f2a0: 647b         	str	r3, [r7, #0x44]
; 	return thread;
 800f2a2: 6c7b         	ldr	r3, [r7, #0x44]
; 	return _priq_run_best(curr_cpu_runq());
 800f2a4: bf00         	nop
; 	struct k_thread *thread = runq_best();
 800f2a6: 63fb         	str	r3, [r7, #0x3c]
; 	return (thread != NULL) ? thread : _current_cpu->idle_thread;
 800f2a8: 6bfb         	ldr	r3, [r7, #0x3c]
 800f2aa: 2b00         	cmp	r3, #0x0
 800f2ac: d102         	bne	0x800f2b4 <ready_thread+0x100> @ imm = #0x4
 800f2ae: 4b2a         	ldr	r3, [pc, #0xa8]         @ 0x800f358 <ready_thread+0x1a4>
 800f2b0: 68db         	ldr	r3, [r3, #0xc]
 800f2b2: e000         	b	0x800f2b6 <ready_thread+0x102> @ imm = #0x0
 800f2b4: 6bfb         	ldr	r3, [r7, #0x3c]
; 	struct k_thread *thread = next_up();
 800f2b6: 63bb         	str	r3, [r7, #0x38]
 800f2b8: 6bbb         	ldr	r3, [r7, #0x38]
 800f2ba: 637b         	str	r3, [r7, #0x34]
 800f2bc: 6cfb         	ldr	r3, [r7, #0x4c]
 800f2be: 633b         	str	r3, [r7, #0x30]
; 	if (preempt_ok != 0) {
 800f2c0: 6b3b         	ldr	r3, [r7, #0x30]
 800f2c2: 2b00         	cmp	r3, #0x0
 800f2c4: d001         	beq	0x800f2ca <ready_thread+0x116> @ imm = #0x2
; 		return true;
 800f2c6: 2301         	movs	r3, #0x1
 800f2c8: e026         	b	0x800f318 <ready_thread+0x164> @ imm = #0x4c
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800f2ca: 4b23         	ldr	r3, [pc, #0x8c]         @ 0x800f358 <ready_thread+0x1a4>
 800f2cc: 689b         	ldr	r3, [r3, #0x8]
 800f2ce: 62fb         	str	r3, [r7, #0x2c]
; 	return ret;
 800f2d0: 6afb         	ldr	r3, [r7, #0x2c]
; 	if (z_is_thread_prevented_from_running(arch_current_thread())) {
 800f2d2: 4618         	mov	r0, r3
 800f2d4: f00d fda6    	bl	0x801ce24 <z_is_thread_prevented_from_running> @ imm = #0xdb4c
 800f2d8: 4603         	mov	r3, r0
 800f2da: 2b00         	cmp	r3, #0x0
 800f2dc: d001         	beq	0x800f2e2 <ready_thread+0x12e> @ imm = #0x2
; 		return true;
 800f2de: 2301         	movs	r3, #0x1
 800f2e0: e01a         	b	0x800f318 <ready_thread+0x164> @ imm = #0x34
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800f2e2: 4b1d         	ldr	r3, [pc, #0x74]         @ 0x800f358 <ready_thread+0x1a4>
 800f2e4: 689b         	ldr	r3, [r3, #0x8]
 800f2e6: 62bb         	str	r3, [r7, #0x28]
; 	return ret;
 800f2e8: 6abb         	ldr	r3, [r7, #0x28]
; 	if (thread_is_preemptible(arch_current_thread()) || thread_is_metairq(thread)) {
 800f2ea: 4618         	mov	r0, r3
 800f2ec: f00d fd6e    	bl	0x801cdcc <thread_is_preemptible> @ imm = #0xdadc
 800f2f0: 4603         	mov	r3, r0
 800f2f2: 2b00         	cmp	r3, #0x0
 800f2f4: d105         	bne	0x800f302 <ready_thread+0x14e> @ imm = #0xa
 800f2f6: 6b78         	ldr	r0, [r7, #0x34]
 800f2f8: f00d fd78    	bl	0x801cdec <thread_is_metairq> @ imm = #0xdaf0
 800f2fc: 4603         	mov	r3, r0
 800f2fe: 2b00         	cmp	r3, #0x0
 800f300: d001         	beq	0x800f306 <ready_thread+0x152> @ imm = #0x2
; 		return true;
 800f302: 2301         	movs	r3, #0x1
 800f304: e008         	b	0x800f318 <ready_thread+0x164> @ imm = #0x10
; 	    && z_is_thread_timeout_active(thread)) {
 800f306: 6b78         	ldr	r0, [r7, #0x34]
 800f308: f00d fda0    	bl	0x801ce4c <z_is_thread_timeout_active> @ imm = #0xdb40
 800f30c: 4603         	mov	r3, r0
; 	if (IS_ENABLED(CONFIG_SWAP_NONATOMIC)
 800f30e: 2b00         	cmp	r3, #0x0
 800f310: d001         	beq	0x800f316 <ready_thread+0x162> @ imm = #0x2
; 		return true;
 800f312: 2301         	movs	r3, #0x1
 800f314: e000         	b	0x800f318 <ready_thread+0x164> @ imm = #0x0
; 	return false;
 800f316: 2300         	movs	r3, #0x0
; 	if (should_preempt(thread, preempt_ok)) {
 800f318: 2b00         	cmp	r3, #0x0
 800f31a: d010         	beq	0x800f33e <ready_thread+0x18a> @ imm = #0x20
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800f31c: 4b0e         	ldr	r3, [pc, #0x38]         @ 0x800f358 <ready_thread+0x1a4>
 800f31e: 689b         	ldr	r3, [r3, #0x8]
 800f320: 627b         	str	r3, [r7, #0x24]
; 	return ret;
 800f322: 6a7b         	ldr	r3, [r7, #0x24]
; 		if (thread != arch_current_thread()) {
 800f324: 6bba         	ldr	r2, [r7, #0x38]
 800f326: 429a         	cmp	r2, r3
 800f328: d002         	beq	0x800f330 <ready_thread+0x17c> @ imm = #0x4
; 			z_reset_time_slice(thread);
 800f32a: 6bb8         	ldr	r0, [r7, #0x38]
 800f32c: f001 fb1a    	bl	0x8010964 <z_reset_time_slice> @ imm = #0x1634
; 		update_metairq_preempt(thread);
 800f330: 6bb8         	ldr	r0, [r7, #0x38]
 800f332: f00d ff00    	bl	0x801d136 <update_metairq_preempt> @ imm = #0xde00
; 		_kernel.ready_q.cache = thread;
 800f336: 4a08         	ldr	r2, [pc, #0x20]         @ 0x800f358 <ready_thread+0x1a4>
 800f338: 6bbb         	ldr	r3, [r7, #0x38]
 800f33a: 61d3         	str	r3, [r2, #0x1c]
; }
 800f33c: e005         	b	0x800f34a <ready_thread+0x196> @ imm = #0xa
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800f33e: 4b06         	ldr	r3, [pc, #0x18]         @ 0x800f358 <ready_thread+0x1a4>
 800f340: 689b         	ldr	r3, [r3, #0x8]
 800f342: 623b         	str	r3, [r7, #0x20]
; 	return ret;
 800f344: 6a3b         	ldr	r3, [r7, #0x20]
; 		_kernel.ready_q.cache = arch_current_thread();
 800f346: 4a04         	ldr	r2, [pc, #0x10]         @ 0x800f358 <ready_thread+0x1a4>
 800f348: 61d3         	str	r3, [r2, #0x1c]
; }
 800f34a: bf00         	nop
; }
 800f34c: bf00         	nop
 800f34e: 3750         	adds	r7, #0x50
 800f350: 46bd         	mov	sp, r7
 800f352: bd80         	pop	{r7, pc}

0800f354 <$d>:
 800f354: 10 17 00 20  	.word	0x20001710
 800f358: f0 16 00 20  	.word	0x200016f0

0800f35c <z_ready_thread>:
; {
 800f35c: b580         	push	{r7, lr}
 800f35e: b090         	sub	sp, #0x40
 800f360: af00         	add	r7, sp, #0x0
 800f362: 6078         	str	r0, [r7, #0x4]
; 	K_SPINLOCK(&_sched_spinlock) {
 800f364: 2300         	movs	r3, #0x0
 800f366: 61bb         	str	r3, [r7, #0x18]
 800f368: 4b1f         	ldr	r3, [pc, #0x7c]         @ 0x800f3e8 <z_ready_thread+0x8c>
 800f36a: 63fb         	str	r3, [r7, #0x3c]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800f36c: f3ef 8311    	mrs	r3, basepri
 800f370: 63bb         	str	r3, [r7, #0x38]
;   return(result);
 800f372: 6bbb         	ldr	r3, [r7, #0x38]
; 	key = __get_BASEPRI();
 800f374: 637b         	str	r3, [r7, #0x34]
 800f376: 2310         	movs	r3, #0x10
 800f378: 633b         	str	r3, [r7, #0x30]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 800f37a: 6b3b         	ldr	r3, [r7, #0x30]
 800f37c: f383 8812    	msr	basepri_max, r3
; }
 800f380: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800f382: f3bf 8f6f    	isb	sy
; }
 800f386: bf00         	nop
; 	return key;
 800f388: 6b7b         	ldr	r3, [r7, #0x34]
; 	k.key = arch_irq_lock();
 800f38a: 60fb         	str	r3, [r7, #0xc]
 800f38c: 6bfb         	ldr	r3, [r7, #0x3c]
 800f38e: 62fb         	str	r3, [r7, #0x2c]
; }
 800f390: bf00         	nop
 800f392: 6bfb         	ldr	r3, [r7, #0x3c]
 800f394: 62bb         	str	r3, [r7, #0x28]
; }
 800f396: bf00         	nop
; 	return k;
 800f398: 68fb         	ldr	r3, [r7, #0xc]
 800f39a: 617b         	str	r3, [r7, #0x14]
; 	K_SPINLOCK(&_sched_spinlock) {
 800f39c: e01b         	b	0x800f3d6 <z_ready_thread+0x7a> @ imm = #0x36
; 		if (thread_active_elsewhere(thread) == NULL) {
 800f39e: 6878         	ldr	r0, [r7, #0x4]
 800f3a0: f00d fed2    	bl	0x801d148 <thread_active_elsewhere> @ imm = #0xdda4
 800f3a4: 4603         	mov	r3, r0
 800f3a6: 2b00         	cmp	r3, #0x0
 800f3a8: d102         	bne	0x800f3b0 <z_ready_thread+0x54> @ imm = #0x4
; 			ready_thread(thread);
 800f3aa: 6878         	ldr	r0, [r7, #0x4]
 800f3ac: f7ff ff02    	bl	0x800f1b4 <ready_thread> @ imm = #-0x1fc
 800f3b0: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x800f3e8 <z_ready_thread+0x8c>
 800f3b2: 627b         	str	r3, [r7, #0x24]
 800f3b4: 697b         	ldr	r3, [r7, #0x14]
 800f3b6: 613b         	str	r3, [r7, #0x10]
; 	arch_irq_unlock(key.key);
 800f3b8: 693b         	ldr	r3, [r7, #0x10]
 800f3ba: 623b         	str	r3, [r7, #0x20]
 800f3bc: 6a3b         	ldr	r3, [r7, #0x20]
 800f3be: 61fb         	str	r3, [r7, #0x1c]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800f3c0: 69fb         	ldr	r3, [r7, #0x1c]
 800f3c2: f383 8811    	msr	basepri, r3
; }
 800f3c6: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800f3c8: f3bf 8f6f    	isb	sy
; }
 800f3cc: bf00         	nop
; }
 800f3ce: bf00         	nop
; }
 800f3d0: bf00         	nop
; 	K_SPINLOCK(&_sched_spinlock) {
 800f3d2: 2301         	movs	r3, #0x1
 800f3d4: 61bb         	str	r3, [r7, #0x18]
 800f3d6: 69bb         	ldr	r3, [r7, #0x18]
 800f3d8: 2b00         	cmp	r3, #0x0
 800f3da: d0e0         	beq	0x800f39e <z_ready_thread+0x42> @ imm = #-0x40
; }
 800f3dc: bf00         	nop
 800f3de: bf00         	nop
 800f3e0: 3740         	adds	r7, #0x40
 800f3e2: 46bd         	mov	sp, r7
 800f3e4: bd80         	pop	{r7, pc}
 800f3e6: bf00         	nop

0800f3e8 <$d>:
 800f3e8: 70 1f 00 20  	.word	0x20001f70

0800f3ec <thread_halt_spin>:
; {
 800f3ec: b590         	push	{r4, r7, lr}
 800f3ee: b091         	sub	sp, #0x44
 800f3f0: af00         	add	r7, sp, #0x0
 800f3f2: 6078         	str	r0, [r7, #0x4]
 800f3f4: 6039         	str	r1, [r7]
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800f3f6: 4b2d         	ldr	r3, [pc, #0xb4]         @ 0x800f4ac <thread_halt_spin+0xc0>
 800f3f8: 689b         	ldr	r3, [r3, #0x8]
 800f3fa: 63bb         	str	r3, [r7, #0x38]
; 	return ret;
 800f3fc: 6bbb         	ldr	r3, [r7, #0x38]
; 	if (is_halting(arch_current_thread())) {
 800f3fe: 4618         	mov	r0, r3
 800f400: f00d fe72    	bl	0x801d0e8 <is_halting>  @ imm = #0xdce4
 800f404: 4603         	mov	r3, r0
 800f406: 2b00         	cmp	r3, #0x0
 800f408: d014         	beq	0x800f434 <thread_halt_spin+0x48> @ imm = #0x28
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800f40a: 4b28         	ldr	r3, [pc, #0xa0]         @ 0x800f4ac <thread_halt_spin+0xc0>
 800f40c: 689b         	ldr	r3, [r3, #0x8]
 800f40e: 633b         	str	r3, [r7, #0x30]
; 	return ret;
 800f410: 6b3c         	ldr	r4, [r7, #0x30]
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800f412: 4b26         	ldr	r3, [pc, #0x98]         @ 0x800f4ac <thread_halt_spin+0xc0>
 800f414: 689b         	ldr	r3, [r3, #0x8]
 800f416: 637b         	str	r3, [r7, #0x34]
; 	return ret;
 800f418: 6b7b         	ldr	r3, [r7, #0x34]
; 			    is_aborting(arch_current_thread()) ? _THREAD_DEAD : _THREAD_SUSPENDED);
 800f41a: 4618         	mov	r0, r3
 800f41c: f00d fe52    	bl	0x801d0c4 <is_aborting> @ imm = #0xdca4
 800f420: 4603         	mov	r3, r0
; 		halt_thread(arch_current_thread(),
 800f422: 2b00         	cmp	r3, #0x0
 800f424: d001         	beq	0x800f42a <thread_halt_spin+0x3e> @ imm = #0x2
 800f426: 2308         	movs	r3, #0x8
 800f428: e000         	b	0x800f42c <thread_halt_spin+0x40> @ imm = #0x0
 800f42a: 2310         	movs	r3, #0x10
 800f42c: 4619         	mov	r1, r3
 800f42e: 4620         	mov	r0, r4
 800f430: f001 f834    	bl	0x801049c <halt_thread> @ imm = #0x1068
 800f434: 4b1e         	ldr	r3, [pc, #0x78]         @ 0x800f4b0 <thread_halt_spin+0xc4>
 800f436: 62fb         	str	r3, [r7, #0x2c]
 800f438: 683b         	ldr	r3, [r7]
 800f43a: 60fb         	str	r3, [r7, #0xc]
; 	arch_irq_unlock(key.key);
 800f43c: 68fb         	ldr	r3, [r7, #0xc]
 800f43e: 62bb         	str	r3, [r7, #0x28]
 800f440: 6abb         	ldr	r3, [r7, #0x28]
 800f442: 627b         	str	r3, [r7, #0x24]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800f444: 6a7b         	ldr	r3, [r7, #0x24]
 800f446: f383 8811    	msr	basepri, r3
; }
 800f44a: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800f44c: f3bf 8f6f    	isb	sy
; }
 800f450: bf00         	nop
; }
 800f452: bf00         	nop
; }
 800f454: bf00         	nop
; 	while (is_halting(thread)) {
 800f456: e01d         	b	0x800f494 <thread_halt_spin+0xa8> @ imm = #0x3a
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800f458: f3ef 8311    	mrs	r3, basepri
 800f45c: 61bb         	str	r3, [r7, #0x18]
;   return(result);
 800f45e: 69bb         	ldr	r3, [r7, #0x18]
; 	key = __get_BASEPRI();
 800f460: 617b         	str	r3, [r7, #0x14]
 800f462: 2310         	movs	r3, #0x10
 800f464: 613b         	str	r3, [r7, #0x10]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 800f466: 693b         	ldr	r3, [r7, #0x10]
 800f468: f383 8812    	msr	basepri_max, r3
; }
 800f46c: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800f46e: f3bf 8f6f    	isb	sy
; }
 800f472: bf00         	nop
; 	return key;
 800f474: 697b         	ldr	r3, [r7, #0x14]
; 		unsigned int k = arch_irq_lock();
 800f476: 63fb         	str	r3, [r7, #0x3c]
; 		arch_spin_relax(); /* Requires interrupts be masked */
 800f478: f00c fcd5    	bl	0x801be26 <arch_spin_relax> @ imm = #0xc9aa
 800f47c: 6bfb         	ldr	r3, [r7, #0x3c]
 800f47e: 623b         	str	r3, [r7, #0x20]
 800f480: 6a3b         	ldr	r3, [r7, #0x20]
 800f482: 61fb         	str	r3, [r7, #0x1c]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800f484: 69fb         	ldr	r3, [r7, #0x1c]
 800f486: f383 8811    	msr	basepri, r3
; }
 800f48a: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800f48c: f3bf 8f6f    	isb	sy
; }
 800f490: bf00         	nop
; }
 800f492: bf00         	nop
; 	while (is_halting(thread)) {
 800f494: 6878         	ldr	r0, [r7, #0x4]
 800f496: f00d fe27    	bl	0x801d0e8 <is_halting>  @ imm = #0xdc4e
 800f49a: 4603         	mov	r3, r0
 800f49c: 2b00         	cmp	r3, #0x0
 800f49e: d1db         	bne	0x800f458 <thread_halt_spin+0x6c> @ imm = #-0x4a
; }
 800f4a0: bf00         	nop
 800f4a2: bf00         	nop
 800f4a4: 3744         	adds	r7, #0x44
 800f4a6: 46bd         	mov	sp, r7
 800f4a8: bd90         	pop	{r4, r7, pc}
 800f4aa: bf00         	nop

0800f4ac <$d>:
 800f4ac: f0 16 00 20  	.word	0x200016f0
 800f4b0: 70 1f 00 20  	.word	0x20001f70

0800f4b4 <z_thread_halt>:
; {
 800f4b4: b580         	push	{r7, lr}
 800f4b6: b094         	sub	sp, #0x50
 800f4b8: af00         	add	r7, sp, #0x0
 800f4ba: 60f8         	str	r0, [r7, #0xc]
 800f4bc: 60b9         	str	r1, [r7, #0x8]
 800f4be: 4613         	mov	r3, r2
 800f4c0: 71fb         	strb	r3, [r7, #0x7]
; 	_wait_q_t *wq = &thread->join_queue;
 800f4c2: 68fb         	ldr	r3, [r7, #0xc]
 800f4c4: 3368         	adds	r3, #0x68
 800f4c6: 64fb         	str	r3, [r7, #0x4c]
; 	struct _cpu *cpu = thread_active_elsewhere(thread);
 800f4c8: 68f8         	ldr	r0, [r7, #0xc]
 800f4ca: f00d fe3d    	bl	0x801d148 <thread_active_elsewhere> @ imm = #0xdc7a
 800f4ce: 64b8         	str	r0, [r7, #0x48]
; 	if (cpu != NULL) {
 800f4d0: 6cbb         	ldr	r3, [r7, #0x48]
 800f4d2: 2b00         	cmp	r3, #0x0
 800f4d4: d02f         	beq	0x800f536 <z_thread_halt+0x82> @ imm = #0x5e
; 		thread->base.thread_state |= (terminate ? _THREAD_ABORTING
 800f4d6: 68fb         	ldr	r3, [r7, #0xc]
 800f4d8: 7b5b         	ldrb	r3, [r3, #0xd]
 800f4da: 79fa         	ldrb	r2, [r7, #0x7]
 800f4dc: 2a00         	cmp	r2, #0x0
 800f4de: d001         	beq	0x800f4e4 <z_thread_halt+0x30> @ imm = #0x2
 800f4e0: 2220         	movs	r2, #0x20
 800f4e2: e000         	b	0x800f4e6 <z_thread_halt+0x32> @ imm = #0x0
 800f4e4: 2240         	movs	r2, #0x40
 800f4e6: 4313         	orrs	r3, r2
 800f4e8: b2da         	uxtb	r2, r3
 800f4ea: 68fb         	ldr	r3, [r7, #0xc]
 800f4ec: 735a         	strb	r2, [r3, #0xd]
;   __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 800f4ee: f3ef 8305    	mrs	r3, ipsr
 800f4f2: 647b         	str	r3, [r7, #0x44]
;   return(result);
 800f4f4: 6c7b         	ldr	r3, [r7, #0x44]
; 	return (__get_IPSR()) ? (true) : (false);
 800f4f6: 2b00         	cmp	r3, #0x0
 800f4f8: bf14         	ite	ne
 800f4fa: 2301         	movne	r3, #0x1
 800f4fc: 2300         	moveq	r3, #0x0
 800f4fe: b2db         	uxtb	r3, r3
; 		if (arch_is_in_isr()) {
 800f500: 2b00         	cmp	r3, #0x0
 800f502: d004         	beq	0x800f50e <z_thread_halt+0x5a> @ imm = #0x8
; 			thread_halt_spin(thread, key);
 800f504: 68b9         	ldr	r1, [r7, #0x8]
 800f506: 68f8         	ldr	r0, [r7, #0xc]
 800f508: f7ff ff70    	bl	0x800f3ec <thread_halt_spin> @ imm = #-0x120
; }
 800f50c: e04f         	b	0x800f5ae <z_thread_halt+0xfa> @ imm = #0x9e
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800f50e: 4b2a         	ldr	r3, [pc, #0xa8]         @ 0x800f5b8 <z_thread_halt+0x104>
 800f510: 689b         	ldr	r3, [r3, #0x8]
 800f512: 63bb         	str	r3, [r7, #0x38]
; 	return ret;
 800f514: 6bbb         	ldr	r3, [r7, #0x38]
; 			add_to_waitq_locked(arch_current_thread(), wq);
 800f516: 6cf9         	ldr	r1, [r7, #0x4c]
 800f518: 4618         	mov	r0, r3
 800f51a: f00d fe1f    	bl	0x801d15c <add_to_waitq_locked> @ imm = #0xdc3e
 800f51e: 4b27         	ldr	r3, [pc, #0x9c]         @ 0x800f5bc <z_thread_halt+0x108>
 800f520: 643b         	str	r3, [r7, #0x40]
 800f522: 68bb         	ldr	r3, [r7, #0x8]
 800f524: 613b         	str	r3, [r7, #0x10]
 800f526: 6c3b         	ldr	r3, [r7, #0x40]
 800f528: 63fb         	str	r3, [r7, #0x3c]
; }
 800f52a: bf00         	nop
; 	return z_swap_irqlock(key.key);
 800f52c: 693b         	ldr	r3, [r7, #0x10]
 800f52e: 4618         	mov	r0, r3
 800f530: f00d fd78    	bl	0x801d024 <z_swap_irqlock> @ imm = #0xdaf0
 800f534: e03b         	b	0x800f5ae <z_thread_halt+0xfa> @ imm = #0x76
; 		halt_thread(thread, terminate ? _THREAD_DEAD : _THREAD_SUSPENDED);
 800f536: 79fb         	ldrb	r3, [r7, #0x7]
 800f538: 2b00         	cmp	r3, #0x0
 800f53a: d001         	beq	0x800f540 <z_thread_halt+0x8c> @ imm = #0x2
 800f53c: 2308         	movs	r3, #0x8
 800f53e: e000         	b	0x800f542 <z_thread_halt+0x8e> @ imm = #0x0
 800f540: 2310         	movs	r3, #0x10
 800f542: 4619         	mov	r1, r3
 800f544: 68f8         	ldr	r0, [r7, #0xc]
 800f546: f000 ffa9    	bl	0x801049c <halt_thread> @ imm = #0xf52
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800f54a: 4b1b         	ldr	r3, [pc, #0x6c]         @ 0x800f5b8 <z_thread_halt+0x104>
 800f54c: 689b         	ldr	r3, [r3, #0x8]
 800f54e: 637b         	str	r3, [r7, #0x34]
; 	return ret;
 800f550: 6b7b         	ldr	r3, [r7, #0x34]
; 		if ((thread == arch_current_thread()) && !arch_is_in_isr()) {
 800f552: 68fa         	ldr	r2, [r7, #0xc]
 800f554: 429a         	cmp	r2, r3
 800f556: d119         	bne	0x800f58c <z_thread_halt+0xd8> @ imm = #0x32
;   __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 800f558: f3ef 8305    	mrs	r3, ipsr
 800f55c: 633b         	str	r3, [r7, #0x30]
;   return(result);
 800f55e: 6b3b         	ldr	r3, [r7, #0x30]
; 	return (__get_IPSR()) ? (true) : (false);
 800f560: 2b00         	cmp	r3, #0x0
 800f562: bf14         	ite	ne
 800f564: 2301         	movne	r3, #0x1
 800f566: 2300         	moveq	r3, #0x0
 800f568: b2db         	uxtb	r3, r3
; 		if ((thread == arch_current_thread()) && !arch_is_in_isr()) {
 800f56a: f083 0301    	eor	r3, r3, #0x1
 800f56e: b2db         	uxtb	r3, r3
 800f570: 2b00         	cmp	r3, #0x0
 800f572: d00b         	beq	0x800f58c <z_thread_halt+0xd8> @ imm = #0x16
 800f574: 4b11         	ldr	r3, [pc, #0x44]         @ 0x800f5bc <z_thread_halt+0x108>
 800f576: 62fb         	str	r3, [r7, #0x2c]
 800f578: 68bb         	ldr	r3, [r7, #0x8]
 800f57a: 617b         	str	r3, [r7, #0x14]
 800f57c: 6afb         	ldr	r3, [r7, #0x2c]
 800f57e: 62bb         	str	r3, [r7, #0x28]
; }
 800f580: bf00         	nop
; 	return z_swap_irqlock(key.key);
 800f582: 697b         	ldr	r3, [r7, #0x14]
 800f584: 4618         	mov	r0, r3
 800f586: f00d fd4d    	bl	0x801d024 <z_swap_irqlock> @ imm = #0xda9a
; 			z_swap(&_sched_spinlock, key);
 800f58a: e010         	b	0x800f5ae <z_thread_halt+0xfa> @ imm = #0x20
 800f58c: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x800f5bc <z_thread_halt+0x108>
 800f58e: 627b         	str	r3, [r7, #0x24]
 800f590: 68bb         	ldr	r3, [r7, #0x8]
 800f592: 61bb         	str	r3, [r7, #0x18]
; 	arch_irq_unlock(key.key);
 800f594: 69bb         	ldr	r3, [r7, #0x18]
 800f596: 623b         	str	r3, [r7, #0x20]
 800f598: 6a3b         	ldr	r3, [r7, #0x20]
 800f59a: 61fb         	str	r3, [r7, #0x1c]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800f59c: 69fb         	ldr	r3, [r7, #0x1c]
 800f59e: f383 8811    	msr	basepri, r3
; }
 800f5a2: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800f5a4: f3bf 8f6f    	isb	sy
; }
 800f5a8: bf00         	nop
; }
 800f5aa: bf00         	nop
; }
 800f5ac: bf00         	nop
; }
 800f5ae: bf00         	nop
 800f5b0: 3750         	adds	r7, #0x50
 800f5b2: 46bd         	mov	sp, r7
 800f5b4: bd80         	pop	{r7, pc}
 800f5b6: bf00         	nop

0800f5b8 <$d>:
 800f5b8: f0 16 00 20  	.word	0x200016f0
 800f5bc: 70 1f 00 20  	.word	0x20001f70

0800f5c0 <z_impl_k_thread_suspend>:
; {
 800f5c0: b580         	push	{r7, lr}
 800f5c2: b0ac         	sub	sp, #0xb0
 800f5c4: af00         	add	r7, sp, #0x0
 800f5c6: 6078         	str	r0, [r7, #0x4]
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800f5c8: 4b8e         	ldr	r3, [pc, #0x238]        @ 0x800f804 <z_impl_k_thread_suspend+0x244>
 800f5ca: 689b         	ldr	r3, [r3, #0x8]
 800f5cc: f8c7 30ac    	str.w	r3, [r7, #0xac]
; 	return ret;
 800f5d0: f8d7 30ac    	ldr.w	r3, [r7, #0xac]
; 	if (thread == arch_current_thread() && !arch_is_in_isr() && !IS_ENABLED(CONFIG_SMP)) {
 800f5d4: 687a         	ldr	r2, [r7, #0x4]
 800f5d6: 429a         	cmp	r2, r3
 800f5d8: f040 80d7    	bne.w	0x800f78a <z_impl_k_thread_suspend+0x1ca> @ imm = #0x1ae
;   __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 800f5dc: f3ef 8305    	mrs	r3, ipsr
 800f5e0: f8c7 30a8    	str.w	r3, [r7, #0xa8]
;   return(result);
 800f5e4: f8d7 30a8    	ldr.w	r3, [r7, #0xa8]
; 	return (__get_IPSR()) ? (true) : (false);
 800f5e8: 2b00         	cmp	r3, #0x0
 800f5ea: bf14         	ite	ne
 800f5ec: 2301         	movne	r3, #0x1
 800f5ee: 2300         	moveq	r3, #0x0
 800f5f0: b2db         	uxtb	r3, r3
; 	if (thread == arch_current_thread() && !arch_is_in_isr() && !IS_ENABLED(CONFIG_SMP)) {
 800f5f2: f083 0301    	eor	r3, r3, #0x1
 800f5f6: b2db         	uxtb	r3, r3
 800f5f8: 2b00         	cmp	r3, #0x0
 800f5fa: f000 80c6    	beq.w	0x800f78a <z_impl_k_thread_suspend+0x1ca> @ imm = #0x18c
 800f5fe: 4b82         	ldr	r3, [pc, #0x208]        @ 0x800f808 <z_impl_k_thread_suspend+0x248>
 800f600: 65bb         	str	r3, [r7, #0x58]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800f602: f3ef 8311    	mrs	r3, basepri
 800f606: 657b         	str	r3, [r7, #0x54]
;   return(result);
 800f608: 6d7b         	ldr	r3, [r7, #0x54]
; 	key = __get_BASEPRI();
 800f60a: 653b         	str	r3, [r7, #0x50]
 800f60c: 2310         	movs	r3, #0x10
 800f60e: 64fb         	str	r3, [r7, #0x4c]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 800f610: 6cfb         	ldr	r3, [r7, #0x4c]
 800f612: f383 8812    	msr	basepri_max, r3
; }
 800f616: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800f618: f3bf 8f6f    	isb	sy
; }
 800f61c: bf00         	nop
; 	return key;
 800f61e: 6d3b         	ldr	r3, [r7, #0x50]
; 	k.key = arch_irq_lock();
 800f620: 60fb         	str	r3, [r7, #0xc]
 800f622: 6dbb         	ldr	r3, [r7, #0x58]
 800f624: 64bb         	str	r3, [r7, #0x48]
; }
 800f626: bf00         	nop
 800f628: 6dbb         	ldr	r3, [r7, #0x58]
 800f62a: 647b         	str	r3, [r7, #0x44]
; }
 800f62c: bf00         	nop
; 	return k;
 800f62e: 68fb         	ldr	r3, [r7, #0xc]
 800f630: 613b         	str	r3, [r7, #0x10]
; 		z_mark_thread_as_suspended(thread);
 800f632: 6878         	ldr	r0, [r7, #0x4]
 800f634: f00d fc64    	bl	0x801cf00 <z_mark_thread_as_suspended> @ imm = #0xd8c8
 800f638: 687b         	ldr	r3, [r7, #0x4]
 800f63a: 66fb         	str	r3, [r7, #0x6c]
; 	thread->base.thread_state &= ~_THREAD_QUEUED;
 800f63c: 6efb         	ldr	r3, [r7, #0x6c]
 800f63e: 7b5b         	ldrb	r3, [r3, #0xd]
 800f640: f003 037f    	and	r3, r3, #0x7f
 800f644: b2da         	uxtb	r2, r3
 800f646: 6efb         	ldr	r3, [r7, #0x6c]
 800f648: 735a         	strb	r2, [r3, #0xd]
; 	if (should_queue_thread(thread)) {
 800f64a: 6ef8         	ldr	r0, [r7, #0x6c]
 800f64c: f00d fd30    	bl	0x801d0b0 <should_queue_thread> @ imm = #0xda60
 800f650: 4603         	mov	r3, r0
 800f652: 2b00         	cmp	r3, #0x0
 800f654: d00d         	beq	0x800f672 <z_impl_k_thread_suspend+0xb2> @ imm = #0x1a
 800f656: 6efb         	ldr	r3, [r7, #0x6c]
 800f658: 66bb         	str	r3, [r7, #0x68]
 800f65a: 6ebb         	ldr	r3, [r7, #0x68]
 800f65c: 667b         	str	r3, [r7, #0x64]
; 	return &_kernel.ready_q.runq;
 800f65e: 4b6b         	ldr	r3, [pc, #0x1ac]        @ 0x800f80c <z_impl_k_thread_suspend+0x24c>
 800f660: 663b         	str	r3, [r7, #0x60]
 800f662: 6ebb         	ldr	r3, [r7, #0x68]
 800f664: 65fb         	str	r3, [r7, #0x5c]
; 	sys_dlist_remove(&thread->base.qnode_dlist);
 800f666: 6dfb         	ldr	r3, [r7, #0x5c]
 800f668: 4618         	mov	r0, r3
 800f66a: f00d fb61    	bl	0x801cd30 <sys_dlist_remove> @ imm = #0xd6c2
; }
 800f66e: bf00         	nop
; }
 800f670: bf00         	nop
; }
 800f672: bf00         	nop
 800f674: 2301         	movs	r3, #0x1
 800f676: f8c7 309c    	str.w	r3, [r7, #0x9c]
; 	return &_kernel.ready_q.runq;
 800f67a: 4b64         	ldr	r3, [pc, #0x190]        @ 0x800f80c <z_impl_k_thread_suspend+0x24c>
 800f67c: f8c7 3098    	str.w	r3, [r7, #0x98]
; 	struct k_thread *thread = NULL;
 800f680: 2300         	movs	r3, #0x0
 800f682: f8c7 3094    	str.w	r3, [r7, #0x94]
; 	sys_dnode_t *n = sys_dlist_peek_head(pq);
 800f686: f8d7 0098    	ldr.w	r0, [r7, #0x98]
 800f68a: f00d fae7    	bl	0x801cc5c <sys_dlist_peek_head> @ imm = #0xd5ce
 800f68e: f8c7 0090    	str.w	r0, [r7, #0x90]
; 	if (n != NULL) {
 800f692: f8d7 3090    	ldr.w	r3, [r7, #0x90]
 800f696: 2b00         	cmp	r3, #0x0
 800f698: d003         	beq	0x800f6a2 <z_impl_k_thread_suspend+0xe2> @ imm = #0x6
; 		thread = CONTAINER_OF(n, struct k_thread, base.qnode_dlist);
 800f69a: f8d7 3090    	ldr.w	r3, [r7, #0x90]
 800f69e: f8c7 3094    	str.w	r3, [r7, #0x94]
; 	return thread;
 800f6a2: f8d7 3094    	ldr.w	r3, [r7, #0x94]
; 	return _priq_run_best(curr_cpu_runq());
 800f6a6: bf00         	nop
; 	struct k_thread *thread = runq_best();
 800f6a8: f8c7 308c    	str.w	r3, [r7, #0x8c]
; 	return (thread != NULL) ? thread : _current_cpu->idle_thread;
 800f6ac: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 800f6b0: 2b00         	cmp	r3, #0x0
 800f6b2: d102         	bne	0x800f6ba <z_impl_k_thread_suspend+0xfa> @ imm = #0x4
 800f6b4: 4b53         	ldr	r3, [pc, #0x14c]        @ 0x800f804 <z_impl_k_thread_suspend+0x244>
 800f6b6: 68db         	ldr	r3, [r3, #0xc]
 800f6b8: e001         	b	0x800f6be <z_impl_k_thread_suspend+0xfe> @ imm = #0x2
 800f6ba: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
; 	struct k_thread *thread = next_up();
 800f6be: f8c7 3088    	str.w	r3, [r7, #0x88]
 800f6c2: f8d7 3088    	ldr.w	r3, [r7, #0x88]
 800f6c6: f8c7 3084    	str.w	r3, [r7, #0x84]
 800f6ca: f8d7 309c    	ldr.w	r3, [r7, #0x9c]
 800f6ce: f8c7 3080    	str.w	r3, [r7, #0x80]
; 	if (preempt_ok != 0) {
 800f6d2: f8d7 3080    	ldr.w	r3, [r7, #0x80]
 800f6d6: 2b00         	cmp	r3, #0x0
 800f6d8: d001         	beq	0x800f6de <z_impl_k_thread_suspend+0x11e> @ imm = #0x2
; 		return true;
 800f6da: 2301         	movs	r3, #0x1
 800f6dc: e028         	b	0x800f730 <z_impl_k_thread_suspend+0x170> @ imm = #0x50
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800f6de: 4b49         	ldr	r3, [pc, #0x124]        @ 0x800f804 <z_impl_k_thread_suspend+0x244>
 800f6e0: 689b         	ldr	r3, [r3, #0x8]
 800f6e2: 67fb         	str	r3, [r7, #0x7c]
; 	return ret;
 800f6e4: 6ffb         	ldr	r3, [r7, #0x7c]
; 	if (z_is_thread_prevented_from_running(arch_current_thread())) {
 800f6e6: 4618         	mov	r0, r3
 800f6e8: f00d fb9c    	bl	0x801ce24 <z_is_thread_prevented_from_running> @ imm = #0xd738
 800f6ec: 4603         	mov	r3, r0
 800f6ee: 2b00         	cmp	r3, #0x0
 800f6f0: d001         	beq	0x800f6f6 <z_impl_k_thread_suspend+0x136> @ imm = #0x2
; 		return true;
 800f6f2: 2301         	movs	r3, #0x1
 800f6f4: e01c         	b	0x800f730 <z_impl_k_thread_suspend+0x170> @ imm = #0x38
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800f6f6: 4b43         	ldr	r3, [pc, #0x10c]        @ 0x800f804 <z_impl_k_thread_suspend+0x244>
 800f6f8: 689b         	ldr	r3, [r3, #0x8]
 800f6fa: 67bb         	str	r3, [r7, #0x78]
; 	return ret;
 800f6fc: 6fbb         	ldr	r3, [r7, #0x78]
; 	if (thread_is_preemptible(arch_current_thread()) || thread_is_metairq(thread)) {
 800f6fe: 4618         	mov	r0, r3
 800f700: f00d fb64    	bl	0x801cdcc <thread_is_preemptible> @ imm = #0xd6c8
 800f704: 4603         	mov	r3, r0
 800f706: 2b00         	cmp	r3, #0x0
 800f708: d106         	bne	0x800f718 <z_impl_k_thread_suspend+0x158> @ imm = #0xc
 800f70a: f8d7 0084    	ldr.w	r0, [r7, #0x84]
 800f70e: f00d fb6d    	bl	0x801cdec <thread_is_metairq> @ imm = #0xd6da
 800f712: 4603         	mov	r3, r0
 800f714: 2b00         	cmp	r3, #0x0
 800f716: d001         	beq	0x800f71c <z_impl_k_thread_suspend+0x15c> @ imm = #0x2
; 		return true;
 800f718: 2301         	movs	r3, #0x1
 800f71a: e009         	b	0x800f730 <z_impl_k_thread_suspend+0x170> @ imm = #0x12
; 	    && z_is_thread_timeout_active(thread)) {
 800f71c: f8d7 0084    	ldr.w	r0, [r7, #0x84]
 800f720: f00d fb94    	bl	0x801ce4c <z_is_thread_timeout_active> @ imm = #0xd728
 800f724: 4603         	mov	r3, r0
; 	if (IS_ENABLED(CONFIG_SWAP_NONATOMIC)
 800f726: 2b00         	cmp	r3, #0x0
 800f728: d001         	beq	0x800f72e <z_impl_k_thread_suspend+0x16e> @ imm = #0x2
; 		return true;
 800f72a: 2301         	movs	r3, #0x1
 800f72c: e000         	b	0x800f730 <z_impl_k_thread_suspend+0x170> @ imm = #0x0
; 	return false;
 800f72e: 2300         	movs	r3, #0x0
; 	if (should_preempt(thread, preempt_ok)) {
 800f730: 2b00         	cmp	r3, #0x0
 800f732: d014         	beq	0x800f75e <z_impl_k_thread_suspend+0x19e> @ imm = #0x28
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800f734: 4b33         	ldr	r3, [pc, #0xcc]         @ 0x800f804 <z_impl_k_thread_suspend+0x244>
 800f736: 689b         	ldr	r3, [r3, #0x8]
 800f738: 677b         	str	r3, [r7, #0x74]
; 	return ret;
 800f73a: 6f7b         	ldr	r3, [r7, #0x74]
; 		if (thread != arch_current_thread()) {
 800f73c: f8d7 2088    	ldr.w	r2, [r7, #0x88]
 800f740: 429a         	cmp	r2, r3
 800f742: d003         	beq	0x800f74c <z_impl_k_thread_suspend+0x18c> @ imm = #0x6
; 			z_reset_time_slice(thread);
 800f744: f8d7 0088    	ldr.w	r0, [r7, #0x88]
 800f748: f001 f90c    	bl	0x8010964 <z_reset_time_slice> @ imm = #0x1218
; 		update_metairq_preempt(thread);
 800f74c: f8d7 0088    	ldr.w	r0, [r7, #0x88]
 800f750: f00d fcf1    	bl	0x801d136 <update_metairq_preempt> @ imm = #0xd9e2
; 		_kernel.ready_q.cache = thread;
 800f754: 4a2b         	ldr	r2, [pc, #0xac]         @ 0x800f804 <z_impl_k_thread_suspend+0x244>
 800f756: f8d7 3088    	ldr.w	r3, [r7, #0x88]
 800f75a: 61d3         	str	r3, [r2, #0x1c]
; }
 800f75c: e005         	b	0x800f76a <z_impl_k_thread_suspend+0x1aa> @ imm = #0xa
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800f75e: 4b29         	ldr	r3, [pc, #0xa4]         @ 0x800f804 <z_impl_k_thread_suspend+0x244>
 800f760: 689b         	ldr	r3, [r3, #0x8]
 800f762: 673b         	str	r3, [r7, #0x70]
; 	return ret;
 800f764: 6f3b         	ldr	r3, [r7, #0x70]
; 		_kernel.ready_q.cache = arch_current_thread();
 800f766: 4a27         	ldr	r2, [pc, #0x9c]         @ 0x800f804 <z_impl_k_thread_suspend+0x244>
 800f768: 61d3         	str	r3, [r2, #0x1c]
; }
 800f76a: bf00         	nop
 800f76c: 4b26         	ldr	r3, [pc, #0x98]         @ 0x800f808 <z_impl_k_thread_suspend+0x248>
 800f76e: f8c7 30a4    	str.w	r3, [r7, #0xa4]
 800f772: 693b         	ldr	r3, [r7, #0x10]
 800f774: 60bb         	str	r3, [r7, #0x8]
 800f776: f8d7 30a4    	ldr.w	r3, [r7, #0xa4]
 800f77a: f8c7 30a0    	str.w	r3, [r7, #0xa0]
; }
 800f77e: bf00         	nop
; 	return z_swap_irqlock(key.key);
 800f780: 68bb         	ldr	r3, [r7, #0x8]
 800f782: 4618         	mov	r0, r3
 800f784: f00d fc4e    	bl	0x801d024 <z_swap_irqlock> @ imm = #0xd89c
 800f788: e039         	b	0x800f7fe <z_impl_k_thread_suspend+0x23e> @ imm = #0x72
; 	(void)z_abort_thread_timeout(thread);
 800f78a: 6878         	ldr	r0, [r7, #0x4]
 800f78c: f00d fb10    	bl	0x801cdb0 <z_abort_thread_timeout> @ imm = #0xd620
 800f790: 4b1d         	ldr	r3, [pc, #0x74]         @ 0x800f808 <z_impl_k_thread_suspend+0x248>
 800f792: 643b         	str	r3, [r7, #0x40]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800f794: f3ef 8311    	mrs	r3, basepri
 800f798: 63fb         	str	r3, [r7, #0x3c]
;   return(result);
 800f79a: 6bfb         	ldr	r3, [r7, #0x3c]
; 	key = __get_BASEPRI();
 800f79c: 63bb         	str	r3, [r7, #0x38]
 800f79e: 2310         	movs	r3, #0x10
 800f7a0: 637b         	str	r3, [r7, #0x34]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 800f7a2: 6b7b         	ldr	r3, [r7, #0x34]
 800f7a4: f383 8812    	msr	basepri_max, r3
; }
 800f7a8: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800f7aa: f3bf 8f6f    	isb	sy
; }
 800f7ae: bf00         	nop
; 	return key;
 800f7b0: 6bbb         	ldr	r3, [r7, #0x38]
; 	k.key = arch_irq_lock();
 800f7b2: 617b         	str	r3, [r7, #0x14]
 800f7b4: 6c3b         	ldr	r3, [r7, #0x40]
 800f7b6: 633b         	str	r3, [r7, #0x30]
; }
 800f7b8: bf00         	nop
 800f7ba: 6c3b         	ldr	r3, [r7, #0x40]
 800f7bc: 62fb         	str	r3, [r7, #0x2c]
; }
 800f7be: bf00         	nop
; 	return k;
 800f7c0: 697b         	ldr	r3, [r7, #0x14]
 800f7c2: 61fb         	str	r3, [r7, #0x1c]
; 	if ((thread->base.thread_state & _THREAD_SUSPENDED) != 0U) {
 800f7c4: 687b         	ldr	r3, [r7, #0x4]
 800f7c6: 7b5b         	ldrb	r3, [r3, #0xd]
 800f7c8: f003 0310    	and	r3, r3, #0x10
 800f7cc: 2b00         	cmp	r3, #0x0
 800f7ce: d011         	beq	0x800f7f4 <z_impl_k_thread_suspend+0x234> @ imm = #0x22
 800f7d0: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x800f808 <z_impl_k_thread_suspend+0x248>
 800f7d2: 62bb         	str	r3, [r7, #0x28]
 800f7d4: 69fb         	ldr	r3, [r7, #0x1c]
 800f7d6: 61bb         	str	r3, [r7, #0x18]
; 	arch_irq_unlock(key.key);
 800f7d8: 69bb         	ldr	r3, [r7, #0x18]
 800f7da: 627b         	str	r3, [r7, #0x24]
 800f7dc: 6a7b         	ldr	r3, [r7, #0x24]
 800f7de: 623b         	str	r3, [r7, #0x20]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800f7e0: 6a3b         	ldr	r3, [r7, #0x20]
 800f7e2: f383 8811    	msr	basepri, r3
; }
 800f7e6: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800f7e8: f3bf 8f6f    	isb	sy
; }
 800f7ec: bf00         	nop
; }
 800f7ee: bf00         	nop
; }
 800f7f0: bf00         	nop
; 		return;
 800f7f2: e004         	b	0x800f7fe <z_impl_k_thread_suspend+0x23e> @ imm = #0x8
; 	z_thread_halt(thread, key, false);
 800f7f4: 2200         	movs	r2, #0x0
 800f7f6: 69f9         	ldr	r1, [r7, #0x1c]
 800f7f8: 6878         	ldr	r0, [r7, #0x4]
 800f7fa: f7ff fe5b    	bl	0x800f4b4 <z_thread_halt> @ imm = #-0x34a
; }
 800f7fe: 37b0         	adds	r7, #0xb0
 800f800: 46bd         	mov	sp, r7
 800f802: bd80         	pop	{r7, pc}

0800f804 <$d>:
 800f804: f0 16 00 20  	.word	0x200016f0
 800f808: 70 1f 00 20  	.word	0x20001f70
 800f80c: 10 17 00 20  	.word	0x20001710

0800f810 <z_impl_k_thread_resume>:
; {
 800f810: b580         	push	{r7, lr}
 800f812: b08e         	sub	sp, #0x38
 800f814: af00         	add	r7, sp, #0x0
 800f816: 6078         	str	r0, [r7, #0x4]
 800f818: 4b20         	ldr	r3, [pc, #0x80]         @ 0x800f89c <z_impl_k_thread_resume+0x8c>
 800f81a: 637b         	str	r3, [r7, #0x34]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800f81c: f3ef 8311    	mrs	r3, basepri
 800f820: 633b         	str	r3, [r7, #0x30]
;   return(result);
 800f822: 6b3b         	ldr	r3, [r7, #0x30]
; 	key = __get_BASEPRI();
 800f824: 62fb         	str	r3, [r7, #0x2c]
 800f826: 2310         	movs	r3, #0x10
 800f828: 62bb         	str	r3, [r7, #0x28]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 800f82a: 6abb         	ldr	r3, [r7, #0x28]
 800f82c: f383 8812    	msr	basepri_max, r3
; }
 800f830: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800f832: f3bf 8f6f    	isb	sy
; }
 800f836: bf00         	nop
; 	return key;
 800f838: 6afb         	ldr	r3, [r7, #0x2c]
; 	k.key = arch_irq_lock();
 800f83a: 60bb         	str	r3, [r7, #0x8]
 800f83c: 6b7b         	ldr	r3, [r7, #0x34]
 800f83e: 627b         	str	r3, [r7, #0x24]
; }
 800f840: bf00         	nop
 800f842: 6b7b         	ldr	r3, [r7, #0x34]
 800f844: 623b         	str	r3, [r7, #0x20]
; }
 800f846: bf00         	nop
; 	return k;
 800f848: 68bb         	ldr	r3, [r7, #0x8]
 800f84a: 613b         	str	r3, [r7, #0x10]
; 	if (!z_is_thread_suspended(thread)) {
 800f84c: 6878         	ldr	r0, [r7, #0x4]
 800f84e: f00d fad7    	bl	0x801ce00 <z_is_thread_suspended> @ imm = #0xd5ae
 800f852: 4603         	mov	r3, r0
 800f854: f083 0301    	eor	r3, r3, #0x1
 800f858: b2db         	uxtb	r3, r3
 800f85a: 2b00         	cmp	r3, #0x0
 800f85c: d010         	beq	0x800f880 <z_impl_k_thread_resume+0x70> @ imm = #0x20
 800f85e: 4b0f         	ldr	r3, [pc, #0x3c]         @ 0x800f89c <z_impl_k_thread_resume+0x8c>
 800f860: 61fb         	str	r3, [r7, #0x1c]
 800f862: 693b         	ldr	r3, [r7, #0x10]
 800f864: 60fb         	str	r3, [r7, #0xc]
; 	arch_irq_unlock(key.key);
 800f866: 68fb         	ldr	r3, [r7, #0xc]
 800f868: 61bb         	str	r3, [r7, #0x18]
 800f86a: 69bb         	ldr	r3, [r7, #0x18]
 800f86c: 617b         	str	r3, [r7, #0x14]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800f86e: 697b         	ldr	r3, [r7, #0x14]
 800f870: f383 8811    	msr	basepri, r3
; }
 800f874: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800f876: f3bf 8f6f    	isb	sy
; }
 800f87a: bf00         	nop
; }
 800f87c: bf00         	nop
; }
 800f87e: e009         	b	0x800f894 <z_impl_k_thread_resume+0x84> @ imm = #0x12
; 	z_mark_thread_as_not_suspended(thread);
 800f880: 6878         	ldr	r0, [r7, #0x4]
 800f882: f00d fb4d    	bl	0x801cf20 <z_mark_thread_as_not_suspended> @ imm = #0xd69a
; 	ready_thread(thread);
 800f886: 6878         	ldr	r0, [r7, #0x4]
 800f888: f7ff fc94    	bl	0x800f1b4 <ready_thread> @ imm = #-0x6d8
; 	z_reschedule(&_sched_spinlock, key);
 800f88c: 6939         	ldr	r1, [r7, #0x10]
 800f88e: 4803         	ldr	r0, [pc, #0xc]          @ 0x800f89c <z_impl_k_thread_resume+0x8c>
 800f890: f00d fd1b    	bl	0x801d2ca <z_reschedule> @ imm = #0xda36
; }
 800f894: 3738         	adds	r7, #0x38
 800f896: 46bd         	mov	sp, r7
 800f898: bd80         	pop	{r7, pc}
 800f89a: bf00         	nop

0800f89c <$d>:
 800f89c: 70 1f 00 20  	.word	0x20001f70

0800f8a0 <unready_thread>:
; {
 800f8a0: b580         	push	{r7, lr}
 800f8a2: b094         	sub	sp, #0x50
 800f8a4: af00         	add	r7, sp, #0x0
 800f8a6: 6078         	str	r0, [r7, #0x4]
; 	if (z_is_thread_queued(thread)) {
 800f8a8: 6878         	ldr	r0, [r7, #0x4]
 800f8aa: f00d fb1c    	bl	0x801cee6 <z_is_thread_queued> @ imm = #0xd638
 800f8ae: 4603         	mov	r3, r0
 800f8b0: 2b00         	cmp	r3, #0x0
 800f8b2: d01d         	beq	0x800f8f0 <unready_thread+0x50> @ imm = #0x3a
 800f8b4: 687b         	ldr	r3, [r7, #0x4]
 800f8b6: 64fb         	str	r3, [r7, #0x4c]
; 	thread->base.thread_state &= ~_THREAD_QUEUED;
 800f8b8: 6cfb         	ldr	r3, [r7, #0x4c]
 800f8ba: 7b5b         	ldrb	r3, [r3, #0xd]
 800f8bc: f003 037f    	and	r3, r3, #0x7f
 800f8c0: b2da         	uxtb	r2, r3
 800f8c2: 6cfb         	ldr	r3, [r7, #0x4c]
 800f8c4: 735a         	strb	r2, [r3, #0xd]
; 	if (should_queue_thread(thread)) {
 800f8c6: 6cf8         	ldr	r0, [r7, #0x4c]
 800f8c8: f00d fbf2    	bl	0x801d0b0 <should_queue_thread> @ imm = #0xd7e4
 800f8cc: 4603         	mov	r3, r0
 800f8ce: 2b00         	cmp	r3, #0x0
 800f8d0: d00d         	beq	0x800f8ee <unready_thread+0x4e> @ imm = #0x1a
 800f8d2: 6cfb         	ldr	r3, [r7, #0x4c]
 800f8d4: 64bb         	str	r3, [r7, #0x48]
 800f8d6: 6cbb         	ldr	r3, [r7, #0x48]
 800f8d8: 647b         	str	r3, [r7, #0x44]
; 	return &_kernel.ready_q.runq;
 800f8da: 4b3e         	ldr	r3, [pc, #0xf8]         @ 0x800f9d4 <unready_thread+0x134>
 800f8dc: 643b         	str	r3, [r7, #0x40]
 800f8de: 6cbb         	ldr	r3, [r7, #0x48]
 800f8e0: 63fb         	str	r3, [r7, #0x3c]
; 	sys_dlist_remove(&thread->base.qnode_dlist);
 800f8e2: 6bfb         	ldr	r3, [r7, #0x3c]
 800f8e4: 4618         	mov	r0, r3
 800f8e6: f00d fa23    	bl	0x801cd30 <sys_dlist_remove> @ imm = #0xd446
; }
 800f8ea: bf00         	nop
; }
 800f8ec: bf00         	nop
; }
 800f8ee: bf00         	nop
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800f8f0: 4b39         	ldr	r3, [pc, #0xe4]         @ 0x800f9d8 <unready_thread+0x138>
 800f8f2: 689b         	ldr	r3, [r3, #0x8]
 800f8f4: 60bb         	str	r3, [r7, #0x8]
; 	return ret;
 800f8f6: 68bb         	ldr	r3, [r7, #0x8]
; 	update_cache(thread == arch_current_thread());
 800f8f8: 687a         	ldr	r2, [r7, #0x4]
 800f8fa: 429a         	cmp	r2, r3
 800f8fc: bf0c         	ite	eq
 800f8fe: 2301         	moveq	r3, #0x1
 800f900: 2300         	movne	r3, #0x0
 800f902: b2db         	uxtb	r3, r3
 800f904: 63bb         	str	r3, [r7, #0x38]
; 	return &_kernel.ready_q.runq;
 800f906: 4b33         	ldr	r3, [pc, #0xcc]         @ 0x800f9d4 <unready_thread+0x134>
 800f908: 637b         	str	r3, [r7, #0x34]
; 	struct k_thread *thread = NULL;
 800f90a: 2300         	movs	r3, #0x0
 800f90c: 633b         	str	r3, [r7, #0x30]
; 	sys_dnode_t *n = sys_dlist_peek_head(pq);
 800f90e: 6b78         	ldr	r0, [r7, #0x34]
 800f910: f00d f9a4    	bl	0x801cc5c <sys_dlist_peek_head> @ imm = #0xd348
 800f914: 62f8         	str	r0, [r7, #0x2c]
; 	if (n != NULL) {
 800f916: 6afb         	ldr	r3, [r7, #0x2c]
 800f918: 2b00         	cmp	r3, #0x0
 800f91a: d001         	beq	0x800f920 <unready_thread+0x80> @ imm = #0x2
; 		thread = CONTAINER_OF(n, struct k_thread, base.qnode_dlist);
 800f91c: 6afb         	ldr	r3, [r7, #0x2c]
 800f91e: 633b         	str	r3, [r7, #0x30]
; 	return thread;
 800f920: 6b3b         	ldr	r3, [r7, #0x30]
; 	return _priq_run_best(curr_cpu_runq());
 800f922: bf00         	nop
; 	struct k_thread *thread = runq_best();
 800f924: 62bb         	str	r3, [r7, #0x28]
; 	return (thread != NULL) ? thread : _current_cpu->idle_thread;
 800f926: 6abb         	ldr	r3, [r7, #0x28]
 800f928: 2b00         	cmp	r3, #0x0
 800f92a: d102         	bne	0x800f932 <unready_thread+0x92> @ imm = #0x4
 800f92c: 4b2a         	ldr	r3, [pc, #0xa8]         @ 0x800f9d8 <unready_thread+0x138>
 800f92e: 68db         	ldr	r3, [r3, #0xc]
 800f930: e000         	b	0x800f934 <unready_thread+0x94> @ imm = #0x0
 800f932: 6abb         	ldr	r3, [r7, #0x28]
; 	struct k_thread *thread = next_up();
 800f934: 627b         	str	r3, [r7, #0x24]
 800f936: 6a7b         	ldr	r3, [r7, #0x24]
 800f938: 623b         	str	r3, [r7, #0x20]
 800f93a: 6bbb         	ldr	r3, [r7, #0x38]
 800f93c: 61fb         	str	r3, [r7, #0x1c]
; 	if (preempt_ok != 0) {
 800f93e: 69fb         	ldr	r3, [r7, #0x1c]
 800f940: 2b00         	cmp	r3, #0x0
 800f942: d001         	beq	0x800f948 <unready_thread+0xa8> @ imm = #0x2
; 		return true;
 800f944: 2301         	movs	r3, #0x1
 800f946: e026         	b	0x800f996 <unready_thread+0xf6> @ imm = #0x4c
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800f948: 4b23         	ldr	r3, [pc, #0x8c]         @ 0x800f9d8 <unready_thread+0x138>
 800f94a: 689b         	ldr	r3, [r3, #0x8]
 800f94c: 61bb         	str	r3, [r7, #0x18]
; 	return ret;
 800f94e: 69bb         	ldr	r3, [r7, #0x18]
; 	if (z_is_thread_prevented_from_running(arch_current_thread())) {
 800f950: 4618         	mov	r0, r3
 800f952: f00d fa67    	bl	0x801ce24 <z_is_thread_prevented_from_running> @ imm = #0xd4ce
 800f956: 4603         	mov	r3, r0
 800f958: 2b00         	cmp	r3, #0x0
 800f95a: d001         	beq	0x800f960 <unready_thread+0xc0> @ imm = #0x2
; 		return true;
 800f95c: 2301         	movs	r3, #0x1
 800f95e: e01a         	b	0x800f996 <unready_thread+0xf6> @ imm = #0x34
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800f960: 4b1d         	ldr	r3, [pc, #0x74]         @ 0x800f9d8 <unready_thread+0x138>
 800f962: 689b         	ldr	r3, [r3, #0x8]
 800f964: 617b         	str	r3, [r7, #0x14]
; 	return ret;
 800f966: 697b         	ldr	r3, [r7, #0x14]
; 	if (thread_is_preemptible(arch_current_thread()) || thread_is_metairq(thread)) {
 800f968: 4618         	mov	r0, r3
 800f96a: f00d fa2f    	bl	0x801cdcc <thread_is_preemptible> @ imm = #0xd45e
 800f96e: 4603         	mov	r3, r0
 800f970: 2b00         	cmp	r3, #0x0
 800f972: d105         	bne	0x800f980 <unready_thread+0xe0> @ imm = #0xa
 800f974: 6a38         	ldr	r0, [r7, #0x20]
 800f976: f00d fa39    	bl	0x801cdec <thread_is_metairq> @ imm = #0xd472
 800f97a: 4603         	mov	r3, r0
 800f97c: 2b00         	cmp	r3, #0x0
 800f97e: d001         	beq	0x800f984 <unready_thread+0xe4> @ imm = #0x2
; 		return true;
 800f980: 2301         	movs	r3, #0x1
 800f982: e008         	b	0x800f996 <unready_thread+0xf6> @ imm = #0x10
; 	    && z_is_thread_timeout_active(thread)) {
 800f984: 6a38         	ldr	r0, [r7, #0x20]
 800f986: f00d fa61    	bl	0x801ce4c <z_is_thread_timeout_active> @ imm = #0xd4c2
 800f98a: 4603         	mov	r3, r0
; 	if (IS_ENABLED(CONFIG_SWAP_NONATOMIC)
 800f98c: 2b00         	cmp	r3, #0x0
 800f98e: d001         	beq	0x800f994 <unready_thread+0xf4> @ imm = #0x2
; 		return true;
 800f990: 2301         	movs	r3, #0x1
 800f992: e000         	b	0x800f996 <unready_thread+0xf6> @ imm = #0x0
; 	return false;
 800f994: 2300         	movs	r3, #0x0
; 	if (should_preempt(thread, preempt_ok)) {
 800f996: 2b00         	cmp	r3, #0x0
 800f998: d010         	beq	0x800f9bc <unready_thread+0x11c> @ imm = #0x20
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800f99a: 4b0f         	ldr	r3, [pc, #0x3c]         @ 0x800f9d8 <unready_thread+0x138>
 800f99c: 689b         	ldr	r3, [r3, #0x8]
 800f99e: 613b         	str	r3, [r7, #0x10]
; 	return ret;
 800f9a0: 693b         	ldr	r3, [r7, #0x10]
; 		if (thread != arch_current_thread()) {
 800f9a2: 6a7a         	ldr	r2, [r7, #0x24]
 800f9a4: 429a         	cmp	r2, r3
 800f9a6: d002         	beq	0x800f9ae <unready_thread+0x10e> @ imm = #0x4
; 			z_reset_time_slice(thread);
 800f9a8: 6a78         	ldr	r0, [r7, #0x24]
 800f9aa: f000 ffdb    	bl	0x8010964 <z_reset_time_slice> @ imm = #0xfb6
; 		update_metairq_preempt(thread);
 800f9ae: 6a78         	ldr	r0, [r7, #0x24]
 800f9b0: f00d fbc1    	bl	0x801d136 <update_metairq_preempt> @ imm = #0xd782
; 		_kernel.ready_q.cache = thread;
 800f9b4: 4a08         	ldr	r2, [pc, #0x20]         @ 0x800f9d8 <unready_thread+0x138>
 800f9b6: 6a7b         	ldr	r3, [r7, #0x24]
 800f9b8: 61d3         	str	r3, [r2, #0x1c]
; }
 800f9ba: e005         	b	0x800f9c8 <unready_thread+0x128> @ imm = #0xa
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800f9bc: 4b06         	ldr	r3, [pc, #0x18]         @ 0x800f9d8 <unready_thread+0x138>
 800f9be: 689b         	ldr	r3, [r3, #0x8]
 800f9c0: 60fb         	str	r3, [r7, #0xc]
; 	return ret;
 800f9c2: 68fb         	ldr	r3, [r7, #0xc]
; 		_kernel.ready_q.cache = arch_current_thread();
 800f9c4: 4a04         	ldr	r2, [pc, #0x10]         @ 0x800f9d8 <unready_thread+0x138>
 800f9c6: 61d3         	str	r3, [r2, #0x1c]
; }
 800f9c8: bf00         	nop
; }
 800f9ca: bf00         	nop
 800f9cc: 3750         	adds	r7, #0x50
 800f9ce: 46bd         	mov	sp, r7
 800f9d0: bd80         	pop	{r7, pc}
 800f9d2: bf00         	nop

0800f9d4 <$d>:
 800f9d4: 10 17 00 20  	.word	0x20001710
 800f9d8: f0 16 00 20  	.word	0x200016f0

0800f9dc <z_sched_wake_thread>:
; {
 800f9dc: b580         	push	{r7, lr}
 800f9de: b090         	sub	sp, #0x40
 800f9e0: af00         	add	r7, sp, #0x0
 800f9e2: 6078         	str	r0, [r7, #0x4]
 800f9e4: 460b         	mov	r3, r1
 800f9e6: 70fb         	strb	r3, [r7, #0x3]
; 	K_SPINLOCK(&_sched_spinlock) {
 800f9e8: 2300         	movs	r3, #0x0
 800f9ea: 617b         	str	r3, [r7, #0x14]
 800f9ec: 4b38         	ldr	r3, [pc, #0xe0]         @ 0x800fad0 <z_sched_wake_thread+0xf4>
 800f9ee: 63bb         	str	r3, [r7, #0x38]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800f9f0: f3ef 8311    	mrs	r3, basepri
 800f9f4: 637b         	str	r3, [r7, #0x34]
;   return(result);
 800f9f6: 6b7b         	ldr	r3, [r7, #0x34]
; 	key = __get_BASEPRI();
 800f9f8: 633b         	str	r3, [r7, #0x30]
 800f9fa: 2310         	movs	r3, #0x10
 800f9fc: 62fb         	str	r3, [r7, #0x2c]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 800f9fe: 6afb         	ldr	r3, [r7, #0x2c]
 800fa00: f383 8812    	msr	basepri_max, r3
; }
 800fa04: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800fa06: f3bf 8f6f    	isb	sy
; }
 800fa0a: bf00         	nop
; 	return key;
 800fa0c: 6b3b         	ldr	r3, [r7, #0x30]
; 	k.key = arch_irq_lock();
 800fa0e: 60bb         	str	r3, [r7, #0x8]
 800fa10: 6bbb         	ldr	r3, [r7, #0x38]
 800fa12: 62bb         	str	r3, [r7, #0x28]
; }
 800fa14: bf00         	nop
 800fa16: 6bbb         	ldr	r3, [r7, #0x38]
 800fa18: 627b         	str	r3, [r7, #0x24]
; }
 800fa1a: bf00         	nop
; 	return k;
 800fa1c: 68bb         	ldr	r3, [r7, #0x8]
 800fa1e: 613b         	str	r3, [r7, #0x10]
; 	K_SPINLOCK(&_sched_spinlock) {
 800fa20: e04d         	b	0x800fabe <z_sched_wake_thread+0xe2> @ imm = #0x9a
; 		bool killed = (thread->base.thread_state &
 800fa22: 687b         	ldr	r3, [r7, #0x4]
 800fa24: 7b5b         	ldrb	r3, [r3, #0xd]
 800fa26: f003 0328    	and	r3, r3, #0x28
 800fa2a: 2b00         	cmp	r3, #0x0
 800fa2c: bf14         	ite	ne
 800fa2e: 2301         	movne	r3, #0x1
 800fa30: 2300         	moveq	r3, #0x0
 800fa32: f887 303f    	strb.w	r3, [r7, #0x3f]
; 		bool do_nothing = thread->no_wake_on_timeout && is_timeout;
 800fa36: 687b         	ldr	r3, [r7, #0x4]
 800fa38: f893 307c    	ldrb.w	r3, [r3, #0x7c]
 800fa3c: 2b00         	cmp	r3, #0x0
 800fa3e: d004         	beq	0x800fa4a <z_sched_wake_thread+0x6e> @ imm = #0x8
 800fa40: 78fb         	ldrb	r3, [r7, #0x3]
 800fa42: 2b00         	cmp	r3, #0x0
 800fa44: d001         	beq	0x800fa4a <z_sched_wake_thread+0x6e> @ imm = #0x2
 800fa46: 2301         	movs	r3, #0x1
 800fa48: e000         	b	0x800fa4c <z_sched_wake_thread+0x70> @ imm = #0x0
 800fa4a: 2300         	movs	r3, #0x0
 800fa4c: f887 303e    	strb.w	r3, [r7, #0x3e]
 800fa50: f897 303e    	ldrb.w	r3, [r7, #0x3e]
 800fa54: f003 0301    	and	r3, r3, #0x1
 800fa58: f887 303e    	strb.w	r3, [r7, #0x3e]
; 		thread->no_wake_on_timeout = false;
 800fa5c: 687b         	ldr	r3, [r7, #0x4]
 800fa5e: 2200         	movs	r2, #0x0
 800fa60: f883 207c    	strb.w	r2, [r3, #0x7c]
; 		if (do_nothing) {
 800fa64: f897 303e    	ldrb.w	r3, [r7, #0x3e]
 800fa68: 2b00         	cmp	r3, #0x0
 800fa6a: d114         	bne	0x800fa96 <z_sched_wake_thread+0xba> @ imm = #0x28
; 		if (!killed) {
 800fa6c: f897 303f    	ldrb.w	r3, [r7, #0x3f]
 800fa70: f083 0301    	eor	r3, r3, #0x1
 800fa74: b2db         	uxtb	r3, r3
 800fa76: 2b00         	cmp	r3, #0x0
 800fa78: d00e         	beq	0x800fa98 <z_sched_wake_thread+0xbc> @ imm = #0x1c
; 			if (thread->base.pended_on != NULL) {
 800fa7a: 687b         	ldr	r3, [r7, #0x4]
 800fa7c: 689b         	ldr	r3, [r3, #0x8]
 800fa7e: 2b00         	cmp	r3, #0x0
 800fa80: d002         	beq	0x800fa88 <z_sched_wake_thread+0xac> @ imm = #0x4
; 				unpend_thread_no_timeout(thread);
 800fa82: 6878         	ldr	r0, [r7, #0x4]
 800fa84: f00d faa7    	bl	0x801cfd6 <unpend_thread_no_timeout> @ imm = #0xd54e
; 			z_mark_thread_as_not_suspended(thread);
 800fa88: 6878         	ldr	r0, [r7, #0x4]
 800fa8a: f00d fa49    	bl	0x801cf20 <z_mark_thread_as_not_suspended> @ imm = #0xd492
; 			ready_thread(thread);
 800fa8e: 6878         	ldr	r0, [r7, #0x4]
 800fa90: f7ff fb90    	bl	0x800f1b4 <ready_thread> @ imm = #-0x8e0
 800fa94: e000         	b	0x800fa98 <z_sched_wake_thread+0xbc> @ imm = #0x0
; 			continue;
 800fa96: bf00         	nop
 800fa98: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x800fad0 <z_sched_wake_thread+0xf4>
 800fa9a: 623b         	str	r3, [r7, #0x20]
 800fa9c: 693b         	ldr	r3, [r7, #0x10]
 800fa9e: 60fb         	str	r3, [r7, #0xc]
; 	arch_irq_unlock(key.key);
 800faa0: 68fb         	ldr	r3, [r7, #0xc]
 800faa2: 61fb         	str	r3, [r7, #0x1c]
 800faa4: 69fb         	ldr	r3, [r7, #0x1c]
 800faa6: 61bb         	str	r3, [r7, #0x18]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800faa8: 69bb         	ldr	r3, [r7, #0x18]
 800faaa: f383 8811    	msr	basepri, r3
; }
 800faae: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800fab0: f3bf 8f6f    	isb	sy
; }
 800fab4: bf00         	nop
; }
 800fab6: bf00         	nop
; }
 800fab8: bf00         	nop
; 	K_SPINLOCK(&_sched_spinlock) {
 800faba: 2301         	movs	r3, #0x1
 800fabc: 617b         	str	r3, [r7, #0x14]
 800fabe: 697b         	ldr	r3, [r7, #0x14]
 800fac0: 2b00         	cmp	r3, #0x0
 800fac2: d0ae         	beq	0x800fa22 <z_sched_wake_thread+0x46> @ imm = #-0xa4
; }
 800fac4: bf00         	nop
 800fac6: bf00         	nop
 800fac8: 3740         	adds	r7, #0x40
 800faca: 46bd         	mov	sp, r7
 800facc: bd80         	pop	{r7, pc}
 800face: bf00         	nop

0800fad0 <$d>:
 800fad0: 70 1f 00 20  	.word	0x20001f70

0800fad4 <z_pend_curr>:
; {
 800fad4: b580         	push	{r7, lr}
 800fad6: b092         	sub	sp, #0x48
 800fad8: af00         	add	r7, sp, #0x0
 800fada: 60f8         	str	r0, [r7, #0xc]
 800fadc: 60b9         	str	r1, [r7, #0x8]
 800fade: 607a         	str	r2, [r7, #0x4]
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800fae0: 4b1c         	ldr	r3, [pc, #0x70]         @ 0x800fb54 <z_pend_curr+0x80>
 800fae2: 689b         	ldr	r3, [r3, #0x8]
 800fae4: 61fb         	str	r3, [r7, #0x1c]
; 	return ret;
 800fae6: 69fb         	ldr	r3, [r7, #0x1c]
; 	pending_current = arch_current_thread();
 800fae8: 4a1b         	ldr	r2, [pc, #0x6c]         @ 0x800fb58 <z_pend_curr+0x84>
 800faea: 6013         	str	r3, [r2]
 800faec: 4b1b         	ldr	r3, [pc, #0x6c]         @ 0x800fb5c <z_pend_curr+0x88>
 800faee: 637b         	str	r3, [r7, #0x34]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800faf0: f3ef 8311    	mrs	r3, basepri
 800faf4: 633b         	str	r3, [r7, #0x30]
;   return(result);
 800faf6: 6b3b         	ldr	r3, [r7, #0x30]
; 	key = __get_BASEPRI();
 800faf8: 62fb         	str	r3, [r7, #0x2c]
 800fafa: 2310         	movs	r3, #0x10
 800fafc: 62bb         	str	r3, [r7, #0x28]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 800fafe: 6abb         	ldr	r3, [r7, #0x28]
 800fb00: f383 8812    	msr	basepri_max, r3
; }
 800fb04: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800fb06: f3bf 8f6f    	isb	sy
; }
 800fb0a: bf00         	nop
; 	return key;
 800fb0c: 6afb         	ldr	r3, [r7, #0x2c]
; 	k.key = arch_irq_lock();
 800fb0e: 61bb         	str	r3, [r7, #0x18]
 800fb10: 6b7b         	ldr	r3, [r7, #0x34]
 800fb12: 627b         	str	r3, [r7, #0x24]
; }
 800fb14: bf00         	nop
 800fb16: 6b7b         	ldr	r3, [r7, #0x34]
 800fb18: 623b         	str	r3, [r7, #0x20]
; }
 800fb1a: bf00         	nop
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800fb1c: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x800fb54 <z_pend_curr+0x80>
 800fb1e: 689b         	ldr	r3, [r3, #0x8]
 800fb20: 63bb         	str	r3, [r7, #0x38]
; 	return ret;
 800fb22: 6bb8         	ldr	r0, [r7, #0x38]
; 	pend_locked(arch_current_thread(), wait_q, timeout);
 800fb24: e9d7 2314    	ldrd	r2, r3, [r7, #80]
 800fb28: 6879         	ldr	r1, [r7, #0x4]
 800fb2a: f00d fb84    	bl	0x801d236 <pend_locked> @ imm = #0xd708
 800fb2e: 68fb         	ldr	r3, [r7, #0xc]
 800fb30: 63fb         	str	r3, [r7, #0x3c]
; }
 800fb32: bf00         	nop
 800fb34: 4b09         	ldr	r3, [pc, #0x24]         @ 0x800fb5c <z_pend_curr+0x88>
 800fb36: 647b         	str	r3, [r7, #0x44]
 800fb38: 68bb         	ldr	r3, [r7, #0x8]
 800fb3a: 617b         	str	r3, [r7, #0x14]
 800fb3c: 6c7b         	ldr	r3, [r7, #0x44]
 800fb3e: 643b         	str	r3, [r7, #0x40]
 800fb40: bf00         	nop
; 	return z_swap_irqlock(key.key);
 800fb42: 697b         	ldr	r3, [r7, #0x14]
 800fb44: 4618         	mov	r0, r3
 800fb46: f00d fa6d    	bl	0x801d024 <z_swap_irqlock> @ imm = #0xd4da
 800fb4a: 4603         	mov	r3, r0
; }
 800fb4c: 4618         	mov	r0, r3
 800fb4e: 3748         	adds	r7, #0x48
 800fb50: 46bd         	mov	sp, r7
 800fb52: bd80         	pop	{r7, pc}

0800fb54 <$d>:
 800fb54: f0 16 00 20  	.word	0x200016f0
 800fb58: 7c 1f 00 20  	.word	0x20001f7c
 800fb5c: 70 1f 00 20  	.word	0x20001f70

0800fb60 <z_thread_prio_set>:
; {
 800fb60: b580         	push	{r7, lr}
 800fb62: b0a8         	sub	sp, #0xa0
 800fb64: af00         	add	r7, sp, #0x0
 800fb66: 6078         	str	r0, [r7, #0x4]
 800fb68: 6039         	str	r1, [r7]
; 	bool need_sched = 0;
 800fb6a: 2300         	movs	r3, #0x0
 800fb6c: f887 309f    	strb.w	r3, [r7, #0x9f]
; 	int old_prio = thread->base.prio;
 800fb70: 687b         	ldr	r3, [r7, #0x4]
 800fb72: f993 300e    	ldrsb.w	r3, [r3, #0xe]
 800fb76: f8c7 3098    	str.w	r3, [r7, #0x98]
; 	K_SPINLOCK(&_sched_spinlock) {
 800fb7a: 2300         	movs	r3, #0x0
 800fb7c: 617b         	str	r3, [r7, #0x14]
 800fb7e: 4b95         	ldr	r3, [pc, #0x254]        @ 0x800fdd4 <z_thread_prio_set+0x274>
 800fb80: f8c7 3094    	str.w	r3, [r7, #0x94]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800fb84: f3ef 8311    	mrs	r3, basepri
 800fb88: f8c7 3090    	str.w	r3, [r7, #0x90]
;   return(result);
 800fb8c: f8d7 3090    	ldr.w	r3, [r7, #0x90]
; 	key = __get_BASEPRI();
 800fb90: f8c7 308c    	str.w	r3, [r7, #0x8c]
 800fb94: 2310         	movs	r3, #0x10
 800fb96: f8c7 3088    	str.w	r3, [r7, #0x88]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 800fb9a: f8d7 3088    	ldr.w	r3, [r7, #0x88]
 800fb9e: f383 8812    	msr	basepri_max, r3
; }
 800fba2: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800fba4: f3bf 8f6f    	isb	sy
; }
 800fba8: bf00         	nop
; 	return key;
 800fbaa: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
; 	k.key = arch_irq_lock();
 800fbae: 60bb         	str	r3, [r7, #0x8]
 800fbb0: f8d7 3094    	ldr.w	r3, [r7, #0x94]
 800fbb4: f8c7 3084    	str.w	r3, [r7, #0x84]
; }
 800fbb8: bf00         	nop
 800fbba: f8d7 3094    	ldr.w	r3, [r7, #0x94]
 800fbbe: f8c7 3080    	str.w	r3, [r7, #0x80]
; }
 800fbc2: bf00         	nop
; 	return k;
 800fbc4: 68bb         	ldr	r3, [r7, #0x8]
 800fbc6: 613b         	str	r3, [r7, #0x10]
; 	K_SPINLOCK(&_sched_spinlock) {
 800fbc8: e0fa         	b	0x800fdc0 <z_thread_prio_set+0x260> @ imm = #0x1f4
; 		need_sched = z_is_thread_ready(thread);
 800fbca: 6878         	ldr	r0, [r7, #0x4]
 800fbcc: f00d f957    	bl	0x801ce7e <z_is_thread_ready> @ imm = #0xd2ae
 800fbd0: 4603         	mov	r3, r0
 800fbd2: f887 309f    	strb.w	r3, [r7, #0x9f]
; 		if (need_sched) {
 800fbd6: f897 309f    	ldrb.w	r3, [r7, #0x9f]
 800fbda: 2b00         	cmp	r3, #0x0
 800fbdc: f000 80d9    	beq.w	0x800fd92 <z_thread_prio_set+0x232> @ imm = #0x1b2
 800fbe0: 687b         	ldr	r3, [r7, #0x4]
 800fbe2: 667b         	str	r3, [r7, #0x64]
; 	thread->base.thread_state &= ~_THREAD_QUEUED;
 800fbe4: 6e7b         	ldr	r3, [r7, #0x64]
 800fbe6: 7b5b         	ldrb	r3, [r3, #0xd]
 800fbe8: f003 037f    	and	r3, r3, #0x7f
 800fbec: b2da         	uxtb	r2, r3
 800fbee: 6e7b         	ldr	r3, [r7, #0x64]
 800fbf0: 735a         	strb	r2, [r3, #0xd]
; 	if (should_queue_thread(thread)) {
 800fbf2: 6e78         	ldr	r0, [r7, #0x64]
 800fbf4: f00d fa5c    	bl	0x801d0b0 <should_queue_thread> @ imm = #0xd4b8
 800fbf8: 4603         	mov	r3, r0
 800fbfa: 2b00         	cmp	r3, #0x0
 800fbfc: d00d         	beq	0x800fc1a <z_thread_prio_set+0xba> @ imm = #0x1a
 800fbfe: 6e7b         	ldr	r3, [r7, #0x64]
 800fc00: 663b         	str	r3, [r7, #0x60]
 800fc02: 6e3b         	ldr	r3, [r7, #0x60]
 800fc04: 65fb         	str	r3, [r7, #0x5c]
; 	return &_kernel.ready_q.runq;
 800fc06: 4b74         	ldr	r3, [pc, #0x1d0]        @ 0x800fdd8 <z_thread_prio_set+0x278>
 800fc08: 65bb         	str	r3, [r7, #0x58]
 800fc0a: 6e3b         	ldr	r3, [r7, #0x60]
 800fc0c: 657b         	str	r3, [r7, #0x54]
; 	sys_dlist_remove(&thread->base.qnode_dlist);
 800fc0e: 6d7b         	ldr	r3, [r7, #0x54]
 800fc10: 4618         	mov	r0, r3
 800fc12: f00d f88d    	bl	0x801cd30 <sys_dlist_remove> @ imm = #0xd11a
; }
 800fc16: bf00         	nop
; }
 800fc18: bf00         	nop
; }
 800fc1a: bf00         	nop
; 				thread->base.prio = prio;
 800fc1c: 683b         	ldr	r3, [r7]
 800fc1e: b25a         	sxtb	r2, r3
 800fc20: 687b         	ldr	r3, [r7, #0x4]
 800fc22: 739a         	strb	r2, [r3, #0xe]
 800fc24: 687b         	ldr	r3, [r7, #0x4]
 800fc26: 67fb         	str	r3, [r7, #0x7c]
; 	thread->base.thread_state |= _THREAD_QUEUED;
 800fc28: 6ffb         	ldr	r3, [r7, #0x7c]
 800fc2a: 7b5b         	ldrb	r3, [r3, #0xd]
 800fc2c: f063 037f    	orn	r3, r3, #0x7f
 800fc30: b2da         	uxtb	r2, r3
 800fc32: 6ffb         	ldr	r3, [r7, #0x7c]
 800fc34: 735a         	strb	r2, [r3, #0xd]
; 	if (should_queue_thread(thread)) {
 800fc36: 6ff8         	ldr	r0, [r7, #0x7c]
 800fc38: f00d fa3a    	bl	0x801d0b0 <should_queue_thread> @ imm = #0xd474
 800fc3c: 4603         	mov	r3, r0
 800fc3e: 2b00         	cmp	r3, #0x0
 800fc40: d042         	beq	0x800fcc8 <z_thread_prio_set+0x168> @ imm = #0x84
 800fc42: 6ffb         	ldr	r3, [r7, #0x7c]
 800fc44: 67bb         	str	r3, [r7, #0x78]
 800fc46: 6fbb         	ldr	r3, [r7, #0x78]
 800fc48: 677b         	str	r3, [r7, #0x74]
; 	return &_kernel.ready_q.runq;
 800fc4a: 4b63         	ldr	r3, [pc, #0x18c]        @ 0x800fdd8 <z_thread_prio_set+0x278>
 800fc4c: 673b         	str	r3, [r7, #0x70]
 800fc4e: 6fbb         	ldr	r3, [r7, #0x78]
 800fc50: 66fb         	str	r3, [r7, #0x6c]
; 	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
 800fc52: 6f38         	ldr	r0, [r7, #0x70]
 800fc54: f00d f802    	bl	0x801cc5c <sys_dlist_peek_head> @ imm = #0xd004
 800fc58: 4603         	mov	r3, r0
 800fc5a: 2b00         	cmp	r3, #0x0
 800fc5c: d004         	beq	0x800fc68 <z_thread_prio_set+0x108> @ imm = #0x8
 800fc5e: 6f38         	ldr	r0, [r7, #0x70]
 800fc60: f00c fffc    	bl	0x801cc5c <sys_dlist_peek_head> @ imm = #0xcff8
 800fc64: 4603         	mov	r3, r0
 800fc66: e000         	b	0x800fc6a <z_thread_prio_set+0x10a> @ imm = #0x0
 800fc68: 2300         	movs	r3, #0x0
 800fc6a: 66bb         	str	r3, [r7, #0x68]
 800fc6c: e023         	b	0x800fcb6 <z_thread_prio_set+0x156> @ imm = #0x46
; 		if (z_sched_prio_cmp(thread, t) > 0) {
 800fc6e: 6eb9         	ldr	r1, [r7, #0x68]
 800fc70: 6ef8         	ldr	r0, [r7, #0x6c]
 800fc72: f00d fa02    	bl	0x801d07a <z_sched_prio_cmp> @ imm = #0xd404
 800fc76: 4603         	mov	r3, r0
 800fc78: 2b00         	cmp	r3, #0x0
 800fc7a: dd06         	ble	0x800fc8a <z_thread_prio_set+0x12a> @ imm = #0xc
; 			sys_dlist_insert(&t->base.qnode_dlist,
 800fc7c: 6ebb         	ldr	r3, [r7, #0x68]
 800fc7e: 6efa         	ldr	r2, [r7, #0x6c]
 800fc80: 4611         	mov	r1, r2
 800fc82: 4618         	mov	r0, r3
 800fc84: f00d f83b    	bl	0x801ccfe <sys_dlist_insert> @ imm = #0xd076
; 			return;
 800fc88: e01d         	b	0x800fcc6 <z_thread_prio_set+0x166> @ imm = #0x3a
; 	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
 800fc8a: 6ebb         	ldr	r3, [r7, #0x68]
 800fc8c: 2b00         	cmp	r3, #0x0
 800fc8e: d010         	beq	0x800fcb2 <z_thread_prio_set+0x152> @ imm = #0x20
 800fc90: 6ebb         	ldr	r3, [r7, #0x68]
 800fc92: 4619         	mov	r1, r3
 800fc94: 6f38         	ldr	r0, [r7, #0x70]
 800fc96: f00d f806    	bl	0x801cca6 <sys_dlist_peek_next> @ imm = #0xd00c
 800fc9a: 4603         	mov	r3, r0
 800fc9c: 2b00         	cmp	r3, #0x0
 800fc9e: d006         	beq	0x800fcae <z_thread_prio_set+0x14e> @ imm = #0xc
 800fca0: 6ebb         	ldr	r3, [r7, #0x68]
 800fca2: 4619         	mov	r1, r3
 800fca4: 6f38         	ldr	r0, [r7, #0x70]
 800fca6: f00c fffe    	bl	0x801cca6 <sys_dlist_peek_next> @ imm = #0xcffc
 800fcaa: 4603         	mov	r3, r0
 800fcac: e002         	b	0x800fcb4 <z_thread_prio_set+0x154> @ imm = #0x4
 800fcae: 2300         	movs	r3, #0x0
 800fcb0: e000         	b	0x800fcb4 <z_thread_prio_set+0x154> @ imm = #0x0
 800fcb2: 2300         	movs	r3, #0x0
 800fcb4: 66bb         	str	r3, [r7, #0x68]
 800fcb6: 6ebb         	ldr	r3, [r7, #0x68]
 800fcb8: 2b00         	cmp	r3, #0x0
 800fcba: d1d8         	bne	0x800fc6e <z_thread_prio_set+0x10e> @ imm = #-0x50
; 	sys_dlist_append(pq, &thread->base.qnode_dlist);
 800fcbc: 6efb         	ldr	r3, [r7, #0x6c]
 800fcbe: 4619         	mov	r1, r3
 800fcc0: 6f38         	ldr	r0, [r7, #0x70]
 800fcc2: f00d f803    	bl	0x801cccc <sys_dlist_append> @ imm = #0xd006
; }
 800fcc6: bf00         	nop
; }
 800fcc8: bf00         	nop
 800fcca: 2301         	movs	r3, #0x1
 800fccc: 653b         	str	r3, [r7, #0x50]
; 	return &_kernel.ready_q.runq;
 800fcce: 4b42         	ldr	r3, [pc, #0x108]        @ 0x800fdd8 <z_thread_prio_set+0x278>
 800fcd0: 64fb         	str	r3, [r7, #0x4c]
; 	struct k_thread *thread = NULL;
 800fcd2: 2300         	movs	r3, #0x0
 800fcd4: 64bb         	str	r3, [r7, #0x48]
; 	sys_dnode_t *n = sys_dlist_peek_head(pq);
 800fcd6: 6cf8         	ldr	r0, [r7, #0x4c]
 800fcd8: f00c ffc0    	bl	0x801cc5c <sys_dlist_peek_head> @ imm = #0xcf80
 800fcdc: 6478         	str	r0, [r7, #0x44]
; 	if (n != NULL) {
 800fcde: 6c7b         	ldr	r3, [r7, #0x44]
 800fce0: 2b00         	cmp	r3, #0x0
 800fce2: d001         	beq	0x800fce8 <z_thread_prio_set+0x188> @ imm = #0x2
; 		thread = CONTAINER_OF(n, struct k_thread, base.qnode_dlist);
 800fce4: 6c7b         	ldr	r3, [r7, #0x44]
 800fce6: 64bb         	str	r3, [r7, #0x48]
; 	return thread;
 800fce8: 6cbb         	ldr	r3, [r7, #0x48]
; 	return _priq_run_best(curr_cpu_runq());
 800fcea: bf00         	nop
; 	struct k_thread *thread = runq_best();
 800fcec: 643b         	str	r3, [r7, #0x40]
; 	return (thread != NULL) ? thread : _current_cpu->idle_thread;
 800fcee: 6c3b         	ldr	r3, [r7, #0x40]
 800fcf0: 2b00         	cmp	r3, #0x0
 800fcf2: d102         	bne	0x800fcfa <z_thread_prio_set+0x19a> @ imm = #0x4
 800fcf4: 4b39         	ldr	r3, [pc, #0xe4]         @ 0x800fddc <z_thread_prio_set+0x27c>
 800fcf6: 68db         	ldr	r3, [r3, #0xc]
 800fcf8: e000         	b	0x800fcfc <z_thread_prio_set+0x19c> @ imm = #0x0
 800fcfa: 6c3b         	ldr	r3, [r7, #0x40]
; 	struct k_thread *thread = next_up();
 800fcfc: 63fb         	str	r3, [r7, #0x3c]
 800fcfe: 6bfb         	ldr	r3, [r7, #0x3c]
 800fd00: 63bb         	str	r3, [r7, #0x38]
 800fd02: 6d3b         	ldr	r3, [r7, #0x50]
 800fd04: 637b         	str	r3, [r7, #0x34]
; 	if (preempt_ok != 0) {
 800fd06: 6b7b         	ldr	r3, [r7, #0x34]
 800fd08: 2b00         	cmp	r3, #0x0
 800fd0a: d001         	beq	0x800fd10 <z_thread_prio_set+0x1b0> @ imm = #0x2
; 		return true;
 800fd0c: 2301         	movs	r3, #0x1
 800fd0e: e026         	b	0x800fd5e <z_thread_prio_set+0x1fe> @ imm = #0x4c
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800fd10: 4b32         	ldr	r3, [pc, #0xc8]         @ 0x800fddc <z_thread_prio_set+0x27c>
 800fd12: 689b         	ldr	r3, [r3, #0x8]
 800fd14: 633b         	str	r3, [r7, #0x30]
; 	return ret;
 800fd16: 6b3b         	ldr	r3, [r7, #0x30]
; 	if (z_is_thread_prevented_from_running(arch_current_thread())) {
 800fd18: 4618         	mov	r0, r3
 800fd1a: f00d f883    	bl	0x801ce24 <z_is_thread_prevented_from_running> @ imm = #0xd106
 800fd1e: 4603         	mov	r3, r0
 800fd20: 2b00         	cmp	r3, #0x0
 800fd22: d001         	beq	0x800fd28 <z_thread_prio_set+0x1c8> @ imm = #0x2
; 		return true;
 800fd24: 2301         	movs	r3, #0x1
 800fd26: e01a         	b	0x800fd5e <z_thread_prio_set+0x1fe> @ imm = #0x34
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800fd28: 4b2c         	ldr	r3, [pc, #0xb0]         @ 0x800fddc <z_thread_prio_set+0x27c>
 800fd2a: 689b         	ldr	r3, [r3, #0x8]
 800fd2c: 62fb         	str	r3, [r7, #0x2c]
; 	return ret;
 800fd2e: 6afb         	ldr	r3, [r7, #0x2c]
; 	if (thread_is_preemptible(arch_current_thread()) || thread_is_metairq(thread)) {
 800fd30: 4618         	mov	r0, r3
 800fd32: f00d f84b    	bl	0x801cdcc <thread_is_preemptible> @ imm = #0xd096
 800fd36: 4603         	mov	r3, r0
 800fd38: 2b00         	cmp	r3, #0x0
 800fd3a: d105         	bne	0x800fd48 <z_thread_prio_set+0x1e8> @ imm = #0xa
 800fd3c: 6bb8         	ldr	r0, [r7, #0x38]
 800fd3e: f00d f855    	bl	0x801cdec <thread_is_metairq> @ imm = #0xd0aa
 800fd42: 4603         	mov	r3, r0
 800fd44: 2b00         	cmp	r3, #0x0
 800fd46: d001         	beq	0x800fd4c <z_thread_prio_set+0x1ec> @ imm = #0x2
; 		return true;
 800fd48: 2301         	movs	r3, #0x1
 800fd4a: e008         	b	0x800fd5e <z_thread_prio_set+0x1fe> @ imm = #0x10
; 	    && z_is_thread_timeout_active(thread)) {
 800fd4c: 6bb8         	ldr	r0, [r7, #0x38]
 800fd4e: f00d f87d    	bl	0x801ce4c <z_is_thread_timeout_active> @ imm = #0xd0fa
 800fd52: 4603         	mov	r3, r0
; 	if (IS_ENABLED(CONFIG_SWAP_NONATOMIC)
 800fd54: 2b00         	cmp	r3, #0x0
 800fd56: d001         	beq	0x800fd5c <z_thread_prio_set+0x1fc> @ imm = #0x2
; 		return true;
 800fd58: 2301         	movs	r3, #0x1
 800fd5a: e000         	b	0x800fd5e <z_thread_prio_set+0x1fe> @ imm = #0x0
; 	return false;
 800fd5c: 2300         	movs	r3, #0x0
; 	if (should_preempt(thread, preempt_ok)) {
 800fd5e: 2b00         	cmp	r3, #0x0
 800fd60: d010         	beq	0x800fd84 <z_thread_prio_set+0x224> @ imm = #0x20
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800fd62: 4b1e         	ldr	r3, [pc, #0x78]         @ 0x800fddc <z_thread_prio_set+0x27c>
 800fd64: 689b         	ldr	r3, [r3, #0x8]
 800fd66: 62bb         	str	r3, [r7, #0x28]
; 	return ret;
 800fd68: 6abb         	ldr	r3, [r7, #0x28]
; 		if (thread != arch_current_thread()) {
 800fd6a: 6bfa         	ldr	r2, [r7, #0x3c]
 800fd6c: 429a         	cmp	r2, r3
 800fd6e: d002         	beq	0x800fd76 <z_thread_prio_set+0x216> @ imm = #0x4
; 			z_reset_time_slice(thread);
 800fd70: 6bf8         	ldr	r0, [r7, #0x3c]
 800fd72: f000 fdf7    	bl	0x8010964 <z_reset_time_slice> @ imm = #0xbee
; 		update_metairq_preempt(thread);
 800fd76: 6bf8         	ldr	r0, [r7, #0x3c]
 800fd78: f00d f9dd    	bl	0x801d136 <update_metairq_preempt> @ imm = #0xd3ba
; 		_kernel.ready_q.cache = thread;
 800fd7c: 4a17         	ldr	r2, [pc, #0x5c]         @ 0x800fddc <z_thread_prio_set+0x27c>
 800fd7e: 6bfb         	ldr	r3, [r7, #0x3c]
 800fd80: 61d3         	str	r3, [r2, #0x1c]
; }
 800fd82: e00a         	b	0x800fd9a <z_thread_prio_set+0x23a> @ imm = #0x14
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800fd84: 4b15         	ldr	r3, [pc, #0x54]         @ 0x800fddc <z_thread_prio_set+0x27c>
 800fd86: 689b         	ldr	r3, [r3, #0x8]
 800fd88: 627b         	str	r3, [r7, #0x24]
; 	return ret;
 800fd8a: 6a7b         	ldr	r3, [r7, #0x24]
; 		_kernel.ready_q.cache = arch_current_thread();
 800fd8c: 4a13         	ldr	r2, [pc, #0x4c]         @ 0x800fddc <z_thread_prio_set+0x27c>
 800fd8e: 61d3         	str	r3, [r2, #0x1c]
; }
 800fd90: e003         	b	0x800fd9a <z_thread_prio_set+0x23a> @ imm = #0x6
; 			thread->base.prio = prio;
 800fd92: 683b         	ldr	r3, [r7]
 800fd94: b25a         	sxtb	r2, r3
 800fd96: 687b         	ldr	r3, [r7, #0x4]
 800fd98: 739a         	strb	r2, [r3, #0xe]
 800fd9a: 4b0e         	ldr	r3, [pc, #0x38]         @ 0x800fdd4 <z_thread_prio_set+0x274>
 800fd9c: 623b         	str	r3, [r7, #0x20]
 800fd9e: 693b         	ldr	r3, [r7, #0x10]
 800fda0: 60fb         	str	r3, [r7, #0xc]
; 	arch_irq_unlock(key.key);
 800fda2: 68fb         	ldr	r3, [r7, #0xc]
 800fda4: 61fb         	str	r3, [r7, #0x1c]
 800fda6: 69fb         	ldr	r3, [r7, #0x1c]
 800fda8: 61bb         	str	r3, [r7, #0x18]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800fdaa: 69bb         	ldr	r3, [r7, #0x18]
 800fdac: f383 8811    	msr	basepri, r3
; }
 800fdb0: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800fdb2: f3bf 8f6f    	isb	sy
; }
 800fdb6: bf00         	nop
; }
 800fdb8: bf00         	nop
; }
 800fdba: bf00         	nop
; 	K_SPINLOCK(&_sched_spinlock) {
 800fdbc: 2301         	movs	r3, #0x1
 800fdbe: 617b         	str	r3, [r7, #0x14]
 800fdc0: 697b         	ldr	r3, [r7, #0x14]
 800fdc2: 2b00         	cmp	r3, #0x0
 800fdc4: f43f af01    	beq.w	0x800fbca <z_thread_prio_set+0x6a> @ imm = #-0x1fe
; 	return need_sched;
 800fdc8: f897 309f    	ldrb.w	r3, [r7, #0x9f]
; }
 800fdcc: 4618         	mov	r0, r3
 800fdce: 37a0         	adds	r7, #0xa0
 800fdd0: 46bd         	mov	sp, r7
 800fdd2: bd80         	pop	{r7, pc}

0800fdd4 <$d>:
 800fdd4: 70 1f 00 20  	.word	0x20001f70
 800fdd8: 10 17 00 20  	.word	0x20001710
 800fddc: f0 16 00 20  	.word	0x200016f0

0800fde0 <need_swap>:
; {
 800fde0: b480         	push	{r7}
 800fde2: b083         	sub	sp, #0xc
 800fde4: af00         	add	r7, sp, #0x0
; 	new_thread = _kernel.ready_q.cache;
 800fde6: 4b09         	ldr	r3, [pc, #0x24]         @ 0x800fe0c <need_swap+0x2c>
 800fde8: 69db         	ldr	r3, [r3, #0x1c]
 800fdea: 607b         	str	r3, [r7, #0x4]
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800fdec: 4b07         	ldr	r3, [pc, #0x1c]         @ 0x800fe0c <need_swap+0x2c>
 800fdee: 689b         	ldr	r3, [r3, #0x8]
 800fdf0: 603b         	str	r3, [r7]
; 	return ret;
 800fdf2: 683b         	ldr	r3, [r7]
; 	return new_thread != arch_current_thread();
 800fdf4: 687a         	ldr	r2, [r7, #0x4]
 800fdf6: 429a         	cmp	r2, r3
 800fdf8: bf14         	ite	ne
 800fdfa: 2301         	movne	r3, #0x1
 800fdfc: 2300         	moveq	r3, #0x0
 800fdfe: b2db         	uxtb	r3, r3
; }
 800fe00: 4618         	mov	r0, r3
 800fe02: 370c         	adds	r7, #0xc
 800fe04: 46bd         	mov	sp, r7
 800fe06: bc80         	pop	{r7}
 800fe08: 4770         	bx	lr
 800fe0a: bf00         	nop

0800fe0c <$d>:
 800fe0c: f0 16 00 20  	.word	0x200016f0

0800fe10 <k_sched_lock>:
; {
 800fe10: b580         	push	{r7, lr}
 800fe12: b08e         	sub	sp, #0x38
 800fe14: af00         	add	r7, sp, #0x0
; 	K_SPINLOCK(&_sched_spinlock) {
 800fe16: 2300         	movs	r3, #0x0
 800fe18: 613b         	str	r3, [r7, #0x10]
 800fe1a: 4b1c         	ldr	r3, [pc, #0x70]         @ 0x800fe8c <k_sched_lock+0x7c>
 800fe1c: 637b         	str	r3, [r7, #0x34]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800fe1e: f3ef 8311    	mrs	r3, basepri
 800fe22: 633b         	str	r3, [r7, #0x30]
;   return(result);
 800fe24: 6b3b         	ldr	r3, [r7, #0x30]
; 	key = __get_BASEPRI();
 800fe26: 62fb         	str	r3, [r7, #0x2c]
 800fe28: 2310         	movs	r3, #0x10
 800fe2a: 62bb         	str	r3, [r7, #0x28]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 800fe2c: 6abb         	ldr	r3, [r7, #0x28]
 800fe2e: f383 8812    	msr	basepri_max, r3
; }
 800fe32: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800fe34: f3bf 8f6f    	isb	sy
; }
 800fe38: bf00         	nop
; 	return key;
 800fe3a: 6afb         	ldr	r3, [r7, #0x2c]
; 	k.key = arch_irq_lock();
 800fe3c: 607b         	str	r3, [r7, #0x4]
 800fe3e: 6b7b         	ldr	r3, [r7, #0x34]
 800fe40: 627b         	str	r3, [r7, #0x24]
; }
 800fe42: bf00         	nop
 800fe44: 6b7b         	ldr	r3, [r7, #0x34]
 800fe46: 623b         	str	r3, [r7, #0x20]
; }
 800fe48: bf00         	nop
; 	return k;
 800fe4a: 687b         	ldr	r3, [r7, #0x4]
 800fe4c: 60fb         	str	r3, [r7, #0xc]
; 	K_SPINLOCK(&_sched_spinlock) {
 800fe4e: e014         	b	0x800fe7a <k_sched_lock+0x6a> @ imm = #0x28
; 		z_sched_lock();
 800fe50: f7ff f88a    	bl	0x800ef68 <z_sched_lock> @ imm = #-0xeec
 800fe54: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x800fe8c <k_sched_lock+0x7c>
 800fe56: 61fb         	str	r3, [r7, #0x1c]
 800fe58: 68fb         	ldr	r3, [r7, #0xc]
 800fe5a: 60bb         	str	r3, [r7, #0x8]
; 	arch_irq_unlock(key.key);
 800fe5c: 68bb         	ldr	r3, [r7, #0x8]
 800fe5e: 61bb         	str	r3, [r7, #0x18]
 800fe60: 69bb         	ldr	r3, [r7, #0x18]
 800fe62: 617b         	str	r3, [r7, #0x14]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800fe64: 697b         	ldr	r3, [r7, #0x14]
 800fe66: f383 8811    	msr	basepri, r3
; }
 800fe6a: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800fe6c: f3bf 8f6f    	isb	sy
; }
 800fe70: bf00         	nop
; }
 800fe72: bf00         	nop
; }
 800fe74: bf00         	nop
; 	K_SPINLOCK(&_sched_spinlock) {
 800fe76: 2301         	movs	r3, #0x1
 800fe78: 613b         	str	r3, [r7, #0x10]
 800fe7a: 693b         	ldr	r3, [r7, #0x10]
 800fe7c: 2b00         	cmp	r3, #0x0
 800fe7e: d0e7         	beq	0x800fe50 <k_sched_lock+0x40> @ imm = #-0x32
; }
 800fe80: bf00         	nop
 800fe82: bf00         	nop
 800fe84: 3738         	adds	r7, #0x38
 800fe86: 46bd         	mov	sp, r7
 800fe88: bd80         	pop	{r7, pc}
 800fe8a: bf00         	nop

0800fe8c <$d>:
 800fe8c: 70 1f 00 20  	.word	0x20001f70

0800fe90 <k_sched_unlock>:
; {
 800fe90: b580         	push	{r7, lr}
 800fe92: b0a4         	sub	sp, #0x90
 800fe94: af06         	add	r7, sp, #0x18
; 	K_SPINLOCK(&_sched_spinlock) {
 800fe96: 2300         	movs	r3, #0x0
 800fe98: 60fb         	str	r3, [r7, #0xc]
 800fe9a: 4b66         	ldr	r3, [pc, #0x198]        @ 0x8010034 <k_sched_unlock+0x1a4>
 800fe9c: 66fb         	str	r3, [r7, #0x6c]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800fe9e: f3ef 8311    	mrs	r3, basepri
 800fea2: 66bb         	str	r3, [r7, #0x68]
;   return(result);
 800fea4: 6ebb         	ldr	r3, [r7, #0x68]
; 	key = __get_BASEPRI();
 800fea6: 667b         	str	r3, [r7, #0x64]
 800fea8: 2310         	movs	r3, #0x10
 800feaa: 663b         	str	r3, [r7, #0x60]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 800feac: 6e3b         	ldr	r3, [r7, #0x60]
 800feae: f383 8812    	msr	basepri_max, r3
; }
 800feb2: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800feb4: f3bf 8f6f    	isb	sy
; }
 800feb8: bf00         	nop
; 	return key;
 800feba: 6e7b         	ldr	r3, [r7, #0x64]
; 	k.key = arch_irq_lock();
 800febc: 603b         	str	r3, [r7]
 800febe: 6efb         	ldr	r3, [r7, #0x6c]
 800fec0: 65fb         	str	r3, [r7, #0x5c]
; }
 800fec2: bf00         	nop
 800fec4: 6efb         	ldr	r3, [r7, #0x6c]
 800fec6: 65bb         	str	r3, [r7, #0x58]
; }
 800fec8: bf00         	nop
; 	return k;
 800feca: 683b         	ldr	r3, [r7]
 800fecc: 60bb         	str	r3, [r7, #0x8]
; 	K_SPINLOCK(&_sched_spinlock) {
 800fece: e07e         	b	0x800ffce <k_sched_unlock+0x13e> @ imm = #0xfc
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800fed0: 4b59         	ldr	r3, [pc, #0x164]        @ 0x8010038 <k_sched_unlock+0x1a8>
 800fed2: 689b         	ldr	r3, [r3, #0x8]
 800fed4: 61bb         	str	r3, [r7, #0x18]
; 	return ret;
 800fed6: 69bb         	ldr	r3, [r7, #0x18]
; 		++arch_current_thread()->base.sched_locked;
 800fed8: 7bda         	ldrb	r2, [r3, #0xf]
 800feda: 3201         	adds	r2, #0x1
 800fedc: b2d2         	uxtb	r2, r2
 800fede: 73da         	strb	r2, [r3, #0xf]
 800fee0: 2300         	movs	r3, #0x0
 800fee2: 64bb         	str	r3, [r7, #0x48]
; 	return &_kernel.ready_q.runq;
 800fee4: 4b55         	ldr	r3, [pc, #0x154]        @ 0x801003c <k_sched_unlock+0x1ac>
 800fee6: 647b         	str	r3, [r7, #0x44]
; 	struct k_thread *thread = NULL;
 800fee8: 2300         	movs	r3, #0x0
 800feea: 643b         	str	r3, [r7, #0x40]
; 	sys_dnode_t *n = sys_dlist_peek_head(pq);
 800feec: 6c78         	ldr	r0, [r7, #0x44]
 800feee: f00c feb5    	bl	0x801cc5c <sys_dlist_peek_head> @ imm = #0xcd6a
 800fef2: 63f8         	str	r0, [r7, #0x3c]
; 	if (n != NULL) {
 800fef4: 6bfb         	ldr	r3, [r7, #0x3c]
 800fef6: 2b00         	cmp	r3, #0x0
 800fef8: d001         	beq	0x800fefe <k_sched_unlock+0x6e> @ imm = #0x2
; 		thread = CONTAINER_OF(n, struct k_thread, base.qnode_dlist);
 800fefa: 6bfb         	ldr	r3, [r7, #0x3c]
 800fefc: 643b         	str	r3, [r7, #0x40]
; 	return thread;
 800fefe: 6c3b         	ldr	r3, [r7, #0x40]
; 	return _priq_run_best(curr_cpu_runq());
 800ff00: bf00         	nop
; 	struct k_thread *thread = runq_best();
 800ff02: 63bb         	str	r3, [r7, #0x38]
; 	return (thread != NULL) ? thread : _current_cpu->idle_thread;
 800ff04: 6bbb         	ldr	r3, [r7, #0x38]
 800ff06: 2b00         	cmp	r3, #0x0
 800ff08: d102         	bne	0x800ff10 <k_sched_unlock+0x80> @ imm = #0x4
 800ff0a: 4b4b         	ldr	r3, [pc, #0x12c]        @ 0x8010038 <k_sched_unlock+0x1a8>
 800ff0c: 68db         	ldr	r3, [r3, #0xc]
 800ff0e: e000         	b	0x800ff12 <k_sched_unlock+0x82> @ imm = #0x0
 800ff10: 6bbb         	ldr	r3, [r7, #0x38]
; 	struct k_thread *thread = next_up();
 800ff12: 637b         	str	r3, [r7, #0x34]
 800ff14: 6b7b         	ldr	r3, [r7, #0x34]
 800ff16: 633b         	str	r3, [r7, #0x30]
 800ff18: 6cbb         	ldr	r3, [r7, #0x48]
 800ff1a: 62fb         	str	r3, [r7, #0x2c]
; 	if (preempt_ok != 0) {
 800ff1c: 6afb         	ldr	r3, [r7, #0x2c]
 800ff1e: 2b00         	cmp	r3, #0x0
 800ff20: d001         	beq	0x800ff26 <k_sched_unlock+0x96> @ imm = #0x2
; 		return true;
 800ff22: 2301         	movs	r3, #0x1
 800ff24: e026         	b	0x800ff74 <k_sched_unlock+0xe4> @ imm = #0x4c
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800ff26: 4b44         	ldr	r3, [pc, #0x110]        @ 0x8010038 <k_sched_unlock+0x1a8>
 800ff28: 689b         	ldr	r3, [r3, #0x8]
 800ff2a: 62bb         	str	r3, [r7, #0x28]
; 	return ret;
 800ff2c: 6abb         	ldr	r3, [r7, #0x28]
; 	if (z_is_thread_prevented_from_running(arch_current_thread())) {
 800ff2e: 4618         	mov	r0, r3
 800ff30: f00c ff78    	bl	0x801ce24 <z_is_thread_prevented_from_running> @ imm = #0xcef0
 800ff34: 4603         	mov	r3, r0
 800ff36: 2b00         	cmp	r3, #0x0
 800ff38: d001         	beq	0x800ff3e <k_sched_unlock+0xae> @ imm = #0x2
; 		return true;
 800ff3a: 2301         	movs	r3, #0x1
 800ff3c: e01a         	b	0x800ff74 <k_sched_unlock+0xe4> @ imm = #0x34
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800ff3e: 4b3e         	ldr	r3, [pc, #0xf8]         @ 0x8010038 <k_sched_unlock+0x1a8>
 800ff40: 689b         	ldr	r3, [r3, #0x8]
 800ff42: 627b         	str	r3, [r7, #0x24]
; 	return ret;
 800ff44: 6a7b         	ldr	r3, [r7, #0x24]
; 	if (thread_is_preemptible(arch_current_thread()) || thread_is_metairq(thread)) {
 800ff46: 4618         	mov	r0, r3
 800ff48: f00c ff40    	bl	0x801cdcc <thread_is_preemptible> @ imm = #0xce80
 800ff4c: 4603         	mov	r3, r0
 800ff4e: 2b00         	cmp	r3, #0x0
 800ff50: d105         	bne	0x800ff5e <k_sched_unlock+0xce> @ imm = #0xa
 800ff52: 6b38         	ldr	r0, [r7, #0x30]
 800ff54: f00c ff4a    	bl	0x801cdec <thread_is_metairq> @ imm = #0xce94
 800ff58: 4603         	mov	r3, r0
 800ff5a: 2b00         	cmp	r3, #0x0
 800ff5c: d001         	beq	0x800ff62 <k_sched_unlock+0xd2> @ imm = #0x2
; 		return true;
 800ff5e: 2301         	movs	r3, #0x1
 800ff60: e008         	b	0x800ff74 <k_sched_unlock+0xe4> @ imm = #0x10
; 	    && z_is_thread_timeout_active(thread)) {
 800ff62: 6b38         	ldr	r0, [r7, #0x30]
 800ff64: f00c ff72    	bl	0x801ce4c <z_is_thread_timeout_active> @ imm = #0xcee4
 800ff68: 4603         	mov	r3, r0
; 	if (IS_ENABLED(CONFIG_SWAP_NONATOMIC)
 800ff6a: 2b00         	cmp	r3, #0x0
 800ff6c: d001         	beq	0x800ff72 <k_sched_unlock+0xe2> @ imm = #0x2
; 		return true;
 800ff6e: 2301         	movs	r3, #0x1
 800ff70: e000         	b	0x800ff74 <k_sched_unlock+0xe4> @ imm = #0x0
; 	return false;
 800ff72: 2300         	movs	r3, #0x0
; 	if (should_preempt(thread, preempt_ok)) {
 800ff74: 2b00         	cmp	r3, #0x0
 800ff76: d010         	beq	0x800ff9a <k_sched_unlock+0x10a> @ imm = #0x20
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800ff78: 4b2f         	ldr	r3, [pc, #0xbc]         @ 0x8010038 <k_sched_unlock+0x1a8>
 800ff7a: 689b         	ldr	r3, [r3, #0x8]
 800ff7c: 623b         	str	r3, [r7, #0x20]
; 	return ret;
 800ff7e: 6a3b         	ldr	r3, [r7, #0x20]
; 		if (thread != arch_current_thread()) {
 800ff80: 6b7a         	ldr	r2, [r7, #0x34]
 800ff82: 429a         	cmp	r2, r3
 800ff84: d002         	beq	0x800ff8c <k_sched_unlock+0xfc> @ imm = #0x4
; 			z_reset_time_slice(thread);
 800ff86: 6b78         	ldr	r0, [r7, #0x34]
 800ff88: f000 fcec    	bl	0x8010964 <z_reset_time_slice> @ imm = #0x9d8
; 		update_metairq_preempt(thread);
 800ff8c: 6b78         	ldr	r0, [r7, #0x34]
 800ff8e: f00d f8d2    	bl	0x801d136 <update_metairq_preempt> @ imm = #0xd1a4
; 		_kernel.ready_q.cache = thread;
 800ff92: 4a29         	ldr	r2, [pc, #0xa4]         @ 0x8010038 <k_sched_unlock+0x1a8>
 800ff94: 6b7b         	ldr	r3, [r7, #0x34]
 800ff96: 61d3         	str	r3, [r2, #0x1c]
; }
 800ff98: e005         	b	0x800ffa6 <k_sched_unlock+0x116> @ imm = #0xa
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800ff9a: 4b27         	ldr	r3, [pc, #0x9c]         @ 0x8010038 <k_sched_unlock+0x1a8>
 800ff9c: 689b         	ldr	r3, [r3, #0x8]
 800ff9e: 61fb         	str	r3, [r7, #0x1c]
; 	return ret;
 800ffa0: 69fb         	ldr	r3, [r7, #0x1c]
; 		_kernel.ready_q.cache = arch_current_thread();
 800ffa2: 4a25         	ldr	r2, [pc, #0x94]         @ 0x8010038 <k_sched_unlock+0x1a8>
 800ffa4: 61d3         	str	r3, [r2, #0x1c]
; }
 800ffa6: bf00         	nop
 800ffa8: 4b22         	ldr	r3, [pc, #0x88]         @ 0x8010034 <k_sched_unlock+0x1a4>
 800ffaa: 657b         	str	r3, [r7, #0x54]
 800ffac: 68bb         	ldr	r3, [r7, #0x8]
 800ffae: 607b         	str	r3, [r7, #0x4]
; 	arch_irq_unlock(key.key);
 800ffb0: 687b         	ldr	r3, [r7, #0x4]
 800ffb2: 653b         	str	r3, [r7, #0x50]
 800ffb4: 6d3b         	ldr	r3, [r7, #0x50]
 800ffb6: 64fb         	str	r3, [r7, #0x4c]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800ffb8: 6cfb         	ldr	r3, [r7, #0x4c]
 800ffba: f383 8811    	msr	basepri, r3
; }
 800ffbe: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800ffc0: f3bf 8f6f    	isb	sy
; }
 800ffc4: bf00         	nop
; }
 800ffc6: bf00         	nop
; }
 800ffc8: bf00         	nop
; 	K_SPINLOCK(&_sched_spinlock) {
 800ffca: 2301         	movs	r3, #0x1
 800ffcc: 60fb         	str	r3, [r7, #0xc]
 800ffce: 68fb         	ldr	r3, [r7, #0xc]
 800ffd0: 2b00         	cmp	r3, #0x0
 800ffd2: f43f af7d    	beq.w	0x800fed0 <k_sched_unlock+0x40> @ imm = #-0x106
; 	LOG_DBG("scheduler unlocked (%p:%d)",
 800ffd6: 2303         	movs	r3, #0x3
 800ffd8: 2b03         	cmp	r3, #0x3
 800ffda: d925         	bls	0x8010028 <k_sched_unlock+0x198> @ imm = #0x4a
 800ffdc: 2301         	movs	r3, #0x1
 800ffde: f887 3077    	strb.w	r3, [r7, #0x77]
 800ffe2: f897 3077    	ldrb.w	r3, [r7, #0x77]
 800ffe6: f083 0301    	eor	r3, r3, #0x1
 800ffea: b2db         	uxtb	r3, r3
 800ffec: 2b00         	cmp	r3, #0x0
 800ffee: d11b         	bne	0x8010028 <k_sched_unlock+0x198> @ imm = #0x36
 800fff0: 4b13         	ldr	r3, [pc, #0x4c]         @ 0x8010040 <k_sched_unlock+0x1b0>
 800fff2: 6819         	ldr	r1, [r3]
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800fff4: 4b10         	ldr	r3, [pc, #0x40]         @ 0x8010038 <k_sched_unlock+0x1a8>
 800fff6: 689b         	ldr	r3, [r3, #0x8]
 800fff8: 613b         	str	r3, [r7, #0x10]
; 	return ret;
 800fffa: 693b         	ldr	r3, [r7, #0x10]
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800fffc: 4a0e         	ldr	r2, [pc, #0x38]         @ 0x8010038 <k_sched_unlock+0x1a8>
 800fffe: 6892         	ldr	r2, [r2, #0x8]
 8010000: 617a         	str	r2, [r7, #0x14]
; 	return ret;
 8010002: 697a         	ldr	r2, [r7, #0x14]
; 	LOG_DBG("scheduler unlocked (%p:%d)",
 8010004: 7bd2         	ldrb	r2, [r2, #0xf]
 8010006: 9205         	str	r2, [sp, #0x14]
 8010008: 9304         	str	r3, [sp, #0x10]
 801000a: 4b0e         	ldr	r3, [pc, #0x38]         @ 0x8010044 <k_sched_unlock+0x1b4>
 801000c: 9303         	str	r3, [sp, #0xc]
 801000e: 4b0e         	ldr	r3, [pc, #0x38]         @ 0x8010048 <k_sched_unlock+0x1b8>
 8010010: 9302         	str	r3, [sp, #0x8]
 8010012: 2308         	movs	r3, #0x8
 8010014: 9301         	str	r3, [sp, #0x4]
 8010016: 2300         	movs	r3, #0x0
 8010018: 9300         	str	r3, [sp]
 801001a: 2300         	movs	r3, #0x0
 801001c: 2204         	movs	r2, #0x4
 801001e: 2000         	movs	r0, #0x0
 8010020: f00d f80d    	bl	0x801d03e <z_log_msg_runtime_create> @ imm = #0xd01a
 8010024: 2300         	movs	r3, #0x0
 8010026: 673b         	str	r3, [r7, #0x70]
; 	z_reschedule_unlocked();
 8010028: f00c ffbc    	bl	0x801cfa4 <z_reschedule_unlocked> @ imm = #0xcf78
; }
 801002c: bf00         	nop
 801002e: 3778         	adds	r7, #0x78
 8010030: 46bd         	mov	sp, r7
 8010032: bd80         	pop	{r7, pc}

08010034 <$d>:
 8010034: 70 1f 00 20  	.word	0x20001f70
 8010038: f0 16 00 20  	.word	0x200016f0
 801003c: 10 17 00 20  	.word	0x20001710
 8010040: b8 05 00 20  	.word	0x200005b8
 8010044: 48 07 02 08  	.word	0x08020748
 8010048: 30 fb 01 08  	.word	0x0801fb30

0801004c <z_sched_init>:
; {
 801004c: b580         	push	{r7, lr}
 801004e: af00         	add	r7, sp, #0x0
; 	init_ready_q(&_kernel.ready_q);
 8010050: 4802         	ldr	r0, [pc, #0x8]          @ 0x801005c <z_sched_init+0x10>
 8010052: f00d f98f    	bl	0x801d374 <init_ready_q> @ imm = #0xd31e
; }
 8010056: bf00         	nop
 8010058: bd80         	pop	{r7, pc}
 801005a: bf00         	nop

0801005c <$d>:
 801005c: 0c 17 00 20  	.word	0x2000170c

08010060 <z_impl_k_yield>:
; {
 8010060: b580         	push	{r7, lr}
 8010062: b0a4         	sub	sp, #0x90
 8010064: af00         	add	r7, sp, #0x0
 8010066: 4b86         	ldr	r3, [pc, #0x218]        @ 0x8010280 <z_impl_k_yield+0x220>
 8010068: f8c7 308c    	str.w	r3, [r7, #0x8c]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 801006c: f3ef 8311    	mrs	r3, basepri
 8010070: f8c7 3088    	str.w	r3, [r7, #0x88]
;   return(result);
 8010074: f8d7 3088    	ldr.w	r3, [r7, #0x88]
; 	key = __get_BASEPRI();
 8010078: f8c7 3084    	str.w	r3, [r7, #0x84]
 801007c: 2310         	movs	r3, #0x10
 801007e: f8c7 3080    	str.w	r3, [r7, #0x80]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 8010082: f8d7 3080    	ldr.w	r3, [r7, #0x80]
 8010086: f383 8812    	msr	basepri_max, r3
; }
 801008a: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 801008c: f3bf 8f6f    	isb	sy
; }
 8010090: bf00         	nop
; 	return key;
 8010092: f8d7 3084    	ldr.w	r3, [r7, #0x84]
; 	k.key = arch_irq_lock();
 8010096: 603b         	str	r3, [r7]
 8010098: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 801009c: 67fb         	str	r3, [r7, #0x7c]
; }
 801009e: bf00         	nop
 80100a0: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 80100a4: 67bb         	str	r3, [r7, #0x78]
; }
 80100a6: bf00         	nop
; 	return k;
 80100a8: 683b         	ldr	r3, [r7]
 80100aa: 60bb         	str	r3, [r7, #0x8]
; 	struct k_thread *ret = _kernel.cpus[0].current;
 80100ac: 4b75         	ldr	r3, [pc, #0x1d4]        @ 0x8010284 <z_impl_k_yield+0x224>
 80100ae: 689b         	ldr	r3, [r3, #0x8]
 80100b0: 60fb         	str	r3, [r7, #0xc]
; 	return ret;
 80100b2: 68fb         	ldr	r3, [r7, #0xc]
 80100b4: 623b         	str	r3, [r7, #0x20]
; 	thread->base.thread_state &= ~_THREAD_QUEUED;
 80100b6: 6a3b         	ldr	r3, [r7, #0x20]
 80100b8: 7b5b         	ldrb	r3, [r3, #0xd]
 80100ba: f003 037f    	and	r3, r3, #0x7f
 80100be: b2da         	uxtb	r2, r3
 80100c0: 6a3b         	ldr	r3, [r7, #0x20]
 80100c2: 735a         	strb	r2, [r3, #0xd]
; 	if (should_queue_thread(thread)) {
 80100c4: 6a38         	ldr	r0, [r7, #0x20]
 80100c6: f00c fff3    	bl	0x801d0b0 <should_queue_thread> @ imm = #0xcfe6
 80100ca: 4603         	mov	r3, r0
 80100cc: 2b00         	cmp	r3, #0x0
 80100ce: d00d         	beq	0x80100ec <z_impl_k_yield+0x8c> @ imm = #0x1a
 80100d0: 6a3b         	ldr	r3, [r7, #0x20]
 80100d2: 61fb         	str	r3, [r7, #0x1c]
 80100d4: 69fb         	ldr	r3, [r7, #0x1c]
 80100d6: 61bb         	str	r3, [r7, #0x18]
; 	return &_kernel.ready_q.runq;
 80100d8: 4b6b         	ldr	r3, [pc, #0x1ac]        @ 0x8010288 <z_impl_k_yield+0x228>
 80100da: 617b         	str	r3, [r7, #0x14]
 80100dc: 69fb         	ldr	r3, [r7, #0x1c]
 80100de: 613b         	str	r3, [r7, #0x10]
; 	sys_dlist_remove(&thread->base.qnode_dlist);
 80100e0: 693b         	ldr	r3, [r7, #0x10]
 80100e2: 4618         	mov	r0, r3
 80100e4: f00c fe24    	bl	0x801cd30 <sys_dlist_remove> @ imm = #0xcc48
; }
 80100e8: bf00         	nop
; }
 80100ea: bf00         	nop
; }
 80100ec: bf00         	nop
; 	struct k_thread *ret = _kernel.cpus[0].current;
 80100ee: 4b65         	ldr	r3, [pc, #0x194]        @ 0x8010284 <z_impl_k_yield+0x224>
 80100f0: 689b         	ldr	r3, [r3, #0x8]
 80100f2: 627b         	str	r3, [r7, #0x24]
; 	return ret;
 80100f4: 6a7b         	ldr	r3, [r7, #0x24]
 80100f6: 63fb         	str	r3, [r7, #0x3c]
; 	thread->base.thread_state |= _THREAD_QUEUED;
 80100f8: 6bfb         	ldr	r3, [r7, #0x3c]
 80100fa: 7b5b         	ldrb	r3, [r3, #0xd]
 80100fc: f063 037f    	orn	r3, r3, #0x7f
 8010100: b2da         	uxtb	r2, r3
 8010102: 6bfb         	ldr	r3, [r7, #0x3c]
 8010104: 735a         	strb	r2, [r3, #0xd]
; 	if (should_queue_thread(thread)) {
 8010106: 6bf8         	ldr	r0, [r7, #0x3c]
 8010108: f00c ffd2    	bl	0x801d0b0 <should_queue_thread> @ imm = #0xcfa4
 801010c: 4603         	mov	r3, r0
 801010e: 2b00         	cmp	r3, #0x0
 8010110: d042         	beq	0x8010198 <z_impl_k_yield+0x138> @ imm = #0x84
 8010112: 6bfb         	ldr	r3, [r7, #0x3c]
 8010114: 63bb         	str	r3, [r7, #0x38]
 8010116: 6bbb         	ldr	r3, [r7, #0x38]
 8010118: 637b         	str	r3, [r7, #0x34]
; 	return &_kernel.ready_q.runq;
 801011a: 4b5b         	ldr	r3, [pc, #0x16c]        @ 0x8010288 <z_impl_k_yield+0x228>
 801011c: 633b         	str	r3, [r7, #0x30]
 801011e: 6bbb         	ldr	r3, [r7, #0x38]
 8010120: 62fb         	str	r3, [r7, #0x2c]
; 	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
 8010122: 6b38         	ldr	r0, [r7, #0x30]
 8010124: f00c fd9a    	bl	0x801cc5c <sys_dlist_peek_head> @ imm = #0xcb34
 8010128: 4603         	mov	r3, r0
 801012a: 2b00         	cmp	r3, #0x0
 801012c: d004         	beq	0x8010138 <z_impl_k_yield+0xd8> @ imm = #0x8
 801012e: 6b38         	ldr	r0, [r7, #0x30]
 8010130: f00c fd94    	bl	0x801cc5c <sys_dlist_peek_head> @ imm = #0xcb28
 8010134: 4603         	mov	r3, r0
 8010136: e000         	b	0x801013a <z_impl_k_yield+0xda> @ imm = #0x0
 8010138: 2300         	movs	r3, #0x0
 801013a: 62bb         	str	r3, [r7, #0x28]
 801013c: e023         	b	0x8010186 <z_impl_k_yield+0x126> @ imm = #0x46
; 		if (z_sched_prio_cmp(thread, t) > 0) {
 801013e: 6ab9         	ldr	r1, [r7, #0x28]
 8010140: 6af8         	ldr	r0, [r7, #0x2c]
 8010142: f00c ff9a    	bl	0x801d07a <z_sched_prio_cmp> @ imm = #0xcf34
 8010146: 4603         	mov	r3, r0
 8010148: 2b00         	cmp	r3, #0x0
 801014a: dd06         	ble	0x801015a <z_impl_k_yield+0xfa> @ imm = #0xc
; 			sys_dlist_insert(&t->base.qnode_dlist,
 801014c: 6abb         	ldr	r3, [r7, #0x28]
 801014e: 6afa         	ldr	r2, [r7, #0x2c]
 8010150: 4611         	mov	r1, r2
 8010152: 4618         	mov	r0, r3
 8010154: f00c fdd3    	bl	0x801ccfe <sys_dlist_insert> @ imm = #0xcba6
; 			return;
 8010158: e01d         	b	0x8010196 <z_impl_k_yield+0x136> @ imm = #0x3a
; 	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
 801015a: 6abb         	ldr	r3, [r7, #0x28]
 801015c: 2b00         	cmp	r3, #0x0
 801015e: d010         	beq	0x8010182 <z_impl_k_yield+0x122> @ imm = #0x20
 8010160: 6abb         	ldr	r3, [r7, #0x28]
 8010162: 4619         	mov	r1, r3
 8010164: 6b38         	ldr	r0, [r7, #0x30]
 8010166: f00c fd9e    	bl	0x801cca6 <sys_dlist_peek_next> @ imm = #0xcb3c
 801016a: 4603         	mov	r3, r0
 801016c: 2b00         	cmp	r3, #0x0
 801016e: d006         	beq	0x801017e <z_impl_k_yield+0x11e> @ imm = #0xc
 8010170: 6abb         	ldr	r3, [r7, #0x28]
 8010172: 4619         	mov	r1, r3
 8010174: 6b38         	ldr	r0, [r7, #0x30]
 8010176: f00c fd96    	bl	0x801cca6 <sys_dlist_peek_next> @ imm = #0xcb2c
 801017a: 4603         	mov	r3, r0
 801017c: e002         	b	0x8010184 <z_impl_k_yield+0x124> @ imm = #0x4
 801017e: 2300         	movs	r3, #0x0
 8010180: e000         	b	0x8010184 <z_impl_k_yield+0x124> @ imm = #0x0
 8010182: 2300         	movs	r3, #0x0
 8010184: 62bb         	str	r3, [r7, #0x28]
 8010186: 6abb         	ldr	r3, [r7, #0x28]
 8010188: 2b00         	cmp	r3, #0x0
 801018a: d1d8         	bne	0x801013e <z_impl_k_yield+0xde> @ imm = #-0x50
; 	sys_dlist_append(pq, &thread->base.qnode_dlist);
 801018c: 6afb         	ldr	r3, [r7, #0x2c]
 801018e: 4619         	mov	r1, r3
 8010190: 6b38         	ldr	r0, [r7, #0x30]
 8010192: f00c fd9b    	bl	0x801cccc <sys_dlist_append> @ imm = #0xcb36
; }
 8010196: bf00         	nop
; }
 8010198: bf00         	nop
 801019a: 2301         	movs	r3, #0x1
 801019c: 66fb         	str	r3, [r7, #0x6c]
; 	return &_kernel.ready_q.runq;
 801019e: 4b3a         	ldr	r3, [pc, #0xe8]         @ 0x8010288 <z_impl_k_yield+0x228>
 80101a0: 66bb         	str	r3, [r7, #0x68]
; 	struct k_thread *thread = NULL;
 80101a2: 2300         	movs	r3, #0x0
 80101a4: 667b         	str	r3, [r7, #0x64]
; 	sys_dnode_t *n = sys_dlist_peek_head(pq);
 80101a6: 6eb8         	ldr	r0, [r7, #0x68]
 80101a8: f00c fd58    	bl	0x801cc5c <sys_dlist_peek_head> @ imm = #0xcab0
 80101ac: 6638         	str	r0, [r7, #0x60]
; 	if (n != NULL) {
 80101ae: 6e3b         	ldr	r3, [r7, #0x60]
 80101b0: 2b00         	cmp	r3, #0x0
 80101b2: d001         	beq	0x80101b8 <z_impl_k_yield+0x158> @ imm = #0x2
; 		thread = CONTAINER_OF(n, struct k_thread, base.qnode_dlist);
 80101b4: 6e3b         	ldr	r3, [r7, #0x60]
 80101b6: 667b         	str	r3, [r7, #0x64]
; 	return thread;
 80101b8: 6e7b         	ldr	r3, [r7, #0x64]
; 	return _priq_run_best(curr_cpu_runq());
 80101ba: bf00         	nop
; 	struct k_thread *thread = runq_best();
 80101bc: 65fb         	str	r3, [r7, #0x5c]
; 	return (thread != NULL) ? thread : _current_cpu->idle_thread;
 80101be: 6dfb         	ldr	r3, [r7, #0x5c]
 80101c0: 2b00         	cmp	r3, #0x0
 80101c2: d102         	bne	0x80101ca <z_impl_k_yield+0x16a> @ imm = #0x4
 80101c4: 4b2f         	ldr	r3, [pc, #0xbc]         @ 0x8010284 <z_impl_k_yield+0x224>
 80101c6: 68db         	ldr	r3, [r3, #0xc]
 80101c8: e000         	b	0x80101cc <z_impl_k_yield+0x16c> @ imm = #0x0
 80101ca: 6dfb         	ldr	r3, [r7, #0x5c]
; 	struct k_thread *thread = next_up();
 80101cc: 65bb         	str	r3, [r7, #0x58]
 80101ce: 6dbb         	ldr	r3, [r7, #0x58]
 80101d0: 657b         	str	r3, [r7, #0x54]
 80101d2: 6efb         	ldr	r3, [r7, #0x6c]
 80101d4: 653b         	str	r3, [r7, #0x50]
; 	if (preempt_ok != 0) {
 80101d6: 6d3b         	ldr	r3, [r7, #0x50]
 80101d8: 2b00         	cmp	r3, #0x0
 80101da: d001         	beq	0x80101e0 <z_impl_k_yield+0x180> @ imm = #0x2
; 		return true;
 80101dc: 2301         	movs	r3, #0x1
 80101de: e026         	b	0x801022e <z_impl_k_yield+0x1ce> @ imm = #0x4c
; 	struct k_thread *ret = _kernel.cpus[0].current;
 80101e0: 4b28         	ldr	r3, [pc, #0xa0]         @ 0x8010284 <z_impl_k_yield+0x224>
 80101e2: 689b         	ldr	r3, [r3, #0x8]
 80101e4: 64fb         	str	r3, [r7, #0x4c]
; 	return ret;
 80101e6: 6cfb         	ldr	r3, [r7, #0x4c]
; 	if (z_is_thread_prevented_from_running(arch_current_thread())) {
 80101e8: 4618         	mov	r0, r3
 80101ea: f00c fe1b    	bl	0x801ce24 <z_is_thread_prevented_from_running> @ imm = #0xcc36
 80101ee: 4603         	mov	r3, r0
 80101f0: 2b00         	cmp	r3, #0x0
 80101f2: d001         	beq	0x80101f8 <z_impl_k_yield+0x198> @ imm = #0x2
; 		return true;
 80101f4: 2301         	movs	r3, #0x1
 80101f6: e01a         	b	0x801022e <z_impl_k_yield+0x1ce> @ imm = #0x34
; 	struct k_thread *ret = _kernel.cpus[0].current;
 80101f8: 4b22         	ldr	r3, [pc, #0x88]         @ 0x8010284 <z_impl_k_yield+0x224>
 80101fa: 689b         	ldr	r3, [r3, #0x8]
 80101fc: 64bb         	str	r3, [r7, #0x48]
; 	return ret;
 80101fe: 6cbb         	ldr	r3, [r7, #0x48]
; 	if (thread_is_preemptible(arch_current_thread()) || thread_is_metairq(thread)) {
 8010200: 4618         	mov	r0, r3
 8010202: f00c fde3    	bl	0x801cdcc <thread_is_preemptible> @ imm = #0xcbc6
 8010206: 4603         	mov	r3, r0
 8010208: 2b00         	cmp	r3, #0x0
 801020a: d105         	bne	0x8010218 <z_impl_k_yield+0x1b8> @ imm = #0xa
 801020c: 6d78         	ldr	r0, [r7, #0x54]
 801020e: f00c fded    	bl	0x801cdec <thread_is_metairq> @ imm = #0xcbda
 8010212: 4603         	mov	r3, r0
 8010214: 2b00         	cmp	r3, #0x0
 8010216: d001         	beq	0x801021c <z_impl_k_yield+0x1bc> @ imm = #0x2
; 		return true;
 8010218: 2301         	movs	r3, #0x1
 801021a: e008         	b	0x801022e <z_impl_k_yield+0x1ce> @ imm = #0x10
; 	    && z_is_thread_timeout_active(thread)) {
 801021c: 6d78         	ldr	r0, [r7, #0x54]
 801021e: f00c fe15    	bl	0x801ce4c <z_is_thread_timeout_active> @ imm = #0xcc2a
 8010222: 4603         	mov	r3, r0
; 	if (IS_ENABLED(CONFIG_SWAP_NONATOMIC)
 8010224: 2b00         	cmp	r3, #0x0
 8010226: d001         	beq	0x801022c <z_impl_k_yield+0x1cc> @ imm = #0x2
; 		return true;
 8010228: 2301         	movs	r3, #0x1
 801022a: e000         	b	0x801022e <z_impl_k_yield+0x1ce> @ imm = #0x0
; 	return false;
 801022c: 2300         	movs	r3, #0x0
; 	if (should_preempt(thread, preempt_ok)) {
 801022e: 2b00         	cmp	r3, #0x0
 8010230: d010         	beq	0x8010254 <z_impl_k_yield+0x1f4> @ imm = #0x20
; 	struct k_thread *ret = _kernel.cpus[0].current;
 8010232: 4b14         	ldr	r3, [pc, #0x50]         @ 0x8010284 <z_impl_k_yield+0x224>
 8010234: 689b         	ldr	r3, [r3, #0x8]
 8010236: 647b         	str	r3, [r7, #0x44]
; 	return ret;
 8010238: 6c7b         	ldr	r3, [r7, #0x44]
; 		if (thread != arch_current_thread()) {
 801023a: 6dba         	ldr	r2, [r7, #0x58]
 801023c: 429a         	cmp	r2, r3
 801023e: d002         	beq	0x8010246 <z_impl_k_yield+0x1e6> @ imm = #0x4
; 			z_reset_time_slice(thread);
 8010240: 6db8         	ldr	r0, [r7, #0x58]
 8010242: f000 fb8f    	bl	0x8010964 <z_reset_time_slice> @ imm = #0x71e
; 		update_metairq_preempt(thread);
 8010246: 6db8         	ldr	r0, [r7, #0x58]
 8010248: f00c ff75    	bl	0x801d136 <update_metairq_preempt> @ imm = #0xceea
; 		_kernel.ready_q.cache = thread;
 801024c: 4a0d         	ldr	r2, [pc, #0x34]         @ 0x8010284 <z_impl_k_yield+0x224>
 801024e: 6dbb         	ldr	r3, [r7, #0x58]
 8010250: 61d3         	str	r3, [r2, #0x1c]
; }
 8010252: e005         	b	0x8010260 <z_impl_k_yield+0x200> @ imm = #0xa
; 	struct k_thread *ret = _kernel.cpus[0].current;
 8010254: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x8010284 <z_impl_k_yield+0x224>
 8010256: 689b         	ldr	r3, [r3, #0x8]
 8010258: 643b         	str	r3, [r7, #0x40]
; 	return ret;
 801025a: 6c3b         	ldr	r3, [r7, #0x40]
; 		_kernel.ready_q.cache = arch_current_thread();
 801025c: 4a09         	ldr	r2, [pc, #0x24]         @ 0x8010284 <z_impl_k_yield+0x224>
 801025e: 61d3         	str	r3, [r2, #0x1c]
; }
 8010260: bf00         	nop
 8010262: 4b07         	ldr	r3, [pc, #0x1c]         @ 0x8010280 <z_impl_k_yield+0x220>
 8010264: 677b         	str	r3, [r7, #0x74]
 8010266: 68bb         	ldr	r3, [r7, #0x8]
 8010268: 607b         	str	r3, [r7, #0x4]
 801026a: 6f7b         	ldr	r3, [r7, #0x74]
 801026c: 673b         	str	r3, [r7, #0x70]
; }
 801026e: bf00         	nop
; 	return z_swap_irqlock(key.key);
 8010270: 687b         	ldr	r3, [r7, #0x4]
 8010272: 4618         	mov	r0, r3
 8010274: f00c fed6    	bl	0x801d024 <z_swap_irqlock> @ imm = #0xcdac
; }
 8010278: bf00         	nop
 801027a: 3790         	adds	r7, #0x90
 801027c: 46bd         	mov	sp, r7
 801027e: bd80         	pop	{r7, pc}

08010280 <$d>:
 8010280: 70 1f 00 20  	.word	0x20001f70
 8010284: f0 16 00 20  	.word	0x200016f0
 8010288: 10 17 00 20  	.word	0x20001710

0801028c <z_tick_sleep>:
; {
 801028c: e92d 43b0    	push.w	{r4, r5, r7, r8, r9, lr}
 8010290: b0a0         	sub	sp, #0x80
 8010292: af06         	add	r7, sp, #0x18
 8010294: e9c7 0100    	strd	r0, r1, [r7]
; 	LOG_DBG("thread %p for %lu ticks", arch_current_thread(), (unsigned long)ticks);
 8010298: 2303         	movs	r3, #0x3
 801029a: 2b03         	cmp	r3, #0x3
 801029c: d921         	bls	0x80102e2 <z_tick_sleep+0x56> @ imm = #0x42
 801029e: 2301         	movs	r3, #0x1
 80102a0: f887 3067    	strb.w	r3, [r7, #0x67]
 80102a4: f897 3067    	ldrb.w	r3, [r7, #0x67]
 80102a8: f083 0301    	eor	r3, r3, #0x1
 80102ac: b2db         	uxtb	r3, r3
 80102ae: 2b00         	cmp	r3, #0x0
 80102b0: d117         	bne	0x80102e2 <z_tick_sleep+0x56> @ imm = #0x2e
 80102b2: 4b4c         	ldr	r3, [pc, #0x130]        @ 0x80103e4 <z_tick_sleep+0x158>
 80102b4: 6819         	ldr	r1, [r3]
; 	struct k_thread *ret = _kernel.cpus[0].current;
 80102b6: 4b4c         	ldr	r3, [pc, #0x130]        @ 0x80103e8 <z_tick_sleep+0x15c>
 80102b8: 689b         	ldr	r3, [r3, #0x8]
 80102ba: 657b         	str	r3, [r7, #0x54]
; 	return ret;
 80102bc: 6d7b         	ldr	r3, [r7, #0x54]
; 	LOG_DBG("thread %p for %lu ticks", arch_current_thread(), (unsigned long)ticks);
 80102be: 683a         	ldr	r2, [r7]
 80102c0: 9205         	str	r2, [sp, #0x14]
 80102c2: 9304         	str	r3, [sp, #0x10]
 80102c4: 4b49         	ldr	r3, [pc, #0x124]        @ 0x80103ec <z_tick_sleep+0x160>
 80102c6: 9303         	str	r3, [sp, #0xc]
 80102c8: 4b49         	ldr	r3, [pc, #0x124]        @ 0x80103f0 <z_tick_sleep+0x164>
 80102ca: 9302         	str	r3, [sp, #0x8]
 80102cc: 2308         	movs	r3, #0x8
 80102ce: 9301         	str	r3, [sp, #0x4]
 80102d0: 2300         	movs	r3, #0x0
 80102d2: 9300         	str	r3, [sp]
 80102d4: 2300         	movs	r3, #0x0
 80102d6: 2204         	movs	r2, #0x4
 80102d8: 2000         	movs	r0, #0x0
 80102da: f00c feb0    	bl	0x801d03e <z_log_msg_runtime_create> @ imm = #0xcd60
 80102de: 2300         	movs	r3, #0x0
 80102e0: 65fb         	str	r3, [r7, #0x5c]
; 	if (ticks == 0) {
 80102e2: e9d7 2300    	ldrd	r2, r3, [r7]
 80102e6: 4313         	orrs	r3, r2
 80102e8: d103         	bne	0x80102f2 <z_tick_sleep+0x66> @ imm = #0x6
; 		k_yield();
 80102ea: f00c fd38    	bl	0x801cd5e <k_yield>     @ imm = #0xca70
; 		return 0;
 80102ee: 2300         	movs	r3, #0x0
 80102f0: e073         	b	0x80103da <z_tick_sleep+0x14e> @ imm = #0xe6
; 	if (Z_TICK_ABS(ticks) <= 0) {
 80102f2: e9d7 2300    	ldrd	r2, r3, [r7]
 80102f6: f06f 0001    	mvn	r0, #0x1
 80102fa: f04f 31ff    	mov.w	r1, #0xffffffff
 80102fe: 1a84         	subs	r4, r0, r2
 8010300: eb61 0503    	sbc.w	r5, r1, r3
 8010304: 2c01         	cmp	r4, #0x1
 8010306: f175 0300    	sbcs	r3, r5, #0x0
 801030a: da06         	bge	0x801031a <z_tick_sleep+0x8e> @ imm = #0xc
; 		expected_wakeup_ticks = ticks + sys_clock_tick_get_32();
 801030c: f00d f9eb    	bl	0x801d6e6 <sys_clock_tick_get_32> @ imm = #0xd3d6
 8010310: 4602         	mov	r2, r0
 8010312: 683b         	ldr	r3, [r7]
 8010314: 4413         	add	r3, r2
 8010316: 663b         	str	r3, [r7, #0x60]
 8010318: e004         	b	0x8010324 <z_tick_sleep+0x98> @ imm = #0x8
; 		expected_wakeup_ticks = Z_TICK_ABS(ticks);
 801031a: 683a         	ldr	r2, [r7]
 801031c: f06f 0301    	mvn	r3, #0x1
 8010320: 1a9b         	subs	r3, r3, r2
 8010322: 663b         	str	r3, [r7, #0x60]
; 	k_timeout_t timeout = Z_TIMEOUT_TICKS(ticks);
 8010324: e9d7 2300    	ldrd	r2, r3, [r7]
 8010328: e9c7 2306    	strd	r2, r3, [r7, #24]
 801032c: 4b31         	ldr	r3, [pc, #0xc4]         @ 0x80103f4 <z_tick_sleep+0x168>
 801032e: 63bb         	str	r3, [r7, #0x38]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 8010330: f3ef 8311    	mrs	r3, basepri
 8010334: 637b         	str	r3, [r7, #0x34]
;   return(result);
 8010336: 6b7b         	ldr	r3, [r7, #0x34]
; 	key = __get_BASEPRI();
 8010338: 633b         	str	r3, [r7, #0x30]
 801033a: 2310         	movs	r3, #0x10
 801033c: 62fb         	str	r3, [r7, #0x2c]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 801033e: 6afb         	ldr	r3, [r7, #0x2c]
 8010340: f383 8812    	msr	basepri_max, r3
; }
 8010344: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8010346: f3bf 8f6f    	isb	sy
; }
 801034a: bf00         	nop
; 	return key;
 801034c: 6b3b         	ldr	r3, [r7, #0x30]
; 	k.key = arch_irq_lock();
 801034e: 613b         	str	r3, [r7, #0x10]
 8010350: 6bbb         	ldr	r3, [r7, #0x38]
 8010352: 62bb         	str	r3, [r7, #0x28]
; }
 8010354: bf00         	nop
 8010356: 6bbb         	ldr	r3, [r7, #0x38]
 8010358: 627b         	str	r3, [r7, #0x24]
; }
 801035a: bf00         	nop
; 	return k;
 801035c: 693b         	ldr	r3, [r7, #0x10]
 801035e: 617b         	str	r3, [r7, #0x14]
; 	struct k_thread *ret = _kernel.cpus[0].current;
 8010360: 4b21         	ldr	r3, [pc, #0x84]         @ 0x80103e8 <z_tick_sleep+0x15c>
 8010362: 689b         	ldr	r3, [r3, #0x8]
 8010364: 63fb         	str	r3, [r7, #0x3c]
; 	return ret;
 8010366: 6bfb         	ldr	r3, [r7, #0x3c]
; 	pending_current = arch_current_thread();
 8010368: 4a23         	ldr	r2, [pc, #0x8c]         @ 0x80103f8 <z_tick_sleep+0x16c>
 801036a: 6013         	str	r3, [r2]
; 	struct k_thread *ret = _kernel.cpus[0].current;
 801036c: 4b1e         	ldr	r3, [pc, #0x78]         @ 0x80103e8 <z_tick_sleep+0x15c>
 801036e: 689b         	ldr	r3, [r3, #0x8]
 8010370: 643b         	str	r3, [r7, #0x40]
; 	return ret;
 8010372: 6c3b         	ldr	r3, [r7, #0x40]
; 	unready_thread(arch_current_thread());
 8010374: 4618         	mov	r0, r3
 8010376: f7ff fa93    	bl	0x800f8a0 <unready_thread> @ imm = #-0xada
; 	struct k_thread *ret = _kernel.cpus[0].current;
 801037a: 4b1b         	ldr	r3, [pc, #0x6c]         @ 0x80103e8 <z_tick_sleep+0x15c>
 801037c: 689b         	ldr	r3, [r3, #0x8]
 801037e: 647b         	str	r3, [r7, #0x44]
; 	return ret;
 8010380: 6c79         	ldr	r1, [r7, #0x44]
; 	z_add_thread_timeout(arch_current_thread(), timeout);
 8010382: e9d7 2306    	ldrd	r2, r3, [r7, #24]
 8010386: 4608         	mov	r0, r1
 8010388: f7fe fdda    	bl	0x800ef40 <z_add_thread_timeout> @ imm = #-0x144c
; 	struct k_thread *ret = _kernel.cpus[0].current;
 801038c: 4b16         	ldr	r3, [pc, #0x58]         @ 0x80103e8 <z_tick_sleep+0x15c>
 801038e: 689b         	ldr	r3, [r3, #0x8]
 8010390: 64bb         	str	r3, [r7, #0x48]
; 	return ret;
 8010392: 6cbb         	ldr	r3, [r7, #0x48]
; 	z_mark_thread_as_suspended(arch_current_thread());
 8010394: 4618         	mov	r0, r3
 8010396: f00c fdb3    	bl	0x801cf00 <z_mark_thread_as_suspended> @ imm = #0xcb66
 801039a: 4b16         	ldr	r3, [pc, #0x58]         @ 0x80103f4 <z_tick_sleep+0x168>
 801039c: 653b         	str	r3, [r7, #0x50]
 801039e: 697b         	ldr	r3, [r7, #0x14]
 80103a0: 60fb         	str	r3, [r7, #0xc]
 80103a2: 6d3b         	ldr	r3, [r7, #0x50]
 80103a4: 64fb         	str	r3, [r7, #0x4c]
; }
 80103a6: bf00         	nop
; 	return z_swap_irqlock(key.key);
 80103a8: 68fb         	ldr	r3, [r7, #0xc]
 80103aa: 4618         	mov	r0, r3
 80103ac: f00c fe3a    	bl	0x801d024 <z_swap_irqlock> @ imm = #0xcc74
; 	uint32_t left_ticks = expected_wakeup_ticks - sys_clock_tick_get_32();
 80103b0: f00d f999    	bl	0x801d6e6 <sys_clock_tick_get_32> @ imm = #0xd332
 80103b4: 4602         	mov	r2, r0
 80103b6: 6e3b         	ldr	r3, [r7, #0x60]
 80103b8: 1a9b         	subs	r3, r3, r2
 80103ba: 65bb         	str	r3, [r7, #0x58]
; 	ticks = (k_ticks_t)(int32_t)left_ticks;
 80103bc: 6dbb         	ldr	r3, [r7, #0x58]
 80103be: 17da         	asrs	r2, r3, #0x1f
 80103c0: 4698         	mov	r8, r3
 80103c2: 4691         	mov	r9, r2
 80103c4: e9c7 8900    	strd	r8, r9, [r7]
; 	if (ticks > 0) {
 80103c8: e9d7 2300    	ldrd	r2, r3, [r7]
 80103cc: 2a01         	cmp	r2, #0x1
 80103ce: f173 0300    	sbcs	r3, r3, #0x0
 80103d2: db01         	blt	0x80103d8 <z_tick_sleep+0x14c> @ imm = #0x2
; 		return ticks;
 80103d4: 683b         	ldr	r3, [r7]
 80103d6: e000         	b	0x80103da <z_tick_sleep+0x14e> @ imm = #0x0
; 	return 0;
 80103d8: 2300         	movs	r3, #0x0
; }
 80103da: 4618         	mov	r0, r3
 80103dc: 3768         	adds	r7, #0x68
 80103de: 46bd         	mov	sp, r7
 80103e0: e8bd 83b0    	pop.w	{r4, r5, r7, r8, r9, pc}

080103e4 <$d>:
 80103e4: b8 05 00 20  	.word	0x200005b8
 80103e8: f0 16 00 20  	.word	0x200016f0
 80103ec: 58 07 02 08  	.word	0x08020758
 80103f0: 50 fb 01 08  	.word	0x0801fb50
 80103f4: 70 1f 00 20  	.word	0x20001f70
 80103f8: 7c 1f 00 20  	.word	0x20001f7c

080103fc <z_impl_k_sleep>:
; {
 80103fc: e92d 43b0    	push.w	{r4, r5, r7, r8, r9, lr}
 8010400: b086         	sub	sp, #0x18
 8010402: af00         	add	r7, sp, #0x0
 8010404: e9c7 0100    	strd	r0, r1, [r7]
; 	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
 8010408: e9d7 2300    	ldrd	r2, r3, [r7]
 801040c: f04f 30ff    	mov.w	r0, #0xffffffff
 8010410: f04f 31ff    	mov.w	r1, #0xffffffff
 8010414: 428b         	cmp	r3, r1
 8010416: bf08         	it	eq
 8010418: 4282         	cmpeq	r2, r0
 801041a: d109         	bne	0x8010430 <z_impl_k_sleep+0x34> @ imm = #0x12
; 	struct k_thread *ret = _kernel.cpus[0].current;
 801041c: 4b17         	ldr	r3, [pc, #0x5c]         @ 0x801047c <z_impl_k_sleep+0x80>
 801041e: 689b         	ldr	r3, [r3, #0x8]
 8010420: 60bb         	str	r3, [r7, #0x8]
; 	return ret;
 8010422: 68bb         	ldr	r3, [r7, #0x8]
; 		k_thread_suspend(arch_current_thread());
 8010424: 4618         	mov	r0, r3
 8010426: f00c fca0    	bl	0x801cd6a <k_thread_suspend> @ imm = #0xc940
; 		return (int32_t) K_TICKS_FOREVER;
 801042a: f04f 33ff    	mov.w	r3, #0xffffffff
 801042e: e020         	b	0x8010472 <z_impl_k_sleep+0x76> @ imm = #0x40
; 	ticks = timeout.ticks;
 8010430: e9d7 2300    	ldrd	r2, r3, [r7]
 8010434: e9c7 2304    	strd	r2, r3, [r7, #16]
; 	ticks = z_tick_sleep(ticks);
 8010438: e9d7 0104    	ldrd	r0, r1, [r7, #16]
 801043c: f7ff ff26    	bl	0x801028c <z_tick_sleep> @ imm = #-0x1b4
 8010440: 4603         	mov	r3, r0
 8010442: 17da         	asrs	r2, r3, #0x1f
 8010444: 4698         	mov	r8, r3
 8010446: 4691         	mov	r9, r2
 8010448: e9c7 8904    	strd	r8, r9, [r7, #16]
; 	int32_t ret = k_ticks_to_ms_ceil64(ticks);
 801044c: e9d7 2304    	ldrd	r2, r3, [r7, #16]
 8010450: f112 0409    	adds.w	r4, r2, #0x9
 8010454: f143 0500    	adc	r5, r3, #0x0
 8010458: f04f 020a    	mov.w	r2, #0xa
 801045c: f04f 0300    	mov.w	r3, #0x0
 8010460: 4620         	mov	r0, r4
 8010462: 4629         	mov	r1, r5
 8010464: f7f0 f9da    	bl	0x800081c <__aeabi_uldivmod> @ imm = #-0xfc4c
 8010468: 4602         	mov	r2, r0
 801046a: 460b         	mov	r3, r1
 801046c: 4613         	mov	r3, r2
 801046e: 60fb         	str	r3, [r7, #0xc]
; 	return ret;
 8010470: 68fb         	ldr	r3, [r7, #0xc]
; }
 8010472: 4618         	mov	r0, r3
 8010474: 3718         	adds	r7, #0x18
 8010476: 46bd         	mov	sp, r7
 8010478: e8bd 83b0    	pop.w	{r4, r5, r7, r8, r9, pc}

0801047c <$d>:
 801047c: f0 16 00 20  	.word	0x200016f0

08010480 <z_impl_k_sched_current_thread_query>:
; {
 8010480: b480         	push	{r7}
 8010482: b083         	sub	sp, #0xc
 8010484: af00         	add	r7, sp, #0x0
; 	struct k_thread *ret = _kernel.cpus[0].current;
 8010486: 4b04         	ldr	r3, [pc, #0x10]         @ 0x8010498 <z_impl_k_sched_current_thread_query+0x18>
 8010488: 689b         	ldr	r3, [r3, #0x8]
 801048a: 607b         	str	r3, [r7, #0x4]
; 	return ret;
 801048c: 687b         	ldr	r3, [r7, #0x4]
; }
 801048e: 4618         	mov	r0, r3
 8010490: 370c         	adds	r7, #0xc
 8010492: 46bd         	mov	sp, r7
 8010494: bc80         	pop	{r7}
 8010496: 4770         	bx	lr

08010498 <$d>:
 8010498: f0 16 00 20  	.word	0x200016f0

0801049c <halt_thread>:
; {
 801049c: b580         	push	{r7, lr}
 801049e: b096         	sub	sp, #0x58
 80104a0: af00         	add	r7, sp, #0x0
 80104a2: 6078         	str	r0, [r7, #0x4]
 80104a4: 460b         	mov	r3, r1
 80104a6: 70fb         	strb	r3, [r7, #0x3]
; 	bool dummify = false;
 80104a8: 2300         	movs	r3, #0x0
 80104aa: f887 3057    	strb.w	r3, [r7, #0x57]
; 	if ((thread->base.thread_state & new_state) == 0U) {
 80104ae: 687b         	ldr	r3, [r7, #0x4]
 80104b0: 7b5a         	ldrb	r2, [r3, #0xd]
 80104b2: 78fb         	ldrb	r3, [r7, #0x3]
 80104b4: 4013         	ands	r3, r2
 80104b6: b2db         	uxtb	r3, r3
 80104b8: 2b00         	cmp	r3, #0x0
 80104ba: f040 80ca    	bne.w	0x8010652 <halt_thread+0x1b6> @ imm = #0x194
; 		thread->base.thread_state |= new_state;
 80104be: 687b         	ldr	r3, [r7, #0x4]
 80104c0: 7b5a         	ldrb	r2, [r3, #0xd]
 80104c2: 78fb         	ldrb	r3, [r7, #0x3]
 80104c4: 4313         	orrs	r3, r2
 80104c6: b2da         	uxtb	r2, r3
 80104c8: 687b         	ldr	r3, [r7, #0x4]
 80104ca: 735a         	strb	r2, [r3, #0xd]
; 		if (z_is_thread_queued(thread)) {
 80104cc: 6878         	ldr	r0, [r7, #0x4]
 80104ce: f00c fd0a    	bl	0x801cee6 <z_is_thread_queued> @ imm = #0xca14
 80104d2: 4603         	mov	r3, r0
 80104d4: 2b00         	cmp	r3, #0x0
 80104d6: d01d         	beq	0x8010514 <halt_thread+0x78> @ imm = #0x3a
 80104d8: 687b         	ldr	r3, [r7, #0x4]
 80104da: 653b         	str	r3, [r7, #0x50]
; 	thread->base.thread_state &= ~_THREAD_QUEUED;
 80104dc: 6d3b         	ldr	r3, [r7, #0x50]
 80104de: 7b5b         	ldrb	r3, [r3, #0xd]
 80104e0: f003 037f    	and	r3, r3, #0x7f
 80104e4: b2da         	uxtb	r2, r3
 80104e6: 6d3b         	ldr	r3, [r7, #0x50]
 80104e8: 735a         	strb	r2, [r3, #0xd]
; 	if (should_queue_thread(thread)) {
 80104ea: 6d38         	ldr	r0, [r7, #0x50]
 80104ec: f00c fde0    	bl	0x801d0b0 <should_queue_thread> @ imm = #0xcbc0
 80104f0: 4603         	mov	r3, r0
 80104f2: 2b00         	cmp	r3, #0x0
 80104f4: d00d         	beq	0x8010512 <halt_thread+0x76> @ imm = #0x1a
 80104f6: 6d3b         	ldr	r3, [r7, #0x50]
 80104f8: 64fb         	str	r3, [r7, #0x4c]
 80104fa: 6cfb         	ldr	r3, [r7, #0x4c]
 80104fc: 64bb         	str	r3, [r7, #0x48]
; 	return &_kernel.ready_q.runq;
 80104fe: 4b56         	ldr	r3, [pc, #0x158]        @ 0x8010658 <halt_thread+0x1bc>
 8010500: 647b         	str	r3, [r7, #0x44]
 8010502: 6cfb         	ldr	r3, [r7, #0x4c]
 8010504: 643b         	str	r3, [r7, #0x40]
; 	sys_dlist_remove(&thread->base.qnode_dlist);
 8010506: 6c3b         	ldr	r3, [r7, #0x40]
 8010508: 4618         	mov	r0, r3
 801050a: f00c fc11    	bl	0x801cd30 <sys_dlist_remove> @ imm = #0xc822
; }
 801050e: bf00         	nop
; }
 8010510: bf00         	nop
; }
 8010512: bf00         	nop
; 		if (new_state == _THREAD_DEAD) {
 8010514: 78fb         	ldrb	r3, [r7, #0x3]
 8010516: 2b08         	cmp	r3, #0x8
 8010518: d123         	bne	0x8010562 <halt_thread+0xc6> @ imm = #0x46
; 			if (thread->base.pended_on != NULL) {
 801051a: 687b         	ldr	r3, [r7, #0x4]
 801051c: 689b         	ldr	r3, [r3, #0x8]
 801051e: 2b00         	cmp	r3, #0x0
 8010520: d002         	beq	0x8010528 <halt_thread+0x8c> @ imm = #0x4
; 				unpend_thread_no_timeout(thread);
 8010522: 6878         	ldr	r0, [r7, #0x4]
 8010524: f00c fd57    	bl	0x801cfd6 <unpend_thread_no_timeout> @ imm = #0xcaae
; 			(void)z_abort_thread_timeout(thread);
 8010528: 6878         	ldr	r0, [r7, #0x4]
 801052a: f00c fc41    	bl	0x801cdb0 <z_abort_thread_timeout> @ imm = #0xc882
; 			unpend_all(&thread->join_queue);
 801052e: 687b         	ldr	r3, [r7, #0x4]
 8010530: 3368         	adds	r3, #0x68
 8010532: 4618         	mov	r0, r3
 8010534: f00c ff5e    	bl	0x801d3f4 <unpend_all>  @ imm = #0xcebc
; 	struct k_thread *ret = _kernel.cpus[0].current;
 8010538: 4b48         	ldr	r3, [pc, #0x120]        @ 0x801065c <halt_thread+0x1c0>
 801053a: 689b         	ldr	r3, [r3, #0x8]
 801053c: 63fb         	str	r3, [r7, #0x3c]
; 	return ret;
 801053e: 6bfb         	ldr	r3, [r7, #0x3c]
; 			if (thread == arch_current_thread() && arch_is_in_isr()) {
 8010540: 687a         	ldr	r2, [r7, #0x4]
 8010542: 429a         	cmp	r2, r3
 8010544: d10d         	bne	0x8010562 <halt_thread+0xc6> @ imm = #0x1a
;   __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 8010546: f3ef 8305    	mrs	r3, ipsr
 801054a: 63bb         	str	r3, [r7, #0x38]
;   return(result);
 801054c: 6bbb         	ldr	r3, [r7, #0x38]
; 	return (__get_IPSR()) ? (true) : (false);
 801054e: 2b00         	cmp	r3, #0x0
 8010550: bf14         	ite	ne
 8010552: 2301         	movne	r3, #0x1
 8010554: 2300         	moveq	r3, #0x0
 8010556: b2db         	uxtb	r3, r3
; 			if (thread == arch_current_thread() && arch_is_in_isr()) {
 8010558: 2b00         	cmp	r3, #0x0
 801055a: d002         	beq	0x8010562 <halt_thread+0xc6> @ imm = #0x4
; 				dummify = true;
 801055c: 2301         	movs	r3, #0x1
 801055e: f887 3057    	strb.w	r3, [r7, #0x57]
 8010562: 2301         	movs	r3, #0x1
 8010564: 637b         	str	r3, [r7, #0x34]
; 	return &_kernel.ready_q.runq;
 8010566: 4b3c         	ldr	r3, [pc, #0xf0]         @ 0x8010658 <halt_thread+0x1bc>
 8010568: 633b         	str	r3, [r7, #0x30]
; 	struct k_thread *thread = NULL;
 801056a: 2300         	movs	r3, #0x0
 801056c: 62fb         	str	r3, [r7, #0x2c]
; 	sys_dnode_t *n = sys_dlist_peek_head(pq);
 801056e: 6b38         	ldr	r0, [r7, #0x30]
 8010570: f00c fb74    	bl	0x801cc5c <sys_dlist_peek_head> @ imm = #0xc6e8
 8010574: 62b8         	str	r0, [r7, #0x28]
; 	if (n != NULL) {
 8010576: 6abb         	ldr	r3, [r7, #0x28]
 8010578: 2b00         	cmp	r3, #0x0
 801057a: d001         	beq	0x8010580 <halt_thread+0xe4> @ imm = #0x2
; 		thread = CONTAINER_OF(n, struct k_thread, base.qnode_dlist);
 801057c: 6abb         	ldr	r3, [r7, #0x28]
 801057e: 62fb         	str	r3, [r7, #0x2c]
; 	return thread;
 8010580: 6afb         	ldr	r3, [r7, #0x2c]
; 	return _priq_run_best(curr_cpu_runq());
 8010582: bf00         	nop
; 	struct k_thread *thread = runq_best();
 8010584: 627b         	str	r3, [r7, #0x24]
; 	return (thread != NULL) ? thread : _current_cpu->idle_thread;
 8010586: 6a7b         	ldr	r3, [r7, #0x24]
 8010588: 2b00         	cmp	r3, #0x0
 801058a: d102         	bne	0x8010592 <halt_thread+0xf6> @ imm = #0x4
 801058c: 4b33         	ldr	r3, [pc, #0xcc]         @ 0x801065c <halt_thread+0x1c0>
 801058e: 68db         	ldr	r3, [r3, #0xc]
 8010590: e000         	b	0x8010594 <halt_thread+0xf8> @ imm = #0x0
 8010592: 6a7b         	ldr	r3, [r7, #0x24]
; 	struct k_thread *thread = next_up();
 8010594: 623b         	str	r3, [r7, #0x20]
 8010596: 6a3b         	ldr	r3, [r7, #0x20]
 8010598: 61fb         	str	r3, [r7, #0x1c]
 801059a: 6b7b         	ldr	r3, [r7, #0x34]
 801059c: 61bb         	str	r3, [r7, #0x18]
; 	if (preempt_ok != 0) {
 801059e: 69bb         	ldr	r3, [r7, #0x18]
 80105a0: 2b00         	cmp	r3, #0x0
 80105a2: d001         	beq	0x80105a8 <halt_thread+0x10c> @ imm = #0x2
; 		return true;
 80105a4: 2301         	movs	r3, #0x1
 80105a6: e026         	b	0x80105f6 <halt_thread+0x15a> @ imm = #0x4c
; 	struct k_thread *ret = _kernel.cpus[0].current;
 80105a8: 4b2c         	ldr	r3, [pc, #0xb0]         @ 0x801065c <halt_thread+0x1c0>
 80105aa: 689b         	ldr	r3, [r3, #0x8]
 80105ac: 617b         	str	r3, [r7, #0x14]
; 	return ret;
 80105ae: 697b         	ldr	r3, [r7, #0x14]
; 	if (z_is_thread_prevented_from_running(arch_current_thread())) {
 80105b0: 4618         	mov	r0, r3
 80105b2: f00c fc37    	bl	0x801ce24 <z_is_thread_prevented_from_running> @ imm = #0xc86e
 80105b6: 4603         	mov	r3, r0
 80105b8: 2b00         	cmp	r3, #0x0
 80105ba: d001         	beq	0x80105c0 <halt_thread+0x124> @ imm = #0x2
; 		return true;
 80105bc: 2301         	movs	r3, #0x1
 80105be: e01a         	b	0x80105f6 <halt_thread+0x15a> @ imm = #0x34
; 	struct k_thread *ret = _kernel.cpus[0].current;
 80105c0: 4b26         	ldr	r3, [pc, #0x98]         @ 0x801065c <halt_thread+0x1c0>
 80105c2: 689b         	ldr	r3, [r3, #0x8]
 80105c4: 613b         	str	r3, [r7, #0x10]
; 	return ret;
 80105c6: 693b         	ldr	r3, [r7, #0x10]
; 	if (thread_is_preemptible(arch_current_thread()) || thread_is_metairq(thread)) {
 80105c8: 4618         	mov	r0, r3
 80105ca: f00c fbff    	bl	0x801cdcc <thread_is_preemptible> @ imm = #0xc7fe
 80105ce: 4603         	mov	r3, r0
 80105d0: 2b00         	cmp	r3, #0x0
 80105d2: d105         	bne	0x80105e0 <halt_thread+0x144> @ imm = #0xa
 80105d4: 69f8         	ldr	r0, [r7, #0x1c]
 80105d6: f00c fc09    	bl	0x801cdec <thread_is_metairq> @ imm = #0xc812
 80105da: 4603         	mov	r3, r0
 80105dc: 2b00         	cmp	r3, #0x0
 80105de: d001         	beq	0x80105e4 <halt_thread+0x148> @ imm = #0x2
; 		return true;
 80105e0: 2301         	movs	r3, #0x1
 80105e2: e008         	b	0x80105f6 <halt_thread+0x15a> @ imm = #0x10
; 	    && z_is_thread_timeout_active(thread)) {
 80105e4: 69f8         	ldr	r0, [r7, #0x1c]
 80105e6: f00c fc31    	bl	0x801ce4c <z_is_thread_timeout_active> @ imm = #0xc862
 80105ea: 4603         	mov	r3, r0
; 	if (IS_ENABLED(CONFIG_SWAP_NONATOMIC)
 80105ec: 2b00         	cmp	r3, #0x0
 80105ee: d001         	beq	0x80105f4 <halt_thread+0x158> @ imm = #0x2
; 		return true;
 80105f0: 2301         	movs	r3, #0x1
 80105f2: e000         	b	0x80105f6 <halt_thread+0x15a> @ imm = #0x0
; 	return false;
 80105f4: 2300         	movs	r3, #0x0
; 	if (should_preempt(thread, preempt_ok)) {
 80105f6: 2b00         	cmp	r3, #0x0
 80105f8: d010         	beq	0x801061c <halt_thread+0x180> @ imm = #0x20
; 	struct k_thread *ret = _kernel.cpus[0].current;
 80105fa: 4b18         	ldr	r3, [pc, #0x60]         @ 0x801065c <halt_thread+0x1c0>
 80105fc: 689b         	ldr	r3, [r3, #0x8]
 80105fe: 60fb         	str	r3, [r7, #0xc]
; 	return ret;
 8010600: 68fb         	ldr	r3, [r7, #0xc]
; 		if (thread != arch_current_thread()) {
 8010602: 6a3a         	ldr	r2, [r7, #0x20]
 8010604: 429a         	cmp	r2, r3
 8010606: d002         	beq	0x801060e <halt_thread+0x172> @ imm = #0x4
; 			z_reset_time_slice(thread);
 8010608: 6a38         	ldr	r0, [r7, #0x20]
 801060a: f000 f9ab    	bl	0x8010964 <z_reset_time_slice> @ imm = #0x356
; 		update_metairq_preempt(thread);
 801060e: 6a38         	ldr	r0, [r7, #0x20]
 8010610: f00c fd91    	bl	0x801d136 <update_metairq_preempt> @ imm = #0xcb22
; 		_kernel.ready_q.cache = thread;
 8010614: 4a11         	ldr	r2, [pc, #0x44]         @ 0x801065c <halt_thread+0x1c0>
 8010616: 6a3b         	ldr	r3, [r7, #0x20]
 8010618: 61d3         	str	r3, [r2, #0x1c]
; }
 801061a: e005         	b	0x8010628 <halt_thread+0x18c> @ imm = #0xa
; 	struct k_thread *ret = _kernel.cpus[0].current;
 801061c: 4b0f         	ldr	r3, [pc, #0x3c]         @ 0x801065c <halt_thread+0x1c0>
 801061e: 689b         	ldr	r3, [r3, #0x8]
 8010620: 60bb         	str	r3, [r7, #0x8]
; 	return ret;
 8010622: 68bb         	ldr	r3, [r7, #0x8]
; 		_kernel.ready_q.cache = arch_current_thread();
 8010624: 4a0d         	ldr	r2, [pc, #0x34]         @ 0x801065c <halt_thread+0x1c0>
 8010626: 61d3         	str	r3, [r2, #0x1c]
; }
 8010628: bf00         	nop
; 		if (new_state == _THREAD_SUSPENDED) {
 801062a: 78fb         	ldrb	r3, [r7, #0x3]
 801062c: 2b10         	cmp	r3, #0x10
 801062e: d103         	bne	0x8010638 <halt_thread+0x19c> @ imm = #0x6
; 			clear_halting(thread);
 8010630: 6878         	ldr	r0, [r7, #0x4]
 8010632: f00c fd6b    	bl	0x801d10c <clear_halting> @ imm = #0xcad6
; 			return;
 8010636: e00c         	b	0x8010652 <halt_thread+0x1b6> @ imm = #0x18
; 		z_thread_monitor_exit(thread);
 8010638: 6878         	ldr	r0, [r7, #0x4]
 801063a: f000 fa49    	bl	0x8010ad0 <z_thread_monitor_exit> @ imm = #0x492
; 		if (dummify && !IS_ENABLED(CONFIG_ARCH_POSIX)) {
 801063e: f897 3057    	ldrb.w	r3, [r7, #0x57]
 8010642: 2b00         	cmp	r3, #0x0
 8010644: d002         	beq	0x801064c <halt_thread+0x1b0> @ imm = #0x4
; 			z_dummy_thread_init(&_thread_dummy);
 8010646: 4806         	ldr	r0, [pc, #0x18]         @ 0x8010660 <halt_thread+0x1c4>
 8010648: f7fe fca0    	bl	0x800ef8c <z_dummy_thread_init> @ imm = #-0x16c0
; 		clear_halting(thread);
 801064c: 6878         	ldr	r0, [r7, #0x4]
 801064e: f00c fd5d    	bl	0x801d10c <clear_halting> @ imm = #0xcaba
; }
 8010652: 3758         	adds	r7, #0x58
 8010654: 46bd         	mov	sp, r7
 8010656: bd80         	pop	{r7, pc}

08010658 <$d>:
 8010658: 10 17 00 20  	.word	0x20001710
 801065c: f0 16 00 20  	.word	0x200016f0
 8010660: d0 18 00 20  	.word	0x200018d0

08010664 <z_thread_abort>:
; {
 8010664: b580         	push	{r7, lr}
 8010666: b094         	sub	sp, #0x50
 8010668: af00         	add	r7, sp, #0x0
 801066a: 6078         	str	r0, [r7, #0x4]
 801066c: 4b30         	ldr	r3, [pc, #0xc0]         @ 0x8010730 <z_thread_abort+0xcc>
 801066e: 64fb         	str	r3, [r7, #0x4c]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 8010670: f3ef 8311    	mrs	r3, basepri
 8010674: 64bb         	str	r3, [r7, #0x48]
;   return(result);
 8010676: 6cbb         	ldr	r3, [r7, #0x48]
; 	key = __get_BASEPRI();
 8010678: 647b         	str	r3, [r7, #0x44]
 801067a: 2310         	movs	r3, #0x10
 801067c: 643b         	str	r3, [r7, #0x40]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 801067e: 6c3b         	ldr	r3, [r7, #0x40]
 8010680: f383 8812    	msr	basepri_max, r3
; }
 8010684: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8010686: f3bf 8f6f    	isb	sy
; }
 801068a: bf00         	nop
; 	return key;
 801068c: 6c7b         	ldr	r3, [r7, #0x44]
; 	k.key = arch_irq_lock();
 801068e: 60bb         	str	r3, [r7, #0x8]
 8010690: 6cfb         	ldr	r3, [r7, #0x4c]
 8010692: 63fb         	str	r3, [r7, #0x3c]
; }
 8010694: bf00         	nop
 8010696: 6cfb         	ldr	r3, [r7, #0x4c]
 8010698: 63bb         	str	r3, [r7, #0x38]
; }
 801069a: bf00         	nop
; 	return k;
 801069c: 68bb         	ldr	r3, [r7, #0x8]
 801069e: 617b         	str	r3, [r7, #0x14]
; 	if (z_is_thread_essential(thread)) {
 80106a0: 6878         	ldr	r0, [r7, #0x4]
 80106a2: f00c fc6d    	bl	0x801cf80 <z_is_thread_essential> @ imm = #0xc8da
 80106a6: 4603         	mov	r3, r0
 80106a8: 2b00         	cmp	r3, #0x0
 80106aa: d020         	beq	0x80106ee <z_thread_abort+0x8a> @ imm = #0x40
 80106ac: 4b20         	ldr	r3, [pc, #0x80]         @ 0x8010730 <z_thread_abort+0xcc>
 80106ae: 62fb         	str	r3, [r7, #0x2c]
 80106b0: 697b         	ldr	r3, [r7, #0x14]
 80106b2: 60fb         	str	r3, [r7, #0xc]
; 	arch_irq_unlock(key.key);
 80106b4: 68fb         	ldr	r3, [r7, #0xc]
 80106b6: 62bb         	str	r3, [r7, #0x28]
 80106b8: 6abb         	ldr	r3, [r7, #0x28]
 80106ba: 627b         	str	r3, [r7, #0x24]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80106bc: 6a7b         	ldr	r3, [r7, #0x24]
 80106be: f383 8811    	msr	basepri, r3
; }
 80106c2: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 80106c4: f3bf 8f6f    	isb	sy
; }
 80106c8: bf00         	nop
; }
 80106ca: bf00         	nop
; }
 80106cc: bf00         	nop
 80106ce: 2300         	movs	r3, #0x0
 80106d0: 637b         	str	r3, [r7, #0x34]
 80106d2: 6b7b         	ldr	r3, [r7, #0x34]
 80106d4: 633b         	str	r3, [r7, #0x30]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80106d6: 6b3b         	ldr	r3, [r7, #0x30]
 80106d8: f383 8811    	msr	basepri, r3
; }
 80106dc: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 80106de: f3bf 8f6f    	isb	sy
; }
 80106e2: bf00         	nop
; }
 80106e4: bf00         	nop
; 		k_panic();
 80106e6: 2304         	movs	r3, #0x4
 80106e8: 4618         	mov	r0, r3
 80106ea: df02         	svc	#0x2
; 		return;
 80106ec: e01c         	b	0x8010728 <z_thread_abort+0xc4> @ imm = #0x38
; 	if ((thread->base.thread_state & _THREAD_DEAD) != 0U) {
 80106ee: 687b         	ldr	r3, [r7, #0x4]
 80106f0: 7b5b         	ldrb	r3, [r3, #0xd]
 80106f2: f003 0308    	and	r3, r3, #0x8
 80106f6: 2b00         	cmp	r3, #0x0
 80106f8: d011         	beq	0x801071e <z_thread_abort+0xba> @ imm = #0x22
 80106fa: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x8010730 <z_thread_abort+0xcc>
 80106fc: 623b         	str	r3, [r7, #0x20]
 80106fe: 697b         	ldr	r3, [r7, #0x14]
 8010700: 613b         	str	r3, [r7, #0x10]
; 	arch_irq_unlock(key.key);
 8010702: 693b         	ldr	r3, [r7, #0x10]
 8010704: 61fb         	str	r3, [r7, #0x1c]
 8010706: 69fb         	ldr	r3, [r7, #0x1c]
 8010708: 61bb         	str	r3, [r7, #0x18]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 801070a: 69bb         	ldr	r3, [r7, #0x18]
 801070c: f383 8811    	msr	basepri, r3
; }
 8010710: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8010712: f3bf 8f6f    	isb	sy
; }
 8010716: bf00         	nop
; }
 8010718: bf00         	nop
; }
 801071a: bf00         	nop
; 		return;
 801071c: e004         	b	0x8010728 <z_thread_abort+0xc4> @ imm = #0x8
; 	z_thread_halt(thread, key, true);
 801071e: 2201         	movs	r2, #0x1
 8010720: 6979         	ldr	r1, [r7, #0x14]
 8010722: 6878         	ldr	r0, [r7, #0x4]
 8010724: f7fe fec6    	bl	0x800f4b4 <z_thread_halt> @ imm = #-0x1274
; }
 8010728: 3750         	adds	r7, #0x50
 801072a: 46bd         	mov	sp, r7
 801072c: bd80         	pop	{r7, pc}
 801072e: bf00         	nop

08010730 <$d>:
 8010730: 70 1f 00 20  	.word	0x20001f70

08010734 <z_sched_wake>:
; {
 8010734: b580         	push	{r7, lr}
 8010736: b09c         	sub	sp, #0x70
 8010738: af00         	add	r7, sp, #0x0
 801073a: 60f8         	str	r0, [r7, #0xc]
 801073c: 60b9         	str	r1, [r7, #0x8]
 801073e: 607a         	str	r2, [r7, #0x4]
; 	bool ret = false;
 8010740: 2300         	movs	r3, #0x0
 8010742: f887 306f    	strb.w	r3, [r7, #0x6f]
; 	K_SPINLOCK(&_sched_spinlock) {
 8010746: 2300         	movs	r3, #0x0
 8010748: 623b         	str	r3, [r7, #0x20]
 801074a: 4b34         	ldr	r3, [pc, #0xd0]         @ 0x801081c <z_sched_wake+0xe8>
 801074c: 667b         	str	r3, [r7, #0x64]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 801074e: f3ef 8311    	mrs	r3, basepri
 8010752: 663b         	str	r3, [r7, #0x60]
;   return(result);
 8010754: 6e3b         	ldr	r3, [r7, #0x60]
; 	key = __get_BASEPRI();
 8010756: 65fb         	str	r3, [r7, #0x5c]
 8010758: 2310         	movs	r3, #0x10
 801075a: 65bb         	str	r3, [r7, #0x58]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 801075c: 6dbb         	ldr	r3, [r7, #0x58]
 801075e: f383 8812    	msr	basepri_max, r3
; }
 8010762: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8010764: f3bf 8f6f    	isb	sy
; }
 8010768: bf00         	nop
; 	return key;
 801076a: 6dfb         	ldr	r3, [r7, #0x5c]
; 	k.key = arch_irq_lock();
 801076c: 617b         	str	r3, [r7, #0x14]
 801076e: 6e7b         	ldr	r3, [r7, #0x64]
 8010770: 657b         	str	r3, [r7, #0x54]
; }
 8010772: bf00         	nop
 8010774: 6e7b         	ldr	r3, [r7, #0x64]
 8010776: 653b         	str	r3, [r7, #0x50]
; }
 8010778: bf00         	nop
; 	return k;
 801077a: 697b         	ldr	r3, [r7, #0x14]
 801077c: 61fb         	str	r3, [r7, #0x1c]
; 	K_SPINLOCK(&_sched_spinlock) {
 801077e: e043         	b	0x8010808 <z_sched_wake+0xd4> @ imm = #0x86
; 		thread = _priq_wait_best(&wait_q->waitq);
 8010780: 68fb         	ldr	r3, [r7, #0xc]
 8010782: 64fb         	str	r3, [r7, #0x4c]
; 	struct k_thread *thread = NULL;
 8010784: 2300         	movs	r3, #0x0
 8010786: 64bb         	str	r3, [r7, #0x48]
; 	sys_dnode_t *n = sys_dlist_peek_head(pq);
 8010788: 6cf8         	ldr	r0, [r7, #0x4c]
 801078a: f00c fa67    	bl	0x801cc5c <sys_dlist_peek_head> @ imm = #0xc4ce
 801078e: 6478         	str	r0, [r7, #0x44]
; 	if (n != NULL) {
 8010790: 6c7b         	ldr	r3, [r7, #0x44]
 8010792: 2b00         	cmp	r3, #0x0
 8010794: d001         	beq	0x801079a <z_sched_wake+0x66> @ imm = #0x2
; 		thread = CONTAINER_OF(n, struct k_thread, base.qnode_dlist);
 8010796: 6c7b         	ldr	r3, [r7, #0x44]
 8010798: 64bb         	str	r3, [r7, #0x48]
; 	return thread;
 801079a: 6cbb         	ldr	r3, [r7, #0x48]
; 		thread = _priq_wait_best(&wait_q->waitq);
 801079c: 66bb         	str	r3, [r7, #0x68]
; 		if (thread != NULL) {
 801079e: 6ebb         	ldr	r3, [r7, #0x68]
 80107a0: 2b00         	cmp	r3, #0x0
 80107a2: d01e         	beq	0x80107e2 <z_sched_wake+0xae> @ imm = #0x3c
; 			z_thread_return_value_set_with_data(thread,
 80107a4: 68bb         	ldr	r3, [r7, #0x8]
 80107a6: 6eba         	ldr	r2, [r7, #0x68]
 80107a8: 643a         	str	r2, [r7, #0x40]
 80107aa: 63fb         	str	r3, [r7, #0x3c]
 80107ac: 687b         	ldr	r3, [r7, #0x4]
 80107ae: 63bb         	str	r3, [r7, #0x38]
 80107b0: 6c3b         	ldr	r3, [r7, #0x40]
 80107b2: 637b         	str	r3, [r7, #0x34]
 80107b4: 6bfb         	ldr	r3, [r7, #0x3c]
 80107b6: 633b         	str	r3, [r7, #0x30]
; 	thread->arch.swap_return_value = value;
 80107b8: 6b7b         	ldr	r3, [r7, #0x34]
 80107ba: 6b3a         	ldr	r2, [r7, #0x30]
 80107bc: f8c3 20cc    	str.w	r2, [r3, #0xcc]
; }
 80107c0: bf00         	nop
; 	thread->base.swap_data = data;
 80107c2: 6c3b         	ldr	r3, [r7, #0x40]
 80107c4: 6bba         	ldr	r2, [r7, #0x38]
 80107c6: 615a         	str	r2, [r3, #0x14]
; }
 80107c8: bf00         	nop
; 			unpend_thread_no_timeout(thread);
 80107ca: 6eb8         	ldr	r0, [r7, #0x68]
 80107cc: f00c fc03    	bl	0x801cfd6 <unpend_thread_no_timeout> @ imm = #0xc806
; 			(void)z_abort_thread_timeout(thread);
 80107d0: 6eb8         	ldr	r0, [r7, #0x68]
 80107d2: f00c faed    	bl	0x801cdb0 <z_abort_thread_timeout> @ imm = #0xc5da
; 			ready_thread(thread);
 80107d6: 6eb8         	ldr	r0, [r7, #0x68]
 80107d8: f7fe fcec    	bl	0x800f1b4 <ready_thread> @ imm = #-0x1628
; 			ret = true;
 80107dc: 2301         	movs	r3, #0x1
 80107de: f887 306f    	strb.w	r3, [r7, #0x6f]
 80107e2: 4b0e         	ldr	r3, [pc, #0x38]         @ 0x801081c <z_sched_wake+0xe8>
 80107e4: 62fb         	str	r3, [r7, #0x2c]
 80107e6: 69fb         	ldr	r3, [r7, #0x1c]
 80107e8: 61bb         	str	r3, [r7, #0x18]
; 	arch_irq_unlock(key.key);
 80107ea: 69bb         	ldr	r3, [r7, #0x18]
 80107ec: 62bb         	str	r3, [r7, #0x28]
 80107ee: 6abb         	ldr	r3, [r7, #0x28]
 80107f0: 627b         	str	r3, [r7, #0x24]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80107f2: 6a7b         	ldr	r3, [r7, #0x24]
 80107f4: f383 8811    	msr	basepri, r3
; }
 80107f8: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 80107fa: f3bf 8f6f    	isb	sy
; }
 80107fe: bf00         	nop
; }
 8010800: bf00         	nop
; }
 8010802: bf00         	nop
; 	K_SPINLOCK(&_sched_spinlock) {
 8010804: 2301         	movs	r3, #0x1
 8010806: 623b         	str	r3, [r7, #0x20]
 8010808: 6a3b         	ldr	r3, [r7, #0x20]
 801080a: 2b00         	cmp	r3, #0x0
 801080c: d0b8         	beq	0x8010780 <z_sched_wake+0x4c> @ imm = #-0x90
; 	return ret;
 801080e: f897 306f    	ldrb.w	r3, [r7, #0x6f]
; }
 8010812: 4618         	mov	r0, r3
 8010814: 3770         	adds	r7, #0x70
 8010816: 46bd         	mov	sp, r7
 8010818: bd80         	pop	{r7, pc}
 801081a: bf00         	nop

0801081c <$d>:
 801081c: 70 1f 00 20  	.word	0x20001f70

08010820 <z_sched_wait>:
; {
 8010820: b580         	push	{r7, lr}
 8010822: b088         	sub	sp, #0x20
 8010824: af02         	add	r7, sp, #0x8
 8010826: 60f8         	str	r0, [r7, #0xc]
 8010828: 60b9         	str	r1, [r7, #0x8]
 801082a: 607a         	str	r2, [r7, #0x4]
; 	int ret = z_pend_curr(lock, key, wait_q, timeout);
 801082c: e9d7 2308    	ldrd	r2, r3, [r7, #32]
 8010830: e9cd 2300    	strd	r2, r3, [sp]
 8010834: 687a         	ldr	r2, [r7, #0x4]
 8010836: 68b9         	ldr	r1, [r7, #0x8]
 8010838: 68f8         	ldr	r0, [r7, #0xc]
 801083a: f7ff f94b    	bl	0x800fad4 <z_pend_curr> @ imm = #-0xd6a
 801083e: 6178         	str	r0, [r7, #0x14]
; 	if (data != NULL) {
 8010840: 6abb         	ldr	r3, [r7, #0x28]
 8010842: 2b00         	cmp	r3, #0x0
 8010844: d006         	beq	0x8010854 <z_sched_wait+0x34> @ imm = #0xc
; 	struct k_thread *ret = _kernel.cpus[0].current;
 8010846: 4b06         	ldr	r3, [pc, #0x18]         @ 0x8010860 <z_sched_wait+0x40>
 8010848: 689b         	ldr	r3, [r3, #0x8]
 801084a: 613b         	str	r3, [r7, #0x10]
; 	return ret;
 801084c: 693b         	ldr	r3, [r7, #0x10]
; 		*data = arch_current_thread()->base.swap_data;
 801084e: 695a         	ldr	r2, [r3, #0x14]
 8010850: 6abb         	ldr	r3, [r7, #0x28]
 8010852: 601a         	str	r2, [r3]
; 	return ret;
 8010854: 697b         	ldr	r3, [r7, #0x14]
; }
 8010856: 4618         	mov	r0, r3
 8010858: 3718         	adds	r7, #0x18
 801085a: 46bd         	mov	sp, r7
 801085c: bd80         	pop	{r7, pc}
 801085e: bf00         	nop

08010860 <$d>:
 8010860: f0 16 00 20  	.word	0x200016f0

08010864 <z_is_idle_thread_object>:
; {
 8010864: b480         	push	{r7}
 8010866: b083         	sub	sp, #0xc
 8010868: af00         	add	r7, sp, #0x0
 801086a: 6078         	str	r0, [r7, #0x4]
; 	return thread == &z_idle_threads[0];
 801086c: 687b         	ldr	r3, [r7, #0x4]
 801086e: 4a05         	ldr	r2, [pc, #0x14]         @ 0x8010884 <z_is_idle_thread_object+0x20>
 8010870: 4293         	cmp	r3, r2
 8010872: bf0c         	ite	eq
 8010874: 2301         	moveq	r3, #0x1
 8010876: 2300         	movne	r3, #0x0
 8010878: b2db         	uxtb	r3, r3
; }
 801087a: 4618         	mov	r0, r3
 801087c: 370c         	adds	r7, #0xc
 801087e: 46bd         	mov	sp, r7
 8010880: bc80         	pop	{r7}
 8010882: 4770         	bx	lr

08010884 <$d>:
 8010884: 00 18 00 20  	.word	0x20001800

08010888 <slice_time>:
; {
 8010888: b480         	push	{r7}
 801088a: b085         	sub	sp, #0x14
 801088c: af00         	add	r7, sp, #0x0
 801088e: 6078         	str	r0, [r7, #0x4]
; 	int ret = slice_ticks;
 8010890: 4b04         	ldr	r3, [pc, #0x10]         @ 0x80108a4 <slice_time+0x1c>
 8010892: 681b         	ldr	r3, [r3]
 8010894: 60fb         	str	r3, [r7, #0xc]
; 	return ret;
 8010896: 68fb         	ldr	r3, [r7, #0xc]
; }
 8010898: 4618         	mov	r0, r3
 801089a: 3714         	adds	r7, #0x14
 801089c: 46bd         	mov	sp, r7
 801089e: bc80         	pop	{r7}
 80108a0: 4770         	bx	lr
 80108a2: bf00         	nop

080108a4 <$d>:
 80108a4: 70 1f 00 20  	.word	0x20001f70

080108a8 <thread_is_sliceable>:
; {
 80108a8: b580         	push	{r7, lr}
 80108aa: b084         	sub	sp, #0x10
 80108ac: af00         	add	r7, sp, #0x0
 80108ae: 6078         	str	r0, [r7, #0x4]
; 	bool ret = thread_is_preemptible(thread)
 80108b0: 6878         	ldr	r0, [r7, #0x4]
 80108b2: f00c fdc6    	bl	0x801d442 <thread_is_preemptible> @ imm = #0xcb8c
 80108b6: 4603         	mov	r3, r0
; 		&& !z_is_idle_thread_object(thread);
 80108b8: 2b00         	cmp	r3, #0x0
 80108ba: d029         	beq	0x8010910 <thread_is_sliceable+0x68> @ imm = #0x52
; 		&& slice_time(thread) != 0
 80108bc: 6878         	ldr	r0, [r7, #0x4]
 80108be: f7ff ffe3    	bl	0x8010888 <slice_time>  @ imm = #-0x3a
 80108c2: 4603         	mov	r3, r0
 80108c4: 2b00         	cmp	r3, #0x0
 80108c6: d023         	beq	0x8010910 <thread_is_sliceable+0x68> @ imm = #0x46
; 		&& !z_is_prio_higher(thread->base.prio, slice_max_prio)
 80108c8: 687b         	ldr	r3, [r7, #0x4]
 80108ca: f993 300e    	ldrsb.w	r3, [r3, #0xe]
 80108ce: 461a         	mov	r2, r3
 80108d0: 4b15         	ldr	r3, [pc, #0x54]         @ 0x8010928 <thread_is_sliceable+0x80>
 80108d2: 681b         	ldr	r3, [r3]
 80108d4: 4619         	mov	r1, r3
 80108d6: 4610         	mov	r0, r2
 80108d8: f00c fde8    	bl	0x801d4ac <z_is_prio_higher> @ imm = #0xcbd0
 80108dc: 4603         	mov	r3, r0
 80108de: f083 0301    	eor	r3, r3, #0x1
 80108e2: b2db         	uxtb	r3, r3
 80108e4: 2b00         	cmp	r3, #0x0
 80108e6: d013         	beq	0x8010910 <thread_is_sliceable+0x68> @ imm = #0x26
; 		&& !z_is_thread_prevented_from_running(thread)
 80108e8: 6878         	ldr	r0, [r7, #0x4]
 80108ea: f00c fdba    	bl	0x801d462 <z_is_thread_prevented_from_running> @ imm = #0xcb74
 80108ee: 4603         	mov	r3, r0
 80108f0: f083 0301    	eor	r3, r3, #0x1
 80108f4: b2db         	uxtb	r3, r3
 80108f6: 2b00         	cmp	r3, #0x0
 80108f8: d00a         	beq	0x8010910 <thread_is_sliceable+0x68> @ imm = #0x14
; 		&& !z_is_idle_thread_object(thread);
 80108fa: 6878         	ldr	r0, [r7, #0x4]
 80108fc: f7ff ffb2    	bl	0x8010864 <z_is_idle_thread_object> @ imm = #-0x9c
 8010900: 4603         	mov	r3, r0
 8010902: f083 0301    	eor	r3, r3, #0x1
 8010906: b2db         	uxtb	r3, r3
 8010908: 2b00         	cmp	r3, #0x0
 801090a: d001         	beq	0x8010910 <thread_is_sliceable+0x68> @ imm = #0x2
 801090c: 2301         	movs	r3, #0x1
 801090e: e000         	b	0x8010912 <thread_is_sliceable+0x6a> @ imm = #0x0
 8010910: 2300         	movs	r3, #0x0
; 	bool ret = thread_is_preemptible(thread)
 8010912: 73fb         	strb	r3, [r7, #0xf]
 8010914: 7bfb         	ldrb	r3, [r7, #0xf]
 8010916: f003 0301    	and	r3, r3, #0x1
 801091a: 73fb         	strb	r3, [r7, #0xf]
; 	return ret;
 801091c: 7bfb         	ldrb	r3, [r7, #0xf]
; }
 801091e: 4618         	mov	r0, r3
 8010920: 3710         	adds	r7, #0x10
 8010922: 46bd         	mov	sp, r7
 8010924: bd80         	pop	{r7, pc}
 8010926: bf00         	nop

08010928 <$d>:
 8010928: 74 1f 00 20  	.word	0x20001f74

0801092c <slice_timeout>:
; {
 801092c: b480         	push	{r7}
 801092e: b085         	sub	sp, #0x14
 8010930: af00         	add	r7, sp, #0x0
 8010932: 6078         	str	r0, [r7, #0x4]
; 	int cpu = ARRAY_INDEX(slice_timeouts, timeout);
 8010934: 687b         	ldr	r3, [r7, #0x4]
 8010936: 4a08         	ldr	r2, [pc, #0x20]         @ 0x8010958 <slice_timeout+0x2c>
 8010938: 1a9b         	subs	r3, r3, r2
 801093a: 10db         	asrs	r3, r3, #0x3
 801093c: 4a07         	ldr	r2, [pc, #0x1c]         @ 0x801095c <slice_timeout+0x30>
 801093e: fb02 f303    	mul	r3, r2, r3
 8010942: 60fb         	str	r3, [r7, #0xc]
; 	slice_expired[cpu] = true;
 8010944: 4a06         	ldr	r2, [pc, #0x18]         @ 0x8010960 <slice_timeout+0x34>
 8010946: 68fb         	ldr	r3, [r7, #0xc]
 8010948: 4413         	add	r3, r2
 801094a: 2201         	movs	r2, #0x1
 801094c: 701a         	strb	r2, [r3]
; }
 801094e: bf00         	nop
 8010950: 3714         	adds	r7, #0x14
 8010952: 46bd         	mov	sp, r7
 8010954: bc80         	pop	{r7}
 8010956: 4770         	bx	lr

08010958 <$d>:
 8010958: a0 19 00 20  	.word	0x200019a0
 801095c: ab aa aa aa  	.word	0xaaaaaaab
 8010960: 78 1f 00 20  	.word	0x20001f78

08010964 <z_reset_time_slice>:
; {
 8010964: e92d 4390    	push.w	{r4, r7, r8, r9, lr}
 8010968: b085         	sub	sp, #0x14
 801096a: af00         	add	r7, sp, #0x0
 801096c: 6078         	str	r0, [r7, #0x4]
; 	int cpu = _current_cpu->id;
 801096e: 4b19         	ldr	r3, [pc, #0x64]         @ 0x80109d4 <z_reset_time_slice+0x70>
 8010970: 7c1b         	ldrb	r3, [r3, #0x10]
 8010972: 60fb         	str	r3, [r7, #0xc]
; 	z_abort_timeout(&slice_timeouts[cpu]);
 8010974: 68fa         	ldr	r2, [r7, #0xc]
 8010976: 4613         	mov	r3, r2
 8010978: 005b         	lsls	r3, r3, #0x1
 801097a: 4413         	add	r3, r2
 801097c: 00db         	lsls	r3, r3, #0x3
 801097e: 4a16         	ldr	r2, [pc, #0x58]         @ 0x80109d8 <z_reset_time_slice+0x74>
 8010980: 4413         	add	r3, r2
 8010982: 4618         	mov	r0, r3
 8010984: f000 fa4a    	bl	0x8010e1c <z_abort_timeout> @ imm = #0x494
; 	slice_expired[cpu] = false;
 8010988: 4a14         	ldr	r2, [pc, #0x50]         @ 0x80109dc <z_reset_time_slice+0x78>
 801098a: 68fb         	ldr	r3, [r7, #0xc]
 801098c: 4413         	add	r3, r2
 801098e: 2200         	movs	r2, #0x0
 8010990: 701a         	strb	r2, [r3]
; 	if (thread_is_sliceable(thread)) {
 8010992: 6878         	ldr	r0, [r7, #0x4]
 8010994: f7ff ff88    	bl	0x80108a8 <thread_is_sliceable> @ imm = #-0xf0
 8010998: 4603         	mov	r3, r0
 801099a: 2b00         	cmp	r3, #0x0
 801099c: d014         	beq	0x80109c8 <z_reset_time_slice+0x64> @ imm = #0x28
; 		z_add_timeout(&slice_timeouts[cpu], slice_timeout,
 801099e: 68fa         	ldr	r2, [r7, #0xc]
 80109a0: 4613         	mov	r3, r2
 80109a2: 005b         	lsls	r3, r3, #0x1
 80109a4: 4413         	add	r3, r2
 80109a6: 00db         	lsls	r3, r3, #0x3
 80109a8: 4a0b         	ldr	r2, [pc, #0x2c]         @ 0x80109d8 <z_reset_time_slice+0x74>
 80109aa: 189c         	adds	r4, r3, r2
; 			      K_TICKS(slice_time(thread) - 1));
 80109ac: 6878         	ldr	r0, [r7, #0x4]
 80109ae: f7ff ff6b    	bl	0x8010888 <slice_time>  @ imm = #-0x12a
 80109b2: 4603         	mov	r3, r0
 80109b4: 3b01         	subs	r3, #0x1
 80109b6: 17da         	asrs	r2, r3, #0x1f
 80109b8: 4698         	mov	r8, r3
 80109ba: 4691         	mov	r9, r2
 80109bc: 4642         	mov	r2, r8
 80109be: 464b         	mov	r3, r9
; 		z_add_timeout(&slice_timeouts[cpu], slice_timeout,
 80109c0: 4907         	ldr	r1, [pc, #0x1c]         @ 0x80109e0 <z_reset_time_slice+0x7c>
 80109c2: 4620         	mov	r0, r4
 80109c4: f000 f932    	bl	0x8010c2c <z_add_timeout> @ imm = #0x264
; }
 80109c8: bf00         	nop
 80109ca: 3714         	adds	r7, #0x14
 80109cc: 46bd         	mov	sp, r7
 80109ce: e8bd 8390    	pop.w	{r4, r7, r8, r9, pc}
 80109d2: bf00         	nop

080109d4 <$d>:
 80109d4: f0 16 00 20  	.word	0x200016f0
 80109d8: a0 19 00 20  	.word	0x200019a0
 80109dc: 78 1f 00 20  	.word	0x20001f78
 80109e0: 2d 09 01 08  	.word	0x0801092d

080109e4 <z_time_slice>:
; {
 80109e4: b580         	push	{r7, lr}
 80109e6: b092         	sub	sp, #0x48
 80109e8: af00         	add	r7, sp, #0x0
 80109ea: 4b35         	ldr	r3, [pc, #0xd4]         @ 0x8010ac0 <z_time_slice+0xdc>
 80109ec: 63fb         	str	r3, [r7, #0x3c]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 80109ee: f3ef 8311    	mrs	r3, basepri
 80109f2: 63bb         	str	r3, [r7, #0x38]
;   return(result);
 80109f4: 6bbb         	ldr	r3, [r7, #0x38]
; 	key = __get_BASEPRI();
 80109f6: 637b         	str	r3, [r7, #0x34]
 80109f8: 2310         	movs	r3, #0x10
 80109fa: 633b         	str	r3, [r7, #0x30]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 80109fc: 6b3b         	ldr	r3, [r7, #0x30]
 80109fe: f383 8812    	msr	basepri_max, r3
; }
 8010a02: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8010a04: f3bf 8f6f    	isb	sy
; }
 8010a08: bf00         	nop
; 	return key;
 8010a0a: 6b7b         	ldr	r3, [r7, #0x34]
; 	k.key = arch_irq_lock();
 8010a0c: 603b         	str	r3, [r7]
 8010a0e: 6bfb         	ldr	r3, [r7, #0x3c]
 8010a10: 62fb         	str	r3, [r7, #0x2c]
; }
 8010a12: bf00         	nop
 8010a14: 6bfb         	ldr	r3, [r7, #0x3c]
 8010a16: 62bb         	str	r3, [r7, #0x28]
; }
 8010a18: bf00         	nop
; 	return k;
 8010a1a: 683b         	ldr	r3, [r7]
 8010a1c: 60fb         	str	r3, [r7, #0xc]
; 	struct k_thread *ret = _kernel.cpus[0].current;
 8010a1e: 4b29         	ldr	r3, [pc, #0xa4]         @ 0x8010ac4 <z_time_slice+0xe0>
 8010a20: 689b         	ldr	r3, [r3, #0x8]
 8010a22: 643b         	str	r3, [r7, #0x40]
; 	return ret;
 8010a24: 6c3b         	ldr	r3, [r7, #0x40]
; 	struct k_thread *curr = arch_current_thread();
 8010a26: 647b         	str	r3, [r7, #0x44]
; 	if (pending_current == curr) {
 8010a28: 4b27         	ldr	r3, [pc, #0x9c]         @ 0x8010ac8 <z_time_slice+0xe4>
 8010a2a: 681b         	ldr	r3, [r3]
 8010a2c: 6c7a         	ldr	r2, [r7, #0x44]
 8010a2e: 429a         	cmp	r2, r3
 8010a30: d113         	bne	0x8010a5a <z_time_slice+0x76> @ imm = #0x26
; 		z_reset_time_slice(curr);
 8010a32: 6c78         	ldr	r0, [r7, #0x44]
 8010a34: f7ff ff96    	bl	0x8010964 <z_reset_time_slice> @ imm = #-0xd4
 8010a38: 4b21         	ldr	r3, [pc, #0x84]         @ 0x8010ac0 <z_time_slice+0xdc>
 8010a3a: 627b         	str	r3, [r7, #0x24]
 8010a3c: 68fb         	ldr	r3, [r7, #0xc]
 8010a3e: 607b         	str	r3, [r7, #0x4]
; 	arch_irq_unlock(key.key);
 8010a40: 687b         	ldr	r3, [r7, #0x4]
 8010a42: 623b         	str	r3, [r7, #0x20]
 8010a44: 6a3b         	ldr	r3, [r7, #0x20]
 8010a46: 61fb         	str	r3, [r7, #0x1c]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8010a48: 69fb         	ldr	r3, [r7, #0x1c]
 8010a4a: f383 8811    	msr	basepri, r3
; }
 8010a4e: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8010a50: f3bf 8f6f    	isb	sy
; }
 8010a54: bf00         	nop
; }
 8010a56: bf00         	nop
; }
 8010a58: e02f         	b	0x8010aba <z_time_slice+0xd6> @ imm = #0x5e
; 	pending_current = NULL;
 8010a5a: 4b1b         	ldr	r3, [pc, #0x6c]         @ 0x8010ac8 <z_time_slice+0xe4>
 8010a5c: 2200         	movs	r2, #0x0
 8010a5e: 601a         	str	r2, [r3]
; 	if (slice_expired[_current_cpu->id] && thread_is_sliceable(curr)) {
 8010a60: 4b18         	ldr	r3, [pc, #0x60]         @ 0x8010ac4 <z_time_slice+0xe0>
 8010a62: 7c1b         	ldrb	r3, [r3, #0x10]
 8010a64: 461a         	mov	r2, r3
 8010a66: 4b19         	ldr	r3, [pc, #0x64]         @ 0x8010acc <z_time_slice+0xe8>
 8010a68: 5c9b         	ldrb	r3, [r3, r2]
 8010a6a: 2b00         	cmp	r3, #0x0
 8010a6c: d014         	beq	0x8010a98 <z_time_slice+0xb4> @ imm = #0x28
 8010a6e: 6c78         	ldr	r0, [r7, #0x44]
 8010a70: f7ff ff1a    	bl	0x80108a8 <thread_is_sliceable> @ imm = #-0x1cc
 8010a74: 4603         	mov	r3, r0
 8010a76: 2b00         	cmp	r3, #0x0
 8010a78: d00e         	beq	0x8010a98 <z_time_slice+0xb4> @ imm = #0x1c
; 		if (!z_is_thread_prevented_from_running(curr)) {
 8010a7a: 6c78         	ldr	r0, [r7, #0x44]
 8010a7c: f00c fcf1    	bl	0x801d462 <z_is_thread_prevented_from_running> @ imm = #0xc9e2
 8010a80: 4603         	mov	r3, r0
 8010a82: f083 0301    	eor	r3, r3, #0x1
 8010a86: b2db         	uxtb	r3, r3
 8010a88: 2b00         	cmp	r3, #0x0
 8010a8a: d002         	beq	0x8010a92 <z_time_slice+0xae> @ imm = #0x4
; 			move_thread_to_end_of_prio_q(curr);
 8010a8c: 6c78         	ldr	r0, [r7, #0x44]
 8010a8e: f7fe faa1    	bl	0x800efd4 <move_thread_to_end_of_prio_q> @ imm = #-0x1abe
; 		z_reset_time_slice(curr);
 8010a92: 6c78         	ldr	r0, [r7, #0x44]
 8010a94: f7ff ff66    	bl	0x8010964 <z_reset_time_slice> @ imm = #-0x134
 8010a98: 4b09         	ldr	r3, [pc, #0x24]         @ 0x8010ac0 <z_time_slice+0xdc>
 8010a9a: 61bb         	str	r3, [r7, #0x18]
 8010a9c: 68fb         	ldr	r3, [r7, #0xc]
 8010a9e: 60bb         	str	r3, [r7, #0x8]
; 	arch_irq_unlock(key.key);
 8010aa0: 68bb         	ldr	r3, [r7, #0x8]
 8010aa2: 617b         	str	r3, [r7, #0x14]
 8010aa4: 697b         	ldr	r3, [r7, #0x14]
 8010aa6: 613b         	str	r3, [r7, #0x10]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8010aa8: 693b         	ldr	r3, [r7, #0x10]
 8010aaa: f383 8811    	msr	basepri, r3
; }
 8010aae: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8010ab0: f3bf 8f6f    	isb	sy
; }
 8010ab4: bf00         	nop
; }
 8010ab6: bf00         	nop
; }
 8010ab8: bf00         	nop
; }
 8010aba: 3748         	adds	r7, #0x48
 8010abc: 46bd         	mov	sp, r7
 8010abe: bd80         	pop	{r7, pc}

08010ac0 <$d>:
 8010ac0: 70 1f 00 20  	.word	0x20001f70
 8010ac4: f0 16 00 20  	.word	0x200016f0
 8010ac8: 7c 1f 00 20  	.word	0x20001f7c
 8010acc: 78 1f 00 20  	.word	0x20001f78

08010ad0 <z_thread_monitor_exit>:
; {
 8010ad0: b480         	push	{r7}
 8010ad2: b091         	sub	sp, #0x44
 8010ad4: af00         	add	r7, sp, #0x0
 8010ad6: 6078         	str	r0, [r7, #0x4]
 8010ad8: 4b2a         	ldr	r3, [pc, #0xa8]         @ 0x8010b84 <z_thread_monitor_exit+0xb4>
 8010ada: 63bb         	str	r3, [r7, #0x38]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 8010adc: f3ef 8311    	mrs	r3, basepri
 8010ae0: 637b         	str	r3, [r7, #0x34]
;   return(result);
 8010ae2: 6b7b         	ldr	r3, [r7, #0x34]
; 	key = __get_BASEPRI();
 8010ae4: 633b         	str	r3, [r7, #0x30]
 8010ae6: 2310         	movs	r3, #0x10
 8010ae8: 62fb         	str	r3, [r7, #0x2c]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 8010aea: 6afb         	ldr	r3, [r7, #0x2c]
 8010aec: f383 8812    	msr	basepri_max, r3
; }
 8010af0: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8010af2: f3bf 8f6f    	isb	sy
; }
 8010af6: bf00         	nop
; 	return key;
 8010af8: 6b3b         	ldr	r3, [r7, #0x30]
; 	k.key = arch_irq_lock();
 8010afa: 60fb         	str	r3, [r7, #0xc]
 8010afc: 6bbb         	ldr	r3, [r7, #0x38]
 8010afe: 62bb         	str	r3, [r7, #0x28]
; }
 8010b00: bf00         	nop
 8010b02: 6bbb         	ldr	r3, [r7, #0x38]
 8010b04: 627b         	str	r3, [r7, #0x24]
; }
 8010b06: bf00         	nop
; 	return k;
 8010b08: 68fb         	ldr	r3, [r7, #0xc]
 8010b0a: 617b         	str	r3, [r7, #0x14]
; 	if (thread == _kernel.threads) {
 8010b0c: 4b1e         	ldr	r3, [pc, #0x78]         @ 0x8010b88 <z_thread_monitor_exit+0xb8>
 8010b0e: 6a9b         	ldr	r3, [r3, #0x28]
 8010b10: 687a         	ldr	r2, [r7, #0x4]
 8010b12: 429a         	cmp	r2, r3
 8010b14: d106         	bne	0x8010b24 <z_thread_monitor_exit+0x54> @ imm = #0xc
; 		_kernel.threads = _kernel.threads->next_thread;
 8010b16: 4b1c         	ldr	r3, [pc, #0x70]         @ 0x8010b88 <z_thread_monitor_exit+0xb8>
 8010b18: 6a9b         	ldr	r3, [r3, #0x28]
 8010b1a: f8d3 3090    	ldr.w	r3, [r3, #0x90]
 8010b1e: 4a1a         	ldr	r2, [pc, #0x68]         @ 0x8010b88 <z_thread_monitor_exit+0xb8>
 8010b20: 6293         	str	r3, [r2, #0x28]
 8010b22: e019         	b	0x8010b58 <z_thread_monitor_exit+0x88> @ imm = #0x32
; 		prev_thread = _kernel.threads;
 8010b24: 4b18         	ldr	r3, [pc, #0x60]         @ 0x8010b88 <z_thread_monitor_exit+0xb8>
 8010b26: 6a9b         	ldr	r3, [r3, #0x28]
 8010b28: 63fb         	str	r3, [r7, #0x3c]
; 		while ((prev_thread != NULL) &&
 8010b2a: e003         	b	0x8010b34 <z_thread_monitor_exit+0x64> @ imm = #0x6
; 			prev_thread = prev_thread->next_thread;
 8010b2c: 6bfb         	ldr	r3, [r7, #0x3c]
 8010b2e: f8d3 3090    	ldr.w	r3, [r3, #0x90]
 8010b32: 63fb         	str	r3, [r7, #0x3c]
; 		while ((prev_thread != NULL) &&
 8010b34: 6bfb         	ldr	r3, [r7, #0x3c]
 8010b36: 2b00         	cmp	r3, #0x0
 8010b38: d005         	beq	0x8010b46 <z_thread_monitor_exit+0x76> @ imm = #0xa
; 			(thread != prev_thread->next_thread)) {
 8010b3a: 6bfb         	ldr	r3, [r7, #0x3c]
 8010b3c: f8d3 3090    	ldr.w	r3, [r3, #0x90]
; 		while ((prev_thread != NULL) &&
 8010b40: 687a         	ldr	r2, [r7, #0x4]
 8010b42: 429a         	cmp	r2, r3
 8010b44: d1f2         	bne	0x8010b2c <z_thread_monitor_exit+0x5c> @ imm = #-0x1c
; 		if (prev_thread != NULL) {
 8010b46: 6bfb         	ldr	r3, [r7, #0x3c]
 8010b48: 2b00         	cmp	r3, #0x0
 8010b4a: d005         	beq	0x8010b58 <z_thread_monitor_exit+0x88> @ imm = #0xa
; 			prev_thread->next_thread = thread->next_thread;
 8010b4c: 687b         	ldr	r3, [r7, #0x4]
 8010b4e: f8d3 2090    	ldr.w	r2, [r3, #0x90]
 8010b52: 6bfb         	ldr	r3, [r7, #0x3c]
 8010b54: f8c3 2090    	str.w	r2, [r3, #0x90]
 8010b58: 4b0a         	ldr	r3, [pc, #0x28]         @ 0x8010b84 <z_thread_monitor_exit+0xb4>
 8010b5a: 623b         	str	r3, [r7, #0x20]
 8010b5c: 697b         	ldr	r3, [r7, #0x14]
 8010b5e: 613b         	str	r3, [r7, #0x10]
; 	arch_irq_unlock(key.key);
 8010b60: 693b         	ldr	r3, [r7, #0x10]
 8010b62: 61fb         	str	r3, [r7, #0x1c]
 8010b64: 69fb         	ldr	r3, [r7, #0x1c]
 8010b66: 61bb         	str	r3, [r7, #0x18]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8010b68: 69bb         	ldr	r3, [r7, #0x18]
 8010b6a: f383 8811    	msr	basepri, r3
; }
 8010b6e: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8010b70: f3bf 8f6f    	isb	sy
; }
 8010b74: bf00         	nop
; }
 8010b76: bf00         	nop
; }
 8010b78: bf00         	nop
; }
 8010b7a: bf00         	nop
 8010b7c: 3744         	adds	r7, #0x44
 8010b7e: 46bd         	mov	sp, r7
 8010b80: bc80         	pop	{r7}
 8010b82: 4770         	bx	lr

08010b84 <$d>:
 8010b84: 80 1f 00 20  	.word	0x20001f80
 8010b88: f0 16 00 20  	.word	0x200016f0

08010b8c <z_data_copy>:
; {
 8010b8c: b580         	push	{r7, lr}
 8010b8e: af00         	add	r7, sp, #0x0
; 		       __data_region_end - __data_region_start);
 8010b90: 4a08         	ldr	r2, [pc, #0x20]         @ 0x8010bb4 <z_data_copy+0x28>
 8010b92: 4b09         	ldr	r3, [pc, #0x24]         @ 0x8010bb8 <z_data_copy+0x2c>
 8010b94: 1ad3         	subs	r3, r2, r3
; 	z_early_memcpy(&__data_region_start, &__data_region_load_start,
 8010b96: 461a         	mov	r2, r3
 8010b98: 4908         	ldr	r1, [pc, #0x20]         @ 0x8010bbc <z_data_copy+0x30>
 8010b9a: 4807         	ldr	r0, [pc, #0x1c]         @ 0x8010bb8 <z_data_copy+0x2c>
 8010b9c: f00b f8da    	bl	0x801bd54 <z_early_memcpy> @ imm = #0xb1b4
; 		       __ramfunc_end - __ramfunc_region_start);
 8010ba0: 4a07         	ldr	r2, [pc, #0x1c]         @ 0x8010bc0 <z_data_copy+0x34>
 8010ba2: 4b08         	ldr	r3, [pc, #0x20]         @ 0x8010bc4 <z_data_copy+0x38>
 8010ba4: 1ad3         	subs	r3, r2, r3
; 	z_early_memcpy(&__ramfunc_region_start, &__ramfunc_load_start,
 8010ba6: 461a         	mov	r2, r3
 8010ba8: 4907         	ldr	r1, [pc, #0x1c]         @ 0x8010bc8 <z_data_copy+0x3c>
 8010baa: 4806         	ldr	r0, [pc, #0x18]         @ 0x8010bc4 <z_data_copy+0x38>
 8010bac: f00b f8d2    	bl	0x801bd54 <z_early_memcpy> @ imm = #0xb1a4
; }
 8010bb0: bf00         	nop
 8010bb2: bd80         	pop	{r7, pc}

08010bb4 <$d>:
 8010bb4: 28 06 00 20  	.word	0x20000628
 8010bb8: 00 00 00 20  	.word	0x20000000
 8010bbc: 10 0d 02 08  	.word	0x08020d10
 8010bc0: 00 00 00 20  	.word	0x20000000
 8010bc4: 00 00 00 20  	.word	0x20000000
 8010bc8: 10 0d 02 08  	.word	0x08020d10

08010bcc <first>:
; {
 8010bcc: b580         	push	{r7, lr}
 8010bce: b082         	sub	sp, #0x8
 8010bd0: af00         	add	r7, sp, #0x0
; 	sys_dnode_t *t = sys_dlist_peek_head(&timeout_list);
 8010bd2: 4804         	ldr	r0, [pc, #0x10]         @ 0x8010be4 <first+0x18>
 8010bd4: f00c fca8    	bl	0x801d528 <sys_dlist_peek_head> @ imm = #0xc950
 8010bd8: 6078         	str	r0, [r7, #0x4]
; 	return (t == NULL) ? NULL : CONTAINER_OF(t, struct _timeout, node);
 8010bda: 687b         	ldr	r3, [r7, #0x4]
; }
 8010bdc: 4618         	mov	r0, r3
 8010bde: 3708         	adds	r7, #0x8
 8010be0: 46bd         	mov	sp, r7
 8010be2: bd80         	pop	{r7, pc}

08010be4 <$d>:
 8010be4: bc 05 00 20  	.word	0x200005bc

08010be8 <next>:
; {
 8010be8: b580         	push	{r7, lr}
 8010bea: b084         	sub	sp, #0x10
 8010bec: af00         	add	r7, sp, #0x0
 8010bee: 6078         	str	r0, [r7, #0x4]
; 	sys_dnode_t *n = sys_dlist_peek_next(&timeout_list, &t->node);
 8010bf0: 687b         	ldr	r3, [r7, #0x4]
 8010bf2: 4619         	mov	r1, r3
 8010bf4: 4804         	ldr	r0, [pc, #0x10]         @ 0x8010c08 <next+0x20>
 8010bf6: f00c fcbc    	bl	0x801d572 <sys_dlist_peek_next> @ imm = #0xc978
 8010bfa: 60f8         	str	r0, [r7, #0xc]
; 	return (n == NULL) ? NULL : CONTAINER_OF(n, struct _timeout, node);
 8010bfc: 68fb         	ldr	r3, [r7, #0xc]
; }
 8010bfe: 4618         	mov	r0, r3
 8010c00: 3710         	adds	r7, #0x10
 8010c02: 46bd         	mov	sp, r7
 8010c04: bd80         	pop	{r7, pc}
 8010c06: bf00         	nop

08010c08 <$d>:
 8010c08: bc 05 00 20  	.word	0x200005bc

08010c0c <elapsed>:
; {
 8010c0c: b580         	push	{r7, lr}
 8010c0e: af00         	add	r7, sp, #0x0
; 	return announce_remaining == 0 ? sys_clock_elapsed() : 0U;
 8010c10: 4b05         	ldr	r3, [pc, #0x14]         @ 0x8010c28 <elapsed+0x1c>
 8010c12: 681b         	ldr	r3, [r3]
 8010c14: 2b00         	cmp	r3, #0x0
 8010c16: d103         	bne	0x8010c20 <elapsed+0x14> @ imm = #0x6
 8010c18: f7fb febe    	bl	0x800c998 <sys_clock_elapsed> @ imm = #-0x4284
 8010c1c: 4603         	mov	r3, r0
 8010c1e: e000         	b	0x8010c22 <elapsed+0x16> @ imm = #0x0
 8010c20: 2300         	movs	r3, #0x0
; }
 8010c22: 4618         	mov	r0, r3
 8010c24: bd80         	pop	{r7, pc}
 8010c26: bf00         	nop

08010c28 <$d>:
 8010c28: 80 1f 00 20  	.word	0x20001f80

08010c2c <z_add_timeout>:
; {
 8010c2c: e92d 4fb0    	push.w	{r4, r5, r7, r8, r9, r10, r11, lr}
 8010c30: b0a0         	sub	sp, #0x80
 8010c32: af00         	add	r7, sp, #0x0
 8010c34: 6378         	str	r0, [r7, #0x34]
 8010c36: 6339         	str	r1, [r7, #0x30]
 8010c38: e9c7 230a    	strd	r2, r3, [r7, #40]
; 	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
 8010c3c: e9d7 010a    	ldrd	r0, r1, [r7, #40]
 8010c40: f04f 32ff    	mov.w	r2, #0xffffffff
 8010c44: f04f 33ff    	mov.w	r3, #0xffffffff
 8010c48: 4299         	cmp	r1, r3
 8010c4a: bf08         	it	eq
 8010c4c: 4290         	cmpeq	r0, r2
 8010c4e: d100         	bne	0x8010c52 <z_add_timeout+0x26> @ imm = #0x0
 8010c50: e0d8         	b	0x8010e04 <z_add_timeout+0x1d8> @ imm = #0x1b0
; 	to->fn = fn;
 8010c52: 6b7a         	ldr	r2, [r7, #0x34]
 8010c54: 6b3b         	ldr	r3, [r7, #0x30]
 8010c56: 6093         	str	r3, [r2, #0x8]
; 	K_SPINLOCK(&timeout_lock) {
 8010c58: 2300         	movs	r3, #0x0
 8010c5a: 64bb         	str	r3, [r7, #0x48]
 8010c5c: 4b6b         	ldr	r3, [pc, #0x1ac]        @ 0x8010e0c <z_add_timeout+0x1e0>
 8010c5e: 66fb         	str	r3, [r7, #0x6c]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 8010c60: f3ef 8311    	mrs	r3, basepri
 8010c64: 66bb         	str	r3, [r7, #0x68]
;   return(result);
 8010c66: 6ebb         	ldr	r3, [r7, #0x68]
; 	key = __get_BASEPRI();
 8010c68: 667b         	str	r3, [r7, #0x64]
 8010c6a: 2310         	movs	r3, #0x10
 8010c6c: 663b         	str	r3, [r7, #0x60]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 8010c6e: 6e3b         	ldr	r3, [r7, #0x60]
 8010c70: f383 8812    	msr	basepri_max, r3
; }
 8010c74: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8010c76: f3bf 8f6f    	isb	sy
; }
 8010c7a: bf00         	nop
; 	return key;
 8010c7c: 6e7b         	ldr	r3, [r7, #0x64]
; 	k.key = arch_irq_lock();
 8010c7e: 63fb         	str	r3, [r7, #0x3c]
 8010c80: 6efb         	ldr	r3, [r7, #0x6c]
 8010c82: 65fb         	str	r3, [r7, #0x5c]
; }
 8010c84: bf00         	nop
 8010c86: 6efb         	ldr	r3, [r7, #0x6c]
 8010c88: 65bb         	str	r3, [r7, #0x58]
; }
 8010c8a: bf00         	nop
; 	return k;
 8010c8c: 6bfb         	ldr	r3, [r7, #0x3c]
 8010c8e: 647b         	str	r3, [r7, #0x44]
; 	K_SPINLOCK(&timeout_lock) {
 8010c90: e0b4         	b	0x8010dfc <z_add_timeout+0x1d0> @ imm = #0x168
; 		    (Z_TICK_ABS(timeout.ticks) >= 0)) {
 8010c92: e9d7 230a    	ldrd	r2, r3, [r7, #40]
 8010c96: f06f 0001    	mvn	r0, #0x1
 8010c9a: f04f 31ff    	mov.w	r1, #0xffffffff
 8010c9e: 1a80         	subs	r0, r0, r2
 8010ca0: 6238         	str	r0, [r7, #0x20]
 8010ca2: eb61 0303    	sbc.w	r3, r1, r3
 8010ca6: 627b         	str	r3, [r7, #0x24]
; 		if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) &&
 8010ca8: 6a7b         	ldr	r3, [r7, #0x24]
 8010caa: 2b00         	cmp	r3, #0x0
 8010cac: db24         	blt	0x8010cf8 <z_add_timeout+0xcc> @ imm = #0x48
; 			k_ticks_t ticks = Z_TICK_ABS(timeout.ticks) - curr_tick;
 8010cae: e9d7 230a    	ldrd	r2, r3, [r7, #40]
 8010cb2: 4610         	mov	r0, r2
 8010cb4: 4619         	mov	r1, r3
 8010cb6: 4b56         	ldr	r3, [pc, #0x158]        @ 0x8010e10 <z_add_timeout+0x1e4>
 8010cb8: e9d3 2300    	ldrd	r2, r3, [r3]
 8010cbc: 1884         	adds	r4, r0, r2
 8010cbe: eb41 0503    	adc.w	r5, r1, r3
 8010cc2: f06f 0201    	mvn	r2, #0x1
 8010cc6: f04f 33ff    	mov.w	r3, #0xffffffff
 8010cca: 1b12         	subs	r2, r2, r4
 8010ccc: 61ba         	str	r2, [r7, #0x18]
 8010cce: eb63 0305    	sbc.w	r3, r3, r5
 8010cd2: 61fb         	str	r3, [r7, #0x1c]
 8010cd4: e9d7 2306    	ldrd	r2, r3, [r7, #24]
 8010cd8: e9c7 231c    	strd	r2, r3, [r7, #112]
; 			to->dticks = MAX(1, ticks);
 8010cdc: e9d7 231c    	ldrd	r2, r3, [r7, #112]
 8010ce0: 2a01         	cmp	r2, #0x1
 8010ce2: f173 0100    	sbcs	r1, r3, #0x0
 8010ce6: da03         	bge	0x8010cf0 <z_add_timeout+0xc4> @ imm = #0x6
 8010ce8: f04f 0201    	mov.w	r2, #0x1
 8010cec: f04f 0300    	mov.w	r3, #0x0
 8010cf0: 6b79         	ldr	r1, [r7, #0x34]
 8010cf2: e9c1 2304    	strd	r2, r3, [r1, #16]
 8010cf6: e016         	b	0x8010d26 <z_add_timeout+0xfa> @ imm = #0x2c
; 			to->dticks = timeout.ticks + 1 + elapsed();
 8010cf8: e9d7 230a    	ldrd	r2, r3, [r7, #40]
 8010cfc: f112 0801    	adds.w	r8, r2, #0x1
 8010d00: f143 0900    	adc	r9, r3, #0x0
 8010d04: f7ff ff82    	bl	0x8010c0c <elapsed>     @ imm = #-0xfc
 8010d08: 4603         	mov	r3, r0
 8010d0a: 17da         	asrs	r2, r3, #0x1f
 8010d0c: 469a         	mov	r10, r3
 8010d0e: 4693         	mov	r11, r2
 8010d10: eb18 030a    	adds.w	r3, r8, r10
 8010d14: 613b         	str	r3, [r7, #0x10]
 8010d16: eb49 030b    	adc.w	r3, r9, r11
 8010d1a: 617b         	str	r3, [r7, #0x14]
 8010d1c: 6b7b         	ldr	r3, [r7, #0x34]
 8010d1e: e9d7 1204    	ldrd	r1, r2, [r7, #16]
 8010d22: e9c3 1204    	strd	r1, r2, [r3, #16]
; 		for (t = first(); t != NULL; t = next(t)) {
 8010d26: f7ff ff51    	bl	0x8010bcc <first>       @ imm = #-0x15e
 8010d2a: 67f8         	str	r0, [r7, #0x7c]
 8010d2c: e037         	b	0x8010d9e <z_add_timeout+0x172> @ imm = #0x6e
; 			if (t->dticks > to->dticks) {
 8010d2e: 6ffb         	ldr	r3, [r7, #0x7c]
 8010d30: e9d3 0104    	ldrd	r0, r1, [r3, #16]
 8010d34: 6b7b         	ldr	r3, [r7, #0x34]
 8010d36: e9d3 2304    	ldrd	r2, r3, [r3, #16]
 8010d3a: 4282         	cmp	r2, r0
 8010d3c: 418b         	sbcs	r3, r1
 8010d3e: da18         	bge	0x8010d72 <z_add_timeout+0x146> @ imm = #0x30
; 				t->dticks -= to->dticks;
 8010d40: 6ffb         	ldr	r3, [r7, #0x7c]
 8010d42: e9d3 0104    	ldrd	r0, r1, [r3, #16]
 8010d46: 6b7b         	ldr	r3, [r7, #0x34]
 8010d48: e9d3 2304    	ldrd	r2, r3, [r3, #16]
 8010d4c: ebb0 0c02    	subs.w	r12, r0, r2
 8010d50: f8c7 c008    	str.w	r12, [r7, #0x8]
 8010d54: eb61 0303    	sbc.w	r3, r1, r3
 8010d58: 60fb         	str	r3, [r7, #0xc]
 8010d5a: 6ffb         	ldr	r3, [r7, #0x7c]
 8010d5c: e9d7 1202    	ldrd	r1, r2, [r7, #8]
 8010d60: e9c3 1204    	strd	r1, r2, [r3, #16]
; 				sys_dlist_insert(&t->node, &to->node);
 8010d64: 6ffa         	ldr	r2, [r7, #0x7c]
 8010d66: 6b7b         	ldr	r3, [r7, #0x34]
 8010d68: 4619         	mov	r1, r3
 8010d6a: 4610         	mov	r0, r2
 8010d6c: f00c fc2d    	bl	0x801d5ca <sys_dlist_insert> @ imm = #0xc85a
; 				break;
 8010d70: e018         	b	0x8010da4 <z_add_timeout+0x178> @ imm = #0x30
; 			to->dticks -= t->dticks;
 8010d72: 6b7b         	ldr	r3, [r7, #0x34]
 8010d74: e9d3 0104    	ldrd	r0, r1, [r3, #16]
 8010d78: 6ffb         	ldr	r3, [r7, #0x7c]
 8010d7a: e9d3 2304    	ldrd	r2, r3, [r3, #16]
 8010d7e: ebb0 0c02    	subs.w	r12, r0, r2
 8010d82: f8c7 c000    	str.w	r12, [r7]
 8010d86: eb61 0303    	sbc.w	r3, r1, r3
 8010d8a: 607b         	str	r3, [r7, #0x4]
 8010d8c: 6b7b         	ldr	r3, [r7, #0x34]
 8010d8e: e9d7 1200    	ldrd	r1, r2, [r7]
 8010d92: e9c3 1204    	strd	r1, r2, [r3, #16]
; 		for (t = first(); t != NULL; t = next(t)) {
 8010d96: 6ff8         	ldr	r0, [r7, #0x7c]
 8010d98: f7ff ff26    	bl	0x8010be8 <next>        @ imm = #-0x1b4
 8010d9c: 67f8         	str	r0, [r7, #0x7c]
 8010d9e: 6ffb         	ldr	r3, [r7, #0x7c]
 8010da0: 2b00         	cmp	r3, #0x0
 8010da2: d1c4         	bne	0x8010d2e <z_add_timeout+0x102> @ imm = #-0x78
; 		if (t == NULL) {
 8010da4: 6ffb         	ldr	r3, [r7, #0x7c]
 8010da6: 2b00         	cmp	r3, #0x0
 8010da8: d104         	bne	0x8010db4 <z_add_timeout+0x188> @ imm = #0x8
; 			sys_dlist_append(&timeout_list, &to->node);
 8010daa: 6b7b         	ldr	r3, [r7, #0x34]
 8010dac: 4619         	mov	r1, r3
 8010dae: 4819         	ldr	r0, [pc, #0x64]         @ 0x8010e14 <z_add_timeout+0x1e8>
 8010db0: f00c fbf2    	bl	0x801d598 <sys_dlist_append> @ imm = #0xc7e4
; 		if (to == first() && announce_remaining == 0) {
 8010db4: f7ff ff0a    	bl	0x8010bcc <first>       @ imm = #-0x1ec
 8010db8: 4602         	mov	r2, r0
 8010dba: 6b7b         	ldr	r3, [r7, #0x34]
 8010dbc: 4293         	cmp	r3, r2
 8010dbe: d10a         	bne	0x8010dd6 <z_add_timeout+0x1aa> @ imm = #0x14
 8010dc0: 4b15         	ldr	r3, [pc, #0x54]         @ 0x8010e18 <z_add_timeout+0x1ec>
 8010dc2: 681b         	ldr	r3, [r3]
 8010dc4: 2b00         	cmp	r3, #0x0
 8010dc6: d106         	bne	0x8010dd6 <z_add_timeout+0x1aa> @ imm = #0xc
; 			sys_clock_set_timeout(next_timeout(), false);
 8010dc8: f00c fc4f    	bl	0x801d66a <next_timeout> @ imm = #0xc89e
 8010dcc: 4603         	mov	r3, r0
 8010dce: 2100         	movs	r1, #0x0
 8010dd0: 4618         	mov	r0, r3
 8010dd2: f7fb fcdd    	bl	0x800c790 <sys_clock_set_timeout> @ imm = #-0x4646
 8010dd6: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x8010e0c <z_add_timeout+0x1e0>
 8010dd8: 657b         	str	r3, [r7, #0x54]
 8010dda: 6c7b         	ldr	r3, [r7, #0x44]
 8010ddc: 643b         	str	r3, [r7, #0x40]
; 	arch_irq_unlock(key.key);
 8010dde: 6c3b         	ldr	r3, [r7, #0x40]
 8010de0: 653b         	str	r3, [r7, #0x50]
 8010de2: 6d3b         	ldr	r3, [r7, #0x50]
 8010de4: 64fb         	str	r3, [r7, #0x4c]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8010de6: 6cfb         	ldr	r3, [r7, #0x4c]
 8010de8: f383 8811    	msr	basepri, r3
; }
 8010dec: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8010dee: f3bf 8f6f    	isb	sy
; }
 8010df2: bf00         	nop
; }
 8010df4: bf00         	nop
; }
 8010df6: bf00         	nop
; 	K_SPINLOCK(&timeout_lock) {
 8010df8: 2301         	movs	r3, #0x1
 8010dfa: 64bb         	str	r3, [r7, #0x48]
 8010dfc: 6cbb         	ldr	r3, [r7, #0x48]
 8010dfe: 2b00         	cmp	r3, #0x0
 8010e00: f43f af47    	beq.w	0x8010c92 <z_add_timeout+0x66> @ imm = #-0x172
; }
 8010e04: 3780         	adds	r7, #0x80
 8010e06: 46bd         	mov	sp, r7
 8010e08: e8bd 8fb0    	pop.w	{r4, r5, r7, r8, r9, r10, r11, pc}

08010e0c <$d>:
 8010e0c: 80 1f 00 20  	.word	0x20001f80
 8010e10: b8 19 00 20  	.word	0x200019b8
 8010e14: bc 05 00 20  	.word	0x200005bc
 8010e18: 80 1f 00 20  	.word	0x20001f80

08010e1c <z_abort_timeout>:
; {
 8010e1c: b580         	push	{r7, lr}
 8010e1e: b090         	sub	sp, #0x40
 8010e20: af00         	add	r7, sp, #0x0
 8010e22: 6078         	str	r0, [r7, #0x4]
; 	int ret = -EINVAL;
 8010e24: f06f 0315    	mvn	r3, #0x15
 8010e28: 63fb         	str	r3, [r7, #0x3c]
; 	K_SPINLOCK(&timeout_lock) {
 8010e2a: 2300         	movs	r3, #0x0
 8010e2c: 617b         	str	r3, [r7, #0x14]
 8010e2e: 4b21         	ldr	r3, [pc, #0x84]         @ 0x8010eb4 <z_abort_timeout+0x98>
 8010e30: 63bb         	str	r3, [r7, #0x38]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 8010e32: f3ef 8311    	mrs	r3, basepri
 8010e36: 637b         	str	r3, [r7, #0x34]
;   return(result);
 8010e38: 6b7b         	ldr	r3, [r7, #0x34]
; 	key = __get_BASEPRI();
 8010e3a: 633b         	str	r3, [r7, #0x30]
 8010e3c: 2310         	movs	r3, #0x10
 8010e3e: 62fb         	str	r3, [r7, #0x2c]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 8010e40: 6afb         	ldr	r3, [r7, #0x2c]
 8010e42: f383 8812    	msr	basepri_max, r3
; }
 8010e46: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8010e48: f3bf 8f6f    	isb	sy
; }
 8010e4c: bf00         	nop
; 	return key;
 8010e4e: 6b3b         	ldr	r3, [r7, #0x30]
; 	k.key = arch_irq_lock();
 8010e50: 60bb         	str	r3, [r7, #0x8]
 8010e52: 6bbb         	ldr	r3, [r7, #0x38]
 8010e54: 62bb         	str	r3, [r7, #0x28]
; }
 8010e56: bf00         	nop
 8010e58: 6bbb         	ldr	r3, [r7, #0x38]
 8010e5a: 627b         	str	r3, [r7, #0x24]
; }
 8010e5c: bf00         	nop
; 	return k;
 8010e5e: 68bb         	ldr	r3, [r7, #0x8]
 8010e60: 613b         	str	r3, [r7, #0x10]
; 	K_SPINLOCK(&timeout_lock) {
 8010e62: e01e         	b	0x8010ea2 <z_abort_timeout+0x86> @ imm = #0x3c
; 		if (sys_dnode_is_linked(&to->node)) {
 8010e64: 687b         	ldr	r3, [r7, #0x4]
 8010e66: 4618         	mov	r0, r3
 8010e68: f00c fb3d    	bl	0x801d4e6 <sys_dnode_is_linked> @ imm = #0xc67a
 8010e6c: 4603         	mov	r3, r0
 8010e6e: 2b00         	cmp	r3, #0x0
 8010e70: d004         	beq	0x8010e7c <z_abort_timeout+0x60> @ imm = #0x8
; 			remove_timeout(to);
 8010e72: 6878         	ldr	r0, [r7, #0x4]
 8010e74: f00c fbd9    	bl	0x801d62a <remove_timeout> @ imm = #0xc7b2
; 			ret = 0;
 8010e78: 2300         	movs	r3, #0x0
 8010e7a: 63fb         	str	r3, [r7, #0x3c]
 8010e7c: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x8010eb4 <z_abort_timeout+0x98>
 8010e7e: 623b         	str	r3, [r7, #0x20]
 8010e80: 693b         	ldr	r3, [r7, #0x10]
 8010e82: 60fb         	str	r3, [r7, #0xc]
; 	arch_irq_unlock(key.key);
 8010e84: 68fb         	ldr	r3, [r7, #0xc]
 8010e86: 61fb         	str	r3, [r7, #0x1c]
 8010e88: 69fb         	ldr	r3, [r7, #0x1c]
 8010e8a: 61bb         	str	r3, [r7, #0x18]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8010e8c: 69bb         	ldr	r3, [r7, #0x18]
 8010e8e: f383 8811    	msr	basepri, r3
; }
 8010e92: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8010e94: f3bf 8f6f    	isb	sy
; }
 8010e98: bf00         	nop
; }
 8010e9a: bf00         	nop
; }
 8010e9c: bf00         	nop
; 	K_SPINLOCK(&timeout_lock) {
 8010e9e: 2301         	movs	r3, #0x1
 8010ea0: 617b         	str	r3, [r7, #0x14]
 8010ea2: 697b         	ldr	r3, [r7, #0x14]
 8010ea4: 2b00         	cmp	r3, #0x0
 8010ea6: d0dd         	beq	0x8010e64 <z_abort_timeout+0x48> @ imm = #-0x46
; 	return ret;
 8010ea8: 6bfb         	ldr	r3, [r7, #0x3c]
; }
 8010eaa: 4618         	mov	r0, r3
 8010eac: 3740         	adds	r7, #0x40
 8010eae: 46bd         	mov	sp, r7
 8010eb0: bd80         	pop	{r7, pc}
 8010eb2: bf00         	nop

08010eb4 <$d>:
 8010eb4: 80 1f 00 20  	.word	0x20001f80

08010eb8 <sys_clock_announce>:
; {
 8010eb8: e92d 4fb0    	push.w	{r4, r5, r7, r8, r9, r10, r11, lr}
 8010ebc: b0a4         	sub	sp, #0x90
 8010ebe: af00         	add	r7, sp, #0x0
 8010ec0: 6278         	str	r0, [r7, #0x24]
 8010ec2: 4b74         	ldr	r3, [pc, #0x1d0]        @ 0x8011094 <sys_clock_announce+0x1dc>
 8010ec4: f8c7 3084    	str.w	r3, [r7, #0x84]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 8010ec8: f3ef 8311    	mrs	r3, basepri
 8010ecc: f8c7 3080    	str.w	r3, [r7, #0x80]
;   return(result);
 8010ed0: f8d7 3080    	ldr.w	r3, [r7, #0x80]
; 	key = __get_BASEPRI();
 8010ed4: 67fb         	str	r3, [r7, #0x7c]
 8010ed6: 2310         	movs	r3, #0x10
 8010ed8: 67bb         	str	r3, [r7, #0x78]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 8010eda: 6fbb         	ldr	r3, [r7, #0x78]
 8010edc: f383 8812    	msr	basepri_max, r3
; }
 8010ee0: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8010ee2: f3bf 8f6f    	isb	sy
; }
 8010ee6: bf00         	nop
; 	return key;
 8010ee8: 6ffb         	ldr	r3, [r7, #0x7c]
; 	k.key = arch_irq_lock();
 8010eea: 637b         	str	r3, [r7, #0x34]
 8010eec: f8d7 3084    	ldr.w	r3, [r7, #0x84]
 8010ef0: 677b         	str	r3, [r7, #0x74]
; }
 8010ef2: bf00         	nop
 8010ef4: f8d7 3084    	ldr.w	r3, [r7, #0x84]
 8010ef8: 673b         	str	r3, [r7, #0x70]
; }
 8010efa: bf00         	nop
; 	return k;
 8010efc: 6b7b         	ldr	r3, [r7, #0x34]
 8010efe: 63fb         	str	r3, [r7, #0x3c]
; 	announce_remaining = ticks;
 8010f00: 4a65         	ldr	r2, [pc, #0x194]        @ 0x8011098 <sys_clock_announce+0x1e0>
 8010f02: 6a7b         	ldr	r3, [r7, #0x24]
 8010f04: 6013         	str	r3, [r2]
; 	for (t = first();
 8010f06: f7ff fe61    	bl	0x8010bcc <first>       @ imm = #-0x33e
 8010f0a: f8c7 008c    	str.w	r0, [r7, #0x8c]
 8010f0e: e061         	b	0x8010fd4 <sys_clock_announce+0x11c> @ imm = #0xc2
; 		int dt = t->dticks;
 8010f10: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 8010f14: e9d3 2304    	ldrd	r2, r3, [r3, #16]
 8010f18: 4613         	mov	r3, r2
 8010f1a: f8c7 3088    	str.w	r3, [r7, #0x88]
; 		curr_tick += dt;
 8010f1e: f8d7 3088    	ldr.w	r3, [r7, #0x88]
 8010f22: 17da         	asrs	r2, r3, #0x1f
 8010f24: 469a         	mov	r10, r3
 8010f26: 4693         	mov	r11, r2
 8010f28: 4b5c         	ldr	r3, [pc, #0x170]        @ 0x801109c <sys_clock_announce+0x1e4>
 8010f2a: e9d3 2300    	ldrd	r2, r3, [r3]
 8010f2e: eb1a 0102    	adds.w	r1, r10, r2
 8010f32: 61b9         	str	r1, [r7, #0x18]
 8010f34: eb4b 0303    	adc.w	r3, r11, r3
 8010f38: 61fb         	str	r3, [r7, #0x1c]
 8010f3a: 4b58         	ldr	r3, [pc, #0x160]        @ 0x801109c <sys_clock_announce+0x1e4>
 8010f3c: e9d7 1206    	ldrd	r1, r2, [r7, #24]
 8010f40: e9c3 1200    	strd	r1, r2, [r3]
; 		t->dticks = 0;
 8010f44: f8d7 108c    	ldr.w	r1, [r7, #0x8c]
 8010f48: f04f 0200    	mov.w	r2, #0x0
 8010f4c: f04f 0300    	mov.w	r3, #0x0
 8010f50: e9c1 2304    	strd	r2, r3, [r1, #16]
; 		remove_timeout(t);
 8010f54: f8d7 008c    	ldr.w	r0, [r7, #0x8c]
 8010f58: f00c fb67    	bl	0x801d62a <remove_timeout> @ imm = #0xc6ce
 8010f5c: 4b4d         	ldr	r3, [pc, #0x134]        @ 0x8011094 <sys_clock_announce+0x1dc>
 8010f5e: 657b         	str	r3, [r7, #0x54]
 8010f60: 6bfb         	ldr	r3, [r7, #0x3c]
 8010f62: 633b         	str	r3, [r7, #0x30]
; 	arch_irq_unlock(key.key);
 8010f64: 6b3b         	ldr	r3, [r7, #0x30]
 8010f66: 653b         	str	r3, [r7, #0x50]
 8010f68: 6d3b         	ldr	r3, [r7, #0x50]
 8010f6a: 64fb         	str	r3, [r7, #0x4c]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8010f6c: 6cfb         	ldr	r3, [r7, #0x4c]
 8010f6e: f383 8811    	msr	basepri, r3
; }
 8010f72: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8010f74: f3bf 8f6f    	isb	sy
; }
 8010f78: bf00         	nop
; }
 8010f7a: bf00         	nop
; }
 8010f7c: bf00         	nop
; 		t->fn(t);
 8010f7e: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 8010f82: 689b         	ldr	r3, [r3, #0x8]
 8010f84: f8d7 008c    	ldr.w	r0, [r7, #0x8c]
 8010f88: 4798         	blx	r3
 8010f8a: 4b42         	ldr	r3, [pc, #0x108]        @ 0x8011094 <sys_clock_announce+0x1dc>
 8010f8c: 66fb         	str	r3, [r7, #0x6c]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 8010f8e: f3ef 8311    	mrs	r3, basepri
 8010f92: 66bb         	str	r3, [r7, #0x68]
;   return(result);
 8010f94: 6ebb         	ldr	r3, [r7, #0x68]
; 	key = __get_BASEPRI();
 8010f96: 667b         	str	r3, [r7, #0x64]
 8010f98: 2310         	movs	r3, #0x10
 8010f9a: 663b         	str	r3, [r7, #0x60]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 8010f9c: 6e3b         	ldr	r3, [r7, #0x60]
 8010f9e: f383 8812    	msr	basepri_max, r3
; }
 8010fa2: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8010fa4: f3bf 8f6f    	isb	sy
; }
 8010fa8: bf00         	nop
; 	return key;
 8010faa: 6e7b         	ldr	r3, [r7, #0x64]
; 	k.key = arch_irq_lock();
 8010fac: 62fb         	str	r3, [r7, #0x2c]
 8010fae: 6efb         	ldr	r3, [r7, #0x6c]
 8010fb0: 65fb         	str	r3, [r7, #0x5c]
; }
 8010fb2: bf00         	nop
 8010fb4: 6efb         	ldr	r3, [r7, #0x6c]
 8010fb6: 65bb         	str	r3, [r7, #0x58]
; }
 8010fb8: bf00         	nop
; 	return k;
 8010fba: 6afb         	ldr	r3, [r7, #0x2c]
 8010fbc: 63fb         	str	r3, [r7, #0x3c]
; 		announce_remaining -= dt;
 8010fbe: 4b36         	ldr	r3, [pc, #0xd8]         @ 0x8011098 <sys_clock_announce+0x1e0>
 8010fc0: 681a         	ldr	r2, [r3]
 8010fc2: f8d7 3088    	ldr.w	r3, [r7, #0x88]
 8010fc6: 1ad2         	subs	r2, r2, r3
 8010fc8: 4b33         	ldr	r3, [pc, #0xcc]         @ 0x8011098 <sys_clock_announce+0x1e0>
 8010fca: 601a         	str	r2, [r3]
; 	     t = first()) {
 8010fcc: f7ff fdfe    	bl	0x8010bcc <first>       @ imm = #-0x404
 8010fd0: f8c7 008c    	str.w	r0, [r7, #0x8c]
; 	     (t != NULL) && (t->dticks <= announce_remaining);
 8010fd4: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 8010fd8: 2b00         	cmp	r3, #0x0
 8010fda: d00e         	beq	0x8010ffa <sys_clock_announce+0x142> @ imm = #0x1c
 8010fdc: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 8010fe0: e9d3 0104    	ldrd	r0, r1, [r3, #16]
 8010fe4: 4b2c         	ldr	r3, [pc, #0xb0]         @ 0x8011098 <sys_clock_announce+0x1e0>
 8010fe6: 681b         	ldr	r3, [r3]
 8010fe8: 17da         	asrs	r2, r3, #0x1f
 8010fea: 613b         	str	r3, [r7, #0x10]
 8010fec: 617a         	str	r2, [r7, #0x14]
 8010fee: e9d7 2304    	ldrd	r2, r3, [r7, #16]
 8010ff2: 4694         	mov	r12, r2
 8010ff4: 4584         	cmp	r12, r0
 8010ff6: 418b         	sbcs	r3, r1
 8010ff8: da8a         	bge	0x8010f10 <sys_clock_announce+0x58> @ imm = #-0xec
; 	if (t != NULL) {
 8010ffa: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 8010ffe: 2b00         	cmp	r3, #0x0
 8011000: d014         	beq	0x801102c <sys_clock_announce+0x174> @ imm = #0x28
; 		t->dticks -= announce_remaining;
 8011002: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 8011006: e9d3 2304    	ldrd	r2, r3, [r3, #16]
 801100a: 4923         	ldr	r1, [pc, #0x8c]         @ 0x8011098 <sys_clock_announce+0x1e0>
 801100c: 6809         	ldr	r1, [r1]
 801100e: 17c8         	asrs	r0, r1, #0x1f
 8011010: 4688         	mov	r8, r1
 8011012: 4681         	mov	r9, r0
 8011014: ebb2 0108    	subs.w	r1, r2, r8
 8011018: 60b9         	str	r1, [r7, #0x8]
 801101a: eb63 0309    	sbc.w	r3, r3, r9
 801101e: 60fb         	str	r3, [r7, #0xc]
 8011020: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 8011024: e9d7 1202    	ldrd	r1, r2, [r7, #8]
 8011028: e9c3 1204    	strd	r1, r2, [r3, #16]
; 	curr_tick += announce_remaining;
 801102c: 4b1a         	ldr	r3, [pc, #0x68]         @ 0x8011098 <sys_clock_announce+0x1e0>
 801102e: 681b         	ldr	r3, [r3]
 8011030: 17da         	asrs	r2, r3, #0x1f
 8011032: 461c         	mov	r4, r3
 8011034: 4615         	mov	r5, r2
 8011036: 4b19         	ldr	r3, [pc, #0x64]         @ 0x801109c <sys_clock_announce+0x1e4>
 8011038: e9d3 2300    	ldrd	r2, r3, [r3]
 801103c: 18a1         	adds	r1, r4, r2
 801103e: 6039         	str	r1, [r7]
 8011040: eb45 0303    	adc.w	r3, r5, r3
 8011044: 607b         	str	r3, [r7, #0x4]
 8011046: 4b15         	ldr	r3, [pc, #0x54]         @ 0x801109c <sys_clock_announce+0x1e4>
 8011048: e9d7 1200    	ldrd	r1, r2, [r7]
 801104c: e9c3 1200    	strd	r1, r2, [r3]
; 	announce_remaining = 0;
 8011050: 4b11         	ldr	r3, [pc, #0x44]         @ 0x8011098 <sys_clock_announce+0x1e0>
 8011052: 2200         	movs	r2, #0x0
 8011054: 601a         	str	r2, [r3]
; 	sys_clock_set_timeout(next_timeout(), false);
 8011056: f00c fb08    	bl	0x801d66a <next_timeout> @ imm = #0xc610
 801105a: 4603         	mov	r3, r0
 801105c: 2100         	movs	r1, #0x0
 801105e: 4618         	mov	r0, r3
 8011060: f7fb fb96    	bl	0x800c790 <sys_clock_set_timeout> @ imm = #-0x48d4
 8011064: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x8011094 <sys_clock_announce+0x1dc>
 8011066: 64bb         	str	r3, [r7, #0x48]
 8011068: 6bfb         	ldr	r3, [r7, #0x3c]
 801106a: 63bb         	str	r3, [r7, #0x38]
; 	arch_irq_unlock(key.key);
 801106c: 6bbb         	ldr	r3, [r7, #0x38]
 801106e: 647b         	str	r3, [r7, #0x44]
 8011070: 6c7b         	ldr	r3, [r7, #0x44]
 8011072: 643b         	str	r3, [r7, #0x40]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8011074: 6c3b         	ldr	r3, [r7, #0x40]
 8011076: f383 8811    	msr	basepri, r3
; }
 801107a: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 801107c: f3bf 8f6f    	isb	sy
; }
 8011080: bf00         	nop
; }
 8011082: bf00         	nop
; }
 8011084: bf00         	nop
; 	z_time_slice();
 8011086: f7ff fcad    	bl	0x80109e4 <z_time_slice> @ imm = #-0x6a6
; }
 801108a: 3790         	adds	r7, #0x90
 801108c: 46bd         	mov	sp, r7
 801108e: e8bd 8fb0    	pop.w	{r4, r5, r7, r8, r9, r10, r11, pc}
 8011092: bf00         	nop

08011094 <$d>:
 8011094: 80 1f 00 20  	.word	0x20001f80
 8011098: 80 1f 00 20  	.word	0x20001f80
 801109c: b8 19 00 20  	.word	0x200019b8

080110a0 <sys_clock_tick_get>:
; {
 80110a0: e92d 43b0    	push.w	{r4, r5, r7, r8, r9, lr}
 80110a4: b090         	sub	sp, #0x40
 80110a6: af00         	add	r7, sp, #0x0
; 	uint64_t t = 0U;
 80110a8: f04f 0200    	mov.w	r2, #0x0
 80110ac: f04f 0300    	mov.w	r3, #0x0
 80110b0: e9c7 230e    	strd	r2, r3, [r7, #56]
; 	K_SPINLOCK(&timeout_lock) {
 80110b4: 2300         	movs	r3, #0x0
 80110b6: 613b         	str	r3, [r7, #0x10]
 80110b8: 4b23         	ldr	r3, [pc, #0x8c]         @ 0x8011148 <sys_clock_tick_get+0xa8>
 80110ba: 637b         	str	r3, [r7, #0x34]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 80110bc: f3ef 8311    	mrs	r3, basepri
 80110c0: 633b         	str	r3, [r7, #0x30]
;   return(result);
 80110c2: 6b3b         	ldr	r3, [r7, #0x30]
; 	key = __get_BASEPRI();
 80110c4: 62fb         	str	r3, [r7, #0x2c]
 80110c6: 2310         	movs	r3, #0x10
 80110c8: 62bb         	str	r3, [r7, #0x28]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 80110ca: 6abb         	ldr	r3, [r7, #0x28]
 80110cc: f383 8812    	msr	basepri_max, r3
; }
 80110d0: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 80110d2: f3bf 8f6f    	isb	sy
; }
 80110d6: bf00         	nop
; 	return key;
 80110d8: 6afb         	ldr	r3, [r7, #0x2c]
; 	k.key = arch_irq_lock();
 80110da: 607b         	str	r3, [r7, #0x4]
 80110dc: 6b7b         	ldr	r3, [r7, #0x34]
 80110de: 627b         	str	r3, [r7, #0x24]
; }
 80110e0: bf00         	nop
 80110e2: 6b7b         	ldr	r3, [r7, #0x34]
 80110e4: 623b         	str	r3, [r7, #0x20]
; }
 80110e6: bf00         	nop
; 	return k;
 80110e8: 687b         	ldr	r3, [r7, #0x4]
 80110ea: 60fb         	str	r3, [r7, #0xc]
; 	K_SPINLOCK(&timeout_lock) {
 80110ec: e021         	b	0x8011132 <sys_clock_tick_get+0x92> @ imm = #0x42
; 		t = curr_tick + elapsed();
 80110ee: f7ff fd8d    	bl	0x8010c0c <elapsed>     @ imm = #-0x4e6
 80110f2: 4603         	mov	r3, r0
 80110f4: 17da         	asrs	r2, r3, #0x1f
 80110f6: 461c         	mov	r4, r3
 80110f8: 4615         	mov	r5, r2
 80110fa: 4b14         	ldr	r3, [pc, #0x50]         @ 0x801114c <sys_clock_tick_get+0xac>
 80110fc: e9d3 2300    	ldrd	r2, r3, [r3]
 8011100: eb14 0802    	adds.w	r8, r4, r2
 8011104: eb45 0903    	adc.w	r9, r5, r3
 8011108: e9c7 890e    	strd	r8, r9, [r7, #56]
 801110c: 4b0e         	ldr	r3, [pc, #0x38]         @ 0x8011148 <sys_clock_tick_get+0xa8>
 801110e: 61fb         	str	r3, [r7, #0x1c]
 8011110: 68fb         	ldr	r3, [r7, #0xc]
 8011112: 60bb         	str	r3, [r7, #0x8]
; 	arch_irq_unlock(key.key);
 8011114: 68bb         	ldr	r3, [r7, #0x8]
 8011116: 61bb         	str	r3, [r7, #0x18]
 8011118: 69bb         	ldr	r3, [r7, #0x18]
 801111a: 617b         	str	r3, [r7, #0x14]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 801111c: 697b         	ldr	r3, [r7, #0x14]
 801111e: f383 8811    	msr	basepri, r3
; }
 8011122: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8011124: f3bf 8f6f    	isb	sy
; }
 8011128: bf00         	nop
; }
 801112a: bf00         	nop
; }
 801112c: bf00         	nop
; 	K_SPINLOCK(&timeout_lock) {
 801112e: 2301         	movs	r3, #0x1
 8011130: 613b         	str	r3, [r7, #0x10]
 8011132: 693b         	ldr	r3, [r7, #0x10]
 8011134: 2b00         	cmp	r3, #0x0
 8011136: d0da         	beq	0x80110ee <sys_clock_tick_get+0x4e> @ imm = #-0x4c
; 	return t;
 8011138: e9d7 230e    	ldrd	r2, r3, [r7, #56]
; }
 801113c: 4610         	mov	r0, r2
 801113e: 4619         	mov	r1, r3
 8011140: 3740         	adds	r7, #0x40
 8011142: 46bd         	mov	sp, r7
 8011144: e8bd 83b0    	pop.w	{r4, r5, r7, r8, r9, pc}

08011148 <$d>:
 8011148: 80 1f 00 20  	.word	0x20001f80
 801114c: b8 19 00 20  	.word	0x200019b8

08011150 <z_sched_usage_start>:
; {
 8011150: b580         	push	{r7, lr}
 8011152: b082         	sub	sp, #0x8
 8011154: af00         	add	r7, sp, #0x0
 8011156: 6078         	str	r0, [r7, #0x4]
; 	_current_cpu->usage0 = usage_now();
 8011158: f00c fae5    	bl	0x801d726 <usage_now>   @ imm = #0xc5ca
 801115c: 4603         	mov	r3, r0
 801115e: 4a03         	ldr	r2, [pc, #0xc]          @ 0x801116c <z_sched_usage_start+0x1c>
 8011160: 6153         	str	r3, [r2, #0x14]
; }
 8011162: bf00         	nop
 8011164: 3708         	adds	r7, #0x8
 8011166: 46bd         	mov	sp, r7
 8011168: bd80         	pop	{r7, pc}
 801116a: bf00         	nop

0801116c <$d>:
 801116c: f0 16 00 20  	.word	0x200016f0

08011170 <z_sched_usage_stop>:
; {
 8011170: b580         	push	{r7, lr}
 8011172: b090         	sub	sp, #0x40
 8011174: af00         	add	r7, sp, #0x0
 8011176: 4b28         	ldr	r3, [pc, #0xa0]         @ 0x8011218 <z_sched_usage_stop+0xa8>
 8011178: 633b         	str	r3, [r7, #0x30]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 801117a: f3ef 8311    	mrs	r3, basepri
 801117e: 62fb         	str	r3, [r7, #0x2c]
;   return(result);
 8011180: 6afb         	ldr	r3, [r7, #0x2c]
; 	key = __get_BASEPRI();
 8011182: 62bb         	str	r3, [r7, #0x28]
 8011184: 2310         	movs	r3, #0x10
 8011186: 627b         	str	r3, [r7, #0x24]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 8011188: 6a7b         	ldr	r3, [r7, #0x24]
 801118a: f383 8812    	msr	basepri_max, r3
; }
 801118e: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8011190: f3bf 8f6f    	isb	sy
; }
 8011194: bf00         	nop
; 	return key;
 8011196: 6abb         	ldr	r3, [r7, #0x28]
; 	k.key = arch_irq_lock();
 8011198: 607b         	str	r3, [r7, #0x4]
 801119a: 6b3b         	ldr	r3, [r7, #0x30]
 801119c: 623b         	str	r3, [r7, #0x20]
; }
 801119e: bf00         	nop
 80111a0: 6b3b         	ldr	r3, [r7, #0x30]
 80111a2: 61fb         	str	r3, [r7, #0x1c]
; }
 80111a4: bf00         	nop
; 	return k;
 80111a6: 687b         	ldr	r3, [r7, #0x4]
 80111a8: 60fb         	str	r3, [r7, #0xc]
; 	struct _cpu     *cpu = _current_cpu;
 80111aa: 4b1c         	ldr	r3, [pc, #0x70]         @ 0x801121c <z_sched_usage_stop+0xac>
 80111ac: 63fb         	str	r3, [r7, #0x3c]
; 	uint32_t u0 = cpu->usage0;
 80111ae: 6bfb         	ldr	r3, [r7, #0x3c]
 80111b0: 695b         	ldr	r3, [r3, #0x14]
 80111b2: 63bb         	str	r3, [r7, #0x38]
; 	if (u0 != 0) {
 80111b4: 6bbb         	ldr	r3, [r7, #0x38]
 80111b6: 2b00         	cmp	r3, #0x0
 80111b8: d015         	beq	0x80111e6 <z_sched_usage_stop+0x76> @ imm = #0x2a
; 		uint32_t cycles = usage_now() - u0;
 80111ba: f00c fab4    	bl	0x801d726 <usage_now>   @ imm = #0xc568
 80111be: 4602         	mov	r2, r0
 80111c0: 6bbb         	ldr	r3, [r7, #0x38]
 80111c2: 1ad3         	subs	r3, r2, r3
 80111c4: 637b         	str	r3, [r7, #0x34]
; 		if (cpu->current->base.usage.track_usage) {
 80111c6: 6bfb         	ldr	r3, [r7, #0x3c]
 80111c8: 689b         	ldr	r3, [r3, #0x8]
 80111ca: f893 3038    	ldrb.w	r3, [r3, #0x38]
 80111ce: 2b00         	cmp	r3, #0x0
 80111d0: d005         	beq	0x80111de <z_sched_usage_stop+0x6e> @ imm = #0xa
; 			sched_thread_update_usage(cpu->current, cycles);
 80111d2: 6bfb         	ldr	r3, [r7, #0x3c]
 80111d4: 689b         	ldr	r3, [r3, #0x8]
 80111d6: 6b79         	ldr	r1, [r7, #0x34]
 80111d8: 4618         	mov	r0, r3
 80111da: f00c fadf    	bl	0x801d79c <sched_thread_update_usage> @ imm = #0xc5be
; 		sched_cpu_update_usage(cpu, cycles);
 80111de: 6b79         	ldr	r1, [r7, #0x34]
 80111e0: 6bf8         	ldr	r0, [r7, #0x3c]
 80111e2: f00c fab0    	bl	0x801d746 <sched_cpu_update_usage> @ imm = #0xc560
; 	cpu->usage0 = 0;
 80111e6: 6bfb         	ldr	r3, [r7, #0x3c]
 80111e8: 2200         	movs	r2, #0x0
 80111ea: 615a         	str	r2, [r3, #0x14]
 80111ec: 4b0a         	ldr	r3, [pc, #0x28]         @ 0x8011218 <z_sched_usage_stop+0xa8>
 80111ee: 61bb         	str	r3, [r7, #0x18]
 80111f0: 68fb         	ldr	r3, [r7, #0xc]
 80111f2: 60bb         	str	r3, [r7, #0x8]
; 	arch_irq_unlock(key.key);
 80111f4: 68bb         	ldr	r3, [r7, #0x8]
 80111f6: 617b         	str	r3, [r7, #0x14]
 80111f8: 697b         	ldr	r3, [r7, #0x14]
 80111fa: 613b         	str	r3, [r7, #0x10]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80111fc: 693b         	ldr	r3, [r7, #0x10]
 80111fe: f383 8811    	msr	basepri, r3
; }
 8011202: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8011204: f3bf 8f6f    	isb	sy
; }
 8011208: bf00         	nop
; }
 801120a: bf00         	nop
; }
 801120c: bf00         	nop
; }
 801120e: bf00         	nop
 8011210: 3740         	adds	r7, #0x40
 8011212: 46bd         	mov	sp, r7
 8011214: bd80         	pop	{r7, pc}
 8011216: bf00         	nop

08011218 <$d>:
 8011218: 84 1f 00 20  	.word	0x20001f84
 801121c: f0 16 00 20  	.word	0x200016f0

08011220 <boot_banner>:
; {
 8011220: b580         	push	{r7, lr}
 8011222: af00         	add	r7, sp, #0x0
; 	printk("*** " CONFIG_BOOT_BANNER_STRING " " BANNER_VERSION BANNER_POSTFIX " ***\n");
 8011224: 4802         	ldr	r0, [pc, #0x8]          @ 0x8011230 <boot_banner+0x10>
 8011226: f003 fcf9    	bl	0x8014c1c <printk>      @ imm = #0x39f2
; }
 801122a: bf00         	nop
 801122c: bd80         	pop	{r7, pc}
 801122e: bf00         	nop

08011230 <$d>:
 8011230: 6c fb 01 08  	.word	0x0801fb6c

08011234 <k_sys_work_q_init>:
; {
 8011234: b580         	push	{r7, lr}
 8011236: b084         	sub	sp, #0x10
 8011238: af02         	add	r7, sp, #0x8
; 	struct k_work_queue_config cfg = {
 801123a: 4a0a         	ldr	r2, [pc, #0x28]         @ 0x8011264 <k_sys_work_q_init+0x30>
 801123c: 463b         	mov	r3, r7
 801123e: e892 0003    	ldm.w	r2, {r0, r1}
 8011242: e883 0003    	stm.w	r3, {r0, r1}
; 	k_work_queue_start(&k_sys_work_q,
 8011246: 463b         	mov	r3, r7
 8011248: 9300         	str	r3, [sp]
 801124a: f04f 33ff    	mov.w	r3, #0xffffffff
 801124e: f44f 6280    	mov.w	r2, #0x400
 8011252: 4905         	ldr	r1, [pc, #0x14]         @ 0x8011268 <k_sys_work_q_init+0x34>
 8011254: 4805         	ldr	r0, [pc, #0x14]         @ 0x801126c <k_sys_work_q_init+0x38>
 8011256: f7fd fb9b    	bl	0x800e990 <k_work_queue_start> @ imm = #-0x28ca
; 	return 0;
 801125a: 2300         	movs	r3, #0x0
; }
 801125c: 4618         	mov	r0, r3
 801125e: 3708         	adds	r7, #0x8
 8011260: 46bd         	mov	sp, r7
 8011262: bd80         	pop	{r7, pc}

08011264 <$d>:
 8011264: b4 fb 01 08  	.word	0x0801fbb4
 8011268: d0 3f 00 20  	.word	0x20003fd0
 801126c: c0 19 00 20  	.word	0x200019c0

08011270 <skip_to_arg>:
 8011270: e92d 41f0    	push.w	{r4, r5, r6, r7, r8, lr}
 8011274: 2601         	movs	r6, #0x1
 8011276: 4607         	mov	r7, r0
 8011278: 42b2         	cmp	r2, r6
 801127a: dc01         	bgt	0x8011280 <skip_to_arg+0x10> @ imm = #0x2
 801127c: e8bd 81f0    	pop.w	{r4, r5, r6, r7, r8, pc}
 8011280: 463b         	mov	r3, r7
 8011282: 461f         	mov	r7, r3
 8011284: f813 4b01    	ldrb	r4, [r3], #1
 8011288: 2c00         	cmp	r4, #0x0
 801128a: d0f7         	beq	0x801127c <skip_to_arg+0xc> @ imm = #-0x12
 801128c: 2c25         	cmp	r4, #0x25
 801128e: d1f8         	bne	0x8011282 <skip_to_arg+0x12> @ imm = #-0x10
 8011290: 781c         	ldrb	r4, [r3]
 8011292: 2c25         	cmp	r4, #0x25
 8011294: f107 0702    	add.w	r7, r7, #0x2
 8011298: d0f2         	beq	0x8011280 <skip_to_arg+0x10> @ imm = #-0x1c
 801129a: 2300         	movs	r3, #0x0
 801129c: f8df 8104    	ldr.w	r8, [pc, #0x104]        @ 0x80113a4 <skip_to_arg+0x134>
 80112a0: 469c         	mov	r12, r3
 80112a2: 461d         	mov	r5, r3
 80112a4: 2d1f         	cmp	r5, #0x1f
 80112a6: d818         	bhi	0x80112da <skip_to_arg+0x6a> @ imm = #0x30
 80112a8: f1a4 0e20    	sub.w	lr, r4, #0x20
 80112ac: f1be 0f10    	cmp.w	lr, #0x10
 80112b0: d909         	bls	0x80112c6 <skip_to_arg+0x56> @ imm = #0x12
 80112b2: f1a4 0e30    	sub.w	lr, r4, #0x30
 80112b6: f1be 0f09    	cmp.w	lr, #0x9
 80112ba: d81e         	bhi	0x80112fa <skip_to_arg+0x8a> @ imm = #0x3c
 80112bc: 240a         	movs	r4, #0xa
 80112be: fb04 e303    	mla	r3, r4, r3, lr
 80112c2: 2520         	movs	r5, #0x20
 80112c4: e004         	b	0x80112d0 <skip_to_arg+0x60> @ imm = #0x8
 80112c6: fa28 fe0e    	lsr.w	lr, r8, lr
 80112ca: f01e 0f01    	tst.w	lr, #0x1
 80112ce: d006         	beq	0x80112de <skip_to_arg+0x6e> @ imm = #0xc
 80112d0: f817 4b01    	ldrb	r4, [r7], #1
 80112d4: 2c00         	cmp	r4, #0x0
 80112d6: d1e5         	bne	0x80112a4 <skip_to_arg+0x34> @ imm = #-0x36
 80112d8: e028         	b	0x801132c <skip_to_arg+0xbc> @ imm = #0x50
 80112da: 2d7f         	cmp	r5, #0x7f
 80112dc: d81c         	bhi	0x8011318 <skip_to_arg+0xa8> @ imm = #0x38
 80112de: f1a4 0e30    	sub.w	lr, r4, #0x30
 80112e2: f1be 0f09    	cmp.w	lr, #0x9
 80112e6: d9e9         	bls	0x80112bc <skip_to_arg+0x4c> @ imm = #-0x2e
 80112e8: 2c24         	cmp	r4, #0x24
 80112ea: d110         	bne	0x801130e <skip_to_arg+0x9e> @ imm = #0x20
 80112ec: f1bc 0f00    	cmp.w	r12, #0x0
 80112f0: d046         	beq	0x8011380 <skip_to_arg+0x110> @ imm = #0x8c
 80112f2: 42b3         	cmp	r3, r6
 80112f4: d046         	beq	0x8011384 <skip_to_arg+0x114> @ imm = #0x8c
 80112f6: 2300         	movs	r3, #0x0
 80112f8: e7ea         	b	0x80112d0 <skip_to_arg+0x60> @ imm = #-0x2c
 80112fa: f024 0e04    	bic	lr, r4, #0x4
 80112fe: f1be 0f2a    	cmp.w	lr, #0x2a
 8011302: d0f8         	beq	0x80112f6 <skip_to_arg+0x86> @ imm = #-0x10
 8011304: 2c6c         	cmp	r4, #0x6c
 8011306: d109         	bne	0x801131c <skip_to_arg+0xac> @ imm = #0x12
 8011308: f045 0580    	orr	r5, r5, #0x80
 801130c: e7e0         	b	0x80112d0 <skip_to_arg+0x60> @ imm = #-0x40
 801130e: f024 0e04    	bic	lr, r4, #0x4
 8011312: f1be 0f2a    	cmp.w	lr, #0x2a
 8011316: d0ee         	beq	0x80112f6 <skip_to_arg+0x86> @ imm = #-0x24
 8011318: 2c6c         	cmp	r4, #0x6c
 801131a: d022         	beq	0x8011362 <skip_to_arg+0xf2> @ imm = #0x44
 801131c: 2c6c         	cmp	r4, #0x6c
 801131e: d81b         	bhi	0x8011358 <skip_to_arg+0xe8> @ imm = #0x36
 8011320: 2c68         	cmp	r4, #0x68
 8011322: d023         	beq	0x801136c <skip_to_arg+0xfc> @ imm = #0x46
 8011324: 2c6a         	cmp	r4, #0x6a
 8011326: d028         	beq	0x801137a <skip_to_arg+0x10a> @ imm = #0x50
 8011328: 2c4c         	cmp	r4, #0x4c
 801132a: d026         	beq	0x801137a <skip_to_arg+0x10a> @ imm = #0x4c
 801132c: f1bc 0f00    	cmp.w	r12, #0x0
 8011330: d0a4         	beq	0x801127c <skip_to_arg+0xc> @ imm = #-0xb8
 8011332: 45b4         	cmp	r12, r6
 8011334: d1a0         	bne	0x8011278 <skip_to_arg+0x8> @ imm = #-0xc0
 8011336: f044 0720    	orr	r7, r4, #0x20
 801133a: f1a7 0c65    	sub.w	r12, r7, #0x65
 801133e: f1bc 0f02    	cmp.w	r12, #0x2
 8011342: 680b         	ldr	r3, [r1]
 8011344: d901         	bls	0x801134a <skip_to_arg+0xda> @ imm = #0x2
 8011346: 2f61         	cmp	r7, #0x61
 8011348: d11e         	bne	0x8011388 <skip_to_arg+0x118> @ imm = #0x3c
 801134a: 3307         	adds	r3, #0x7
 801134c: f023 0307    	bic	r3, r3, #0x7
 8011350: 3308         	adds	r3, #0x8
 8011352: 600b         	str	r3, [r1]
 8011354: 3601         	adds	r6, #0x1
 8011356: e78e         	b	0x8011276 <skip_to_arg+0x6> @ imm = #-0xe4
 8011358: 2c74         	cmp	r4, #0x74
 801135a: d0b9         	beq	0x80112d0 <skip_to_arg+0x60> @ imm = #-0x8e
 801135c: 2c7a         	cmp	r4, #0x7a
 801135e: d0b7         	beq	0x80112d0 <skip_to_arg+0x60> @ imm = #-0x92
 8011360: e7e4         	b	0x801132c <skip_to_arg+0xbc> @ imm = #-0x38
 8011362: 062c         	lsls	r4, r5, #0x18
 8011364: bf48         	it	mi
 8011366: f445 7500    	orrmi	r5, r5, #0x200
 801136a: e7cd         	b	0x8011308 <skip_to_arg+0x98> @ imm = #-0x66
 801136c: 05ec         	lsls	r4, r5, #0x17
 801136e: bf48         	it	mi
 8011370: f445 7500    	orrmi	r5, r5, #0x200
 8011374: f445 7580    	orr	r5, r5, #0x100
 8011378: e7aa         	b	0x80112d0 <skip_to_arg+0x60> @ imm = #-0xac
 801137a: f445 7520    	orr	r5, r5, #0x280
 801137e: e7a7         	b	0x80112d0 <skip_to_arg+0x60> @ imm = #-0xb2
 8011380: 469c         	mov	r12, r3
 8011382: e7b8         	b	0x80112f6 <skip_to_arg+0x86> @ imm = #-0x90
 8011384: 2463         	movs	r4, #0x63
 8011386: e7d6         	b	0x8011336 <skip_to_arg+0xc6> @ imm = #-0x54
 8011388: 2c69         	cmp	r4, #0x69
 801138a: d002         	beq	0x8011392 <skip_to_arg+0x122> @ imm = #0x4
 801138c: d807         	bhi	0x801139e <skip_to_arg+0x12e> @ imm = #0xe
 801138e: 2c63         	cmp	r4, #0x63
 8011390: d003         	beq	0x801139a <skip_to_arg+0x12a> @ imm = #0x6
 8011392: 062f         	lsls	r7, r5, #0x18
 8011394: d501         	bpl	0x801139a <skip_to_arg+0x12a> @ imm = #0x2
 8011396: 05ac         	lsls	r4, r5, #0x16
 8011398: d4d7         	bmi	0x801134a <skip_to_arg+0xda> @ imm = #-0x52
 801139a: 3304         	adds	r3, #0x4
 801139c: e7d9         	b	0x8011352 <skip_to_arg+0xe2> @ imm = #-0x4e
 801139e: 2c73         	cmp	r4, #0x73
 80113a0: e7f6         	b	0x8011390 <skip_to_arg+0x120> @ imm = #-0x14
 80113a2: bf00         	nop

080113a4 <$d>:
 80113a4: 89 28 01 00  	.word	0x00012889

080113a8 <vfprintf>:
 80113a8: e92d 4ff0    	push.w	{r4, r5, r6, r7, r8, r9, r10, r11, lr}
 80113ac: b095         	sub	sp, #0x54
 80113ae: 6843         	ldr	r3, [r0, #0x4]
 80113b0: 9303         	str	r3, [sp, #0xc]
 80113b2: 7883         	ldrb	r3, [r0, #0x2]
 80113b4: 4680         	mov	r8, r0
 80113b6: 0798         	lsls	r0, r3, #0x1e
 80113b8: e9cd 1208    	strd	r1, r2, [sp, #32]
 80113bc: d517         	bpl	0x80113ee <vfprintf+0x46> @ imm = #0x2e
 80113be: 920d         	str	r2, [sp, #0x34]
 80113c0: 460b         	mov	r3, r1
 80113c2: 2500         	movs	r5, #0x0
 80113c4: 781f         	ldrb	r7, [r3]
 80113c6: b1a7         	cbz	r7, 0x80113f2 <vfprintf+0x4a> @ imm = #0x28
 80113c8: 2f25         	cmp	r7, #0x25
 80113ca: d016         	beq	0x80113fa <vfprintf+0x52> @ imm = #0x2c
 80113cc: 3301         	adds	r3, #0x1
 80113ce: 9307         	str	r3, [sp, #0x1c]
 80113d0: 9b03         	ldr	r3, [sp, #0xc]
 80113d2: 4641         	mov	r1, r8
 80113d4: 4638         	mov	r0, r7
 80113d6: 4798         	blx	r3
 80113d8: 2800         	cmp	r0, #0x0
 80113da: f105 0501    	add.w	r5, r5, #0x1
 80113de: f280 8439    	bge.w	0x8011c54 <vfprintf+0x8ac> @ imm = #0x872
 80113e2: f898 3002    	ldrb.w	r3, [r8, #0x2]
 80113e6: f043 0304    	orr	r3, r3, #0x4
 80113ea: f888 3002    	strb.w	r3, [r8, #0x2]
 80113ee: f04f 35ff    	mov.w	r5, #0xffffffff
 80113f2: 4628         	mov	r0, r5
 80113f4: b015         	add	sp, #0x54
 80113f6: e8bd 8ff0    	pop.w	{r4, r5, r6, r7, r8, r9, r10, r11, pc}
 80113fa: 785f         	ldrb	r7, [r3, #0x1]
 80113fc: 1c9a         	adds	r2, r3, #0x2
 80113fe: 2f25         	cmp	r7, #0x25
 8011400: 9207         	str	r2, [sp, #0x1c]
 8011402: d0e5         	beq	0x80113d0 <vfprintf+0x28> @ imm = #-0x36
 8011404: 2400         	movs	r4, #0x0
 8011406: 4626         	mov	r6, r4
 8011408: 46a2         	mov	r10, r4
 801140a: 46a3         	mov	r11, r4
 801140c: f1bb 0f1f    	cmp.w	r11, #0x1f
 8011410: d832         	bhi	0x8011478 <vfprintf+0xd0> @ imm = #0x64
 8011412: f1a7 0320    	sub.w	r3, r7, #0x20
 8011416: 2b10         	cmp	r3, #0x10
 8011418: d80a         	bhi	0x8011430 <vfprintf+0x88> @ imm = #0x14
 801141a: e8df f003    	tbb	[pc, r3]

0801141e <$d>:
 801141e: 24 09 09 2a  	.word	0x2a090924
 8011422: 09 09 09 1b  	.word	0x1b090909
 8011426: 09 09 09 22  	.word	0x22090909
 801142a: 09 27 09 09  	.word	0x09092709
 801142e: 19           	.byte	0x19

0801142f <$d>:
 801142f: 00           	.byte	0x00

08011430 <$t>:
 8011430: f1a7 0330    	sub.w	r3, r7, #0x30
 8011434: 2b09         	cmp	r3, #0x9
 8011436: d92d         	bls	0x8011494 <vfprintf+0xec> @ imm = #0x5a
 8011438: 2f2a         	cmp	r7, #0x2a
 801143a: d139         	bne	0x80114b0 <vfprintf+0x108> @ imm = #0x72
 801143c: b954         	cbnz	r4, 0x8011454 <vfprintf+0xac> @ imm = #0x14
 801143e: 9b0d         	ldr	r3, [sp, #0x34]
 8011440: f01b 0f40    	tst.w	r11, #0x40
 8011444: f853 2b04    	ldr	r2, [r3], #4
 8011448: 930d         	str	r3, [sp, #0x34]
 801144a: d029         	beq	0x80114a0 <vfprintf+0xf8> @ imm = #0x52
 801144c: 4616         	mov	r6, r2
 801144e: e001         	b	0x8011454 <vfprintf+0xac> @ imm = #0x2
 8011450: f04b 0b01    	orr	r11, r11, #0x1
 8011454: 9b07         	ldr	r3, [sp, #0x1c]
 8011456: f813 7b01    	ldrb	r7, [r3], #1
 801145a: 9307         	str	r3, [sp, #0x1c]
 801145c: 2f00         	cmp	r7, #0x0
 801145e: d1d5         	bne	0x801140c <vfprintf+0x64> @ imm = #-0x56
 8011460: e05b         	b	0x801151a <vfprintf+0x172> @ imm = #0xb6
 8011462: f04b 0b02    	orr	r11, r11, #0x2
 8011466: f04b 0b04    	orr	r11, r11, #0x4
 801146a: e7f3         	b	0x8011454 <vfprintf+0xac> @ imm = #-0x1a
 801146c: f04b 0b08    	orr	r11, r11, #0x8
 8011470: e7f0         	b	0x8011454 <vfprintf+0xac> @ imm = #-0x20
 8011472: f04b 0b10    	orr	r11, r11, #0x10
 8011476: e7ed         	b	0x8011454 <vfprintf+0xac> @ imm = #-0x26
 8011478: f1bb 0f7f    	cmp.w	r11, #0x7f
 801147c: d83f         	bhi	0x80114fe <vfprintf+0x156> @ imm = #0x7e
 801147e: f1a7 0330    	sub.w	r3, r7, #0x30
 8011482: 2b09         	cmp	r3, #0x9
 8011484: d8d8         	bhi	0x8011438 <vfprintf+0x90> @ imm = #-0x50
 8011486: f01b 0f40    	tst.w	r11, #0x40
 801148a: d003         	beq	0x8011494 <vfprintf+0xec> @ imm = #0x6
 801148c: 220a         	movs	r2, #0xa
 801148e: fb02 3606    	mla	r6, r2, r6, r3
 8011492: e7df         	b	0x8011454 <vfprintf+0xac> @ imm = #-0x42
 8011494: 220a         	movs	r2, #0xa
 8011496: fb02 3a0a    	mla	r10, r2, r10, r3
 801149a: f04b 0b20    	orr	r11, r11, #0x20
 801149e: e7d9         	b	0x8011454 <vfprintf+0xac> @ imm = #-0x4e
 80114a0: f1b2 0a00    	subs.w	r10, r2, #0x0
 80114a4: daf9         	bge	0x801149a <vfprintf+0xf2> @ imm = #-0xe
 80114a6: f1ca 0a00    	rsb.w	r10, r10, #0x0
 80114aa: f04b 0b28    	orr	r11, r11, #0x28
 80114ae: e7d1         	b	0x8011454 <vfprintf+0xac> @ imm = #-0x5e
 80114b0: 2f2e         	cmp	r7, #0x2e
 80114b2: d105         	bne	0x80114c0 <vfprintf+0x118> @ imm = #0xa
 80114b4: f01b 0f40    	tst.w	r11, #0x40
 80114b8: d19b         	bne	0x80113f2 <vfprintf+0x4a> @ imm = #-0xca
 80114ba: f04b 0b40    	orr	r11, r11, #0x40
 80114be: e7c9         	b	0x8011454 <vfprintf+0xac> @ imm = #-0x6e
 80114c0: 2f24         	cmp	r7, #0x24
 80114c2: d11c         	bne	0x80114fe <vfprintf+0x156> @ imm = #0x38
 80114c4: 2c00         	cmp	r4, #0x0
 80114c6: f000 8142    	beq.w	0x801174e <vfprintf+0x3a6> @ imm = #0x284
 80114ca: 9b09         	ldr	r3, [sp, #0x24]
 80114cc: 930d         	str	r3, [sp, #0x34]
 80114ce: f01b 0f40    	tst.w	r11, #0x40
 80114d2: d10a         	bne	0x80114ea <vfprintf+0x142> @ imm = #0x14
 80114d4: 4652         	mov	r2, r10
 80114d6: 9808         	ldr	r0, [sp, #0x20]
 80114d8: a90d         	add	r1, sp, #0x34
 80114da: f7ff fec9    	bl	0x8011270 <skip_to_arg> @ imm = #-0x26e
 80114de: 9b0d         	ldr	r3, [sp, #0x34]
 80114e0: 1d1a         	adds	r2, r3, #0x4
 80114e2: f8d3 a000    	ldr.w	r10, [r3]
 80114e6: 920d         	str	r2, [sp, #0x34]
 80114e8: e7b4         	b	0x8011454 <vfprintf+0xac> @ imm = #-0x98
 80114ea: 4632         	mov	r2, r6
 80114ec: 9808         	ldr	r0, [sp, #0x20]
 80114ee: a90d         	add	r1, sp, #0x34
 80114f0: f7ff febe    	bl	0x8011270 <skip_to_arg> @ imm = #-0x284
 80114f4: 9b0d         	ldr	r3, [sp, #0x34]
 80114f6: 1d1a         	adds	r2, r3, #0x4
 80114f8: 681e         	ldr	r6, [r3]
 80114fa: 920d         	str	r2, [sp, #0x34]
 80114fc: e7aa         	b	0x8011454 <vfprintf+0xac> @ imm = #-0xac
 80114fe: 2f6c         	cmp	r7, #0x6c
 8011500: f000 8112    	beq.w	0x8011728 <vfprintf+0x380> @ imm = #0x224
 8011504: f200 8109    	bhi.w	0x801171a <vfprintf+0x372> @ imm = #0x212
 8011508: 2f68         	cmp	r7, #0x68
 801150a: f000 8115    	beq.w	0x8011738 <vfprintf+0x390> @ imm = #0x22a
 801150e: 2f6a         	cmp	r7, #0x6a
 8011510: f000 811a    	beq.w	0x8011748 <vfprintf+0x3a0> @ imm = #0x234
 8011514: 2f4c         	cmp	r7, #0x4c
 8011516: f000 8117    	beq.w	0x8011748 <vfprintf+0x3a0> @ imm = #0x22e
 801151a: b134         	cbz	r4, 0x801152a <vfprintf+0x182> @ imm = #0xc
 801151c: 9b09         	ldr	r3, [sp, #0x24]
 801151e: 9808         	ldr	r0, [sp, #0x20]
 8011520: 930d         	str	r3, [sp, #0x34]
 8011522: 4622         	mov	r2, r4
 8011524: a90d         	add	r1, sp, #0x34
 8011526: f7ff fea3    	bl	0x8011270 <skip_to_arg> @ imm = #-0x2ba
 801152a: 2e00         	cmp	r6, #0x0
 801152c: f047 0920    	orr	r9, r7, #0x20
 8011530: bfb8         	it	lt
 8011532: f02b 0b40    	biclt	r11, r11, #0x40
 8011536: f1a9 0365    	sub.w	r3, r9, #0x65
 801153a: bfbc         	itt	lt
 801153c: fa1f fb8b    	uxthlt.w	r11, r11
 8011540: 2600         	movlt	r6, #0x0
 8011542: 2b02         	cmp	r3, #0x2
 8011544: f240 8108    	bls.w	0x8011758 <vfprintf+0x3b0> @ imm = #0x210
 8011548: f1b9 0f61    	cmp.w	r9, #0x61
 801154c: f040 8267    	bne.w	0x8011a1e <vfprintf+0x676> @ imm = #0x4ce
 8011550: 43ff         	mvns	r7, r7
 8011552: f007 0320    	and	r3, r7, #0x20
 8011556: 9306         	str	r3, [sp, #0x18]
 8011558: 9b0d         	ldr	r3, [sp, #0x34]
 801155a: 3307         	adds	r3, #0x7
 801155c: f023 0307    	bic	r3, r3, #0x7
 8011560: f01b 0f40    	tst.w	r11, #0x40
 8011564: e9d3 0100    	ldrd	r0, r1, [r3]
 8011568: f103 0208    	add.w	r2, r3, #0x8
 801156c: bf08         	it	eq
 801156e: f04f 36ff    	moveq.w	r6, #0xffffffff
 8011572: 9b06         	ldr	r3, [sp, #0x18]
 8011574: 920d         	str	r2, [sp, #0x34]
 8011576: 9300         	str	r3, [sp]
 8011578: aa0e         	add	r2, sp, #0x38
 801157a: 4633         	mov	r3, r6
 801157c: f00c fac7    	bl	0x801db0e <__dtox_engine> @ imm = #0xc58e
 8011580: 3001         	adds	r0, #0x1
 8011582: b2c3         	uxtb	r3, r0
 8011584: 42b3         	cmp	r3, r6
 8011586: f44b 54c0    	orr	r4, r11, #0x1800
 801158a: 9304         	str	r3, [sp, #0x10]
 801158c: db01         	blt	0x8011592 <vfprintf+0x1ea> @ imm = #0x2
 801158e: 9b04         	ldr	r3, [sp, #0x10]
 8011590: 1e5e         	subs	r6, r3, #0x1
 8011592: 2301         	movs	r3, #0x1
 8011594: 9f0e         	ldr	r7, [sp, #0x38]
 8011596: 9305         	str	r3, [sp, #0x14]
 8011598: 46a3         	mov	r11, r4
 801159a: f04f 0970    	mov.w	r9, #0x70
 801159e: f107 0309    	add.w	r3, r7, #0x9
 80115a2: 2b12         	cmp	r3, #0x12
 80115a4: d90d         	bls	0x80115c2 <vfprintf+0x21a> @ imm = #0x1a
 80115a6: f107 0363    	add.w	r3, r7, #0x63
 80115aa: 2bc6         	cmp	r3, #0xc6
 80115ac: f240 810f    	bls.w	0x80117ce <vfprintf+0x426> @ imm = #0x21e
 80115b0: f207 33e7    	addw	r3, r7, #0x3e7
 80115b4: f240 72ce    	movw	r2, #0x7ce
 80115b8: 4293         	cmp	r3, r2
 80115ba: bf94         	ite	ls
 80115bc: 2303         	movls	r3, #0x3
 80115be: 2304         	movhi	r3, #0x4
 80115c0: 9305         	str	r3, [sp, #0x14]
 80115c2: f89d 203c    	ldrb.w	r2, [sp, #0x3c]
 80115c6: f002 030c    	and	r3, r2, #0xc
 80115ca: f012 0201    	ands	r2, r2, #0x1
 80115ce: f040 8119    	bne.w	0x8011804 <vfprintf+0x45c> @ imm = #0x232
 80115d2: f01b 0f02    	tst.w	r11, #0x2
 80115d6: f040 8112    	bne.w	0x80117fe <vfprintf+0x456> @ imm = #0x224
 80115da: f01b 0404    	ands	r4, r11, #0x4
 80115de: f000 80f8    	beq.w	0x80117d2 <vfprintf+0x42a> @ imm = #0x1f0
 80115e2: 2b00         	cmp	r3, #0x0
 80115e4: f040 8111    	bne.w	0x801180a <vfprintf+0x462> @ imm = #0x222
 80115e8: 2320         	movs	r3, #0x20
 80115ea: f41b 5f40    	tst.w	r11, #0x3000
 80115ee: d11f         	bne	0x8011630 <vfprintf+0x288> @ imm = #0x3e
 80115f0: 9a04         	ldr	r2, [sp, #0x10]
 80115f2: 3250         	adds	r2, #0x50
 80115f4: 2e00         	cmp	r6, #0x0
 80115f6: 446a         	add	r2, sp, r2
 80115f8: bf08         	it	eq
 80115fa: 2601         	moveq	r6, #0x1
 80115fc: 3a13         	subs	r2, #0x13
 80115fe: 9904         	ldr	r1, [sp, #0x10]
 8011600: b121         	cbz	r1, 0x801160c <vfprintf+0x264> @ imm = #0x8
 8011602: f812 1d01    	ldrb	r1, [r2, #-1]!
 8011606: 2930         	cmp	r1, #0x30
 8011608: f000 8136    	beq.w	0x8011878 <vfprintf+0x4d0> @ imm = #0x26c
 801160c: f01b 0f10    	tst.w	r11, #0x10
 8011610: 9a04         	ldr	r2, [sp, #0x10]
 8011612: bf18         	it	ne
 8011614: 4632         	movne	r2, r6
 8011616: 1d39         	adds	r1, r7, #0x4
 8011618: f2c0 8133    	blt.w	0x8011882 <vfprintf+0x4da> @ imm = #0x266
 801161c: 42b7         	cmp	r7, r6
 801161e: f280 8130    	bge.w	0x8011882 <vfprintf+0x4da> @ imm = #0x260
 8011622: 42ba         	cmp	r2, r7
 8011624: f44b 5b00    	orr	r11, r11, #0x2000
 8011628: f340 812d    	ble.w	0x8011886 <vfprintf+0x4de> @ imm = #0x25a
 801162c: 1c7e         	adds	r6, r7, #0x1
 801162e: 1b96         	subs	r6, r2, r6
 8011630: f41b 5200    	ands	r2, r11, #0x2000
 8011634: 920a         	str	r2, [sp, #0x28]
 8011636: f000 8128    	beq.w	0x801188a <vfprintf+0x4e2> @ imm = #0x250
 801163a: ea27 74e7    	bic.w	r4, r7, r7, asr #31
 801163e: 3401         	adds	r4, #0x1
 8011640: b103         	cbz	r3, 0x8011644 <vfprintf+0x29c> @ imm = #0x0
 8011642: 3401         	adds	r4, #0x1
 8011644: 2e00         	cmp	r6, #0x0
 8011646: f000 8128    	beq.w	0x801189a <vfprintf+0x4f2> @ imm = #0x250
 801164a: 1c72         	adds	r2, r6, #0x1
 801164c: 4414         	add	r4, r2
 801164e: 45a2         	cmp	r10, r4
 8011650: bfcc         	ite	gt
 8011652: ebaa 0404    	subgt.w	r4, r10, r4
 8011656: 2400         	movle	r4, #0x0
 8011658: f01b 0f09    	tst.w	r11, #0x9
 801165c: d104         	bne	0x8011668 <vfprintf+0x2c0> @ imm = #0x8
 801165e: 442c         	add	r4, r5
 8011660: 42a5         	cmp	r5, r4
 8011662: f040 811f    	bne.w	0x80118a4 <vfprintf+0x4fc> @ imm = #0x23e
 8011666: 2400         	movs	r4, #0x0
 8011668: b143         	cbz	r3, 0x801167c <vfprintf+0x2d4> @ imm = #0x10
 801166a: 4618         	mov	r0, r3
 801166c: 4641         	mov	r1, r8
 801166e: 9b03         	ldr	r3, [sp, #0xc]
 8011670: 4798         	blx	r3
 8011672: 2800         	cmp	r0, #0x0
 8011674: f105 0501    	add.w	r5, r5, #0x1
 8011678: f6ff aeb3    	blt.w	0x80113e2 <vfprintf+0x3a> @ imm = #-0x29a
 801167c: f41b 6f00    	tst.w	r11, #0x800
 8011680: d013         	beq	0x80116aa <vfprintf+0x302> @ imm = #0x26
 8011682: 9b03         	ldr	r3, [sp, #0xc]
 8011684: 4641         	mov	r1, r8
 8011686: 2030         	movs	r0, #0x30
 8011688: 4798         	blx	r3
 801168a: 2800         	cmp	r0, #0x0
 801168c: f6ff aea9    	blt.w	0x80113e2 <vfprintf+0x3a> @ imm = #-0x2ae
 8011690: 9b06         	ldr	r3, [sp, #0x18]
 8011692: f1c3 0078    	rsb.w	r0, r3, #0x78
 8011696: 4641         	mov	r1, r8
 8011698: 9b03         	ldr	r3, [sp, #0xc]
 801169a: f000 00f8    	and	r0, r0, #0xf8
 801169e: 4798         	blx	r3
 80116a0: 2800         	cmp	r0, #0x0
 80116a2: f105 0502    	add.w	r5, r5, #0x2
 80116a6: f6ff ae9c    	blt.w	0x80113e2 <vfprintf+0x3a> @ imm = #-0x2c8
 80116aa: f01b 0f08    	tst.w	r11, #0x8
 80116ae: d105         	bne	0x80116bc <vfprintf+0x314> @ imm = #0xa
 80116b0: 442c         	add	r4, r5
 80116b2: 42ac         	cmp	r4, r5
 80116b4: f040 8102    	bne.w	0x80118bc <vfprintf+0x514> @ imm = #0x204
 80116b8: 4625         	mov	r5, r4
 80116ba: 2400         	movs	r4, #0x0
 80116bc: 9b0a         	ldr	r3, [sp, #0x28]
 80116be: 2b00         	cmp	r3, #0x0
 80116c0: f000 811c    	beq.w	0x80118fc <vfprintf+0x554> @ imm = #0x238
 80116c4: ea27 7ae7    	bic.w	r10, r7, r7, asr #31
 80116c8: eba7 070a    	sub.w	r7, r7, r10
 80116cc: 4276         	rsbs	r6, r6, #0
 80116ce: 9b04         	ldr	r3, [sp, #0x10]
 80116d0: 42bb         	cmp	r3, r7
 80116d2: bf84         	itt	hi
 80116d4: ab0e         	addhi	r3, sp, #0x38
 80116d6: 18fb         	addhi	r3, r7, r3
 80116d8: f10a 3aff    	add.w	r10, r10, #0xffffffff
 80116dc: bf88         	it	hi
 80116de: 7958         	ldrbhi	r0, [r3, #0x5]
 80116e0: 9b03         	ldr	r3, [sp, #0xc]
 80116e2: bf98         	it	ls
 80116e4: 2030         	movls	r0, #0x30
 80116e6: 4556         	cmp	r6, r10
 80116e8: f105 0901    	add.w	r9, r5, #0x1
 80116ec: 4641         	mov	r1, r8
 80116ee: f300 80ef    	bgt.w	0x80118d0 <vfprintf+0x528> @ imm = #0x1de
 80116f2: 4798         	blx	r3
 80116f4: 2800         	cmp	r0, #0x0
 80116f6: f107 0701    	add.w	r7, r7, #0x1
 80116fa: f6ff ae72    	blt.w	0x80113e2 <vfprintf+0x3a> @ imm = #-0x31c
 80116fe: f1ba 3fff    	cmp.w	r10, #0xffffffff
 8011702: d108         	bne	0x8011716 <vfprintf+0x36e> @ imm = #0x10
 8011704: 9b03         	ldr	r3, [sp, #0xc]
 8011706: 4641         	mov	r1, r8
 8011708: 202e         	movs	r0, #0x2e
 801170a: 4798         	blx	r3
 801170c: 2800         	cmp	r0, #0x0
 801170e: f6ff ae68    	blt.w	0x80113e2 <vfprintf+0x3a> @ imm = #-0x330
 8011712: f105 0902    	add.w	r9, r5, #0x2
 8011716: 464d         	mov	r5, r9
 8011718: e7d9         	b	0x80116ce <vfprintf+0x326> @ imm = #-0x4e
 801171a: 2f74         	cmp	r7, #0x74
 801171c: f43f ae9a    	beq.w	0x8011454 <vfprintf+0xac> @ imm = #-0x2cc
 8011720: 2f7a         	cmp	r7, #0x7a
 8011722: f43f ae97    	beq.w	0x8011454 <vfprintf+0xac> @ imm = #-0x2d2
 8011726: e6f8         	b	0x801151a <vfprintf+0x172> @ imm = #-0x210
 8011728: f01b 0f80    	tst.w	r11, #0x80
 801172c: bf18         	it	ne
 801172e: f44b 7b00    	orrne	r11, r11, #0x200
 8011732: f04b 0b80    	orr	r11, r11, #0x80
 8011736: e68d         	b	0x8011454 <vfprintf+0xac> @ imm = #-0x2e6
 8011738: f41b 7f80    	tst.w	r11, #0x100
 801173c: bf18         	it	ne
 801173e: f44b 7b00    	orrne	r11, r11, #0x200
 8011742: f44b 7b80    	orr	r11, r11, #0x100
 8011746: e685         	b	0x8011454 <vfprintf+0xac> @ imm = #-0x2f6
 8011748: f44b 7b20    	orr	r11, r11, #0x280
 801174c: e682         	b	0x8011454 <vfprintf+0xac> @ imm = #-0x2fc
 801174e: 4626         	mov	r6, r4
 8011750: 46b3         	mov	r11, r6
 8011752: 4654         	mov	r4, r10
 8011754: 46b2         	mov	r10, r6
 8011756: e67d         	b	0x8011454 <vfprintf+0xac> @ imm = #-0x306
 8011758: 43ff         	mvns	r7, r7
 801175a: f007 0320    	and	r3, r7, #0x20
 801175e: 9306         	str	r3, [sp, #0x18]
 8011760: 9b0d         	ldr	r3, [sp, #0x34]
 8011762: 3307         	adds	r3, #0x7
 8011764: f023 0307    	bic	r3, r3, #0x7
 8011768: f01b 0f40    	tst.w	r11, #0x40
 801176c: f103 0208    	add.w	r2, r3, #0x8
 8011770: bf08         	it	eq
 8011772: 2606         	moveq	r6, #0x6
 8011774: f1b9 0f65    	cmp.w	r9, #0x65
 8011778: e9d3 0100    	ldrd	r0, r1, [r3]
 801177c: 920d         	str	r2, [sp, #0x34]
 801177e: d113         	bne	0x80117a8 <vfprintf+0x400> @ imm = #0x26
 8011780: 1c73         	adds	r3, r6, #0x1
 8011782: 2200         	movs	r2, #0x0
 8011784: b2db         	uxtb	r3, r3
 8011786: f44b 5b80    	orr	r11, r11, #0x1000
 801178a: 4614         	mov	r4, r2
 801178c: 2b11         	cmp	r3, #0x11
 801178e: e9cd 2400    	strd	r2, r4, [sp]
 8011792: bf28         	it	hs
 8011794: 2311         	movhs	r3, #0x11
 8011796: aa0e         	add	r2, sp, #0x38
 8011798: f000 fafc    	bl	0x8011d94 <__dtoa_engine> @ imm = #0x5f8
 801179c: b2c3         	uxtb	r3, r0
 801179e: 9304         	str	r3, [sp, #0x10]
 80117a0: 2302         	movs	r3, #0x2
 80117a2: 9f0e         	ldr	r7, [sp, #0x38]
 80117a4: 9305         	str	r3, [sp, #0x14]
 80117a6: e6fa         	b	0x801159e <vfprintf+0x1f6> @ imm = #-0x20c
 80117a8: f1b9 0f66    	cmp.w	r9, #0x66
 80117ac: d105         	bne	0x80117ba <vfprintf+0x412> @ imm = #0xa
 80117ae: f44b 5b00    	orr	r11, r11, #0x2000
 80117b2: 4634         	mov	r4, r6
 80117b4: 2201         	movs	r2, #0x1
 80117b6: 2311         	movs	r3, #0x11
 80117b8: e7e8         	b	0x801178c <vfprintf+0x3e4> @ imm = #-0x30
 80117ba: b2f3         	uxtb	r3, r6
 80117bc: 2b01         	cmp	r3, #0x1
 80117be: f04f 0200    	mov.w	r2, #0x0
 80117c2: bf38         	it	lo
 80117c4: 2301         	movlo	r3, #0x1
 80117c6: 4614         	mov	r4, r2
 80117c8: f04f 0965    	mov.w	r9, #0x65
 80117cc: e7de         	b	0x801178c <vfprintf+0x3e4> @ imm = #-0x44
 80117ce: 2302         	movs	r3, #0x2
 80117d0: e6f6         	b	0x80115c0 <vfprintf+0x218> @ imm = #-0x214
 80117d2: 2b00         	cmp	r3, #0x0
 80117d4: f43f af09    	beq.w	0x80115ea <vfprintf+0x242> @ imm = #-0x1ee
 80117d8: f1ba 0f03    	cmp.w	r10, #0x3
 80117dc: dc3b         	bgt	0x8011856 <vfprintf+0x4ae> @ imm = #0x76
 80117de: f89d 303c    	ldrb.w	r3, [sp, #0x3c]
 80117e2: 4ea6         	ldr	r6, [pc, #0x298]        @ 0x8011a7c <vfprintf+0x6d4>
 80117e4: f013 0f08    	tst.w	r3, #0x8
 80117e8: 4ba5         	ldr	r3, [pc, #0x294]        @ 0x8011a80 <vfprintf+0x6d8>
 80117ea: bf08         	it	eq
 80117ec: 461e         	moveq	r6, r3
 80117ee: 4637         	mov	r7, r6
 80117f0: 46b9         	mov	r9, r7
 80117f2: f817 0b01    	ldrb	r0, [r7], #1
 80117f6: bbb0         	cbnz	r0, 0x8011866 <vfprintf+0x4be> @ imm = #0x6c
 80117f8: 1bae         	subs	r6, r5, r6
 80117fa: 44b1         	add	r9, r6
 80117fc: e07b         	b	0x80118f6 <vfprintf+0x54e> @ imm = #0xf6
 80117fe: bb33         	cbnz	r3, 0x801184e <vfprintf+0x4a6> @ imm = #0x4c
 8011800: 232b         	movs	r3, #0x2b
 8011802: e6f2         	b	0x80115ea <vfprintf+0x242> @ imm = #-0x21c
 8011804: bb2b         	cbnz	r3, 0x8011852 <vfprintf+0x4aa> @ imm = #0x4a
 8011806: 232d         	movs	r3, #0x2d
 8011808: e6ef         	b	0x80115ea <vfprintf+0x242> @ imm = #-0x222
 801180a: 2220         	movs	r2, #0x20
 801180c: f1ba 0f04    	cmp.w	r10, #0x4
 8011810: dd13         	ble	0x801183a <vfprintf+0x492> @ imm = #0x26
 8011812: f01b 0f08    	tst.w	r11, #0x8
 8011816: f1aa 0404    	sub.w	r4, r10, #0x4
 801181a: d10f         	bne	0x801183c <vfprintf+0x494> @ imm = #0x1e
 801181c: 442c         	add	r4, r5
 801181e: 9b03         	ldr	r3, [sp, #0xc]
 8011820: 9204         	str	r2, [sp, #0x10]
 8011822: 4641         	mov	r1, r8
 8011824: 2020         	movs	r0, #0x20
 8011826: 4798         	blx	r3
 8011828: 2800         	cmp	r0, #0x0
 801182a: f105 0501    	add.w	r5, r5, #0x1
 801182e: f6ff add8    	blt.w	0x80113e2 <vfprintf+0x3a> @ imm = #-0x450
 8011832: 42a5         	cmp	r5, r4
 8011834: 9a04         	ldr	r2, [sp, #0x10]
 8011836: d1f2         	bne	0x801181e <vfprintf+0x476> @ imm = #-0x1c
 8011838: b19a         	cbz	r2, 0x8011862 <vfprintf+0x4ba> @ imm = #0x26
 801183a: 2400         	movs	r4, #0x0
 801183c: 9b03         	ldr	r3, [sp, #0xc]
 801183e: 4641         	mov	r1, r8
 8011840: 4610         	mov	r0, r2
 8011842: 4798         	blx	r3
 8011844: 2800         	cmp	r0, #0x0
 8011846: f105 0501    	add.w	r5, r5, #0x1
 801184a: dac8         	bge	0x80117de <vfprintf+0x436> @ imm = #-0x70
 801184c: e5c9         	b	0x80113e2 <vfprintf+0x3a> @ imm = #-0x46e
 801184e: 222b         	movs	r2, #0x2b
 8011850: e7dc         	b	0x801180c <vfprintf+0x464> @ imm = #-0x48
 8011852: 222d         	movs	r2, #0x2d
 8011854: e7da         	b	0x801180c <vfprintf+0x464> @ imm = #-0x4c
 8011856: f01b 0f08    	tst.w	r11, #0x8
 801185a: f1aa 0403    	sub.w	r4, r10, #0x3
 801185e: d1be         	bne	0x80117de <vfprintf+0x436> @ imm = #-0x84
 8011860: e7dc         	b	0x801181c <vfprintf+0x474> @ imm = #-0x48
 8011862: 4614         	mov	r4, r2
 8011864: e7bb         	b	0x80117de <vfprintf+0x436> @ imm = #-0x8a
 8011866: 9b06         	ldr	r3, [sp, #0x18]
 8011868: 1ac0         	subs	r0, r0, r3
 801186a: 4641         	mov	r1, r8
 801186c: 9b03         	ldr	r3, [sp, #0xc]
 801186e: b2c0         	uxtb	r0, r0
 8011870: 4798         	blx	r3
 8011872: 2800         	cmp	r0, #0x0
 8011874: dabc         	bge	0x80117f0 <vfprintf+0x448> @ imm = #-0x88
 8011876: e5b4         	b	0x80113e2 <vfprintf+0x3a> @ imm = #-0x498
 8011878: 9904         	ldr	r1, [sp, #0x10]
 801187a: 3901         	subs	r1, #0x1
 801187c: b2c9         	uxtb	r1, r1
 801187e: 9104         	str	r1, [sp, #0x10]
 8011880: e6bd         	b	0x80115fe <vfprintf+0x256> @ imm = #-0x286
 8011882: 1e56         	subs	r6, r2, #0x1
 8011884: e6d4         	b	0x8011630 <vfprintf+0x288> @ imm = #-0x258
 8011886: 2600         	movs	r6, #0x0
 8011888: e6d2         	b	0x8011630 <vfprintf+0x288> @ imm = #-0x25c
 801188a: f41b 6f00    	tst.w	r11, #0x800
 801188e: 9a05         	ldr	r2, [sp, #0x14]
 8011890: bf0c         	ite	eq
 8011892: 2403         	moveq	r4, #0x3
 8011894: 2405         	movne	r4, #0x5
 8011896: 4414         	add	r4, r2
 8011898: e6d2         	b	0x8011640 <vfprintf+0x298> @ imm = #-0x25c
 801189a: f01b 0f10    	tst.w	r11, #0x10
 801189e: bf18         	it	ne
 80118a0: 3401         	addne	r4, #0x1
 80118a2: e6d4         	b	0x801164e <vfprintf+0x2a6> @ imm = #-0x258
 80118a4: 930b         	str	r3, [sp, #0x2c]
 80118a6: 4641         	mov	r1, r8
 80118a8: 9b03         	ldr	r3, [sp, #0xc]
 80118aa: 2020         	movs	r0, #0x20
 80118ac: 4798         	blx	r3
 80118ae: 2800         	cmp	r0, #0x0
 80118b0: 9b0b         	ldr	r3, [sp, #0x2c]
 80118b2: f105 0501    	add.w	r5, r5, #0x1
 80118b6: f6bf aed3    	bge.w	0x8011660 <vfprintf+0x2b8> @ imm = #-0x25a
 80118ba: e592         	b	0x80113e2 <vfprintf+0x3a> @ imm = #-0x4dc
 80118bc: 9b03         	ldr	r3, [sp, #0xc]
 80118be: 4641         	mov	r1, r8
 80118c0: 2030         	movs	r0, #0x30
 80118c2: 4798         	blx	r3
 80118c4: 2800         	cmp	r0, #0x0
 80118c6: f105 0501    	add.w	r5, r5, #0x1
 80118ca: f6bf aef2    	bge.w	0x80116b2 <vfprintf+0x30a> @ imm = #-0x21c
 80118ce: e588         	b	0x80113e2 <vfprintf+0x3a> @ imm = #-0x4f0
 80118d0: 4798         	blx	r3
 80118d2: 2800         	cmp	r0, #0x0
 80118d4: f6ff ad85    	blt.w	0x80113e2 <vfprintf+0x3a> @ imm = #-0x4f6
 80118d8: f01b 0f10    	tst.w	r11, #0x10
 80118dc: d00b         	beq	0x80118f6 <vfprintf+0x54e> @ imm = #0x16
 80118de: f1ba 3fff    	cmp.w	r10, #0xffffffff
 80118e2: d108         	bne	0x80118f6 <vfprintf+0x54e> @ imm = #0x10
 80118e4: f105 0902    	add.w	r9, r5, #0x2
 80118e8: 4641         	mov	r1, r8
 80118ea: 202e         	movs	r0, #0x2e
 80118ec: 9b03         	ldr	r3, [sp, #0xc]
 80118ee: 4798         	blx	r3
 80118f0: 2800         	cmp	r0, #0x0
 80118f2: f6ff ad76    	blt.w	0x80113e2 <vfprintf+0x3a> @ imm = #-0x514
 80118f6: 464d         	mov	r5, r9
 80118f8: 444c         	add	r4, r9
 80118fa: e233         	b	0x8011d64 <vfprintf+0x9bc> @ imm = #0x466
 80118fc: f89d 003d    	ldrb.w	r0, [sp, #0x3d]
 8011900: 9b03         	ldr	r3, [sp, #0xc]
 8011902: 4641         	mov	r1, r8
 8011904: 4798         	blx	r3
 8011906: 2800         	cmp	r0, #0x0
 8011908: f6ff ad6b    	blt.w	0x80113e2 <vfprintf+0x3a> @ imm = #-0x52a
 801190c: 2e00         	cmp	r6, #0x0
 801190e: dd69         	ble	0x80119e4 <vfprintf+0x63c> @ imm = #0xd2
 8011910: 9b03         	ldr	r3, [sp, #0xc]
 8011912: 4641         	mov	r1, r8
 8011914: 202e         	movs	r0, #0x2e
 8011916: 4798         	blx	r3
 8011918: 2800         	cmp	r0, #0x0
 801191a: f6ff ad62    	blt.w	0x80113e2 <vfprintf+0x3a> @ imm = #-0x53c
 801191e: f04f 0a01    	mov.w	r10, #0x1
 8011922: 9b04         	ldr	r3, [sp, #0x10]
 8011924: 459a         	cmp	r10, r3
 8011926: bfbb         	ittet	lt
 8011928: ab0e         	addlt	r3, sp, #0x38
 801192a: 4453         	addlt	r3, r10
 801192c: 2030         	movge	r0, #0x30
 801192e: 7958         	ldrblt	r0, [r3, #0x5]
 8011930: 9b03         	ldr	r3, [sp, #0xc]
 8011932: 4641         	mov	r1, r8
 8011934: 4798         	blx	r3
 8011936: 2800         	cmp	r0, #0x0
 8011938: 46d3         	mov	r11, r10
 801193a: f6ff ad52    	blt.w	0x80113e2 <vfprintf+0x3a> @ imm = #-0x55c
 801193e: f10a 0a01    	add.w	r10, r10, #0x1
 8011942: 4556         	cmp	r6, r10
 8011944: daed         	bge	0x8011922 <vfprintf+0x57a> @ imm = #-0x26
 8011946: 3502         	adds	r5, #0x2
 8011948: 445d         	add	r5, r11
 801194a: 9b06         	ldr	r3, [sp, #0x18]
 801194c: eba9 0003    	sub.w	r0, r9, r3
 8011950: 4641         	mov	r1, r8
 8011952: 9b03         	ldr	r3, [sp, #0xc]
 8011954: b2c0         	uxtb	r0, r0
 8011956: 4798         	blx	r3
 8011958: 2800         	cmp	r0, #0x0
 801195a: f6ff ad42    	blt.w	0x80113e2 <vfprintf+0x3a> @ imm = #-0x57c
 801195e: 2f00         	cmp	r7, #0x0
 8011960: bfb4         	ite	lt
 8011962: 202d         	movlt	r0, #0x2d
 8011964: 202b         	movge	r0, #0x2b
 8011966: 9b03         	ldr	r3, [sp, #0xc]
 8011968: 4641         	mov	r1, r8
 801196a: bfb8         	it	lt
 801196c: 427f         	rsblt	r7, r7, #0
 801196e: 4798         	blx	r3
 8011970: 2800         	cmp	r0, #0x0
 8011972: f6ff ad36    	blt.w	0x80113e2 <vfprintf+0x3a> @ imm = #-0x594
 8011976: 9b05         	ldr	r3, [sp, #0x14]
 8011978: 2b04         	cmp	r3, #0x4
 801197a: d141         	bne	0x8011a00 <vfprintf+0x658> @ imm = #0x82
 801197c: f44f 797a    	mov.w	r9, #0x3e8
 8011980: fbb7 f6f9    	udiv	r6, r7, r9
 8011984: f106 0030    	add.w	r0, r6, #0x30
 8011988: 9b03         	ldr	r3, [sp, #0xc]
 801198a: 4641         	mov	r1, r8
 801198c: b2c0         	uxtb	r0, r0
 801198e: 4798         	blx	r3
 8011990: 2800         	cmp	r0, #0x0
 8011992: f105 0503    	add.w	r5, r5, #0x3
 8011996: f6ff ad24    	blt.w	0x80113e2 <vfprintf+0x3a> @ imm = #-0x5b8
 801199a: fb09 7716    	mls	r7, r9, r6, r7
 801199e: f04f 0964    	mov.w	r9, #0x64
 80119a2: fbb7 f6f9    	udiv	r6, r7, r9
 80119a6: f106 0030    	add.w	r0, r6, #0x30
 80119aa: 9b03         	ldr	r3, [sp, #0xc]
 80119ac: 4641         	mov	r1, r8
 80119ae: b2c0         	uxtb	r0, r0
 80119b0: 4798         	blx	r3
 80119b2: 2800         	cmp	r0, #0x0
 80119b4: f105 0501    	add.w	r5, r5, #0x1
 80119b8: f6ff ad13    	blt.w	0x80113e2 <vfprintf+0x3a> @ imm = #-0x5da
 80119bc: fb09 7716    	mls	r7, r9, r6, r7
 80119c0: f04f 090a    	mov.w	r9, #0xa
 80119c4: fbb7 f6f9    	udiv	r6, r7, r9
 80119c8: f106 0030    	add.w	r0, r6, #0x30
 80119cc: 9b03         	ldr	r3, [sp, #0xc]
 80119ce: 4641         	mov	r1, r8
 80119d0: b2c0         	uxtb	r0, r0
 80119d2: 4798         	blx	r3
 80119d4: 2800         	cmp	r0, #0x0
 80119d6: f105 0501    	add.w	r5, r5, #0x1
 80119da: f6ff ad02    	blt.w	0x80113e2 <vfprintf+0x3a> @ imm = #-0x5fc
 80119de: fb09 7716    	mls	r7, r9, r6, r7
 80119e2: e015         	b	0x8011a10 <vfprintf+0x668> @ imm = #0x2a
 80119e4: f01b 0f10    	tst.w	r11, #0x10
 80119e8: d101         	bne	0x80119ee <vfprintf+0x646> @ imm = #0x2
 80119ea: 3501         	adds	r5, #0x1
 80119ec: e7ad         	b	0x801194a <vfprintf+0x5a2> @ imm = #-0xa6
 80119ee: 9b03         	ldr	r3, [sp, #0xc]
 80119f0: 4641         	mov	r1, r8
 80119f2: 202e         	movs	r0, #0x2e
 80119f4: 4798         	blx	r3
 80119f6: 2800         	cmp	r0, #0x0
 80119f8: f105 0502    	add.w	r5, r5, #0x2
 80119fc: daa5         	bge	0x801194a <vfprintf+0x5a2> @ imm = #-0xb6
 80119fe: e4f0         	b	0x80113e2 <vfprintf+0x3a> @ imm = #-0x620
 8011a00: 9b05         	ldr	r3, [sp, #0x14]
 8011a02: 2b03         	cmp	r3, #0x3
 8011a04: f105 0502    	add.w	r5, r5, #0x2
 8011a08: d0c9         	beq	0x801199e <vfprintf+0x5f6> @ imm = #-0x6e
 8011a0a: 9b05         	ldr	r3, [sp, #0x14]
 8011a0c: 2b01         	cmp	r3, #0x1
 8011a0e: d1d7         	bne	0x80119c0 <vfprintf+0x618> @ imm = #-0x52
 8011a10: f107 0030    	add.w	r0, r7, #0x30
 8011a14: f105 0901    	add.w	r9, r5, #0x1
 8011a18: 4641         	mov	r1, r8
 8011a1a: b2c0         	uxtb	r0, r0
 8011a1c: e766         	b	0x80118ec <vfprintf+0x544> @ imm = #-0x134
 8011a1e: f1a7 0363    	sub.w	r3, r7, #0x63
 8011a22: 2b12         	cmp	r3, #0x12
 8011a24: f200 80ff    	bhi.w	0x8011c26 <vfprintf+0x87e> @ imm = #0x1fe
 8011a28: e8df f013    	tbh	[pc, r3, lsl #1]

08011a2c <$d>:
 8011a2c: 13 00 57 00  	.word	0x00570013
 8011a30: fd 00 fd 00  	.word	0x00fd00fd
 8011a34: fd 00 fd 00  	.word	0x00fd00fd
 8011a38: 57 00 fd 00  	.word	0x00fd0057
 8011a3c: fd 00 fd 00  	.word	0x00fd00fd
 8011a40: fd 00 fd 00  	.word	0x00fd00fd
 8011a44: 17 01 f8 00  	.word	0x00f80117
 8011a48: fd 00 fd 00  	.word	0x00fd00fd
 8011a4c: 2c 00 fd 00  	.word	0x00fd002c
 8011a50: b9 00        	.short	0x00b9

08011a52 <$t>:
 8011a52: 9b0d         	ldr	r3, [sp, #0x34]
 8011a54: 1d1a         	adds	r2, r3, #0x4
 8011a56: 681b         	ldr	r3, [r3]
 8011a58: 920d         	str	r2, [sp, #0x34]
 8011a5a: f88d 3038    	strb.w	r3, [sp, #0x38]
 8011a5e: 2401         	movs	r4, #0x1
 8011a60: af0e         	add	r7, sp, #0x38
 8011a62: f01b 0f08    	tst.w	r11, #0x8
 8011a66: d02e         	beq	0x8011ac6 <vfprintf+0x71e> @ imm = #0x5c
 8011a68: 193e         	adds	r6, r7, r4
 8011a6a: 46b9         	mov	r9, r7
 8011a6c: 45b1         	cmp	r9, r6
 8011a6e: d12c         	bne	0x8011aca <vfprintf+0x722> @ imm = #0x58
 8011a70: 1bef         	subs	r7, r5, r7
 8011a72: 44b9         	add	r9, r7
 8011a74: ebaa 0404    	sub.w	r4, r10, r4
 8011a78: e73d         	b	0x80118f6 <vfprintf+0x54e> @ imm = #-0x186
 8011a7a: bf00         	nop

08011a7c <$d>:
 8011a7c: 05 0d 02 08  	.word	0x08020d05
 8011a80: 01 0d 02 08  	.word	0x08020d01

08011a84 <$t>:
 8011a84: 9b0d         	ldr	r3, [sp, #0x34]
 8011a86: 1d1a         	adds	r2, r3, #0x4
 8011a88: 920d         	str	r2, [sp, #0x34]
 8011a8a: 681f         	ldr	r7, [r3]
 8011a8c: 4bab         	ldr	r3, [pc, #0x2ac]        @ 0x8011d3c <vfprintf+0x994>
 8011a8e: 2f00         	cmp	r7, #0x0
 8011a90: bf08         	it	eq
 8011a92: 461f         	moveq	r7, r3
 8011a94: f01b 0f40    	tst.w	r11, #0x40
 8011a98: bf14         	ite	ne
 8011a9a: 4631         	movne	r1, r6
 8011a9c: f04f 31ff    	moveq.w	r1, #0xffffffff
 8011aa0: 4638         	mov	r0, r7
 8011aa2: f00b febb    	bl	0x801d81c <strnlen>     @ imm = #0xbd76
 8011aa6: 4604         	mov	r4, r0
 8011aa8: e7db         	b	0x8011a62 <vfprintf+0x6ba> @ imm = #-0x4a
 8011aaa: 9b03         	ldr	r3, [sp, #0xc]
 8011aac: 4641         	mov	r1, r8
 8011aae: 2020         	movs	r0, #0x20
 8011ab0: 4798         	blx	r3
 8011ab2: 2800         	cmp	r0, #0x0
 8011ab4: f6ff ac95    	blt.w	0x80113e2 <vfprintf+0x3a> @ imm = #-0x6d6
 8011ab8: 3e01         	subs	r6, #0x1
 8011aba: 42b4         	cmp	r4, r6
 8011abc: d3f5         	blo	0x8011aaa <vfprintf+0x702> @ imm = #-0x16
 8011abe: 4455         	add	r5, r10
 8011ac0: 1bad         	subs	r5, r5, r6
 8011ac2: 46b2         	mov	r10, r6
 8011ac4: e7d0         	b	0x8011a68 <vfprintf+0x6c0> @ imm = #-0x60
 8011ac6: 4656         	mov	r6, r10
 8011ac8: e7f7         	b	0x8011aba <vfprintf+0x712> @ imm = #-0x12
 8011aca: f819 0b01    	ldrb	r0, [r9], #1
 8011ace: 9b03         	ldr	r3, [sp, #0xc]
 8011ad0: 4641         	mov	r1, r8
 8011ad2: 4798         	blx	r3
 8011ad4: 2800         	cmp	r0, #0x0
 8011ad6: dac9         	bge	0x8011a6c <vfprintf+0x6c4> @ imm = #-0x6e
 8011ad8: e483         	b	0x80113e2 <vfprintf+0x3a> @ imm = #-0x6fa
 8011ada: f01b 0f80    	tst.w	r11, #0x80
 8011ade: 9b0d         	ldr	r3, [sp, #0x34]
 8011ae0: d035         	beq	0x8011b4e <vfprintf+0x7a6> @ imm = #0x6a
 8011ae2: f41b 7f00    	tst.w	r11, #0x200
 8011ae6: d02d         	beq	0x8011b44 <vfprintf+0x79c> @ imm = #0x5a
 8011ae8: 3307         	adds	r3, #0x7
 8011aea: f023 0307    	bic	r3, r3, #0x7
 8011aee: e9d3 0100    	ldrd	r0, r1, [r3]
 8011af2: f103 0208    	add.w	r2, r3, #0x8
 8011af6: 920d         	str	r2, [sp, #0x34]
 8011af8: f02b 0910    	bic	r9, r11, #0x10
 8011afc: 2900         	cmp	r1, #0x0
 8011afe: fa1f f989    	uxth.w	r9, r9
 8011b02: da36         	bge	0x8011b72 <vfprintf+0x7ca> @ imm = #0x6c
 8011b04: 4240         	rsbs	r0, r0, #0
 8011b06: eb61 0141    	sbc.w	r1, r1, r1, lsl #1
 8011b0a: f449 6980    	orr	r9, r9, #0x400
 8011b0e: f10d 0b38    	add.w	r11, sp, #0x38
 8011b12: 230a         	movs	r3, #0xa
 8011b14: 465a         	mov	r2, r11
 8011b16: f00b fe8d    	bl	0x801d834 <__ultoa_invert> @ imm = #0xbd1a
 8011b1a: f019 0f40    	tst.w	r9, #0x40
 8011b1e: eba0 0b0b    	sub.w	r11, r0, r11
 8011b22: d065         	beq	0x8011bf0 <vfprintf+0x848> @ imm = #0xca
 8011b24: f029 0201    	bic	r2, r9, #0x1
 8011b28: 455e         	cmp	r6, r11
 8011b2a: b292         	uxth	r2, r2
 8011b2c: f340 80b2    	ble.w	0x8011c94 <vfprintf+0x8ec> @ imm = #0x164
 8011b30: 2f00         	cmp	r7, #0x0
 8011b32: f000 80a9    	beq.w	0x8011c88 <vfprintf+0x8e0> @ imm = #0x152
 8011b36: f019 0310    	ands	r3, r9, #0x10
 8011b3a: 4634         	mov	r4, r6
 8011b3c: 4691         	mov	r9, r2
 8011b3e: d026         	beq	0x8011b8e <vfprintf+0x7e6> @ imm = #0x4c
 8011b40: 3402         	adds	r4, #0x2
 8011b42: e05c         	b	0x8011bfe <vfprintf+0x856> @ imm = #0xb8
 8011b44: 1d1a         	adds	r2, r3, #0x4
 8011b46: 6818         	ldr	r0, [r3]
 8011b48: 920d         	str	r2, [sp, #0x34]
 8011b4a: 17c1         	asrs	r1, r0, #0x1f
 8011b4c: e7d4         	b	0x8011af8 <vfprintf+0x750> @ imm = #-0x58
 8011b4e: 1d1a         	adds	r2, r3, #0x4
 8011b50: f41b 7f80    	tst.w	r11, #0x100
 8011b54: 6819         	ldr	r1, [r3]
 8011b56: 920d         	str	r2, [sp, #0x34]
 8011b58: d101         	bne	0x8011b5e <vfprintf+0x7b6> @ imm = #0x2
 8011b5a: 4608         	mov	r0, r1
 8011b5c: e7f5         	b	0x8011b4a <vfprintf+0x7a2> @ imm = #-0x16
 8011b5e: f41b 7f00    	tst.w	r11, #0x200
 8011b62: bf15         	itete	ne
 8011b64: b248         	sxtbne	r0, r1
 8011b66: b208         	sxtheq	r0, r1
 8011b68: f341 11c0    	sbfxne	r1, r1, #0x7, #0x1
 8011b6c: f341 31c0    	sbfxeq	r1, r1, #0xf, #0x1
 8011b70: e7c2         	b	0x8011af8 <vfprintf+0x750> @ imm = #-0x7c
 8011b72: ea50 0301    	orrs.w	r3, r0, r1
 8011b76: d1ca         	bne	0x8011b0e <vfprintf+0x766> @ imm = #-0x6c
 8011b78: f01b 0f40    	tst.w	r11, #0x40
 8011b7c: d0c7         	beq	0x8011b0e <vfprintf+0x766> @ imm = #-0x72
 8011b7e: 2e00         	cmp	r6, #0x0
 8011b80: d1c5         	bne	0x8011b0e <vfprintf+0x766> @ imm = #-0x76
 8011b82: f02b 0b11    	bic	r11, r11, #0x11
 8011b86: fa1f f98b    	uxth.w	r9, r11
 8011b8a: 4634         	mov	r4, r6
 8011b8c: 46b3         	mov	r11, r6
 8011b8e: f240 4306    	movw	r3, #0x406
 8011b92: ea19 0303    	ands.w	r3, r9, r3
 8011b96: bf1c         	itt	ne
 8011b98: 3401         	addne	r4, #0x1
 8011b9a: 2300         	movne	r3, #0x0
 8011b9c: e02f         	b	0x8011bfe <vfprintf+0x856> @ imm = #0x5e
 8011b9e: f02b 0b10    	bic	r11, r11, #0x10
 8011ba2: fa1f fb8b    	uxth.w	r11, r11
 8011ba6: 230a         	movs	r3, #0xa
 8011ba8: f01b 0480    	ands	r4, r11, #0x80
 8011bac: 9a0d         	ldr	r2, [sp, #0x34]
 8011bae: d057         	beq	0x8011c60 <vfprintf+0x8b8> @ imm = #0xae
 8011bb0: f41b 7100    	ands	r1, r11, #0x200
 8011bb4: bf1d         	ittte	ne
 8011bb6: 3207         	addne	r2, #0x7
 8011bb8: f022 0207    	bicne	r2, r2, #0x7
 8011bbc: f102 0108    	addne.w	r1, r2, #0x8
 8011bc0: 1d10         	addeq	r0, r2, #0x4
 8011bc2: bf19         	ittee	ne
 8011bc4: 910d         	strne	r1, [sp, #0x34]
 8011bc6: e9d2 0100    	ldrdne	r0, r1, [r2]
 8011bca: 900d         	streq	r0, [sp, #0x34]
 8011bcc: 6810         	ldreq	r0, [r2]
 8011bce: ea50 0201    	orrs.w	r2, r0, r1
 8011bd2: d152         	bne	0x8011c7a <vfprintf+0x8d2> @ imm = #0xa4
 8011bd4: f02b 0916    	bic	r9, r11, #0x16
 8011bd8: f01b 0f40    	tst.w	r11, #0x40
 8011bdc: fa1f f989    	uxth.w	r9, r9
 8011be0: d04f         	beq	0x8011c82 <vfprintf+0x8da> @ imm = #0x9e
 8011be2: 2e00         	cmp	r6, #0x0
 8011be4: d14d         	bne	0x8011c82 <vfprintf+0x8da> @ imm = #0x9a
 8011be6: f02b 0b17    	bic	r11, r11, #0x17
 8011bea: fa1f f98b    	uxth.w	r9, r11
 8011bee: 46b3         	mov	r11, r6
 8011bf0: f019 0310    	ands	r3, r9, #0x10
 8011bf4: d052         	beq	0x8011c9c <vfprintf+0x8f4> @ imm = #0xa4
 8011bf6: 2f00         	cmp	r7, #0x0
 8011bf8: d14e         	bne	0x8011c98 <vfprintf+0x8f0> @ imm = #0x9c
 8011bfa: f10b 0401    	add.w	r4, r11, #0x1
 8011bfe: f019 0f08    	tst.w	r9, #0x8
 8011c02: d15e         	bne	0x8011cc2 <vfprintf+0x91a> @ imm = #0xbc
 8011c04: f019 0f01    	tst.w	r9, #0x1
 8011c08: d006         	beq	0x8011c18 <vfprintf+0x870> @ imm = #0xc
 8011c0a: 45a2         	cmp	r10, r4
 8011c0c: dd6e         	ble	0x8011cec <vfprintf+0x944> @ imm = #0xdc
 8011c0e: ebaa 0404    	sub.w	r4, r10, r4
 8011c12: eb04 060b    	add.w	r6, r4, r11
 8011c16: 4654         	mov	r4, r10
 8011c18: 4622         	mov	r2, r4
 8011c1a: e04d         	b	0x8011cb8 <vfprintf+0x910> @ imm = #0x9a
 8011c1c: f04b 0b10    	orr	r11, r11, #0x10
 8011c20: 2310         	movs	r3, #0x10
 8011c22: 2778         	movs	r7, #0x78
 8011c24: e7c0         	b	0x8011ba8 <vfprintf+0x800> @ imm = #-0x80
 8011c26: f1b9 0f78    	cmp.w	r9, #0x78
 8011c2a: d104         	bne	0x8011c36 <vfprintf+0x88e> @ imm = #0x8
 8011c2c: f1c7 0378    	rsb.w	r3, r7, #0x78
 8011c30: f043 0310    	orr	r3, r3, #0x10
 8011c34: e7b8         	b	0x8011ba8 <vfprintf+0x800> @ imm = #-0x90
 8011c36: 9b03         	ldr	r3, [sp, #0xc]
 8011c38: 4641         	mov	r1, r8
 8011c3a: 2025         	movs	r0, #0x25
 8011c3c: 4798         	blx	r3
 8011c3e: 2800         	cmp	r0, #0x0
 8011c40: f6ff abcf    	blt.w	0x80113e2 <vfprintf+0x3a> @ imm = #-0x862
 8011c44: 9b03         	ldr	r3, [sp, #0xc]
 8011c46: 4641         	mov	r1, r8
 8011c48: 4638         	mov	r0, r7
 8011c4a: 4798         	blx	r3
 8011c4c: 2800         	cmp	r0, #0x0
 8011c4e: f6ff abc8    	blt.w	0x80113e2 <vfprintf+0x3a> @ imm = #-0x870
 8011c52: 3502         	adds	r5, #0x2
 8011c54: 9b07         	ldr	r3, [sp, #0x1c]
 8011c56: f7ff bbb5    	b.w	0x80113c4 <vfprintf+0x1c> @ imm = #-0x896
 8011c5a: 2308         	movs	r3, #0x8
 8011c5c: 2700         	movs	r7, #0x0
 8011c5e: e7a3         	b	0x8011ba8 <vfprintf+0x800> @ imm = #-0xba
 8011c60: 1d11         	adds	r1, r2, #0x4
 8011c62: 910d         	str	r1, [sp, #0x34]
 8011c64: f41b 7180    	ands	r1, r11, #0x100
 8011c68: 6810         	ldr	r0, [r2]
 8011c6a: d0b0         	beq	0x8011bce <vfprintf+0x826> @ imm = #-0xa0
 8011c6c: f41b 7100    	ands	r1, r11, #0x200
 8011c70: bf1a         	itte	ne
 8011c72: b2c0         	uxtbne	r0, r0
 8011c74: 4621         	movne	r1, r4
 8011c76: b280         	uxtheq	r0, r0
 8011c78: e7a9         	b	0x8011bce <vfprintf+0x826> @ imm = #-0xae
 8011c7a: f02b 0b06    	bic	r11, r11, #0x6
 8011c7e: fa1f f98b    	uxth.w	r9, r11
 8011c82: f10d 0b38    	add.w	r11, sp, #0x38
 8011c86: e745         	b	0x8011b14 <vfprintf+0x76c> @ imm = #-0x176
 8011c88: f029 0911    	bic	r9, r9, #0x11
 8011c8c: fa1f f989    	uxth.w	r9, r9
 8011c90: 4634         	mov	r4, r6
 8011c92: e77c         	b	0x8011b8e <vfprintf+0x7e6> @ imm = #-0x108
 8011c94: 4691         	mov	r9, r2
 8011c96: e7ab         	b	0x8011bf0 <vfprintf+0x848> @ imm = #-0xaa
 8011c98: 465c         	mov	r4, r11
 8011c9a: e751         	b	0x8011b40 <vfprintf+0x798> @ imm = #-0x15e
 8011c9c: 465c         	mov	r4, r11
 8011c9e: e776         	b	0x8011b8e <vfprintf+0x7e6> @ imm = #-0x114
 8011ca0: e9cd 2304    	strd	r2, r3, [sp, #16]
 8011ca4: 4641         	mov	r1, r8
 8011ca6: 9b03         	ldr	r3, [sp, #0xc]
 8011ca8: 2020         	movs	r0, #0x20
 8011caa: 4798         	blx	r3
 8011cac: 2800         	cmp	r0, #0x0
 8011cae: f6ff ab98    	blt.w	0x80113e2 <vfprintf+0x3a> @ imm = #-0x8d0
 8011cb2: 9a04         	ldr	r2, [sp, #0x10]
 8011cb4: 9b05         	ldr	r3, [sp, #0x14]
 8011cb6: 3201         	adds	r2, #0x1
 8011cb8: 4592         	cmp	r10, r2
 8011cba: dcf1         	bgt	0x8011ca0 <vfprintf+0x8f8> @ imm = #-0x1e
 8011cbc: 1b2c         	subs	r4, r5, r4
 8011cbe: 18a5         	adds	r5, r4, r2
 8011cc0: 4614         	mov	r4, r2
 8011cc2: b1f3         	cbz	r3, 0x8011d02 <vfprintf+0x95a> @ imm = #0x3c
 8011cc4: 9b03         	ldr	r3, [sp, #0xc]
 8011cc6: 4641         	mov	r1, r8
 8011cc8: 2030         	movs	r0, #0x30
 8011cca: 4798         	blx	r3
 8011ccc: 2800         	cmp	r0, #0x0
 8011cce: f6ff ab88    	blt.w	0x80113e2 <vfprintf+0x3a> @ imm = #-0x8f0
 8011cd2: b96f         	cbnz	r7, 0x8011cf0 <vfprintf+0x948> @ imm = #0x1a
 8011cd4: 3501         	adds	r5, #0x1
 8011cd6: 46a9         	mov	r9, r5
 8011cd8: 442e         	add	r6, r5
 8011cda: eba6 0309    	sub.w	r3, r6, r9
 8011cde: 455b         	cmp	r3, r11
 8011ce0: dc21         	bgt	0x8011d26 <vfprintf+0x97e> @ imm = #0x42
 8011ce2: 465d         	mov	r5, r11
 8011ce4: ae0e         	add	r6, sp, #0x38
 8011ce6: bb5d         	cbnz	r5, 0x8011d40 <vfprintf+0x998> @ imm = #0x56
 8011ce8: 44d9         	add	r9, r11
 8011cea: e6c3         	b	0x8011a74 <vfprintf+0x6cc> @ imm = #-0x27a
 8011cec: 465e         	mov	r6, r11
 8011cee: e793         	b	0x8011c18 <vfprintf+0x870> @ imm = #-0xda
 8011cf0: 3502         	adds	r5, #0x2
 8011cf2: 4641         	mov	r1, r8
 8011cf4: 4638         	mov	r0, r7
 8011cf6: 9b03         	ldr	r3, [sp, #0xc]
 8011cf8: 4798         	blx	r3
 8011cfa: 2800         	cmp	r0, #0x0
 8011cfc: daeb         	bge	0x8011cd6 <vfprintf+0x92e> @ imm = #-0x2a
 8011cfe: f7ff bb70    	b.w	0x80113e2 <vfprintf+0x3a> @ imm = #-0x920
 8011d02: f240 4306    	movw	r3, #0x406
 8011d06: ea19 0f03    	tst.w	r9, r3
 8011d0a: d0e4         	beq	0x8011cd6 <vfprintf+0x92e> @ imm = #-0x38
 8011d0c: f019 0f02    	tst.w	r9, #0x2
 8011d10: bf14         	ite	ne
 8011d12: 202b         	movne	r0, #0x2b
 8011d14: 2020         	moveq	r0, #0x20
 8011d16: f419 6f80    	tst.w	r9, #0x400
 8011d1a: f105 0501    	add.w	r5, r5, #0x1
 8011d1e: 4641         	mov	r1, r8
 8011d20: bf18         	it	ne
 8011d22: 202d         	movne	r0, #0x2d
 8011d24: e7e7         	b	0x8011cf6 <vfprintf+0x94e> @ imm = #-0x32
 8011d26: 9b03         	ldr	r3, [sp, #0xc]
 8011d28: 4641         	mov	r1, r8
 8011d2a: 2030         	movs	r0, #0x30
 8011d2c: 4798         	blx	r3
 8011d2e: 2800         	cmp	r0, #0x0
 8011d30: f109 0901    	add.w	r9, r9, #0x1
 8011d34: dad1         	bge	0x8011cda <vfprintf+0x932> @ imm = #-0x5e
 8011d36: f7ff bb54    	b.w	0x80113e2 <vfprintf+0x3a> @ imm = #-0x958
 8011d3a: bf00         	nop

08011d3c <$d>:
 8011d3c: 09 0d 02 08  	.word	0x08020d09

08011d40 <$t>:
 8011d40: 3d01         	subs	r5, #0x1
 8011d42: 9b03         	ldr	r3, [sp, #0xc]
 8011d44: 5d70         	ldrb	r0, [r6, r5]
 8011d46: 4641         	mov	r1, r8
 8011d48: 4798         	blx	r3
 8011d4a: 2800         	cmp	r0, #0x0
 8011d4c: dacb         	bge	0x8011ce6 <vfprintf+0x93e> @ imm = #-0x6a
 8011d4e: f7ff bb48    	b.w	0x80113e2 <vfprintf+0x3a> @ imm = #-0x970
 8011d52: 9b03         	ldr	r3, [sp, #0xc]
 8011d54: 4641         	mov	r1, r8
 8011d56: 2020         	movs	r0, #0x20
 8011d58: 4798         	blx	r3
 8011d5a: 2800         	cmp	r0, #0x0
 8011d5c: f105 0501    	add.w	r5, r5, #0x1
 8011d60: f6ff ab3f    	blt.w	0x80113e2 <vfprintf+0x3a> @ imm = #-0x982
 8011d64: 1b63         	subs	r3, r4, r5
 8011d66: 2b00         	cmp	r3, #0x0
 8011d68: dcf3         	bgt	0x8011d52 <vfprintf+0x9aa> @ imm = #-0x1a
 8011d6a: e773         	b	0x8011c54 <vfprintf+0x8ac> @ imm = #-0x11a

08011d6c <div10>:
 8011d6c: b51f         	push	{r0, r1, r2, r3, r4, lr}
 8011d6e: ab02         	add	r3, sp, #0x8
 8011d70: 9300         	str	r3, [sp]
 8011d72: 4a07         	ldr	r2, [pc, #0x1c]         @ 0x8011d90 <div10+0x24>
 8011d74: f04f 33cc    	mov.w	r3, #0xcccccccc
 8011d78: f00b fe3f    	bl	0x801d9fa <__umul128>   @ imm = #0xbc7e
 8011d7c: e9dd 0102    	ldrd	r0, r1, [sp, #8]
 8011d80: 08c0         	lsrs	r0, r0, #0x3
 8011d82: ea40 7041    	orr.w	r0, r0, r1, lsl #29
 8011d86: 08c9         	lsrs	r1, r1, #0x3
 8011d88: b005         	add	sp, #0x14
 8011d8a: f85d fb04    	ldr	pc, [sp], #4
 8011d8e: bf00         	nop

08011d90 <$d>:
 8011d90: cd cc cc cc  	.word	0xcccccccd

08011d94 <__dtoa_engine>:
 8011d94: e92d 4ff0    	push.w	{r4, r5, r6, r7, r8, r9, r10, r11, lr}
 8011d98: b09b         	sub	sp, #0x6c
 8011d9a: 4604         	mov	r4, r0
 8011d9c: 9205         	str	r2, [sp, #0x14]
 8011d9e: 460a         	mov	r2, r1
 8011da0: 930a         	str	r3, [sp, #0x28]
 8011da2: f3c2 550a    	ubfx	r5, r2, #0x14, #0xb
 8011da6: f89d 3090    	ldrb.w	r3, [sp, #0x90]
 8011daa: 930b         	str	r3, [sp, #0x2c]
 8011dac: 0fd2         	lsrs	r2, r2, #0x1f
 8011dae: f3c1 0313    	ubfx	r3, r1, #0x0, #0x14
 8011db2: 9209         	str	r2, [sp, #0x24]
 8011db4: 0d09         	lsrs	r1, r1, #0x14
 8011db6: b97d         	cbnz	r5, 0x8011dd8 <__dtoa_engine+0x44> @ imm = #0x1e
 8011db8: ea50 0203    	orrs.w	r2, r0, r3
 8011dbc: d11b         	bne	0x8011df6 <__dtoa_engine+0x62> @ imm = #0x36
 8011dbe: 9a05         	ldr	r2, [sp, #0x14]
 8011dc0: 2330         	movs	r3, #0x30
 8011dc2: 7153         	strb	r3, [r2, #0x5]
 8011dc4: 9b09         	ldr	r3, [sp, #0x24]
 8011dc6: 6015         	str	r5, [r2]
 8011dc8: f043 0302    	orr	r3, r3, #0x2
 8011dcc: 7113         	strb	r3, [r2, #0x4]
 8011dce: 2701         	movs	r7, #0x1
 8011dd0: 4638         	mov	r0, r7
 8011dd2: b01b         	add	sp, #0x6c
 8011dd4: e8bd 8ff0    	pop.w	{r4, r5, r6, r7, r8, r9, r10, r11, pc}
 8011dd8: f240 72ff    	movw	r2, #0x7ff
 8011ddc: 4295         	cmp	r5, r2
 8011dde: d14a         	bne	0x8011e76 <__dtoa_engine+0xe2> @ imm = #0x94
 8011de0: 4303         	orrs	r3, r0
 8011de2: 9b09         	ldr	r3, [sp, #0x24]
 8011de4: 9a05         	ldr	r2, [sp, #0x14]
 8011de6: bf14         	ite	ne
 8011de8: f043 0308    	orrne	r3, r3, #0x8
 8011dec: f043 0304    	orreq	r3, r3, #0x4
 8011df0: 7113         	strb	r3, [r2, #0x4]
 8011df2: 2700         	movs	r7, #0x0
 8011df4: e7ec         	b	0x8011dd0 <__dtoa_engine+0x3c> @ imm = #-0x28
 8011df6: f000 0201    	and	r2, r0, #0x1
 8011dfa: 9208         	str	r2, [sp, #0x20]
 8011dfc: ea4f 0883    	lsl.w	r8, r3, #0x2
 8011e00: 2201         	movs	r2, #0x1
 8011e02: 4dac         	ldr	r5, [pc, #0x2b0]        @ 0x80120b4 <__dtoa_engine+0x320>
 8011e04: ea48 7890    	orr.w	r8, r8, r0, lsr #30
 8011e08: 0087         	lsls	r7, r0, #0x2
 8011e0a: 469a         	mov	r10, r3
 8011e0c: 4616         	mov	r6, r2
 8011e0e: f1c5 0b00    	rsb.w	r11, r5, #0x0
 8011e12: 4658         	mov	r0, r11
 8011e14: 9206         	str	r2, [sp, #0x18]
 8011e16: f000 fa11    	bl	0x801223c <__log10Pow5> @ imm = #0x422
 8011e1a: f1b5 3fff    	cmp.w	r5, #0xffffffff
 8011e1e: bfac         	ite	ge
 8011e20: 4681         	movge	r9, r0
 8011e22: f1a0 0901    	sublt.w	r9, r0, #0x1
 8011e26: ebab 0b09    	sub.w	r11, r11, r9
 8011e2a: eb09 0305    	add.w	r3, r9, r5
 8011e2e: 4658         	mov	r0, r11
 8011e30: 9304         	str	r3, [sp, #0x10]
 8011e32: f000 fa09    	bl	0x8012248 <__pow5bits>  @ imm = #0x412
 8011e36: a916         	add	r1, sp, #0x58
 8011e38: f1a0 057d    	sub.w	r5, r0, #0x7d
 8011e3c: 4658         	mov	r0, r11
 8011e3e: f000 fa23    	bl	0x8012288 <__double_computePow5> @ imm = #0x446
 8011e42: ab12         	add	r3, sp, #0x48
 8011e44: 9a06         	ldr	r2, [sp, #0x18]
 8011e46: 9301         	str	r3, [sp, #0x4]
 8011e48: eba9 0505    	sub.w	r5, r9, r5
 8011e4c: ab10         	add	r3, sp, #0x40
 8011e4e: 9202         	str	r2, [sp, #0x8]
 8011e50: 9300         	str	r3, [sp]
 8011e52: 4620         	mov	r0, r4
 8011e54: 462b         	mov	r3, r5
 8011e56: aa16         	add	r2, sp, #0x58
 8011e58: 4651         	mov	r1, r10
 8011e5a: f00b fd13    	bl	0x801d884 <mulShiftAll64> @ imm = #0xba26
 8011e5e: f1b9 0f01    	cmp.w	r9, #0x1
 8011e62: 4604         	mov	r4, r0
 8011e64: 460d         	mov	r5, r1
 8011e66: f200 80d2    	bhi.w	0x801200e <__dtoa_engine+0x27a> @ imm = #0x1a4
 8011e6a: 9b08         	ldr	r3, [sp, #0x20]
 8011e6c: 2b00         	cmp	r3, #0x0
 8011e6e: f040 80c5    	bne.w	0x8011ffc <__dtoa_engine+0x268> @ imm = #0x18a
 8011e72: 2701         	movs	r7, #0x1
 8011e74: e06b         	b	0x8011f4e <__dtoa_engine+0x1ba> @ imm = #0xd6
 8011e76: f443 1a80    	orr	r10, r3, #0x100000
 8011e7a: f000 0201    	and	r2, r0, #0x1
 8011e7e: ea4f 088a    	lsl.w	r8, r10, #0x2
 8011e82: 4303         	orrs	r3, r0
 8011e84: f2a5 4535    	subw	r5, r5, #0x435
 8011e88: 9208         	str	r2, [sp, #0x20]
 8011e8a: ea48 7890    	orr.w	r8, r8, r0, lsr #30
 8011e8e: ea4f 0780    	lsl.w	r7, r0, #0x2
 8011e92: d149         	bne	0x8011f28 <__dtoa_engine+0x194> @ imm = #0x92
 8011e94: f240 73fe    	movw	r3, #0x7fe
 8011e98: 4219         	tst	r1, r3
 8011e9a: bf0c         	ite	eq
 8011e9c: 2601         	moveq	r6, #0x1
 8011e9e: 2600         	movne	r6, #0x0
 8011ea0: 2d00         	cmp	r5, #0x0
 8011ea2: 4632         	mov	r2, r6
 8011ea4: dbb3         	blt	0x8011e0e <__dtoa_engine+0x7a> @ imm = #-0x9a
 8011ea6: 4628         	mov	r0, r5
 8011ea8: f000 f9c2    	bl	0x8012230 <__log10Pow2> @ imm = #0x384
 8011eac: 2d03         	cmp	r5, #0x3
 8011eae: bfc8         	it	gt
 8011eb0: 3801         	subgt	r0, #0x1
 8011eb2: 9004         	str	r0, [sp, #0x10]
 8011eb4: f000 f9c8    	bl	0x8012248 <__pow5bits>  @ imm = #0x390
 8011eb8: 9b04         	ldr	r3, [sp, #0x10]
 8011eba: 307c         	adds	r0, #0x7c
 8011ebc: 1b5d         	subs	r5, r3, r5
 8011ebe: 4405         	add	r5, r0
 8011ec0: a916         	add	r1, sp, #0x58
 8011ec2: 4618         	mov	r0, r3
 8011ec4: f000 fa54    	bl	0x8012370 <__double_computeInvPow5> @ imm = #0x4a8
 8011ec8: ab12         	add	r3, sp, #0x48
 8011eca: 9301         	str	r3, [sp, #0x4]
 8011ecc: ab10         	add	r3, sp, #0x40
 8011ece: 9300         	str	r3, [sp]
 8011ed0: 4620         	mov	r0, r4
 8011ed2: 462b         	mov	r3, r5
 8011ed4: 9602         	str	r6, [sp, #0x8]
 8011ed6: aa16         	add	r2, sp, #0x58
 8011ed8: 4651         	mov	r1, r10
 8011eda: f00b fcd3    	bl	0x801d884 <mulShiftAll64> @ imm = #0xb9a6
 8011ede: 9b04         	ldr	r3, [sp, #0x10]
 8011ee0: 2b15         	cmp	r3, #0x15
 8011ee2: 4604         	mov	r4, r0
 8011ee4: 460d         	mov	r5, r1
 8011ee6: f200 8086    	bhi.w	0x8011ff6 <__dtoa_engine+0x262> @ imm = #0x10c
 8011eea: ab14         	add	r3, sp, #0x50
 8011eec: 4a72         	ldr	r2, [pc, #0x1c8]        @ 0x80120b8 <__dtoa_engine+0x324>
 8011eee: 9300         	str	r3, [sp]
 8011ef0: 4638         	mov	r0, r7
 8011ef2: f04f 33cc    	mov.w	r3, #0xcccccccc
 8011ef6: 4641         	mov	r1, r8
 8011ef8: f00b fd7f    	bl	0x801d9fa <__umul128>   @ imm = #0xbafe
 8011efc: 9b14         	ldr	r3, [sp, #0x50]
 8011efe: 9a15         	ldr	r2, [sp, #0x54]
 8011f00: 089b         	lsrs	r3, r3, #0x2
 8011f02: ea43 7382    	orr.w	r3, r3, r2, lsl #30
 8011f06: eb03 0383    	add.w	r3, r3, r3, lsl #2
 8011f0a: 42bb         	cmp	r3, r7
 8011f0c: e9dd 9a10    	ldrd	r9, r10, [sp, #64]
 8011f10: d10c         	bne	0x8011f2c <__dtoa_engine+0x198> @ imm = #0x18
 8011f12: 4638         	mov	r0, r7
 8011f14: 4641         	mov	r1, r8
 8011f16: f000 f99f    	bl	0x8012258 <__pow5Factor> @ imm = #0x33e
 8011f1a: 9b04         	ldr	r3, [sp, #0x10]
 8011f1c: 4283         	cmp	r3, r0
 8011f1e: bf8c         	ite	hi
 8011f20: 2700         	movhi	r7, #0x0
 8011f22: 2701         	movls	r7, #0x1
 8011f24: 2600         	movs	r6, #0x0
 8011f26: e012         	b	0x8011f4e <__dtoa_engine+0x1ba> @ imm = #0x24
 8011f28: 2601         	movs	r6, #0x1
 8011f2a: e7b9         	b	0x8011ea0 <__dtoa_engine+0x10c> @ imm = #-0x8e
 8011f2c: 9b08         	ldr	r3, [sp, #0x20]
 8011f2e: 2b00         	cmp	r3, #0x0
 8011f30: d151         	bne	0x8011fd6 <__dtoa_engine+0x242> @ imm = #0xa2
 8011f32: 3f01         	subs	r7, #0x1
 8011f34: f148 31ff    	adc	r1, r8, #0xffffffff
 8011f38: 1bb8         	subs	r0, r7, r6
 8011f3a: f161 0100    	sbc	r1, r1, #0x0
 8011f3e: f000 f98b    	bl	0x8012258 <__pow5Factor> @ imm = #0x316
 8011f42: 9b04         	ldr	r3, [sp, #0x10]
 8011f44: 9f08         	ldr	r7, [sp, #0x20]
 8011f46: 4283         	cmp	r3, r0
 8011f48: bf8c         	ite	hi
 8011f4a: 2600         	movhi	r6, #0x0
 8011f4c: 2601         	movls	r6, #0x1
 8011f4e: 9b0b         	ldr	r3, [sp, #0x2c]
 8011f50: 2b00         	cmp	r3, #0x0
 8011f52: f040 8091    	bne.w	0x8012078 <__dtoa_engine+0x2e4> @ imm = #0x122
 8011f56: f8dd b028    	ldr.w	r11, [sp, #0x28]
 8011f5a: f04f 0800    	mov.w	r8, #0x0
 8011f5e: e9cd 8806    	strd	r8, r8, [sp, #24]
 8011f62: f04f 0a0a    	mov.w	r10, #0xa
 8011f66: e9dd 0110    	ldrd	r0, r1, [sp, #64]
 8011f6a: f7ff feff    	bl	0x8011d6c <div10>       @ imm = #-0x202
 8011f6e: 9b12         	ldr	r3, [sp, #0x48]
 8011f70: 930e         	str	r3, [sp, #0x38]
 8011f72: e9cd 010c    	strd	r0, r1, [sp, #48]
 8011f76: 4618         	mov	r0, r3
 8011f78: 9913         	ldr	r1, [sp, #0x4c]
 8011f7a: f7ff fef7    	bl	0x8011d6c <div10>       @ imm = #-0x212
 8011f7e: 9b0c         	ldr	r3, [sp, #0x30]
 8011f80: 9a0d         	ldr	r2, [sp, #0x34]
 8011f82: 910f         	str	r1, [sp, #0x3c]
 8011f84: 4298         	cmp	r0, r3
 8011f86: 460b         	mov	r3, r1
 8011f88: 4193         	sbcs	r3, r2
 8011f8a: 4681         	mov	r9, r0
 8011f8c: f080 808e    	bhs.w	0x80120ac <__dtoa_engine+0x318> @ imm = #0x11c
 8011f90: 4620         	mov	r0, r4
 8011f92: 4629         	mov	r1, r5
 8011f94: f7ff feea    	bl	0x8011d6c <div10>       @ imm = #-0x22c
 8011f98: 9a0e         	ldr	r2, [sp, #0x38]
 8011f9a: fb0a f309    	mul	r3, r10, r9
 8011f9e: 4293         	cmp	r3, r2
 8011fa0: bf14         	ite	ne
 8011fa2: 2600         	movne	r6, #0x0
 8011fa4: f006 0601    	andeq	r6, r6, #0x1
 8011fa8: 9b0c         	ldr	r3, [sp, #0x30]
 8011faa: 9310         	str	r3, [sp, #0x40]
 8011fac: 9b0d         	ldr	r3, [sp, #0x34]
 8011fae: e9cd 3911    	strd	r3, r9, [sp, #68]
 8011fb2: 9b0f         	ldr	r3, [sp, #0x3c]
 8011fb4: 9313         	str	r3, [sp, #0x4c]
 8011fb6: 9b07         	ldr	r3, [sp, #0x1c]
 8011fb8: f1b8 0f00    	cmp.w	r8, #0x0
 8011fbc: bf14         	ite	ne
 8011fbe: 2700         	movne	r7, #0x0
 8011fc0: f007 0701    	andeq	r7, r7, #0x1
 8011fc4: 3301         	adds	r3, #0x1
 8011fc6: fb0a 4810    	mls	r8, r10, r0, r4
 8011fca: fa5f f888    	uxtb.w	r8, r8
 8011fce: 9307         	str	r3, [sp, #0x1c]
 8011fd0: 4604         	mov	r4, r0
 8011fd2: 460d         	mov	r5, r1
 8011fd4: e7c7         	b	0x8011f66 <__dtoa_engine+0x1d2> @ imm = #-0x72
 8011fd6: 1cb8         	adds	r0, r7, #0x2
 8011fd8: f148 0100    	adc	r1, r8, #0x0
 8011fdc: f000 f93c    	bl	0x8012258 <__pow5Factor> @ imm = #0x278
 8011fe0: 9b04         	ldr	r3, [sp, #0x10]
 8011fe2: 4283         	cmp	r3, r0
 8011fe4: bf8c         	ite	hi
 8011fe6: 2000         	movhi	r0, #0x0
 8011fe8: 2001         	movls	r0, #0x1
 8011fea: ebb9 0000    	subs.w	r0, r9, r0
 8011fee: f16a 0200    	sbc	r2, r10, #0x0
 8011ff2: e9cd 0210    	strd	r0, r2, [sp, #64]
 8011ff6: 2700         	movs	r7, #0x0
 8011ff8: 463e         	mov	r6, r7
 8011ffa: e7a8         	b	0x8011f4e <__dtoa_engine+0x1ba> @ imm = #-0xb0
 8011ffc: 9b10         	ldr	r3, [sp, #0x40]
 8011ffe: 9a11         	ldr	r2, [sp, #0x44]
 8012000: 3b01         	subs	r3, #0x1
 8012002: f142 32ff    	adc	r2, r2, #0xffffffff
 8012006: e9cd 3210    	strd	r3, r2, [sp, #64]
 801200a: 2701         	movs	r7, #0x1
 801200c: e78a         	b	0x8011f24 <__dtoa_engine+0x190> @ imm = #-0xec
 801200e: f1b9 0f3e    	cmp.w	r9, #0x3e
 8012012: d8f0         	bhi	0x8011ff6 <__dtoa_engine+0x262> @ imm = #-0x20
 8012014: f04f 33ff    	mov.w	r3, #0xffffffff
 8012018: f1a9 0020    	sub.w	r0, r9, #0x20
 801201c: fa03 f209    	lsl.w	r2, r3, r9
 8012020: fa03 f000    	lsl.w	r0, r3, r0
 8012024: f1c9 0120    	rsb.w	r1, r9, #0x20
 8012028: fa23 f101    	lsr.w	r1, r3, r1
 801202c: 4302         	orrs	r2, r0
 801202e: 430a         	orrs	r2, r1
 8012030: fa03 f309    	lsl.w	r3, r3, r9
 8012034: ea27 0703    	bic.w	r7, r7, r3
 8012038: ea28 0802    	bic.w	r8, r8, r2
 801203c: ea57 0708    	orrs.w	r7, r7, r8
 8012040: bf0c         	ite	eq
 8012042: 2701         	moveq	r7, #0x1
 8012044: 2700         	movne	r7, #0x0
 8012046: e76d         	b	0x8011f24 <__dtoa_engine+0x190> @ imm = #-0x126
 8012048: fb00 fc02    	mul	r12, r0, r2
 801204c: fba1 1200    	umull	r1, r2, r1, r0
 8012050: 3301         	adds	r3, #0x1
 8012052: 4462         	add	r2, r12
 8012054: 428c         	cmp	r4, r1
 8012056: eb75 0c02    	sbcs.w	r12, r5, r2
 801205a: d2f5         	bhs	0x8012048 <__dtoa_engine+0x2b4> @ imm = #-0x16
 801205c: 9a04         	ldr	r2, [sp, #0x10]
 801205e: f8dd b028    	ldr.w	r11, [sp, #0x28]
 8012062: 4413         	add	r3, r2
 8012064: 9a25         	ldr	r2, [sp, #0x94]
 8012066: 4413         	add	r3, r2
 8012068: 0fd2         	lsrs	r2, r2, #0x1f
 801206a: 4293         	cmp	r3, r2
 801206c: bfb8         	it	lt
 801206e: 4613         	movlt	r3, r2
 8012070: 459b         	cmp	r11, r3
 8012072: bfa8         	it	ge
 8012074: 469b         	movge	r11, r3
 8012076: e770         	b	0x8011f5a <__dtoa_engine+0x1c6> @ imm = #-0x120
 8012078: 210a         	movs	r1, #0xa
 801207a: 2200         	movs	r2, #0x0
 801207c: 2301         	movs	r3, #0x1
 801207e: 4608         	mov	r0, r1
 8012080: e7e8         	b	0x8012054 <__dtoa_engine+0x2c0> @ imm = #-0x30
 8012082: fb0a f003    	mul	r0, r10, r3
 8012086: fba2 230a    	umull	r2, r3, r2, r10
 801208a: 3101         	adds	r1, #0x1
 801208c: 4403         	add	r3, r0
 801208e: 4294         	cmp	r4, r2
 8012090: eb75 0003    	sbcs.w	r0, r5, r3
 8012094: d2f5         	bhs	0x8012082 <__dtoa_engine+0x2ee> @ imm = #-0x16
 8012096: 4559         	cmp	r1, r11
 8012098: dd10         	ble	0x80120bc <__dtoa_engine+0x328> @ imm = #0x20
 801209a: f1bb 0f00    	cmp.w	r11, #0x0
 801209e: d102         	bne	0x80120a6 <__dtoa_engine+0x312> @ imm = #0x4
 80120a0: ea54 0305    	orrs.w	r3, r4, r5
 80120a4: d00a         	beq	0x80120bc <__dtoa_engine+0x328> @ imm = #0x14
 80120a6: 2301         	movs	r3, #0x1
 80120a8: 9306         	str	r3, [sp, #0x18]
 80120aa: e771         	b	0x8011f90 <__dtoa_engine+0x1fc> @ imm = #-0x11e
 80120ac: 220a         	movs	r2, #0xa
 80120ae: 2300         	movs	r3, #0x0
 80120b0: 2101         	movs	r1, #0x1
 80120b2: e7ec         	b	0x801208e <__dtoa_engine+0x2fa> @ imm = #-0x28

080120b4 <$d>:
 80120b4: cc fb ff ff  	.word	0xfffffbcc
 80120b8: cd cc cc cc  	.word	0xcccccccd

080120bc <$t>:
 80120bc: 2e00         	cmp	r6, #0x0
 80120be: d02f         	beq	0x8012120 <__dtoa_engine+0x38c> @ imm = #0x5e
 80120c0: f04f 0a0a    	mov.w	r10, #0xa
 80120c4: 9b12         	ldr	r3, [sp, #0x48]
 80120c6: 9913         	ldr	r1, [sp, #0x4c]
 80120c8: 930d         	str	r3, [sp, #0x34]
 80120ca: 4618         	mov	r0, r3
 80120cc: f7ff fe4e    	bl	0x8011d6c <div10>       @ imm = #-0x364
 80120d0: 9b0d         	ldr	r3, [sp, #0x34]
 80120d2: 910c         	str	r1, [sp, #0x30]
 80120d4: fb0a f200    	mul	r2, r10, r0
 80120d8: 429a         	cmp	r2, r3
 80120da: 4681         	mov	r9, r0
 80120dc: d120         	bne	0x8012120 <__dtoa_engine+0x38c> @ imm = #0x40
 80120de: e9dd 0110    	ldrd	r0, r1, [sp, #64]
 80120e2: f7ff fe43    	bl	0x8011d6c <div10>       @ imm = #-0x37a
 80120e6: 900e         	str	r0, [sp, #0x38]
 80120e8: 910d         	str	r1, [sp, #0x34]
 80120ea: 4620         	mov	r0, r4
 80120ec: 4629         	mov	r1, r5
 80120ee: f7ff fe3d    	bl	0x8011d6c <div10>       @ imm = #-0x386
 80120f2: 9b0d         	ldr	r3, [sp, #0x34]
 80120f4: 9a0e         	ldr	r2, [sp, #0x38]
 80120f6: 9210         	str	r2, [sp, #0x40]
 80120f8: e9cd 3911    	strd	r3, r9, [sp, #68]
 80120fc: 9b0c         	ldr	r3, [sp, #0x30]
 80120fe: 9313         	str	r3, [sp, #0x4c]
 8012100: 9b07         	ldr	r3, [sp, #0x1c]
 8012102: f1b8 0f00    	cmp.w	r8, #0x0
 8012106: bf14         	ite	ne
 8012108: 2700         	movne	r7, #0x0
 801210a: f007 0701    	andeq	r7, r7, #0x1
 801210e: 3301         	adds	r3, #0x1
 8012110: fb0a 4810    	mls	r8, r10, r0, r4
 8012114: fa5f f888    	uxtb.w	r8, r8
 8012118: 9307         	str	r3, [sp, #0x1c]
 801211a: 4604         	mov	r4, r0
 801211c: 460d         	mov	r5, r1
 801211e: e7d1         	b	0x80120c4 <__dtoa_engine+0x330> @ imm = #-0x5e
 8012120: f8dd 9010    	ldr.w	r9, [sp, #0x10]
 8012124: 9b07         	ldr	r3, [sp, #0x1c]
 8012126: 4499         	add	r9, r3
 8012128: 2f00         	cmp	r7, #0x0
 801212a: d05a         	beq	0x80121e2 <__dtoa_engine+0x44e> @ imm = #0xb4
 801212c: f1b8 0f05    	cmp.w	r8, #0x5
 8012130: d157         	bne	0x80121e2 <__dtoa_engine+0x44e> @ imm = #0xae
 8012132: f014 0301    	ands	r3, r4, #0x1
 8012136: d14a         	bne	0x80121ce <__dtoa_engine+0x43a> @ imm = #0x94
 8012138: 9a06         	ldr	r2, [sp, #0x18]
 801213a: b932         	cbnz	r2, 0x801214a <__dtoa_engine+0x3b6> @ imm = #0xc
 801213c: e9dd 2312    	ldrd	r2, r3, [sp, #72]
 8012140: 429d         	cmp	r5, r3
 8012142: bf08         	it	eq
 8012144: 4294         	cmpeq	r4, r2
 8012146: d05f         	beq	0x8012208 <__dtoa_engine+0x474> @ imm = #0xbe
 8012148: 9b06         	ldr	r3, [sp, #0x18]
 801214a: 1918         	adds	r0, r3, r4
 801214c: f04f 040a    	mov.w	r4, #0xa
 8012150: f145 0100    	adc	r1, r5, #0x0
 8012154: 2200         	movs	r2, #0x0
 8012156: 2601         	movs	r6, #0x1
 8012158: 4625         	mov	r5, r4
 801215a: 42a0         	cmp	r0, r4
 801215c: eb71 0702    	sbcs.w	r7, r1, r2
 8012160: d255         	bhs	0x801220e <__dtoa_engine+0x47a> @ imm = #0xaa
 8012162: b1eb         	cbz	r3, 0x80121a0 <__dtoa_engine+0x40c> @ imm = #0x3a
 8012164: 45b3         	cmp	r11, r6
 8012166: da1b         	bge	0x80121a0 <__dtoa_engine+0x40c> @ imm = #0x36
 8012168: 9b0b         	ldr	r3, [sp, #0x2c]
 801216a: b16b         	cbz	r3, 0x8012188 <__dtoa_engine+0x3f4> @ imm = #0x1a
 801216c: 9a25         	ldr	r2, [sp, #0x94]
 801216e: f8dd b028    	ldr.w	r11, [sp, #0x28]
 8012172: eb06 0309    	add.w	r3, r6, r9
 8012176: 4413         	add	r3, r2
 8012178: 2b01         	cmp	r3, #0x1
 801217a: bfb8         	it	lt
 801217c: 2301         	movlt	r3, #0x1
 801217e: 459b         	cmp	r11, r3
 8012180: bfa8         	it	ge
 8012182: 469b         	movge	r11, r3
 8012184: 455e         	cmp	r6, r11
 8012186: dd0b         	ble	0x80121a0 <__dtoa_engine+0x40c> @ imm = #0x16
 8012188: 3005         	adds	r0, #0x5
 801218a: f04f 020a    	mov.w	r2, #0xa
 801218e: f04f 0300    	mov.w	r3, #0x0
 8012192: f141 0100    	adc	r1, r1, #0x0
 8012196: f7ee fb41    	bl	0x800081c <__aeabi_uldivmod> @ imm = #-0x1197e
 801219a: f109 0901    	add.w	r9, r9, #0x1
 801219e: 3e01         	subs	r6, #0x1
 80121a0: 455e         	cmp	r6, r11
 80121a2: bfa8         	it	ge
 80121a4: 465e         	movge	r6, r11
 80121a6: b237         	sxth	r7, r6
 80121a8: fa0f f989    	sxth.w	r9, r9
 80121ac: 9b05         	ldr	r3, [sp, #0x14]
 80121ae: fa09 f686    	sxtah	r6, r9, r6
 80121b2: f107 0805    	add.w	r8, r7, #0x5
 80121b6: 3e01         	subs	r6, #0x1
 80121b8: 4498         	add	r8, r3
 80121ba: f04f 0900    	mov.w	r9, #0x0
 80121be: 45b9         	cmp	r9, r7
 80121c0: db2c         	blt	0x801221c <__dtoa_engine+0x488> @ imm = #0x58
 80121c2: 9b05         	ldr	r3, [sp, #0x14]
 80121c4: 461a         	mov	r2, r3
 80121c6: 601e         	str	r6, [r3]
 80121c8: 9b09         	ldr	r3, [sp, #0x24]
 80121ca: 7113         	strb	r3, [r2, #0x4]
 80121cc: e600         	b	0x8011dd0 <__dtoa_engine+0x3c> @ imm = #-0x400
 80121ce: 9b06         	ldr	r3, [sp, #0x18]
 80121d0: b92b         	cbnz	r3, 0x80121de <__dtoa_engine+0x44a> @ imm = #0xa
 80121d2: e9dd 2312    	ldrd	r2, r3, [sp, #72]
 80121d6: 429d         	cmp	r5, r3
 80121d8: bf08         	it	eq
 80121da: 4294         	cmpeq	r4, r2
 80121dc: d009         	beq	0x80121f2 <__dtoa_engine+0x45e> @ imm = #0x12
 80121de: 2301         	movs	r3, #0x1
 80121e0: e7b3         	b	0x801214a <__dtoa_engine+0x3b6> @ imm = #-0x9a
 80121e2: 9b06         	ldr	r3, [sp, #0x18]
 80121e4: b953         	cbnz	r3, 0x80121fc <__dtoa_engine+0x468> @ imm = #0x14
 80121e6: e9dd 2312    	ldrd	r2, r3, [sp, #72]
 80121ea: 429d         	cmp	r5, r3
 80121ec: bf08         	it	eq
 80121ee: 4294         	cmpeq	r4, r2
 80121f0: d104         	bne	0x80121fc <__dtoa_engine+0x468> @ imm = #0x8
 80121f2: 9b08         	ldr	r3, [sp, #0x20]
 80121f4: 2b00         	cmp	r3, #0x0
 80121f6: d1f2         	bne	0x80121de <__dtoa_engine+0x44a> @ imm = #-0x1c
 80121f8: 2e00         	cmp	r6, #0x0
 80121fa: d0f0         	beq	0x80121de <__dtoa_engine+0x44a> @ imm = #-0x20
 80121fc: f1b8 0f04    	cmp.w	r8, #0x4
 8012200: bf94         	ite	ls
 8012202: 2300         	movls	r3, #0x0
 8012204: 2301         	movhi	r3, #0x1
 8012206: e7a0         	b	0x801214a <__dtoa_engine+0x3b6> @ imm = #-0xc0
 8012208: f04f 0804    	mov.w	r8, #0x4
 801220c: e7f1         	b	0x80121f2 <__dtoa_engine+0x45e> @ imm = #-0x1e
 801220e: fb05 f702    	mul	r7, r5, r2
 8012212: fba4 4205    	umull	r4, r2, r4, r5
 8012216: 3601         	adds	r6, #0x1
 8012218: 443a         	add	r2, r7
 801221a: e79e         	b	0x801215a <__dtoa_engine+0x3c6> @ imm = #-0xc4
 801221c: 220a         	movs	r2, #0xa
 801221e: 2300         	movs	r3, #0x0
 8012220: f7ee fafc    	bl	0x800081c <__aeabi_uldivmod> @ imm = #-0x11a08
 8012224: 3230         	adds	r2, #0x30
 8012226: f808 2d01    	strb	r2, [r8, #-1]!
 801222a: f109 0901    	add.w	r9, r9, #0x1
 801222e: e7c6         	b	0x80121be <__dtoa_engine+0x42a> @ imm = #-0x74

08012230 <__log10Pow2>:
 8012230: 4b01         	ldr	r3, [pc, #0x4]          @ 0x8012238 <__log10Pow2+0x8>
 8012232: 4358         	muls	r0, r3, r0
 8012234: 0c80         	lsrs	r0, r0, #0x12
 8012236: 4770         	bx	lr

08012238 <$d>:
 8012238: 41 34 01 00  	.word	0x00013441

0801223c <__log10Pow5>:
 801223c: 4b01         	ldr	r3, [pc, #0x4]          @ 0x8012244 <__log10Pow5+0x8>
 801223e: 4358         	muls	r0, r3, r0
 8012240: 0d00         	lsrs	r0, r0, #0x14
 8012242: 4770         	bx	lr

08012244 <$d>:
 8012244: fb 2e 0b 00  	.word	0x000b2efb

08012248 <__pow5bits>:
 8012248: 4b02         	ldr	r3, [pc, #0x8]          @ 0x8012254 <__pow5bits+0xc>
 801224a: 4358         	muls	r0, r3, r0
 801224c: 0cc0         	lsrs	r0, r0, #0x13
 801224e: 3001         	adds	r0, #0x1
 8012250: 4770         	bx	lr
 8012252: bf00         	nop

08012254 <$d>:
 8012254: 4f 93 12 00  	.word	0x0012934f

08012258 <__pow5Factor>:
 8012258: 4a0a         	ldr	r2, [pc, #0x28]         @ 0x8012284 <__pow5Factor+0x2c>
 801225a: b570         	push	{r4, r5, r6, lr}
 801225c: 4603         	mov	r3, r0
 801225e: f04f 36cc    	mov.w	r6, #0xcccccccc
 8012262: 2000         	movs	r0, #0x0
 8012264: f04f 3533    	mov.w	r5, #0x33333333
 8012268: fb06 f403    	mul	r4, r6, r3
 801226c: fb02 4401    	mla	r4, r2, r1, r4
 8012270: fba3 3102    	umull	r3, r1, r3, r2
 8012274: 4421         	add	r1, r4
 8012276: 429d         	cmp	r5, r3
 8012278: eb75 0401    	sbcs.w	r4, r5, r1
 801227c: d301         	blo	0x8012282 <__pow5Factor+0x2a> @ imm = #0x2
 801227e: 3001         	adds	r0, #0x1
 8012280: e7f2         	b	0x8012268 <__pow5Factor+0x10> @ imm = #-0x1c
 8012282: bd70         	pop	{r4, r5, r6, pc}

08012284 <$d>:
 8012284: cd cc cc cc  	.word	0xcccccccd

08012288 <__double_computePow5>:
 8012288: e92d 4ff0    	push.w	{r4, r5, r6, r7, r8, r9, r10, r11, lr}
 801228c: 231a         	movs	r3, #0x1a
 801228e: 4e35         	ldr	r6, [pc, #0xd4]         @ 0x8012364 <__double_computePow5+0xdc>
 8012290: fbb0 faf3    	udiv	r10, r0, r3
 8012294: fb03 031a    	mls	r3, r3, r10, r0
 8012298: b089         	sub	sp, #0x24
 801229a: 4604         	mov	r4, r0
 801229c: 460d         	mov	r5, r1
 801229e: eb06 160a    	add.w	r6, r6, r10, lsl #4
 80122a2: b953         	cbnz	r3, 0x80122ba <__double_computePow5+0x32> @ imm = #0x14
 80122a4: e9d6 2300    	ldrd	r2, r3, [r6]
 80122a8: e9c1 2300    	strd	r2, r3, [r1]
 80122ac: e9d6 0102    	ldrd	r0, r1, [r6, #8]
 80122b0: e9c5 0102    	strd	r0, r1, [r5, #8]
 80122b4: b009         	add	sp, #0x24
 80122b6: e8bd 8ff0    	pop.w	{r4, r5, r6, r7, r8, r9, r10, r11, pc}
 80122ba: 4a2b         	ldr	r2, [pc, #0xac]         @ 0x8012368 <__double_computePow5+0xe0>
 80122bc: eb02 03c3    	add.w	r3, r2, r3, lsl #3
 80122c0: e9d3 8900    	ldrd	r8, r9, [r3]
 80122c4: ab04         	add	r3, sp, #0x10
 80122c6: 9300         	str	r3, [sp]
 80122c8: e9d6 2302    	ldrd	r2, r3, [r6, #8]
 80122cc: 4640         	mov	r0, r8
 80122ce: 4649         	mov	r1, r9
 80122d0: f00b fb93    	bl	0x801d9fa <__umul128>   @ imm = #0xb726
 80122d4: ab06         	add	r3, sp, #0x18
 80122d6: 9300         	str	r3, [sp]
 80122d8: e9d6 2300    	ldrd	r2, r3, [r6]
 80122dc: 4683         	mov	r11, r0
 80122de: 460f         	mov	r7, r1
 80122e0: 4640         	mov	r0, r8
 80122e2: 4649         	mov	r1, r9
 80122e4: f00b fb89    	bl	0x801d9fa <__umul128>   @ imm = #0xb712
 80122e8: e9dd 6206    	ldrd	r6, r2, [sp, #24]
 80122ec: eb16 060b    	adds.w	r6, r6, r11
 80122f0: eb52 0807    	adcs.w	r8, r2, r7
 80122f4: f04f 0300    	mov.w	r3, #0x0
 80122f8: bf28         	it	hs
 80122fa: 2301         	movhs	r3, #0x1
 80122fc: 4681         	mov	r9, r0
 80122fe: b133         	cbz	r3, 0x801230e <__double_computePow5+0x86> @ imm = #0xc
 8012300: 9b04         	ldr	r3, [sp, #0x10]
 8012302: 9a05         	ldr	r2, [sp, #0x14]
 8012304: 3301         	adds	r3, #0x1
 8012306: f142 0200    	adc	r2, r2, #0x0
 801230a: e9cd 3204    	strd	r3, r2, [sp, #16]
 801230e: 4620         	mov	r0, r4
 8012310: 9103         	str	r1, [sp, #0xc]
 8012312: f7ff ff99    	bl	0x8012248 <__pow5bits>  @ imm = #-0xce
 8012316: 4607         	mov	r7, r0
 8012318: 201a         	movs	r0, #0x1a
 801231a: fb00 f00a    	mul	r0, r0, r10
 801231e: f7ff ff93    	bl	0x8012248 <__pow5bits>  @ imm = #-0xda
 8012322: 1a3f         	subs	r7, r7, r0
 8012324: 4632         	mov	r2, r6
 8012326: 4643         	mov	r3, r8
 8012328: 9903         	ldr	r1, [sp, #0xc]
 801232a: 9700         	str	r7, [sp]
 801232c: 4648         	mov	r0, r9
 801232e: f00b fb7f    	bl	0x801da30 <__shiftright128> @ imm = #0xb6fe
 8012332: ea4f 1c14    	lsr.w	r12, r4, #0x4
 8012336: 4a0d         	ldr	r2, [pc, #0x34]         @ 0x801236c <__double_computePow5+0xe4>
 8012338: 0064         	lsls	r4, r4, #0x1
 801233a: f004 031e    	and	r3, r4, #0x1e
 801233e: f852 402c    	ldr.w	r4, [r2, r12, lsl #2]
 8012342: 40dc         	lsrs	r4, r3
 8012344: f004 0403    	and	r4, r4, #0x3
 8012348: 1824         	adds	r4, r4, r0
 801234a: f141 0100    	adc	r1, r1, #0x0
 801234e: e9c5 4100    	strd	r4, r1, [r5]
 8012352: e9dd 2304    	ldrd	r2, r3, [sp, #16]
 8012356: 9700         	str	r7, [sp]
 8012358: 4630         	mov	r0, r6
 801235a: 4641         	mov	r1, r8
 801235c: f00b fb68    	bl	0x801da30 <__shiftright128> @ imm = #0xb6d0
 8012360: e7a6         	b	0x80122b0 <__double_computePow5+0x28> @ imm = #-0xb4
 8012362: bf00         	nop

08012364 <$d>:
 8012364: 90 fc 01 08  	.word	0x0801fc90
 8012368: c0 fb 01 08  	.word	0x0801fbc0
 801236c: 68 07 02 08  	.word	0x08020768

08012370 <__double_computeInvPow5>:
 8012370: e92d 4ff0    	push.w	{r4, r5, r6, r7, r8, r9, r10, r11, lr}
 8012374: 271a         	movs	r7, #0x1a
 8012376: f8df a0e4    	ldr.w	r10, [pc, #0xe4]        @ 0x801245c <__double_computeInvPow5+0xec>
 801237a: f100 0519    	add.w	r5, r0, #0x19
 801237e: fbb5 f5f7    	udiv	r5, r5, r7
 8012382: 436f         	muls	r7, r5, r7
 8012384: 1a3a         	subs	r2, r7, r0
 8012386: ea4f 1b05    	lsl.w	r11, r5, #0x4
 801238a: b089         	sub	sp, #0x24
 801238c: 4604         	mov	r4, r0
 801238e: 460e         	mov	r6, r1
 8012390: eb0a 1505    	add.w	r5, r10, r5, lsl #4
 8012394: d10a         	bne	0x80123ac <__double_computeInvPow5+0x3c> @ imm = #0x14
 8012396: e9d5 2300    	ldrd	r2, r3, [r5]
 801239a: e9c1 2300    	strd	r2, r3, [r1]
 801239e: e9d5 0102    	ldrd	r0, r1, [r5, #8]
 80123a2: e9c6 0102    	strd	r0, r1, [r6, #8]
 80123a6: b009         	add	sp, #0x24
 80123a8: e8bd 8ff0    	pop.w	{r4, r5, r6, r7, r8, r9, r10, r11, pc}
 80123ac: 4b2c         	ldr	r3, [pc, #0xb0]         @ 0x8012460 <__double_computeInvPow5+0xf0>
 80123ae: eb03 03c2    	add.w	r3, r3, r2, lsl #3
 80123b2: e9d3 8900    	ldrd	r8, r9, [r3]
 80123b6: ab04         	add	r3, sp, #0x10
 80123b8: 9300         	str	r3, [sp]
 80123ba: e9d5 2302    	ldrd	r2, r3, [r5, #8]
 80123be: 4640         	mov	r0, r8
 80123c0: 4649         	mov	r1, r9
 80123c2: f00b fb1a    	bl	0x801d9fa <__umul128>   @ imm = #0xb634
 80123c6: f85a 200b    	ldr.w	r2, [r10, r11]
 80123ca: 686b         	ldr	r3, [r5, #0x4]
 80123cc: 3a01         	subs	r2, #0x1
 80123ce: e9cd 0102    	strd	r0, r1, [sp, #8]
 80123d2: a906         	add	r1, sp, #0x18
 80123d4: f163 0300    	sbc	r3, r3, #0x0
 80123d8: 9100         	str	r1, [sp]
 80123da: 4640         	mov	r0, r8
 80123dc: 4649         	mov	r1, r9
 80123de: f00b fb0c    	bl	0x801d9fa <__umul128>   @ imm = #0xb618
 80123e2: e9dd 5206    	ldrd	r5, r2, [sp, #24]
 80123e6: 468a         	mov	r10, r1
 80123e8: 9902         	ldr	r1, [sp, #0x8]
 80123ea: 186d         	adds	r5, r5, r1
 80123ec: 9903         	ldr	r1, [sp, #0xc]
 80123ee: eb52 0801    	adcs.w	r8, r2, r1
 80123f2: f04f 0300    	mov.w	r3, #0x0
 80123f6: bf28         	it	hs
 80123f8: 2301         	movhs	r3, #0x1
 80123fa: 4681         	mov	r9, r0
 80123fc: b133         	cbz	r3, 0x801240c <__double_computeInvPow5+0x9c> @ imm = #0xc
 80123fe: 9b04         	ldr	r3, [sp, #0x10]
 8012400: 9a05         	ldr	r2, [sp, #0x14]
 8012402: 3301         	adds	r3, #0x1
 8012404: f142 0200    	adc	r2, r2, #0x0
 8012408: e9cd 3204    	strd	r3, r2, [sp, #16]
 801240c: 4638         	mov	r0, r7
 801240e: f7ff ff1b    	bl	0x8012248 <__pow5bits>  @ imm = #-0x1ca
 8012412: 4607         	mov	r7, r0
 8012414: 4620         	mov	r0, r4
 8012416: f7ff ff17    	bl	0x8012248 <__pow5bits>  @ imm = #-0x1d2
 801241a: 1a3f         	subs	r7, r7, r0
 801241c: 462a         	mov	r2, r5
 801241e: 4643         	mov	r3, r8
 8012420: 9700         	str	r7, [sp]
 8012422: 4648         	mov	r0, r9
 8012424: 4651         	mov	r1, r10
 8012426: f00b fb03    	bl	0x801da30 <__shiftright128> @ imm = #0xb606
 801242a: ea4f 1c14    	lsr.w	r12, r4, #0x4
 801242e: 4a0d         	ldr	r2, [pc, #0x34]         @ 0x8012464 <__double_computeInvPow5+0xf4>
 8012430: 0064         	lsls	r4, r4, #0x1
 8012432: f004 031e    	and	r3, r4, #0x1e
 8012436: f852 402c    	ldr.w	r4, [r2, r12, lsl #2]
 801243a: 40dc         	lsrs	r4, r3
 801243c: f004 0403    	and	r4, r4, #0x3
 8012440: 3401         	adds	r4, #0x1
 8012442: 1824         	adds	r4, r4, r0
 8012444: f141 0100    	adc	r1, r1, #0x0
 8012448: e9c6 4100    	strd	r4, r1, [r6]
 801244c: e9dd 2304    	ldrd	r2, r3, [sp, #16]
 8012450: 9700         	str	r7, [sp]
 8012452: 4628         	mov	r0, r5
 8012454: 4641         	mov	r1, r8
 8012456: f00b faeb    	bl	0x801da30 <__shiftright128> @ imm = #0xb5d6
 801245a: e7a2         	b	0x80123a2 <__double_computeInvPow5+0x32> @ imm = #-0xbc

0801245c <$d>:
 801245c: 60 fd 01 08  	.word	0x0801fd60
 8012460: c0 fb 01 08  	.word	0x0801fbc0
 8012464: bc 07 02 08  	.word	0x080207bc

08012468 <acosf>:
 8012468: f020 4200    	bic	r2, r0, #0x80000000
 801246c: f1b2 5f7e    	cmp.w	r2, #0x3f800000
 8012470: b5f8         	push	{r3, r4, r5, r6, r7, lr}
 8012472: 4605         	mov	r5, r0
 8012474: d107         	bne	0x8012486 <acosf+0x1e>  @ imm = #0xe
 8012476: 2800         	cmp	r0, #0x0
 8012478: f300 8135    	bgt.w	0x80126e6 <acosf+0x27e> @ imm = #0x26a
 801247c: 499b         	ldr	r1, [pc, #0x26c]        @ 0x80126ec <acosf+0x284>
 801247e: 489c         	ldr	r0, [pc, #0x270]        @ 0x80126f0 <acosf+0x288>
 8012480: f7ed fe88    	bl	0x8000194 <__aeabi_fadd> @ imm = #-0x122f0
 8012484: bdf8         	pop	{r3, r4, r5, r6, r7, pc}
 8012486: d903         	bls	0x8012490 <acosf+0x28>  @ imm = #0x6
 8012488: e8bd 40f8    	pop.w	{r3, r4, r5, r6, r7, lr}
 801248c: f000 bd24    	b.w	0x8012ed8 <__math_invalidf> @ imm = #0xa48
 8012490: f1b2 5f7c    	cmp.w	r2, #0x3f000000
 8012494: d259         	bhs	0x801254a <acosf+0xe2>  @ imm = #0xb2
 8012496: f1b2 5f0c    	cmp.w	r2, #0x23000000
 801249a: d802         	bhi	0x80124a2 <acosf+0x3a>  @ imm = #0x4
 801249c: 4995         	ldr	r1, [pc, #0x254]        @ 0x80126f4 <acosf+0x28c>
 801249e: 4896         	ldr	r0, [pc, #0x258]        @ 0x80126f8 <acosf+0x290>
 80124a0: e7ee         	b	0x8012480 <acosf+0x18>  @ imm = #-0x24
 80124a2: 4601         	mov	r1, r0
 80124a4: f7ed ff7e    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x12104
 80124a8: 4994         	ldr	r1, [pc, #0x250]        @ 0x80126fc <acosf+0x294>
 80124aa: 4604         	mov	r4, r0
 80124ac: f7ed ff7a    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x1210c
 80124b0: 4993         	ldr	r1, [pc, #0x24c]        @ 0x8012700 <acosf+0x298>
 80124b2: f7ed fe6f    	bl	0x8000194 <__aeabi_fadd> @ imm = #-0x12322
 80124b6: 4621         	mov	r1, r4
 80124b8: f7ed ff74    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x12118
 80124bc: 4991         	ldr	r1, [pc, #0x244]        @ 0x8012704 <acosf+0x29c>
 80124be: f7ed fe67    	bl	0x8000190 <__subsf3>    @ imm = #-0x12332
 80124c2: 4621         	mov	r1, r4
 80124c4: f7ed ff6e    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x12124
 80124c8: 498f         	ldr	r1, [pc, #0x23c]        @ 0x8012708 <acosf+0x2a0>
 80124ca: f7ed fe63    	bl	0x8000194 <__aeabi_fadd> @ imm = #-0x1233a
 80124ce: 4621         	mov	r1, r4
 80124d0: f7ed ff68    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x12130
 80124d4: 498d         	ldr	r1, [pc, #0x234]        @ 0x801270c <acosf+0x2a4>
 80124d6: f7ed fe5b    	bl	0x8000190 <__subsf3>    @ imm = #-0x1234a
 80124da: 4621         	mov	r1, r4
 80124dc: f7ed ff62    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x1213c
 80124e0: 498b         	ldr	r1, [pc, #0x22c]        @ 0x8012710 <acosf+0x2a8>
 80124e2: f7ed fe57    	bl	0x8000194 <__aeabi_fadd> @ imm = #-0x12352
 80124e6: 4621         	mov	r1, r4
 80124e8: f7ed ff5c    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x12148
 80124ec: 4989         	ldr	r1, [pc, #0x224]        @ 0x8012714 <acosf+0x2ac>
 80124ee: 4606         	mov	r6, r0
 80124f0: 4620         	mov	r0, r4
 80124f2: f7ed ff57    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x12152
 80124f6: 4988         	ldr	r1, [pc, #0x220]        @ 0x8012718 <acosf+0x2b0>
 80124f8: f7ed fe4a    	bl	0x8000190 <__subsf3>    @ imm = #-0x1236c
 80124fc: 4621         	mov	r1, r4
 80124fe: f7ed ff51    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x1215e
 8012502: 4986         	ldr	r1, [pc, #0x218]        @ 0x801271c <acosf+0x2b4>
 8012504: f7ed fe46    	bl	0x8000194 <__aeabi_fadd> @ imm = #-0x12374
 8012508: 4621         	mov	r1, r4
 801250a: f7ed ff4b    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x1216a
 801250e: 4984         	ldr	r1, [pc, #0x210]        @ 0x8012720 <acosf+0x2b8>
 8012510: f7ed fe3e    	bl	0x8000190 <__subsf3>    @ imm = #-0x12384
 8012514: 4621         	mov	r1, r4
 8012516: f7ed ff45    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x12176
 801251a: f04f 517e    	mov.w	r1, #0x3f800000
 801251e: f7ed fe39    	bl	0x8000194 <__aeabi_fadd> @ imm = #-0x1238e
 8012522: 4601         	mov	r1, r0
 8012524: 4630         	mov	r0, r6
 8012526: f7ed fff1    	bl	0x800050c <__divsf3>    @ imm = #-0x1201e
 801252a: 4629         	mov	r1, r5
 801252c: f7ed ff3a    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x1218c
 8012530: 4601         	mov	r1, r0
 8012532: 4870         	ldr	r0, [pc, #0x1c0]        @ 0x80126f4 <acosf+0x28c>
 8012534: f7ed fe2c    	bl	0x8000190 <__subsf3>    @ imm = #-0x123a8
 8012538: 4601         	mov	r1, r0
 801253a: 4628         	mov	r0, r5
 801253c: f7ed fe28    	bl	0x8000190 <__subsf3>    @ imm = #-0x123b0
 8012540: 4601         	mov	r1, r0
 8012542: 486d         	ldr	r0, [pc, #0x1b4]        @ 0x80126f8 <acosf+0x290>
 8012544: f7ed fe24    	bl	0x8000190 <__subsf3>    @ imm = #-0x123b8
 8012548: e79c         	b	0x8012484 <acosf+0x1c>  @ imm = #-0xc8
 801254a: 2800         	cmp	r0, #0x0
 801254c: da5b         	bge	0x8012606 <acosf+0x19e> @ imm = #0xb6
 801254e: f04f 517e    	mov.w	r1, #0x3f800000
 8012552: f7ed fe1f    	bl	0x8000194 <__aeabi_fadd> @ imm = #-0x123c2
 8012556: f04f 517c    	mov.w	r1, #0x3f000000
 801255a: f7ed ff23    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x121ba
 801255e: 4604         	mov	r4, r0
 8012560: f00b fa85    	bl	0x801da6e <sqrtf>       @ imm = #0xb50a
 8012564: 4965         	ldr	r1, [pc, #0x194]        @ 0x80126fc <acosf+0x294>
 8012566: 4605         	mov	r5, r0
 8012568: 4620         	mov	r0, r4
 801256a: f7ed ff1b    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x121ca
 801256e: 4964         	ldr	r1, [pc, #0x190]        @ 0x8012700 <acosf+0x298>
 8012570: f7ed fe10    	bl	0x8000194 <__aeabi_fadd> @ imm = #-0x123e0
 8012574: 4621         	mov	r1, r4
 8012576: f7ed ff15    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x121d6
 801257a: 4962         	ldr	r1, [pc, #0x188]        @ 0x8012704 <acosf+0x29c>
 801257c: f7ed fe08    	bl	0x8000190 <__subsf3>    @ imm = #-0x123f0
 8012580: 4621         	mov	r1, r4
 8012582: f7ed ff0f    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x121e2
 8012586: 4960         	ldr	r1, [pc, #0x180]        @ 0x8012708 <acosf+0x2a0>
 8012588: f7ed fe04    	bl	0x8000194 <__aeabi_fadd> @ imm = #-0x123f8
 801258c: 4621         	mov	r1, r4
 801258e: f7ed ff09    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x121ee
 8012592: 495e         	ldr	r1, [pc, #0x178]        @ 0x801270c <acosf+0x2a4>
 8012594: f7ed fdfc    	bl	0x8000190 <__subsf3>    @ imm = #-0x12408
 8012598: 4621         	mov	r1, r4
 801259a: f7ed ff03    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x121fa
 801259e: 495c         	ldr	r1, [pc, #0x170]        @ 0x8012710 <acosf+0x2a8>
 80125a0: f7ed fdf8    	bl	0x8000194 <__aeabi_fadd> @ imm = #-0x12410
 80125a4: 4621         	mov	r1, r4
 80125a6: f7ed fefd    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x12206
 80125aa: 495a         	ldr	r1, [pc, #0x168]        @ 0x8012714 <acosf+0x2ac>
 80125ac: 4606         	mov	r6, r0
 80125ae: 4620         	mov	r0, r4
 80125b0: f7ed fef8    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x12210
 80125b4: 4958         	ldr	r1, [pc, #0x160]        @ 0x8012718 <acosf+0x2b0>
 80125b6: f7ed fdeb    	bl	0x8000190 <__subsf3>    @ imm = #-0x1242a
 80125ba: 4621         	mov	r1, r4
 80125bc: f7ed fef2    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x1221c
 80125c0: 4956         	ldr	r1, [pc, #0x158]        @ 0x801271c <acosf+0x2b4>
 80125c2: f7ed fde7    	bl	0x8000194 <__aeabi_fadd> @ imm = #-0x12432
 80125c6: 4621         	mov	r1, r4
 80125c8: f7ed feec    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x12228
 80125cc: 4954         	ldr	r1, [pc, #0x150]        @ 0x8012720 <acosf+0x2b8>
 80125ce: f7ed fddf    	bl	0x8000190 <__subsf3>    @ imm = #-0x12442
 80125d2: 4621         	mov	r1, r4
 80125d4: f7ed fee6    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x12234
 80125d8: f04f 517e    	mov.w	r1, #0x3f800000
 80125dc: f7ed fdda    	bl	0x8000194 <__aeabi_fadd> @ imm = #-0x1244c
 80125e0: 4601         	mov	r1, r0
 80125e2: 4630         	mov	r0, r6
 80125e4: f7ed ff92    	bl	0x800050c <__divsf3>    @ imm = #-0x120dc
 80125e8: 4629         	mov	r1, r5
 80125ea: f7ed fedb    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x1224a
 80125ee: 4941         	ldr	r1, [pc, #0x104]        @ 0x80126f4 <acosf+0x28c>
 80125f0: f7ed fdce    	bl	0x8000190 <__subsf3>    @ imm = #-0x12464
 80125f4: 4629         	mov	r1, r5
 80125f6: f7ed fdcd    	bl	0x8000194 <__aeabi_fadd> @ imm = #-0x12466
 80125fa: 4601         	mov	r1, r0
 80125fc: f7ed fdca    	bl	0x8000194 <__aeabi_fadd> @ imm = #-0x1246c
 8012600: 4601         	mov	r1, r0
 8012602: 483b         	ldr	r0, [pc, #0xec]         @ 0x80126f0 <acosf+0x288>
 8012604: e79e         	b	0x8012544 <acosf+0xdc>  @ imm = #-0xc4
 8012606: 4601         	mov	r1, r0
 8012608: f04f 507e    	mov.w	r0, #0x3f800000
 801260c: f7ed fdc0    	bl	0x8000190 <__subsf3>    @ imm = #-0x12480
 8012610: f04f 517c    	mov.w	r1, #0x3f000000
 8012614: f7ed fec6    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x12274
 8012618: 4604         	mov	r4, r0
 801261a: f00b fa28    	bl	0x801da6e <sqrtf>       @ imm = #0xb450
 801261e: 4937         	ldr	r1, [pc, #0xdc]         @ 0x80126fc <acosf+0x294>
 8012620: 4606         	mov	r6, r0
 8012622: f420 657f    	bic	r5, r0, #0xff0
 8012626: 4620         	mov	r0, r4
 8012628: f7ed febc    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x12288
 801262c: 4934         	ldr	r1, [pc, #0xd0]         @ 0x8012700 <acosf+0x298>
 801262e: f7ed fdb1    	bl	0x8000194 <__aeabi_fadd> @ imm = #-0x1249e
 8012632: 4621         	mov	r1, r4
 8012634: f7ed feb6    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x12294
 8012638: 4932         	ldr	r1, [pc, #0xc8]         @ 0x8012704 <acosf+0x29c>
 801263a: f7ed fda9    	bl	0x8000190 <__subsf3>    @ imm = #-0x124ae
 801263e: 4621         	mov	r1, r4
 8012640: f7ed feb0    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x122a0
 8012644: 4930         	ldr	r1, [pc, #0xc0]         @ 0x8012708 <acosf+0x2a0>
 8012646: f7ed fda5    	bl	0x8000194 <__aeabi_fadd> @ imm = #-0x124b6
 801264a: 4621         	mov	r1, r4
 801264c: f7ed feaa    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x122ac
 8012650: 492e         	ldr	r1, [pc, #0xb8]         @ 0x801270c <acosf+0x2a4>
 8012652: f7ed fd9d    	bl	0x8000190 <__subsf3>    @ imm = #-0x124c6
 8012656: 4621         	mov	r1, r4
 8012658: f7ed fea4    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x122b8
 801265c: 492c         	ldr	r1, [pc, #0xb0]         @ 0x8012710 <acosf+0x2a8>
 801265e: f7ed fd99    	bl	0x8000194 <__aeabi_fadd> @ imm = #-0x124ce
 8012662: 4621         	mov	r1, r4
 8012664: f7ed fe9e    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x122c4
 8012668: 492a         	ldr	r1, [pc, #0xa8]         @ 0x8012714 <acosf+0x2ac>
 801266a: 4607         	mov	r7, r0
 801266c: 4620         	mov	r0, r4
 801266e: f7ed fe99    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x122ce
 8012672: 4929         	ldr	r1, [pc, #0xa4]         @ 0x8012718 <acosf+0x2b0>
 8012674: f7ed fd8c    	bl	0x8000190 <__subsf3>    @ imm = #-0x124e8
 8012678: 4621         	mov	r1, r4
 801267a: f7ed fe93    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x122da
 801267e: 4927         	ldr	r1, [pc, #0x9c]         @ 0x801271c <acosf+0x2b4>
 8012680: f7ed fd88    	bl	0x8000194 <__aeabi_fadd> @ imm = #-0x124f0
 8012684: 4621         	mov	r1, r4
 8012686: f7ed fe8d    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x122e6
 801268a: 4925         	ldr	r1, [pc, #0x94]         @ 0x8012720 <acosf+0x2b8>
 801268c: f7ed fd80    	bl	0x8000190 <__subsf3>    @ imm = #-0x12500
 8012690: 4621         	mov	r1, r4
 8012692: f7ed fe87    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x122f2
 8012696: f04f 517e    	mov.w	r1, #0x3f800000
 801269a: f7ed fd7b    	bl	0x8000194 <__aeabi_fadd> @ imm = #-0x1250a
 801269e: 4601         	mov	r1, r0
 80126a0: 4638         	mov	r0, r7
 80126a2: f7ed ff33    	bl	0x800050c <__divsf3>    @ imm = #-0x1219a
 80126a6: 4631         	mov	r1, r6
 80126a8: f7ed fe7c    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x12308
 80126ac: f025 050f    	bic	r5, r5, #0xf
 80126b0: 4607         	mov	r7, r0
 80126b2: 4629         	mov	r1, r5
 80126b4: 4628         	mov	r0, r5
 80126b6: f7ed fe75    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x12316
 80126ba: 4601         	mov	r1, r0
 80126bc: 4620         	mov	r0, r4
 80126be: f7ed fd67    	bl	0x8000190 <__subsf3>    @ imm = #-0x12532
 80126c2: 4629         	mov	r1, r5
 80126c4: 4604         	mov	r4, r0
 80126c6: 4630         	mov	r0, r6
 80126c8: f7ed fd64    	bl	0x8000194 <__aeabi_fadd> @ imm = #-0x12538
 80126cc: 4601         	mov	r1, r0
 80126ce: 4620         	mov	r0, r4
 80126d0: f7ed ff1c    	bl	0x800050c <__divsf3>    @ imm = #-0x121c8
 80126d4: 4601         	mov	r1, r0
 80126d6: 4638         	mov	r0, r7
 80126d8: f7ed fd5c    	bl	0x8000194 <__aeabi_fadd> @ imm = #-0x12548
 80126dc: 4629         	mov	r1, r5
 80126de: f7ed fd59    	bl	0x8000194 <__aeabi_fadd> @ imm = #-0x1254e
 80126e2: 4601         	mov	r1, r0
 80126e4: e6cc         	b	0x8012480 <acosf+0x18>  @ imm = #-0x268
 80126e6: 2000         	movs	r0, #0x0
 80126e8: e6cc         	b	0x8012484 <acosf+0x1c>  @ imm = #-0x268
 80126ea: bf00         	nop

080126ec <$d>:
 80126ec: 68 21 22 34  	.word	0x34222168
 80126f0: da 0f 49 40  	.word	0x40490fda
 80126f4: 68 21 a2 33  	.word	0x33a22168
 80126f8: da 0f c9 3f  	.word	0x3fc90fda
 80126fc: 08 ef 11 38  	.word	0x3811ef08
 8012700: 04 7f 4f 3a  	.word	0x3a4f7f04
 8012704: 46 11 24 3d  	.word	0x3d241146
 8012708: a8 0a 4e 3e  	.word	0x3e4e0aa8
 801270c: 90 b0 a6 3e  	.word	0x3ea6b090
 8012710: ab aa 2a 3e  	.word	0x3e2aaaab
 8012714: 2e c6 9d 3d  	.word	0x3d9dc62e
 8012718: 61 33 30 3f  	.word	0x3f303361
 801271c: 2d 57 01 40  	.word	0x4001572d
 8012720: 39 d1 19 40  	.word	0x4019d139

08012724 <asinf>:
 8012724: e92d 47f0    	push.w	{r4, r5, r6, r7, r8, r9, r10, lr}
 8012728: f020 4800    	bic	r8, r0, #0x80000000
 801272c: f1b8 5f7e    	cmp.w	r8, #0x3f800000
 8012730: 4604         	mov	r4, r0
 8012732: 4605         	mov	r5, r0
 8012734: d10d         	bne	0x8012752 <asinf+0x2e>  @ imm = #0x1a
 8012736: 498a         	ldr	r1, [pc, #0x228]        @ 0x8012960 <asinf+0x23c>
 8012738: f7ed fe34    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x12398
 801273c: 4989         	ldr	r1, [pc, #0x224]        @ 0x8012964 <asinf+0x240>
 801273e: 4605         	mov	r5, r0
 8012740: 4620         	mov	r0, r4
 8012742: f7ed fe2f    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x123a2
 8012746: 4601         	mov	r1, r0
 8012748: 4628         	mov	r0, r5
 801274a: f7ed fd23    	bl	0x8000194 <__aeabi_fadd> @ imm = #-0x125ba
 801274e: 4604         	mov	r4, r0
 8012750: e013         	b	0x801277a <asinf+0x56>  @ imm = #0x26
 8012752: d903         	bls	0x801275c <asinf+0x38>  @ imm = #0x6
 8012754: e8bd 47f0    	pop.w	{r4, r5, r6, r7, r8, r9, r10, lr}
 8012758: f000 bbbe    	b.w	0x8012ed8 <__math_invalidf> @ imm = #0x77c
 801275c: f1b8 5f7c    	cmp.w	r8, #0x3f000000
 8012760: d258         	bhs	0x8012814 <asinf+0xf0>  @ imm = #0xb0
 8012762: f1b8 5f48    	cmp.w	r8, #0x32000000
 8012766: d20b         	bhs	0x8012780 <asinf+0x5c>  @ imm = #0x16
 8012768: 497f         	ldr	r1, [pc, #0x1fc]        @ 0x8012968 <asinf+0x244>
 801276a: f7ed fd13    	bl	0x8000194 <__aeabi_fadd> @ imm = #-0x125da
 801276e: f04f 517e    	mov.w	r1, #0x3f800000
 8012772: f7ed ffd3    	bl	0x800071c <__aeabi_fcmpgt> @ imm = #-0x1205a
 8012776: 2800         	cmp	r0, #0x0
 8012778: d04c         	beq	0x8012814 <asinf+0xf0>  @ imm = #0x98
 801277a: 4620         	mov	r0, r4
 801277c: e8bd 87f0    	pop.w	{r4, r5, r6, r7, r8, r9, r10, pc}
 8012780: 4601         	mov	r1, r0
 8012782: f7ed fe0f    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x123e2
 8012786: 4979         	ldr	r1, [pc, #0x1e4]        @ 0x801296c <asinf+0x248>
 8012788: 4605         	mov	r5, r0
 801278a: f7ed fe0b    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x123ea
 801278e: 4978         	ldr	r1, [pc, #0x1e0]        @ 0x8012970 <asinf+0x24c>
 8012790: f7ed fd00    	bl	0x8000194 <__aeabi_fadd> @ imm = #-0x12600
 8012794: 4629         	mov	r1, r5
 8012796: f7ed fe05    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x123f6
 801279a: 4976         	ldr	r1, [pc, #0x1d8]        @ 0x8012974 <asinf+0x250>
 801279c: f7ed fcf8    	bl	0x8000190 <__subsf3>    @ imm = #-0x12610
 80127a0: 4629         	mov	r1, r5
 80127a2: f7ed fdff    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x12402
 80127a6: 4974         	ldr	r1, [pc, #0x1d0]        @ 0x8012978 <asinf+0x254>
 80127a8: f7ed fcf4    	bl	0x8000194 <__aeabi_fadd> @ imm = #-0x12618
 80127ac: 4629         	mov	r1, r5
 80127ae: f7ed fdf9    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x1240e
 80127b2: 4972         	ldr	r1, [pc, #0x1c8]        @ 0x801297c <asinf+0x258>
 80127b4: f7ed fcec    	bl	0x8000190 <__subsf3>    @ imm = #-0x12628
 80127b8: 4629         	mov	r1, r5
 80127ba: f7ed fdf3    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x1241a
 80127be: 4970         	ldr	r1, [pc, #0x1c0]        @ 0x8012980 <asinf+0x25c>
 80127c0: f7ed fce8    	bl	0x8000194 <__aeabi_fadd> @ imm = #-0x12630
 80127c4: 4629         	mov	r1, r5
 80127c6: f7ed fded    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x12426
 80127ca: 496e         	ldr	r1, [pc, #0x1b8]        @ 0x8012984 <asinf+0x260>
 80127cc: 4606         	mov	r6, r0
 80127ce: 4628         	mov	r0, r5
 80127d0: f7ed fde8    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x12430
 80127d4: 496c         	ldr	r1, [pc, #0x1b0]        @ 0x8012988 <asinf+0x264>
 80127d6: f7ed fcdb    	bl	0x8000190 <__subsf3>    @ imm = #-0x1264a
 80127da: 4629         	mov	r1, r5
 80127dc: f7ed fde2    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x1243c
 80127e0: 496a         	ldr	r1, [pc, #0x1a8]        @ 0x801298c <asinf+0x268>
 80127e2: f7ed fcd7    	bl	0x8000194 <__aeabi_fadd> @ imm = #-0x12652
 80127e6: 4629         	mov	r1, r5
 80127e8: f7ed fddc    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x12448
 80127ec: 4968         	ldr	r1, [pc, #0x1a0]        @ 0x8012990 <asinf+0x26c>
 80127ee: f7ed fccf    	bl	0x8000190 <__subsf3>    @ imm = #-0x12662
 80127f2: 4629         	mov	r1, r5
 80127f4: f7ed fdd6    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x12454
 80127f8: f04f 517e    	mov.w	r1, #0x3f800000
 80127fc: f7ed fcca    	bl	0x8000194 <__aeabi_fadd> @ imm = #-0x1266c
 8012800: 4601         	mov	r1, r0
 8012802: 4630         	mov	r0, r6
 8012804: f7ed fe82    	bl	0x800050c <__divsf3>    @ imm = #-0x122fc
 8012808: 4621         	mov	r1, r4
 801280a: f7ed fdcb    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x1246a
 801280e: 4601         	mov	r1, r0
 8012810: 4620         	mov	r0, r4
 8012812: e79a         	b	0x801274a <asinf+0x26>  @ imm = #-0xcc
 8012814: f024 4100    	bic	r1, r4, #0x80000000
 8012818: f04f 507e    	mov.w	r0, #0x3f800000
 801281c: f7ed fcb8    	bl	0x8000190 <__subsf3>    @ imm = #-0x12690
 8012820: f04f 517c    	mov.w	r1, #0x3f000000
 8012824: f7ed fdbe    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x12484
 8012828: 4950         	ldr	r1, [pc, #0x140]        @ 0x801296c <asinf+0x248>
 801282a: 4606         	mov	r6, r0
 801282c: f7ed fdba    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x1248c
 8012830: 494f         	ldr	r1, [pc, #0x13c]        @ 0x8012970 <asinf+0x24c>
 8012832: f7ed fcaf    	bl	0x8000194 <__aeabi_fadd> @ imm = #-0x126a2
 8012836: 4631         	mov	r1, r6
 8012838: f7ed fdb4    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x12498
 801283c: 494d         	ldr	r1, [pc, #0x134]        @ 0x8012974 <asinf+0x250>
 801283e: f7ed fca7    	bl	0x8000190 <__subsf3>    @ imm = #-0x126b2
 8012842: 4631         	mov	r1, r6
 8012844: f7ed fdae    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x124a4
 8012848: 494b         	ldr	r1, [pc, #0x12c]        @ 0x8012978 <asinf+0x254>
 801284a: f7ed fca3    	bl	0x8000194 <__aeabi_fadd> @ imm = #-0x126ba
 801284e: 4631         	mov	r1, r6
 8012850: f7ed fda8    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x124b0
 8012854: 4949         	ldr	r1, [pc, #0x124]        @ 0x801297c <asinf+0x258>
 8012856: f7ed fc9b    	bl	0x8000190 <__subsf3>    @ imm = #-0x126ca
 801285a: 4631         	mov	r1, r6
 801285c: f7ed fda2    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x124bc
 8012860: 4947         	ldr	r1, [pc, #0x11c]        @ 0x8012980 <asinf+0x25c>
 8012862: f7ed fc97    	bl	0x8000194 <__aeabi_fadd> @ imm = #-0x126d2
 8012866: 4631         	mov	r1, r6
 8012868: f7ed fd9c    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x124c8
 801286c: 4945         	ldr	r1, [pc, #0x114]        @ 0x8012984 <asinf+0x260>
 801286e: 4681         	mov	r9, r0
 8012870: 4630         	mov	r0, r6
 8012872: f7ed fd97    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x124d2
 8012876: 4944         	ldr	r1, [pc, #0x110]        @ 0x8012988 <asinf+0x264>
 8012878: f7ed fc8a    	bl	0x8000190 <__subsf3>    @ imm = #-0x126ec
 801287c: 4631         	mov	r1, r6
 801287e: f7ed fd91    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x124de
 8012882: 4942         	ldr	r1, [pc, #0x108]        @ 0x801298c <asinf+0x268>
 8012884: f7ed fc86    	bl	0x8000194 <__aeabi_fadd> @ imm = #-0x126f4
 8012888: 4631         	mov	r1, r6
 801288a: f7ed fd8b    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x124ea
 801288e: 4940         	ldr	r1, [pc, #0x100]        @ 0x8012990 <asinf+0x26c>
 8012890: f7ed fc7e    	bl	0x8000190 <__subsf3>    @ imm = #-0x12704
 8012894: 4631         	mov	r1, r6
 8012896: f7ed fd85    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x124f6
 801289a: f04f 517e    	mov.w	r1, #0x3f800000
 801289e: f7ed fc79    	bl	0x8000194 <__aeabi_fadd> @ imm = #-0x1270e
 80128a2: 4682         	mov	r10, r0
 80128a4: 4630         	mov	r0, r6
 80128a6: f00b f8e2    	bl	0x801da6e <sqrtf>       @ imm = #0xb1c4
 80128aa: 4b3a         	ldr	r3, [pc, #0xe8]         @ 0x8012994 <asinf+0x270>
 80128ac: 4598         	cmp	r8, r3
 80128ae: 4607         	mov	r7, r0
 80128b0: d919         	bls	0x80128e6 <asinf+0x1c2> @ imm = #0x32
 80128b2: 4651         	mov	r1, r10
 80128b4: 4648         	mov	r0, r9
 80128b6: f7ed fe29    	bl	0x800050c <__divsf3>    @ imm = #-0x123ae
 80128ba: 4639         	mov	r1, r7
 80128bc: f7ed fd72    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x1251c
 80128c0: 4639         	mov	r1, r7
 80128c2: f7ed fc67    	bl	0x8000194 <__aeabi_fadd> @ imm = #-0x12732
 80128c6: 4601         	mov	r1, r0
 80128c8: f7ed fc64    	bl	0x8000194 <__aeabi_fadd> @ imm = #-0x12738
 80128cc: 4932         	ldr	r1, [pc, #0xc8]         @ 0x8012998 <asinf+0x274>
 80128ce: f7ed fc61    	bl	0x8000194 <__aeabi_fadd> @ imm = #-0x1273e
 80128d2: 4601         	mov	r1, r0
 80128d4: 4822         	ldr	r0, [pc, #0x88]         @ 0x8012960 <asinf+0x23c>
 80128d6: f7ed fc5b    	bl	0x8000190 <__subsf3>    @ imm = #-0x1274a
 80128da: 2d00         	cmp	r5, #0x0
 80128dc: 4604         	mov	r4, r0
 80128de: bfd8         	it	le
 80128e0: f100 4400    	addle.w	r4, r0, #0x80000000
 80128e4: e749         	b	0x801277a <asinf+0x56>  @ imm = #-0x16e
 80128e6: 4601         	mov	r1, r0
 80128e8: f420 687f    	bic	r8, r0, #0xff0
 80128ec: f7ed fc52    	bl	0x8000194 <__aeabi_fadd> @ imm = #-0x1275c
 80128f0: 4651         	mov	r1, r10
 80128f2: 4604         	mov	r4, r0
 80128f4: 4648         	mov	r0, r9
 80128f6: f7ed fe09    	bl	0x800050c <__divsf3>    @ imm = #-0x123ee
 80128fa: 4601         	mov	r1, r0
 80128fc: 4620         	mov	r0, r4
 80128fe: f7ed fd51    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x1255e
 8012902: f028 080f    	bic	r8, r8, #0xf
 8012906: 4681         	mov	r9, r0
 8012908: 4641         	mov	r1, r8
 801290a: 4640         	mov	r0, r8
 801290c: f7ed fd4a    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x1256c
 8012910: 4601         	mov	r1, r0
 8012912: 4630         	mov	r0, r6
 8012914: f7ed fc3c    	bl	0x8000190 <__subsf3>    @ imm = #-0x12788
 8012918: 4641         	mov	r1, r8
 801291a: 4604         	mov	r4, r0
 801291c: 4638         	mov	r0, r7
 801291e: f7ed fc39    	bl	0x8000194 <__aeabi_fadd> @ imm = #-0x1278e
 8012922: 4601         	mov	r1, r0
 8012924: 4620         	mov	r0, r4
 8012926: f7ed fdf1    	bl	0x800050c <__divsf3>    @ imm = #-0x1241e
 801292a: 4601         	mov	r1, r0
 801292c: f7ed fc32    	bl	0x8000194 <__aeabi_fadd> @ imm = #-0x1279c
 8012930: 4601         	mov	r1, r0
 8012932: 480c         	ldr	r0, [pc, #0x30]         @ 0x8012964 <asinf+0x240>
 8012934: f7ed fc2c    	bl	0x8000190 <__subsf3>    @ imm = #-0x127a8
 8012938: 4601         	mov	r1, r0
 801293a: 4648         	mov	r0, r9
 801293c: f7ed fc28    	bl	0x8000190 <__subsf3>    @ imm = #-0x127b0
 8012940: 4641         	mov	r1, r8
 8012942: 4604         	mov	r4, r0
 8012944: 4640         	mov	r0, r8
 8012946: f7ed fc25    	bl	0x8000194 <__aeabi_fadd> @ imm = #-0x127b6
 801294a: 4601         	mov	r1, r0
 801294c: 4813         	ldr	r0, [pc, #0x4c]         @ 0x801299c <asinf+0x278>
 801294e: f7ed fc1f    	bl	0x8000190 <__subsf3>    @ imm = #-0x127c2
 8012952: 4601         	mov	r1, r0
 8012954: 4620         	mov	r0, r4
 8012956: f7ed fc1b    	bl	0x8000190 <__subsf3>    @ imm = #-0x127ca
 801295a: 4601         	mov	r1, r0
 801295c: 480f         	ldr	r0, [pc, #0x3c]         @ 0x801299c <asinf+0x278>
 801295e: e7ba         	b	0x80128d6 <asinf+0x1b2> @ imm = #-0x8c

08012960 <$d>:
 8012960: db 0f c9 3f  	.word	0x3fc90fdb
 8012964: 2e bd 3b b3  	.word	0xb33bbd2e
 8012968: ca f2 49 71  	.word	0x7149f2ca
 801296c: 08 ef 11 38  	.word	0x3811ef08
 8012970: 04 7f 4f 3a  	.word	0x3a4f7f04
 8012974: 46 11 24 3d  	.word	0x3d241146
 8012978: a8 0a 4e 3e  	.word	0x3e4e0aa8
 801297c: 90 b0 a6 3e  	.word	0x3ea6b090
 8012980: ab aa 2a 3e  	.word	0x3e2aaaab
 8012984: 2e c6 9d 3d  	.word	0x3d9dc62e
 8012988: 61 33 30 3f  	.word	0x3f303361
 801298c: 2d 57 01 40  	.word	0x4001572d
 8012990: 39 d1 19 40  	.word	0x4019d139
 8012994: 99 99 79 3f  	.word	0x3f799999
 8012998: 2e bd 3b 33  	.word	0x333bbd2e
 801299c: db 0f 49 3f  	.word	0x3f490fdb

080129a0 <atan2f>:
 80129a0: b5f8         	push	{r3, r4, r5, r6, r7, lr}
 80129a2: f021 4600    	bic	r6, r1, #0x80000000
 80129a6: f1b6 4fff    	cmp.w	r6, #0x7f800000
 80129aa: 4603         	mov	r3, r0
 80129ac: d805         	bhi	0x80129ba <atan2f+0x1a> @ imm = #0xa
 80129ae: f020 4200    	bic	r2, r0, #0x80000000
 80129b2: f1b2 4fff    	cmp.w	r2, #0x7f800000
 80129b6: 4607         	mov	r7, r0
 80129b8: d904         	bls	0x80129c4 <atan2f+0x24> @ imm = #0x8
 80129ba: 4618         	mov	r0, r3
 80129bc: f7ed fbea    	bl	0x8000194 <__aeabi_fadd> @ imm = #-0x1282c
 80129c0: 4603         	mov	r3, r0
 80129c2: e010         	b	0x80129e6 <atan2f+0x46> @ imm = #0x20
 80129c4: f1b1 5f7e    	cmp.w	r1, #0x3f800000
 80129c8: d103         	bne	0x80129d2 <atan2f+0x32> @ imm = #0x6
 80129ca: e8bd 40f8    	pop.w	{r3, r4, r5, r6, r7, lr}
 80129ce: f000 be25    	b.w	0x801361c <atanf>       @ imm = #0xc4a
 80129d2: 178c         	asrs	r4, r1, #0x1e
 80129d4: f004 0402    	and	r4, r4, #0x2
 80129d8: ea44 74d0    	orr.w	r4, r4, r0, lsr #31
 80129dc: b96a         	cbnz	r2, 0x80129fa <atan2f+0x5a> @ imm = #0x1a
 80129de: 2c02         	cmp	r4, #0x2
 80129e0: d003         	beq	0x80129ea <atan2f+0x4a> @ imm = #0x6
 80129e2: 2c03         	cmp	r4, #0x3
 80129e4: d004         	beq	0x80129f0 <atan2f+0x50> @ imm = #0x8
 80129e6: 4618         	mov	r0, r3
 80129e8: bdf8         	pop	{r3, r4, r5, r6, r7, pc}
 80129ea: 4935         	ldr	r1, [pc, #0xd4]         @ 0x8012ac0 <atan2f+0x120>
 80129ec: 4835         	ldr	r0, [pc, #0xd4]         @ 0x8012ac4 <atan2f+0x124>
 80129ee: e7e5         	b	0x80129bc <atan2f+0x1c> @ imm = #-0x36
 80129f0: 4933         	ldr	r1, [pc, #0xcc]         @ 0x8012ac0 <atan2f+0x120>
 80129f2: 4835         	ldr	r0, [pc, #0xd4]         @ 0x8012ac8 <atan2f+0x128>
 80129f4: f7ed fbcc    	bl	0x8000190 <__subsf3>    @ imm = #-0x12868
 80129f8: e7e2         	b	0x80129c0 <atan2f+0x20> @ imm = #-0x3c
 80129fa: b936         	cbnz	r6, 0x8012a0a <atan2f+0x6a> @ imm = #0xc
 80129fc: 2f00         	cmp	r7, #0x0
 80129fe: 4930         	ldr	r1, [pc, #0xc0]         @ 0x8012ac0 <atan2f+0x120>
 8012a00: da01         	bge	0x8012a06 <atan2f+0x66> @ imm = #0x2
 8012a02: 4832         	ldr	r0, [pc, #0xc8]         @ 0x8012acc <atan2f+0x12c>
 8012a04: e7f6         	b	0x80129f4 <atan2f+0x54> @ imm = #-0x14
 8012a06: 4832         	ldr	r0, [pc, #0xc8]         @ 0x8012ad0 <atan2f+0x130>
 8012a08: e7d8         	b	0x80129bc <atan2f+0x1c> @ imm = #-0x50
 8012a0a: f1b6 4fff    	cmp.w	r6, #0x7f800000
 8012a0e: d121         	bne	0x8012a54 <atan2f+0xb4> @ imm = #0x42
 8012a10: f1b2 4fff    	cmp.w	r2, #0x7f800000
 8012a14: d116         	bne	0x8012a44 <atan2f+0xa4> @ imm = #0x2c
 8012a16: 2c02         	cmp	r4, #0x2
 8012a18: d008         	beq	0x8012a2c <atan2f+0x8c> @ imm = #0x10
 8012a1a: 2c03         	cmp	r4, #0x3
 8012a1c: d00c         	beq	0x8012a38 <atan2f+0x98> @ imm = #0x18
 8012a1e: 2c01         	cmp	r4, #0x1
 8012a20: 4927         	ldr	r1, [pc, #0x9c]         @ 0x8012ac0 <atan2f+0x120>
 8012a22: d001         	beq	0x8012a28 <atan2f+0x88> @ imm = #0x2
 8012a24: 482b         	ldr	r0, [pc, #0xac]         @ 0x8012ad4 <atan2f+0x134>
 8012a26: e7c9         	b	0x80129bc <atan2f+0x1c> @ imm = #-0x6e
 8012a28: 482b         	ldr	r0, [pc, #0xac]         @ 0x8012ad8 <atan2f+0x138>
 8012a2a: e7e3         	b	0x80129f4 <atan2f+0x54> @ imm = #-0x3a
 8012a2c: 492b         	ldr	r1, [pc, #0xac]         @ 0x8012adc <atan2f+0x13c>
 8012a2e: 4829         	ldr	r0, [pc, #0xa4]         @ 0x8012ad4 <atan2f+0x134>
 8012a30: f7ed fcb8    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x12690
 8012a34: 4922         	ldr	r1, [pc, #0x88]         @ 0x8012ac0 <atan2f+0x120>
 8012a36: e7c1         	b	0x80129bc <atan2f+0x1c> @ imm = #-0x7e
 8012a38: 4929         	ldr	r1, [pc, #0xa4]         @ 0x8012ae0 <atan2f+0x140>
 8012a3a: 4826         	ldr	r0, [pc, #0x98]         @ 0x8012ad4 <atan2f+0x134>
 8012a3c: f7ed fcb2    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x1269c
 8012a40: 491f         	ldr	r1, [pc, #0x7c]         @ 0x8012ac0 <atan2f+0x120>
 8012a42: e7d7         	b	0x80129f4 <atan2f+0x54> @ imm = #-0x52
 8012a44: 2c02         	cmp	r4, #0x2
 8012a46: d0d0         	beq	0x80129ea <atan2f+0x4a> @ imm = #-0x60
 8012a48: 2c03         	cmp	r4, #0x3
 8012a4a: d0d1         	beq	0x80129f0 <atan2f+0x50> @ imm = #-0x5e
 8012a4c: 2c01         	cmp	r4, #0x1
 8012a4e: d033         	beq	0x8012ab8 <atan2f+0x118> @ imm = #0x66
 8012a50: 2300         	movs	r3, #0x0
 8012a52: e7c8         	b	0x80129e6 <atan2f+0x46> @ imm = #-0x70
 8012a54: f1b2 4fff    	cmp.w	r2, #0x7f800000
 8012a58: d0d0         	beq	0x80129fc <atan2f+0x5c> @ imm = #-0x60
 8012a5a: 1b92         	subs	r2, r2, r6
 8012a5c: f1b2 5ff4    	cmp.w	r2, #0x1e800000
 8012a60: ea4f 50e2    	asr.w	r0, r2, #0x17
 8012a64: db10         	blt	0x8012a88 <atan2f+0xe8> @ imm = #0x20
 8012a66: 491f         	ldr	r1, [pc, #0x7c]         @ 0x8012ae4 <atan2f+0x144>
 8012a68: 4819         	ldr	r0, [pc, #0x64]         @ 0x8012ad0 <atan2f+0x130>
 8012a6a: f7ed fb91    	bl	0x8000190 <__subsf3>    @ imm = #-0x128de
 8012a6e: 4603         	mov	r3, r0
 8012a70: 2c01         	cmp	r4, #0x1
 8012a72: d017         	beq	0x8012aa4 <atan2f+0x104> @ imm = #0x2e
 8012a74: 2c02         	cmp	r4, #0x2
 8012a76: d018         	beq	0x8012aaa <atan2f+0x10a> @ imm = #0x30
 8012a78: 2c00         	cmp	r4, #0x0
 8012a7a: d0b4         	beq	0x80129e6 <atan2f+0x46> @ imm = #-0x98
 8012a7c: 491a         	ldr	r1, [pc, #0x68]         @ 0x8012ae8 <atan2f+0x148>
 8012a7e: 4618         	mov	r0, r3
 8012a80: f7ed fb88    	bl	0x8000194 <__aeabi_fadd> @ imm = #-0x128f0
 8012a84: 490f         	ldr	r1, [pc, #0x3c]         @ 0x8012ac4 <atan2f+0x124>
 8012a86: e7b5         	b	0x80129f4 <atan2f+0x54> @ imm = #-0x96
 8012a88: 2900         	cmp	r1, #0x0
 8012a8a: da01         	bge	0x8012a90 <atan2f+0xf0> @ imm = #0x2
 8012a8c: 303c         	adds	r0, #0x3c
 8012a8e: db07         	blt	0x8012aa0 <atan2f+0x100> @ imm = #0xe
 8012a90: 4618         	mov	r0, r3
 8012a92: f7ed fd3b    	bl	0x800050c <__divsf3>    @ imm = #-0x1258a
 8012a96: f020 4000    	bic	r0, r0, #0x80000000
 8012a9a: f000 fdbf    	bl	0x801361c <atanf>       @ imm = #0xb7e
 8012a9e: e7e6         	b	0x8012a6e <atan2f+0xce> @ imm = #-0x34
 8012aa0: 2300         	movs	r3, #0x0
 8012aa2: e7e5         	b	0x8012a70 <atan2f+0xd0> @ imm = #-0x36
 8012aa4: f103 4300    	add.w	r3, r3, #0x80000000
 8012aa8: e79d         	b	0x80129e6 <atan2f+0x46> @ imm = #-0xc6
 8012aaa: 490f         	ldr	r1, [pc, #0x3c]         @ 0x8012ae8 <atan2f+0x148>
 8012aac: 4618         	mov	r0, r3
 8012aae: f7ed fb71    	bl	0x8000194 <__aeabi_fadd> @ imm = #-0x1291e
 8012ab2: 4601         	mov	r1, r0
 8012ab4: 4803         	ldr	r0, [pc, #0xc]          @ 0x8012ac4 <atan2f+0x124>
 8012ab6: e79d         	b	0x80129f4 <atan2f+0x54> @ imm = #-0xc6
 8012ab8: f04f 4300    	mov.w	r3, #0x80000000
 8012abc: e793         	b	0x80129e6 <atan2f+0x46> @ imm = #-0xda
 8012abe: bf00         	nop

08012ac0 <$d>:
 8012ac0: 60 42 a2 0d  	.word	0x0da24260
 8012ac4: db 0f 49 40  	.word	0x40490fdb
 8012ac8: db 0f 49 c0  	.word	0xc0490fdb
 8012acc: db 0f c9 bf  	.word	0xbfc90fdb
 8012ad0: db 0f c9 3f  	.word	0x3fc90fdb
 8012ad4: db 0f 49 3f  	.word	0x3f490fdb
 8012ad8: db 0f 49 bf  	.word	0xbf490fdb
 8012adc: 00 00 40 40  	.word	0x40400000
 8012ae0: 00 00 40 c0  	.word	0xc0400000
 8012ae4: 2e bd 3b 33  	.word	0x333bbd2e
 8012ae8: 2e bd bb 33  	.word	0x33bbbd2e

08012aec <cosf>:
 8012aec: b507         	push	{r0, r1, r2, lr}
 8012aee: 4a1b         	ldr	r2, [pc, #0x6c]         @ 0x8012b5c <cosf+0x70>
 8012af0: f020 4300    	bic	r3, r0, #0x80000000
 8012af4: 4293         	cmp	r3, r2
 8012af6: d805         	bhi	0x8012b04 <cosf+0x18>   @ imm = #0xa
 8012af8: 2100         	movs	r1, #0x0
 8012afa: b003         	add	sp, #0xc
 8012afc: f85d eb04    	ldr	lr, [sp], #4
 8012b00: f000 b9f2    	b.w	0x8012ee8 <__kernel_cosf> @ imm = #0x3e4
 8012b04: f1b3 4fff    	cmp.w	r3, #0x7f800000
 8012b08: d304         	blo	0x8012b14 <cosf+0x28>   @ imm = #0x8
 8012b0a: b003         	add	sp, #0xc
 8012b0c: f85d eb04    	ldr	lr, [sp], #4
 8012b10: f000 b9e2    	b.w	0x8012ed8 <__math_invalidf> @ imm = #0x3c4
 8012b14: 4669         	mov	r1, sp
 8012b16: f000 f823    	bl	0x8012b60 <__rem_pio2f> @ imm = #0x46
 8012b1a: f000 0203    	and	r2, r0, #0x3
 8012b1e: 2a01         	cmp	r2, #0x1
 8012b20: d009         	beq	0x8012b36 <cosf+0x4a>   @ imm = #0x12
 8012b22: 2a02         	cmp	r2, #0x2
 8012b24: d00e         	beq	0x8012b44 <cosf+0x58>   @ imm = #0x1c
 8012b26: b992         	cbnz	r2, 0x8012b4e <cosf+0x62> @ imm = #0x24
 8012b28: 9901         	ldr	r1, [sp, #0x4]
 8012b2a: 9800         	ldr	r0, [sp]
 8012b2c: f000 f9dc    	bl	0x8012ee8 <__kernel_cosf> @ imm = #0x3b8
 8012b30: b003         	add	sp, #0xc
 8012b32: f85d fb04    	ldr	pc, [sp], #4
 8012b36: 9901         	ldr	r1, [sp, #0x4]
 8012b38: 9800         	ldr	r0, [sp]
 8012b3a: f000 fcfd    	bl	0x8013538 <__kernel_sinf> @ imm = #0x9fa
 8012b3e: f100 4000    	add.w	r0, r0, #0x80000000
 8012b42: e7f5         	b	0x8012b30 <cosf+0x44>   @ imm = #-0x16
 8012b44: 9901         	ldr	r1, [sp, #0x4]
 8012b46: 9800         	ldr	r0, [sp]
 8012b48: f000 f9ce    	bl	0x8012ee8 <__kernel_cosf> @ imm = #0x39c
 8012b4c: e7f7         	b	0x8012b3e <cosf+0x52>   @ imm = #-0x12
 8012b4e: 9901         	ldr	r1, [sp, #0x4]
 8012b50: 9800         	ldr	r0, [sp]
 8012b52: 2201         	movs	r2, #0x1
 8012b54: f000 fcf0    	bl	0x8013538 <__kernel_sinf> @ imm = #0x9e0
 8012b58: e7ea         	b	0x8012b30 <cosf+0x44>   @ imm = #-0x2c
 8012b5a: bf00         	nop

08012b5c <$d>:
 8012b5c: d8 0f 49 3f  	.word	0x3f490fd8

08012b60 <__rem_pio2f>:
 8012b60: e92d 4ff0    	push.w	{r4, r5, r6, r7, r8, r9, r10, r11, lr}
 8012b64: 4aa4         	ldr	r2, [pc, #0x290]        @ 0x8012df8 <__rem_pio2f+0x298>
 8012b66: f020 4800    	bic	r8, r0, #0x80000000
 8012b6a: 4590         	cmp	r8, r2
 8012b6c: b087         	sub	sp, #0x1c
 8012b6e: 460c         	mov	r4, r1
 8012b70: 4681         	mov	r9, r0
 8012b72: d804         	bhi	0x8012b7e <__rem_pio2f+0x1e> @ imm = #0x8
 8012b74: 2300         	movs	r3, #0x0
 8012b76: 6008         	str	r0, [r1]
 8012b78: 604b         	str	r3, [r1, #0x4]
 8012b7a: 2500         	movs	r5, #0x0
 8012b7c: e01d         	b	0x8012bba <__rem_pio2f+0x5a> @ imm = #0x3a
 8012b7e: 4a9f         	ldr	r2, [pc, #0x27c]        @ 0x8012dfc <__rem_pio2f+0x29c>
 8012b80: 4590         	cmp	r8, r2
 8012b82: d84f         	bhi	0x8012c24 <__rem_pio2f+0xc4> @ imm = #0x9e
 8012b84: f020 4500    	bic	r5, r0, #0x80000000
 8012b88: 2800         	cmp	r0, #0x0
 8012b8a: 499d         	ldr	r1, [pc, #0x274]        @ 0x8012e00 <__rem_pio2f+0x2a0>
 8012b8c: 4f9d         	ldr	r7, [pc, #0x274]        @ 0x8012e04 <__rem_pio2f+0x2a4>
 8012b8e: f025 050f    	bic	r5, r5, #0xf
 8012b92: dd24         	ble	0x8012bde <__rem_pio2f+0x7e> @ imm = #0x48
 8012b94: f7ed fafc    	bl	0x8000190 <__subsf3>    @ imm = #-0x12a08
 8012b98: 42bd         	cmp	r5, r7
 8012b9a: 4606         	mov	r6, r0
 8012b9c: d011         	beq	0x8012bc2 <__rem_pio2f+0x62> @ imm = #0x22
 8012b9e: 499a         	ldr	r1, [pc, #0x268]        @ 0x8012e08 <__rem_pio2f+0x2a8>
 8012ba0: f7ed faf6    	bl	0x8000190 <__subsf3>    @ imm = #-0x12a14
 8012ba4: 4601         	mov	r1, r0
 8012ba6: 4605         	mov	r5, r0
 8012ba8: 4630         	mov	r0, r6
 8012baa: f7ed faf1    	bl	0x8000190 <__subsf3>    @ imm = #-0x12a1e
 8012bae: 4996         	ldr	r1, [pc, #0x258]        @ 0x8012e08 <__rem_pio2f+0x2a8>
 8012bb0: f7ed faee    	bl	0x8000190 <__subsf3>    @ imm = #-0x12a24
 8012bb4: 6025         	str	r5, [r4]
 8012bb6: 6060         	str	r0, [r4, #0x4]
 8012bb8: 2501         	movs	r5, #0x1
 8012bba: 4628         	mov	r0, r5
 8012bbc: b007         	add	sp, #0x1c
 8012bbe: e8bd 8ff0    	pop.w	{r4, r5, r6, r7, r8, r9, r10, r11, pc}
 8012bc2: 4992         	ldr	r1, [pc, #0x248]        @ 0x8012e0c <__rem_pio2f+0x2ac>
 8012bc4: f7ed fae4    	bl	0x8000190 <__subsf3>    @ imm = #-0x12a38
 8012bc8: 4991         	ldr	r1, [pc, #0x244]        @ 0x8012e10 <__rem_pio2f+0x2b0>
 8012bca: 4606         	mov	r6, r0
 8012bcc: f7ed fae0    	bl	0x8000190 <__subsf3>    @ imm = #-0x12a40
 8012bd0: 4601         	mov	r1, r0
 8012bd2: 4605         	mov	r5, r0
 8012bd4: 4630         	mov	r0, r6
 8012bd6: f7ed fadb    	bl	0x8000190 <__subsf3>    @ imm = #-0x12a4a
 8012bda: 498d         	ldr	r1, [pc, #0x234]        @ 0x8012e10 <__rem_pio2f+0x2b0>
 8012bdc: e7e8         	b	0x8012bb0 <__rem_pio2f+0x50> @ imm = #-0x30
 8012bde: f7ed fad9    	bl	0x8000194 <__aeabi_fadd> @ imm = #-0x12a4e
 8012be2: 42bd         	cmp	r5, r7
 8012be4: 4606         	mov	r6, r0
 8012be6: d00f         	beq	0x8012c08 <__rem_pio2f+0xa8> @ imm = #0x1e
 8012be8: 4987         	ldr	r1, [pc, #0x21c]        @ 0x8012e08 <__rem_pio2f+0x2a8>
 8012bea: f7ed fad3    	bl	0x8000194 <__aeabi_fadd> @ imm = #-0x12a5a
 8012bee: 4601         	mov	r1, r0
 8012bf0: 4605         	mov	r5, r0
 8012bf2: 4630         	mov	r0, r6
 8012bf4: f7ed facc    	bl	0x8000190 <__subsf3>    @ imm = #-0x12a68
 8012bf8: 4983         	ldr	r1, [pc, #0x20c]        @ 0x8012e08 <__rem_pio2f+0x2a8>
 8012bfa: f7ed facb    	bl	0x8000194 <__aeabi_fadd> @ imm = #-0x12a6a
 8012bfe: 6025         	str	r5, [r4]
 8012c00: 6060         	str	r0, [r4, #0x4]
 8012c02: f04f 35ff    	mov.w	r5, #0xffffffff
 8012c06: e7d8         	b	0x8012bba <__rem_pio2f+0x5a> @ imm = #-0x50
 8012c08: 4980         	ldr	r1, [pc, #0x200]        @ 0x8012e0c <__rem_pio2f+0x2ac>
 8012c0a: f7ed fac3    	bl	0x8000194 <__aeabi_fadd> @ imm = #-0x12a7a
 8012c0e: 4980         	ldr	r1, [pc, #0x200]        @ 0x8012e10 <__rem_pio2f+0x2b0>
 8012c10: 4606         	mov	r6, r0
 8012c12: f7ed fabf    	bl	0x8000194 <__aeabi_fadd> @ imm = #-0x12a82
 8012c16: 4601         	mov	r1, r0
 8012c18: 4605         	mov	r5, r0
 8012c1a: 4630         	mov	r0, r6
 8012c1c: f7ed fab8    	bl	0x8000190 <__subsf3>    @ imm = #-0x12a90
 8012c20: 497b         	ldr	r1, [pc, #0x1ec]        @ 0x8012e10 <__rem_pio2f+0x2b0>
 8012c22: e7ea         	b	0x8012bfa <__rem_pio2f+0x9a> @ imm = #-0x2c
 8012c24: 4a7b         	ldr	r2, [pc, #0x1ec]        @ 0x8012e14 <__rem_pio2f+0x2b4>
 8012c26: 4590         	cmp	r8, r2
 8012c28: f200 8094    	bhi.w	0x8012d54 <__rem_pio2f+0x1f4> @ imm = #0x128
 8012c2c: f020 4600    	bic	r6, r0, #0x80000000
 8012c30: 4979         	ldr	r1, [pc, #0x1e4]        @ 0x8012e18 <__rem_pio2f+0x2b8>
 8012c32: 4630         	mov	r0, r6
 8012c34: f7ed fbb6    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x12894
 8012c38: f04f 517c    	mov.w	r1, #0x3f000000
 8012c3c: f7ed faaa    	bl	0x8000194 <__aeabi_fadd> @ imm = #-0x12aac
 8012c40: f7ed fd76    	bl	0x8000730 <__fixsfsi>   @ imm = #-0x12514
 8012c44: 4605         	mov	r5, r0
 8012c46: f7ed fb59    	bl	0x80002fc <__floatsisf> @ imm = #-0x1294e
 8012c4a: 496d         	ldr	r1, [pc, #0x1b4]        @ 0x8012e00 <__rem_pio2f+0x2a0>
 8012c4c: 4682         	mov	r10, r0
 8012c4e: f7ed fba9    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x128ae
 8012c52: 4601         	mov	r1, r0
 8012c54: 4630         	mov	r0, r6
 8012c56: f7ed fa9b    	bl	0x8000190 <__subsf3>    @ imm = #-0x12aca
 8012c5a: 496b         	ldr	r1, [pc, #0x1ac]        @ 0x8012e08 <__rem_pio2f+0x2a8>
 8012c5c: 4607         	mov	r7, r0
 8012c5e: 4650         	mov	r0, r10
 8012c60: f7ed fba0    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x128c0
 8012c64: 4601         	mov	r1, r0
 8012c66: 4606         	mov	r6, r0
 8012c68: 4638         	mov	r0, r7
 8012c6a: f7ed fa91    	bl	0x8000190 <__subsf3>    @ imm = #-0x12ade
 8012c6e: 2d1f         	cmp	r5, #0x1f
 8012c70: dc09         	bgt	0x8012c86 <__rem_pio2f+0x126> @ imm = #0x12
 8012c72: 4a6a         	ldr	r2, [pc, #0x1a8]        @ 0x8012e1c <__rem_pio2f+0x2bc>
 8012c74: 1e69         	subs	r1, r5, #0x1
 8012c76: f029 4300    	bic	r3, r9, #0x80000000
 8012c7a: f852 2021    	ldr.w	r2, [r2, r1, lsl #2]
 8012c7e: f023 03ff    	bic	r3, r3, #0xff
 8012c82: 4293         	cmp	r3, r2
 8012c84: d107         	bne	0x8012c96 <__rem_pio2f+0x136> @ imm = #0xe
 8012c86: f3c0 53c7    	ubfx	r3, r0, #0x17, #0x8
 8012c8a: ebc3 53d8    	rsb	r3, r3, r8, lsr #23
 8012c8e: 2b08         	cmp	r3, #0x8
 8012c90: ea4f 5be8    	asr.w	r11, r8, #0x17
 8012c94: dc01         	bgt	0x8012c9a <__rem_pio2f+0x13a> @ imm = #0x2
 8012c96: 6020         	str	r0, [r4]
 8012c98: e026         	b	0x8012ce8 <__rem_pio2f+0x188> @ imm = #0x4c
 8012c9a: 495c         	ldr	r1, [pc, #0x170]        @ 0x8012e0c <__rem_pio2f+0x2ac>
 8012c9c: 4650         	mov	r0, r10
 8012c9e: f7ed fb81    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x128fe
 8012ca2: 4606         	mov	r6, r0
 8012ca4: 4601         	mov	r1, r0
 8012ca6: 4638         	mov	r0, r7
 8012ca8: f7ed fa72    	bl	0x8000190 <__subsf3>    @ imm = #-0x12b1c
 8012cac: 4601         	mov	r1, r0
 8012cae: 4680         	mov	r8, r0
 8012cb0: 4638         	mov	r0, r7
 8012cb2: f7ed fa6d    	bl	0x8000190 <__subsf3>    @ imm = #-0x12b26
 8012cb6: 4631         	mov	r1, r6
 8012cb8: f7ed fa6a    	bl	0x8000190 <__subsf3>    @ imm = #-0x12b2c
 8012cbc: 4954         	ldr	r1, [pc, #0x150]        @ 0x8012e10 <__rem_pio2f+0x2b0>
 8012cbe: 4606         	mov	r6, r0
 8012cc0: 4650         	mov	r0, r10
 8012cc2: f7ed fb6f    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x12922
 8012cc6: 4631         	mov	r1, r6
 8012cc8: f7ed fa62    	bl	0x8000190 <__subsf3>    @ imm = #-0x12b3c
 8012ccc: 4601         	mov	r1, r0
 8012cce: 4606         	mov	r6, r0
 8012cd0: 4640         	mov	r0, r8
 8012cd2: f7ed fa5d    	bl	0x8000190 <__subsf3>    @ imm = #-0x12b46
 8012cd6: f3c0 53c7    	ubfx	r3, r0, #0x17, #0x8
 8012cda: ebab 0b03    	sub.w	r11, r11, r3
 8012cde: f1bb 0f19    	cmp.w	r11, #0x19
 8012ce2: dc18         	bgt	0x8012d16 <__rem_pio2f+0x1b6> @ imm = #0x30
 8012ce4: 6020         	str	r0, [r4]
 8012ce6: 4647         	mov	r7, r8
 8012ce8: f8d4 8000    	ldr.w	r8, [r4]
 8012cec: 4638         	mov	r0, r7
 8012cee: 4641         	mov	r1, r8
 8012cf0: f7ed fa4e    	bl	0x8000190 <__subsf3>    @ imm = #-0x12b64
 8012cf4: 4631         	mov	r1, r6
 8012cf6: f7ed fa4b    	bl	0x8000190 <__subsf3>    @ imm = #-0x12b6a
 8012cfa: f1b9 0f00    	cmp.w	r9, #0x0
 8012cfe: 6060         	str	r0, [r4, #0x4]
 8012d00: f6bf af5b    	bge.w	0x8012bba <__rem_pio2f+0x5a> @ imm = #-0x14a
 8012d04: f108 4800    	add.w	r8, r8, #0x80000000
 8012d08: f100 4000    	add.w	r0, r0, #0x80000000
 8012d0c: f8c4 8000    	str.w	r8, [r4]
 8012d10: 6060         	str	r0, [r4, #0x4]
 8012d12: 426d         	rsbs	r5, r5, #0
 8012d14: e751         	b	0x8012bba <__rem_pio2f+0x5a> @ imm = #-0x15e
 8012d16: 4942         	ldr	r1, [pc, #0x108]        @ 0x8012e20 <__rem_pio2f+0x2c0>
 8012d18: 4650         	mov	r0, r10
 8012d1a: f7ed fb43    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x1297a
 8012d1e: 4606         	mov	r6, r0
 8012d20: 4601         	mov	r1, r0
 8012d22: 4640         	mov	r0, r8
 8012d24: f7ed fa34    	bl	0x8000190 <__subsf3>    @ imm = #-0x12b98
 8012d28: 4607         	mov	r7, r0
 8012d2a: 4601         	mov	r1, r0
 8012d2c: 4640         	mov	r0, r8
 8012d2e: f7ed fa2f    	bl	0x8000190 <__subsf3>    @ imm = #-0x12ba2
 8012d32: 4631         	mov	r1, r6
 8012d34: f7ed fa2c    	bl	0x8000190 <__subsf3>    @ imm = #-0x12ba8
 8012d38: 493a         	ldr	r1, [pc, #0xe8]         @ 0x8012e24 <__rem_pio2f+0x2c4>
 8012d3a: 4606         	mov	r6, r0
 8012d3c: 4650         	mov	r0, r10
 8012d3e: f7ed fb31    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x1299e
 8012d42: 4631         	mov	r1, r6
 8012d44: f7ed fa24    	bl	0x8000190 <__subsf3>    @ imm = #-0x12bb8
 8012d48: 4606         	mov	r6, r0
 8012d4a: 4601         	mov	r1, r0
 8012d4c: 4638         	mov	r0, r7
 8012d4e: f7ed fa1f    	bl	0x8000190 <__subsf3>    @ imm = #-0x12bc2
 8012d52: e7a0         	b	0x8012c96 <__rem_pio2f+0x136> @ imm = #-0xc0
 8012d54: f1b8 4fff    	cmp.w	r8, #0x7f800000
 8012d58: d305         	blo	0x8012d66 <__rem_pio2f+0x206> @ imm = #0xa
 8012d5a: 4601         	mov	r1, r0
 8012d5c: f7ed fa18    	bl	0x8000190 <__subsf3>    @ imm = #-0x12bd0
 8012d60: 6060         	str	r0, [r4, #0x4]
 8012d62: 6020         	str	r0, [r4]
 8012d64: e709         	b	0x8012b7a <__rem_pio2f+0x1a> @ imm = #-0x1ee
 8012d66: ea4f 56e8    	asr.w	r6, r8, #0x17
 8012d6a: 3e86         	subs	r6, #0x86
 8012d6c: eba8 58c6    	sub.w	r8, r8, r6, lsl #23
 8012d70: 4640         	mov	r0, r8
 8012d72: f7ed fcdd    	bl	0x8000730 <__fixsfsi>   @ imm = #-0x12646
 8012d76: f7ed fac1    	bl	0x80002fc <__floatsisf> @ imm = #-0x12a7e
 8012d7a: 4601         	mov	r1, r0
 8012d7c: 9003         	str	r0, [sp, #0xc]
 8012d7e: 4640         	mov	r0, r8
 8012d80: f7ed fa06    	bl	0x8000190 <__subsf3>    @ imm = #-0x12bf4
 8012d84: f04f 4187    	mov.w	r1, #0x43800000
 8012d88: f7ed fb0c    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x129e8
 8012d8c: 4607         	mov	r7, r0
 8012d8e: f7ed fccf    	bl	0x8000730 <__fixsfsi>   @ imm = #-0x12662
 8012d92: f7ed fab3    	bl	0x80002fc <__floatsisf> @ imm = #-0x12a9a
 8012d96: 4601         	mov	r1, r0
 8012d98: 9004         	str	r0, [sp, #0x10]
 8012d9a: 4605         	mov	r5, r0
 8012d9c: 4638         	mov	r0, r7
 8012d9e: f7ed f9f7    	bl	0x8000190 <__subsf3>    @ imm = #-0x12c12
 8012da2: f04f 4187    	mov.w	r1, #0x43800000
 8012da6: f7ed fafd    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x12a06
 8012daa: 2100         	movs	r1, #0x0
 8012dac: 9005         	str	r0, [sp, #0x14]
 8012dae: f7ed fc8d    	bl	0x80006cc <__aeabi_fcmpeq> @ imm = #-0x126e6
 8012db2: b1f0         	cbz	r0, 0x8012df2 <__rem_pio2f+0x292> @ imm = #0x3c
 8012db4: 2100         	movs	r1, #0x0
 8012db6: 4628         	mov	r0, r5
 8012db8: f7ed fc88    	bl	0x80006cc <__aeabi_fcmpeq> @ imm = #-0x126f0
 8012dbc: 2800         	cmp	r0, #0x0
 8012dbe: bf14         	ite	ne
 8012dc0: 2301         	movne	r3, #0x1
 8012dc2: 2302         	moveq	r3, #0x2
 8012dc4: 4a18         	ldr	r2, [pc, #0x60]         @ 0x8012e28 <__rem_pio2f+0x2c8>
 8012dc6: 9201         	str	r2, [sp, #0x4]
 8012dc8: 2202         	movs	r2, #0x2
 8012dca: 9200         	str	r2, [sp]
 8012dcc: 4621         	mov	r1, r4
 8012dce: 4632         	mov	r2, r6
 8012dd0: a803         	add	r0, sp, #0xc
 8012dd2: f000 f903    	bl	0x8012fdc <__kernel_rem_pio2f> @ imm = #0x206
 8012dd6: f1b9 0f00    	cmp.w	r9, #0x0
 8012dda: 4605         	mov	r5, r0
 8012ddc: f6bf aeed    	bge.w	0x8012bba <__rem_pio2f+0x5a> @ imm = #-0x226
 8012de0: 6823         	ldr	r3, [r4]
 8012de2: f103 4300    	add.w	r3, r3, #0x80000000
 8012de6: 6023         	str	r3, [r4]
 8012de8: 6863         	ldr	r3, [r4, #0x4]
 8012dea: f103 4300    	add.w	r3, r3, #0x80000000
 8012dee: 6063         	str	r3, [r4, #0x4]
 8012df0: e78f         	b	0x8012d12 <__rem_pio2f+0x1b2> @ imm = #-0xe2
 8012df2: 2303         	movs	r3, #0x3
 8012df4: e7e6         	b	0x8012dc4 <__rem_pio2f+0x264> @ imm = #-0x34
 8012df6: bf00         	nop

08012df8 <$d>:
 8012df8: d8 0f 49 3f  	.word	0x3f490fd8
 8012dfc: e3 cb 16 40  	.word	0x4016cbe3
 8012e00: 80 0f c9 3f  	.word	0x3fc90f80
 8012e04: d0 0f c9 3f  	.word	0x3fc90fd0
 8012e08: 43 44 35 37  	.word	0x37354443
 8012e0c: 00 44 35 37  	.word	0x37354400
 8012e10: 08 a3 85 2e  	.word	0x2e85a308
 8012e14: 80 0f 49 43  	.word	0x43490f80
 8012e18: 84 f9 22 3f  	.word	0x3f22f984
 8012e1c: 10 08 02 08  	.word	0x08020810
 8012e20: 00 a3 85 2e  	.word	0x2e85a300
 8012e24: 32 31 8d 24  	.word	0x248d3132
 8012e28: 90 08 02 08  	.word	0x08020890

08012e2c <sinf>:
 8012e2c: b507         	push	{r0, r1, r2, lr}
 8012e2e: 4a1c         	ldr	r2, [pc, #0x70]         @ 0x8012ea0 <sinf+0x74>
 8012e30: f020 4300    	bic	r3, r0, #0x80000000
 8012e34: 4293         	cmp	r3, r2
 8012e36: d806         	bhi	0x8012e46 <sinf+0x1a>   @ imm = #0xc
 8012e38: 2200         	movs	r2, #0x0
 8012e3a: 2100         	movs	r1, #0x0
 8012e3c: b003         	add	sp, #0xc
 8012e3e: f85d eb04    	ldr	lr, [sp], #4
 8012e42: f000 bb79    	b.w	0x8013538 <__kernel_sinf> @ imm = #0x6f2
 8012e46: f1b3 4fff    	cmp.w	r3, #0x7f800000
 8012e4a: d304         	blo	0x8012e56 <sinf+0x2a>   @ imm = #0x8
 8012e4c: b003         	add	sp, #0xc
 8012e4e: f85d eb04    	ldr	lr, [sp], #4
 8012e52: f000 b841    	b.w	0x8012ed8 <__math_invalidf> @ imm = #0x82
 8012e56: 4669         	mov	r1, sp
 8012e58: f7ff fe82    	bl	0x8012b60 <__rem_pio2f> @ imm = #-0x2fc
 8012e5c: f000 0003    	and	r0, r0, #0x3
 8012e60: 2801         	cmp	r0, #0x1
 8012e62: d00a         	beq	0x8012e7a <sinf+0x4e>   @ imm = #0x14
 8012e64: 2802         	cmp	r0, #0x2
 8012e66: d00d         	beq	0x8012e84 <sinf+0x58>   @ imm = #0x1a
 8012e68: b9a0         	cbnz	r0, 0x8012e94 <sinf+0x68> @ imm = #0x28
 8012e6a: 9901         	ldr	r1, [sp, #0x4]
 8012e6c: 9800         	ldr	r0, [sp]
 8012e6e: 2201         	movs	r2, #0x1
 8012e70: f000 fb62    	bl	0x8013538 <__kernel_sinf> @ imm = #0x6c4
 8012e74: b003         	add	sp, #0xc
 8012e76: f85d fb04    	ldr	pc, [sp], #4
 8012e7a: 9901         	ldr	r1, [sp, #0x4]
 8012e7c: 9800         	ldr	r0, [sp]
 8012e7e: f000 f833    	bl	0x8012ee8 <__kernel_cosf> @ imm = #0x66
 8012e82: e7f7         	b	0x8012e74 <sinf+0x48>   @ imm = #-0x12
 8012e84: 9901         	ldr	r1, [sp, #0x4]
 8012e86: 9800         	ldr	r0, [sp]
 8012e88: 2201         	movs	r2, #0x1
 8012e8a: f000 fb55    	bl	0x8013538 <__kernel_sinf> @ imm = #0x6aa
 8012e8e: f100 4000    	add.w	r0, r0, #0x80000000
 8012e92: e7ef         	b	0x8012e74 <sinf+0x48>   @ imm = #-0x22
 8012e94: 9901         	ldr	r1, [sp, #0x4]
 8012e96: 9800         	ldr	r0, [sp]
 8012e98: f000 f826    	bl	0x8012ee8 <__kernel_cosf> @ imm = #0x4c
 8012e9c: e7f7         	b	0x8012e8e <sinf+0x62>   @ imm = #-0x12
 8012e9e: bf00         	nop

08012ea0 <$d>:
 8012ea0: d8 0f 49 3f  	.word	0x3f490fd8

08012ea4 <__fpclassifyf>:
 8012ea4: f030 4000    	bics	r0, r0, #0x80000000
 8012ea8: d00d         	beq	0x8012ec6 <__fpclassifyf+0x22> @ imm = #0x1a
 8012eaa: f5a0 0300    	sub.w	r3, r0, #0x800000
 8012eae: f1b3 4ffe    	cmp.w	r3, #0x7f000000
 8012eb2: d30a         	blo	0x8012eca <__fpclassifyf+0x26> @ imm = #0x14
 8012eb4: 4b07         	ldr	r3, [pc, #0x1c]         @ 0x8012ed4 <__fpclassifyf+0x30>
 8012eb6: 1e42         	subs	r2, r0, #0x1
 8012eb8: 429a         	cmp	r2, r3
 8012eba: d908         	bls	0x8012ece <__fpclassifyf+0x2a> @ imm = #0x10
 8012ebc: f1a0 43ff    	sub.w	r3, r0, #0x7f800000
 8012ec0: 4258         	rsbs	r0, r3, #0
 8012ec2: 4158         	adcs	r0, r3
 8012ec4: 4770         	bx	lr
 8012ec6: 2002         	movs	r0, #0x2
 8012ec8: 4770         	bx	lr
 8012eca: 2004         	movs	r0, #0x4
 8012ecc: 4770         	bx	lr
 8012ece: 2003         	movs	r0, #0x3
 8012ed0: 4770         	bx	lr
 8012ed2: bf00         	nop

08012ed4 <$d>:
 8012ed4: fe ff 7f 00  	.word	0x007ffffe

08012ed8 <__math_invalidf>:
 8012ed8: b508         	push	{r3, lr}
 8012eda: f7ff ffe3    	bl	0x8012ea4 <__fpclassifyf> @ imm = #-0x3a
 8012ede: 4801         	ldr	r0, [pc, #0x4]          @ 0x8012ee4 <__math_invalidf+0xc>
 8012ee0: bd08         	pop	{r3, pc}
 8012ee2: bf00         	nop

08012ee4 <$d>:
 8012ee4: 00 00 c0 7f  	.word	0x7fc00000

08012ee8 <__kernel_cosf>:
 8012ee8: e92d 41f0    	push.w	{r4, r5, r6, r7, r8, lr}
 8012eec: f020 4500    	bic	r5, r0, #0x80000000
 8012ef0: f1b5 5f48    	cmp.w	r5, #0x32000000
 8012ef4: 4606         	mov	r6, r0
 8012ef6: 4688         	mov	r8, r1
 8012ef8: d35b         	blo	0x8012fb2 <__kernel_cosf+0xca> @ imm = #0xb6
 8012efa: 4601         	mov	r1, r0
 8012efc: f7ed fa52    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x12b5c
 8012f00: f04f 517c    	mov.w	r1, #0x3f000000
 8012f04: 4604         	mov	r4, r0
 8012f06: f7ed fa4d    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x12b66
 8012f0a: 492b         	ldr	r1, [pc, #0xac]         @ 0x8012fb8 <__kernel_cosf+0xd0>
 8012f0c: 4607         	mov	r7, r0
 8012f0e: 4620         	mov	r0, r4
 8012f10: f7ed fa48    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x12b70
 8012f14: 4929         	ldr	r1, [pc, #0xa4]         @ 0x8012fbc <__kernel_cosf+0xd4>
 8012f16: f7ed f93d    	bl	0x8000194 <__aeabi_fadd> @ imm = #-0x12d86
 8012f1a: 4621         	mov	r1, r4
 8012f1c: f7ed fa42    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x12b7c
 8012f20: 4927         	ldr	r1, [pc, #0x9c]         @ 0x8012fc0 <__kernel_cosf+0xd8>
 8012f22: f7ed f935    	bl	0x8000190 <__subsf3>    @ imm = #-0x12d96
 8012f26: 4621         	mov	r1, r4
 8012f28: f7ed fa3c    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x12b88
 8012f2c: 4925         	ldr	r1, [pc, #0x94]         @ 0x8012fc4 <__kernel_cosf+0xdc>
 8012f2e: f7ed f931    	bl	0x8000194 <__aeabi_fadd> @ imm = #-0x12d9e
 8012f32: 4621         	mov	r1, r4
 8012f34: f7ed fa36    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x12b94
 8012f38: 4923         	ldr	r1, [pc, #0x8c]         @ 0x8012fc8 <__kernel_cosf+0xe0>
 8012f3a: f7ed f929    	bl	0x8000190 <__subsf3>    @ imm = #-0x12dae
 8012f3e: 4621         	mov	r1, r4
 8012f40: f7ed fa30    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x12ba0
 8012f44: 4921         	ldr	r1, [pc, #0x84]         @ 0x8012fcc <__kernel_cosf+0xe4>
 8012f46: f7ed f925    	bl	0x8000194 <__aeabi_fadd> @ imm = #-0x12db6
 8012f4a: 4621         	mov	r1, r4
 8012f4c: f7ed fa2a    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x12bac
 8012f50: 4621         	mov	r1, r4
 8012f52: f7ed fa27    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x12bb2
 8012f56: 4641         	mov	r1, r8
 8012f58: 4604         	mov	r4, r0
 8012f5a: 4630         	mov	r0, r6
 8012f5c: f7ed fa22    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x12bbc
 8012f60: 4601         	mov	r1, r0
 8012f62: 4620         	mov	r0, r4
 8012f64: f7ed f914    	bl	0x8000190 <__subsf3>    @ imm = #-0x12dd8
 8012f68: 4b19         	ldr	r3, [pc, #0x64]         @ 0x8012fd0 <__kernel_cosf+0xe8>
 8012f6a: 429d         	cmp	r5, r3
 8012f6c: 4604         	mov	r4, r0
 8012f6e: d80a         	bhi	0x8012f86 <__kernel_cosf+0x9e> @ imm = #0x14
 8012f70: 4601         	mov	r1, r0
 8012f72: 4638         	mov	r0, r7
 8012f74: f7ed f90c    	bl	0x8000190 <__subsf3>    @ imm = #-0x12de8
 8012f78: 4601         	mov	r1, r0
 8012f7a: f04f 507e    	mov.w	r0, #0x3f800000
 8012f7e: f7ed f907    	bl	0x8000190 <__subsf3>    @ imm = #-0x12df2
 8012f82: e8bd 81f0    	pop.w	{r4, r5, r6, r7, r8, pc}
 8012f86: 4b13         	ldr	r3, [pc, #0x4c]         @ 0x8012fd4 <__kernel_cosf+0xec>
 8012f88: 429d         	cmp	r5, r3
 8012f8a: bf8c         	ite	hi
 8012f8c: 4d12         	ldrhi	r5, [pc, #0x48]         @ 0x8012fd8 <__kernel_cosf+0xf0>
 8012f8e: f105 457f    	addls.w	r5, r5, #0xff000000
 8012f92: 4629         	mov	r1, r5
 8012f94: f04f 507e    	mov.w	r0, #0x3f800000
 8012f98: f7ed f8fa    	bl	0x8000190 <__subsf3>    @ imm = #-0x12e0c
 8012f9c: 4629         	mov	r1, r5
 8012f9e: 4606         	mov	r6, r0
 8012fa0: 4638         	mov	r0, r7
 8012fa2: f7ed f8f5    	bl	0x8000190 <__subsf3>    @ imm = #-0x12e16
 8012fa6: 4621         	mov	r1, r4
 8012fa8: f7ed f8f2    	bl	0x8000190 <__subsf3>    @ imm = #-0x12e1c
 8012fac: 4601         	mov	r1, r0
 8012fae: 4630         	mov	r0, r6
 8012fb0: e7e5         	b	0x8012f7e <__kernel_cosf+0x96> @ imm = #-0x36
 8012fb2: f04f 507e    	mov.w	r0, #0x3f800000
 8012fb6: e7e4         	b	0x8012f82 <__kernel_cosf+0x9a> @ imm = #-0x38

08012fb8 <$d>:
 8012fb8: 4e d7 47 ad  	.word	0xad47d74e
 8012fbc: f6 74 0f 31  	.word	0x310f74f6
 8012fc0: 7c f2 93 34  	.word	0x3493f27c
 8012fc4: 01 0d d0 37  	.word	0x37d00d01
 8012fc8: 61 0b b6 3a  	.word	0x3ab60b61
 8012fcc: ab aa 2a 3d  	.word	0x3d2aaaab
 8012fd0: 99 99 99 3e  	.word	0x3e999999
 8012fd4: 00 00 48 3f  	.word	0x3f480000
 8012fd8: 00 00 90 3e  	.word	0x3e900000

08012fdc <__kernel_rem_pio2f>:
 8012fdc: e92d 4ff0    	push.w	{r4, r5, r6, r7, r8, r9, r10, r11, lr}
 8012fe0: b0db         	sub	sp, #0x16c
 8012fe2: 9202         	str	r2, [sp, #0x8]
 8012fe4: 9304         	str	r3, [sp, #0x10]
 8012fe6: 9a64         	ldr	r2, [sp, #0x190]
 8012fe8: 4bb4         	ldr	r3, [pc, #0x2d0]        @ 0x80132bc <__kernel_rem_pio2f+0x2e0>
 8012fea: 9005         	str	r0, [sp, #0x14]
 8012fec: f853 3022    	ldr.w	r3, [r3, r2, lsl #2]
 8012ff0: 9301         	str	r3, [sp, #0x4]
 8012ff2: 9b04         	ldr	r3, [sp, #0x10]
 8012ff4: 9100         	str	r1, [sp]
 8012ff6: 3b01         	subs	r3, #0x1
 8012ff8: 9303         	str	r3, [sp, #0xc]
 8012ffa: 9b02         	ldr	r3, [sp, #0x8]
 8012ffc: 1d1a         	adds	r2, r3, #0x4
 8012ffe: f2c0 8099    	blt.w	0x8013134 <__kernel_rem_pio2f+0x158> @ imm = #0x132
 8013002: 1edc         	subs	r4, r3, #0x3
 8013004: bf48         	it	mi
 8013006: 1d1c         	addmi	r4, r3, #0x4
 8013008: 10e4         	asrs	r4, r4, #0x3
 801300a: 1c67         	adds	r7, r4, #0x1
 801300c: 00fb         	lsls	r3, r7, #0x3
 801300e: 9306         	str	r3, [sp, #0x18]
 8013010: 9b02         	ldr	r3, [sp, #0x8]
 8013012: 9a03         	ldr	r2, [sp, #0xc]
 8013014: eba3 07c7    	sub.w	r7, r3, r7, lsl #3
 8013018: 9b01         	ldr	r3, [sp, #0x4]
 801301a: eb03 0902    	add.w	r9, r3, r2
 801301e: 9b65         	ldr	r3, [sp, #0x194]
 8013020: eba4 0802    	sub.w	r8, r4, r2
 8013024: ae1e         	add	r6, sp, #0x78
 8013026: eb03 0a88    	add.w	r10, r3, r8, lsl #2
 801302a: 2500         	movs	r5, #0x0
 801302c: f04f 0b00    	mov.w	r11, #0x0
 8013030: 454d         	cmp	r5, r9
 8013032: f340 8081    	ble.w	0x8013138 <__kernel_rem_pio2f+0x15c> @ imm = #0x102
 8013036: 9a04         	ldr	r2, [sp, #0x10]
 8013038: ab1e         	add	r3, sp, #0x78
 801303a: eb03 0582    	add.w	r5, r3, r2, lsl #2
 801303e: f50d 7b8c    	add.w	r11, sp, #0x118
 8013042: f04f 0900    	mov.w	r9, #0x0
 8013046: 2300         	movs	r3, #0x0
 8013048: 9a01         	ldr	r2, [sp, #0x4]
 801304a: 4591         	cmp	r9, r2
 801304c: f340 809c    	ble.w	0x8013188 <__kernel_rem_pio2f+0x1ac> @ imm = #0x138
 8013050: 4613         	mov	r3, r2
 8013052: aa0a         	add	r2, sp, #0x28
 8013054: eb02 0383    	add.w	r3, r2, r3, lsl #2
 8013058: 9308         	str	r3, [sp, #0x20]
 801305a: 9b65         	ldr	r3, [sp, #0x194]
 801305c: eb03 0384    	add.w	r3, r3, r4, lsl #2
 8013060: 9c01         	ldr	r4, [sp, #0x4]
 8013062: 9307         	str	r3, [sp, #0x1c]
 8013064: ab5a         	add	r3, sp, #0x168
 8013066: eb03 0384    	add.w	r3, r3, r4, lsl #2
 801306a: f10d 0828    	add.w	r8, sp, #0x28
 801306e: f853 bc50    	ldr	r11, [r3, #-80]
 8013072: 4646         	mov	r6, r8
 8013074: 4625         	mov	r5, r4
 8013076: f04f 4987    	mov.w	r9, #0x43800000
 801307a: f50d 7a8c    	add.w	r10, sp, #0x118
 801307e: 2d00         	cmp	r5, #0x0
 8013080: f300 8087    	bgt.w	0x8013192 <__kernel_rem_pio2f+0x1b6> @ imm = #0x10e
 8013084: 4639         	mov	r1, r7
 8013086: 4658         	mov	r0, r11
 8013088: f000 fbd8    	bl	0x801383c <scalbnf>     @ imm = #0x7b0
 801308c: f04f 5178    	mov.w	r1, #0x3e000000
 8013090: 4605         	mov	r5, r0
 8013092: f7ed f987    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x12cf2
 8013096: f000 fc1d    	bl	0x80138d4 <floorf>      @ imm = #0x83a
 801309a: f04f 4182    	mov.w	r1, #0x41000000
 801309e: f7ed f981    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x12cfe
 80130a2: 4601         	mov	r1, r0
 80130a4: 4628         	mov	r0, r5
 80130a6: f7ed f873    	bl	0x8000190 <__subsf3>    @ imm = #-0x12f1a
 80130aa: 4605         	mov	r5, r0
 80130ac: f7ed fb40    	bl	0x8000730 <__fixsfsi>   @ imm = #-0x12980
 80130b0: 4606         	mov	r6, r0
 80130b2: f7ed f923    	bl	0x80002fc <__floatsisf> @ imm = #-0x12dba
 80130b6: 4601         	mov	r1, r0
 80130b8: 4628         	mov	r0, r5
 80130ba: f7ed f869    	bl	0x8000190 <__subsf3>    @ imm = #-0x12f2e
 80130be: 2f00         	cmp	r7, #0x0
 80130c0: 4681         	mov	r9, r0
 80130c2: f340 8083    	ble.w	0x80131cc <__kernel_rem_pio2f+0x1f0> @ imm = #0x106
 80130c6: 1e62         	subs	r2, r4, #0x1
 80130c8: ab0a         	add	r3, sp, #0x28
 80130ca: f1c7 0108    	rsb.w	r1, r7, #0x8
 80130ce: f853 5022    	ldr.w	r5, [r3, r2, lsl #2]
 80130d2: fa45 f301    	asr.w	r3, r5, r1
 80130d6: 441e         	add	r6, r3
 80130d8: 408b         	lsls	r3, r1
 80130da: 1aed         	subs	r5, r5, r3
 80130dc: ab0a         	add	r3, sp, #0x28
 80130de: f843 5022    	str.w	r5, [r3, r2, lsl #2]
 80130e2: f1c7 0307    	rsb.w	r3, r7, #0x7
 80130e6: 411d         	asrs	r5, r3
 80130e8: 2d00         	cmp	r5, #0x0
 80130ea: dd7c         	ble	0x80131e6 <__kernel_rem_pio2f+0x20a> @ imm = #0xf8
 80130ec: 2200         	movs	r2, #0x0
 80130ee: 3601         	adds	r6, #0x1
 80130f0: 4692         	mov	r10, r2
 80130f2: 4294         	cmp	r4, r2
 80130f4: f300 80ad    	bgt.w	0x8013252 <__kernel_rem_pio2f+0x276> @ imm = #0x15a
 80130f8: 2f00         	cmp	r7, #0x0
 80130fa: dd05         	ble	0x8013108 <__kernel_rem_pio2f+0x12c> @ imm = #0xa
 80130fc: 2f01         	cmp	r7, #0x1
 80130fe: f000 80c5    	beq.w	0x801328c <__kernel_rem_pio2f+0x2b0> @ imm = #0x18a
 8013102: 2f02         	cmp	r7, #0x2
 8013104: f000 80cc    	beq.w	0x80132a0 <__kernel_rem_pio2f+0x2c4> @ imm = #0x198
 8013108: 2d02         	cmp	r5, #0x2
 801310a: d16c         	bne	0x80131e6 <__kernel_rem_pio2f+0x20a> @ imm = #0xd8
 801310c: 4649         	mov	r1, r9
 801310e: f04f 507e    	mov.w	r0, #0x3f800000
 8013112: f7ed f83d    	bl	0x8000190 <__subsf3>    @ imm = #-0x12f86
 8013116: 4681         	mov	r9, r0
 8013118: f1ba 0f00    	cmp.w	r10, #0x0
 801311c: d063         	beq	0x80131e6 <__kernel_rem_pio2f+0x20a> @ imm = #0xc6
 801311e: 4639         	mov	r1, r7
 8013120: f04f 507e    	mov.w	r0, #0x3f800000
 8013124: f000 fb8a    	bl	0x801383c <scalbnf>     @ imm = #0x714
 8013128: 4601         	mov	r1, r0
 801312a: 4648         	mov	r0, r9
 801312c: f7ed f830    	bl	0x8000190 <__subsf3>    @ imm = #-0x12fa0
 8013130: 4681         	mov	r9, r0
 8013132: e058         	b	0x80131e6 <__kernel_rem_pio2f+0x20a> @ imm = #0xb0
 8013134: 2400         	movs	r4, #0x0
 8013136: e768         	b	0x801300a <__kernel_rem_pio2f+0x2e> @ imm = #-0x130
 8013138: eb18 0f05    	cmn.w	r8, r5
 801313c: d407         	bmi	0x801314e <__kernel_rem_pio2f+0x172> @ imm = #0xe
 801313e: f85a 0025    	ldr.w	r0, [r10, r5, lsl #2]
 8013142: f7ed f8db    	bl	0x80002fc <__floatsisf> @ imm = #-0x12e4a
 8013146: f846 0b04    	str	r0, [r6], #4
 801314a: 3501         	adds	r5, #0x1
 801314c: e770         	b	0x8013030 <__kernel_rem_pio2f+0x54> @ imm = #-0x120
 801314e: 4658         	mov	r0, r11
 8013150: e7f9         	b	0x8013146 <__kernel_rem_pio2f+0x16a> @ imm = #-0xe
 8013152: 9307         	str	r3, [sp, #0x1c]
 8013154: 9b05         	ldr	r3, [sp, #0x14]
 8013156: f8da 1000    	ldr.w	r1, [r10]
 801315a: f853 0028    	ldr.w	r0, [r3, r8, lsl #2]
 801315e: f7ed f921    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x12dbe
 8013162: 4601         	mov	r1, r0
 8013164: 4630         	mov	r0, r6
 8013166: f7ed f815    	bl	0x8000194 <__aeabi_fadd> @ imm = #-0x12fd6
 801316a: 9b07         	ldr	r3, [sp, #0x1c]
 801316c: 4606         	mov	r6, r0
 801316e: f108 0801    	add.w	r8, r8, #0x1
 8013172: 9a03         	ldr	r2, [sp, #0xc]
 8013174: 4590         	cmp	r8, r2
 8013176: f1aa 0a04    	sub.w	r10, r10, #0x4
 801317a: ddea         	ble	0x8013152 <__kernel_rem_pio2f+0x176> @ imm = #-0x2c
 801317c: f84b 6b04    	str	r6, [r11], #4
 8013180: f109 0901    	add.w	r9, r9, #0x1
 8013184: 3504         	adds	r5, #0x4
 8013186: e75f         	b	0x8013048 <__kernel_rem_pio2f+0x6c> @ imm = #-0x142
 8013188: 46aa         	mov	r10, r5
 801318a: 461e         	mov	r6, r3
 801318c: f04f 0800    	mov.w	r8, #0x0
 8013190: e7ef         	b	0x8013172 <__kernel_rem_pio2f+0x196> @ imm = #-0x22
 8013192: f04f 516e    	mov.w	r1, #0x3b800000
 8013196: 4658         	mov	r0, r11
 8013198: f7ed f904    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x12df8
 801319c: f7ed fac8    	bl	0x8000730 <__fixsfsi>   @ imm = #-0x12a70
 80131a0: f7ed f8ac    	bl	0x80002fc <__floatsisf> @ imm = #-0x12ea8
 80131a4: 4649         	mov	r1, r9
 80131a6: 9009         	str	r0, [sp, #0x24]
 80131a8: f7ed f8fc    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x12e08
 80131ac: 4601         	mov	r1, r0
 80131ae: 4658         	mov	r0, r11
 80131b0: f7ec ffee    	bl	0x8000190 <__subsf3>    @ imm = #-0x13024
 80131b4: f7ed fabc    	bl	0x8000730 <__fixsfsi>   @ imm = #-0x12a88
 80131b8: 3d01         	subs	r5, #0x1
 80131ba: f846 0b04    	str	r0, [r6], #4
 80131be: f85a 1025    	ldr.w	r1, [r10, r5, lsl #2]
 80131c2: 9809         	ldr	r0, [sp, #0x24]
 80131c4: f7ec ffe6    	bl	0x8000194 <__aeabi_fadd> @ imm = #-0x13034
 80131c8: 4683         	mov	r11, r0
 80131ca: e758         	b	0x801307e <__kernel_rem_pio2f+0xa2> @ imm = #-0x150
 80131cc: d105         	bne	0x80131da <__kernel_rem_pio2f+0x1fe> @ imm = #0xa
 80131ce: 1e63         	subs	r3, r4, #0x1
 80131d0: aa0a         	add	r2, sp, #0x28
 80131d2: f852 5023    	ldr.w	r5, [r2, r3, lsl #2]
 80131d6: 11ed         	asrs	r5, r5, #0x7
 80131d8: e786         	b	0x80130e8 <__kernel_rem_pio2f+0x10c> @ imm = #-0xf4
 80131da: f04f 517c    	mov.w	r1, #0x3f000000
 80131de: f7ed fa93    	bl	0x8000708 <__aeabi_fcmpge> @ imm = #-0x12ada
 80131e2: 4605         	mov	r5, r0
 80131e4: bb98         	cbnz	r0, 0x801324e <__kernel_rem_pio2f+0x272> @ imm = #0x66
 80131e6: 2100         	movs	r1, #0x0
 80131e8: 4648         	mov	r0, r9
 80131ea: f7ed fa6f    	bl	0x80006cc <__aeabi_fcmpeq> @ imm = #-0x12b22
 80131ee: 2800         	cmp	r0, #0x0
 80131f0: f000 809e    	beq.w	0x8013330 <__kernel_rem_pio2f+0x354> @ imm = #0x13c
 80131f4: 1e63         	subs	r3, r4, #0x1
 80131f6: 2200         	movs	r2, #0x0
 80131f8: 9901         	ldr	r1, [sp, #0x4]
 80131fa: 428b         	cmp	r3, r1
 80131fc: da57         	bge	0x80132ae <__kernel_rem_pio2f+0x2d2> @ imm = #0xae
 80131fe: 2a00         	cmp	r2, #0x0
 8013200: f000 8084    	beq.w	0x801330c <__kernel_rem_pio2f+0x330> @ imm = #0x108
 8013204: 3c01         	subs	r4, #0x1
 8013206: ab0a         	add	r3, sp, #0x28
 8013208: 3f08         	subs	r7, #0x8
 801320a: f853 3024    	ldr.w	r3, [r3, r4, lsl #2]
 801320e: 2b00         	cmp	r3, #0x0
 8013210: d0f8         	beq	0x8013204 <__kernel_rem_pio2f+0x228> @ imm = #-0x10
 8013212: 4639         	mov	r1, r7
 8013214: f04f 507e    	mov.w	r0, #0x3f800000
 8013218: f000 fb10    	bl	0x801383c <scalbnf>     @ imm = #0x620
 801321c: 46a2         	mov	r10, r4
 801321e: 4607         	mov	r7, r0
 8013220: f50d 788c    	add.w	r8, sp, #0x118
 8013224: f04f 596e    	mov.w	r9, #0x3b800000
 8013228: f1ba 0f00    	cmp.w	r10, #0x0
 801322c: f280 80ae    	bge.w	0x801338c <__kernel_rem_pio2f+0x3b0> @ imm = #0x15c
 8013230: 4627         	mov	r7, r4
 8013232: 2200         	movs	r2, #0x0
 8013234: 2f00         	cmp	r7, #0x0
 8013236: f2c0 80d8    	blt.w	0x80133ea <__kernel_rem_pio2f+0x40e> @ imm = #0x1b0
 801323a: a946         	add	r1, sp, #0x118
 801323c: 4b20         	ldr	r3, [pc, #0x80]         @ 0x80132c0 <__kernel_rem_pio2f+0x2e4>
 801323e: eb01 0b87    	add.w	r11, r1, r7, lsl #2
 8013242: 4690         	mov	r8, r2
 8013244: f04f 0a00    	mov.w	r10, #0x0
 8013248: eba4 0907    	sub.w	r9, r4, r7
 801324c: e0c1         	b	0x80133d2 <__kernel_rem_pio2f+0x3f6> @ imm = #0x182
 801324e: 2502         	movs	r5, #0x2
 8013250: e74c         	b	0x80130ec <__kernel_rem_pio2f+0x110> @ imm = #-0x168
 8013252: 4641         	mov	r1, r8
 8013254: f851 3b04    	ldr	r3, [r1], #4
 8013258: f1ba 0f00    	cmp.w	r10, #0x0
 801325c: d10a         	bne	0x8013274 <__kernel_rem_pio2f+0x298> @ imm = #0x14
 801325e: b173         	cbz	r3, 0x801327e <__kernel_rem_pio2f+0x2a2> @ imm = #0x1c
 8013260: 3201         	adds	r2, #0x1
 8013262: f5c3 7380    	rsb.w	r3, r3, #0x100
 8013266: 4294         	cmp	r4, r2
 8013268: f841 3c04    	str	r3, [r1, #-4]
 801326c: dd0b         	ble	0x8013286 <__kernel_rem_pio2f+0x2aa> @ imm = #0x16
 801326e: 680b         	ldr	r3, [r1]
 8013270: f108 0108    	add.w	r1, r8, #0x8
 8013274: f1c3 03ff    	rsb.w	r3, r3, #0xff
 8013278: f841 3c04    	str	r3, [r1, #-4]
 801327c: 2301         	movs	r3, #0x1
 801327e: 3201         	adds	r2, #0x1
 8013280: 4688         	mov	r8, r1
 8013282: 469a         	mov	r10, r3
 8013284: e735         	b	0x80130f2 <__kernel_rem_pio2f+0x116> @ imm = #-0x196
 8013286: f04f 0a01    	mov.w	r10, #0x1
 801328a: e735         	b	0x80130f8 <__kernel_rem_pio2f+0x11c> @ imm = #-0x196
 801328c: 1e62         	subs	r2, r4, #0x1
 801328e: ab0a         	add	r3, sp, #0x28
 8013290: f853 3022    	ldr.w	r3, [r3, r2, lsl #2]
 8013294: f003 037f    	and	r3, r3, #0x7f
 8013298: a90a         	add	r1, sp, #0x28
 801329a: f841 3022    	str.w	r3, [r1, r2, lsl #2]
 801329e: e733         	b	0x8013108 <__kernel_rem_pio2f+0x12c> @ imm = #-0x19a
 80132a0: 1e62         	subs	r2, r4, #0x1
 80132a2: ab0a         	add	r3, sp, #0x28
 80132a4: f853 3022    	ldr.w	r3, [r3, r2, lsl #2]
 80132a8: f003 033f    	and	r3, r3, #0x3f
 80132ac: e7f4         	b	0x8013298 <__kernel_rem_pio2f+0x2bc> @ imm = #-0x18
 80132ae: a90a         	add	r1, sp, #0x28
 80132b0: f851 1023    	ldr.w	r1, [r1, r3, lsl #2]
 80132b4: 3b01         	subs	r3, #0x1
 80132b6: 430a         	orrs	r2, r1
 80132b8: e79e         	b	0x80131f8 <__kernel_rem_pio2f+0x21c> @ imm = #-0xc4
 80132ba: bf00         	nop

080132bc <$d>:
 80132bc: d4 0b 02 08  	.word	0x08020bd4
 80132c0: a8 0b 02 08  	.word	0x08020ba8

080132c4 <$t>:
 80132c4: 3301         	adds	r3, #0x1
 80132c6: f852 1d04    	ldr	r1, [r2, #-4]!
 80132ca: 2900         	cmp	r1, #0x0
 80132cc: d0fa         	beq	0x80132c4 <__kernel_rem_pio2f+0x2e8> @ imm = #-0xc
 80132ce: 9a04         	ldr	r2, [sp, #0x10]
 80132d0: a91e         	add	r1, sp, #0x78
 80132d2: 18a2         	adds	r2, r4, r2
 80132d4: 1c66         	adds	r6, r4, #0x1
 80132d6: eb01 0582    	add.w	r5, r1, r2, lsl #2
 80132da: 441c         	add	r4, r3
 80132dc: f50d 798c    	add.w	r9, sp, #0x118
 80132e0: 42b4         	cmp	r4, r6
 80132e2: f6ff aebf    	blt.w	0x8013064 <__kernel_rem_pio2f+0x88> @ imm = #-0x282
 80132e6: 9b07         	ldr	r3, [sp, #0x1c]
 80132e8: f853 0026    	ldr.w	r0, [r3, r6, lsl #2]
 80132ec: f7ed f806    	bl	0x80002fc <__floatsisf> @ imm = #-0x12ff4
 80132f0: 46ab         	mov	r11, r5
 80132f2: 6028         	str	r0, [r5]
 80132f4: f04f 0a00    	mov.w	r10, #0x0
 80132f8: f04f 0800    	mov.w	r8, #0x0
 80132fc: 9b03         	ldr	r3, [sp, #0xc]
 80132fe: 459a         	cmp	r10, r3
 8013300: dd07         	ble	0x8013312 <__kernel_rem_pio2f+0x336> @ imm = #0xe
 8013302: f849 8026    	str.w	r8, [r9, r6, lsl #2]
 8013306: 3504         	adds	r5, #0x4
 8013308: 3601         	adds	r6, #0x1
 801330a: e7e9         	b	0x80132e0 <__kernel_rem_pio2f+0x304> @ imm = #-0x2e
 801330c: 9a08         	ldr	r2, [sp, #0x20]
 801330e: 2301         	movs	r3, #0x1
 8013310: e7d9         	b	0x80132c6 <__kernel_rem_pio2f+0x2ea> @ imm = #-0x4e
 8013312: 9b05         	ldr	r3, [sp, #0x14]
 8013314: f85b 0904    	ldr	r0, [r11], #-4
 8013318: f853 102a    	ldr.w	r1, [r3, r10, lsl #2]
 801331c: f7ed f842    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x12f7c
 8013320: 4601         	mov	r1, r0
 8013322: 4640         	mov	r0, r8
 8013324: f7ec ff36    	bl	0x8000194 <__aeabi_fadd> @ imm = #-0x13194
 8013328: f10a 0a01    	add.w	r10, r10, #0x1
 801332c: 4680         	mov	r8, r0
 801332e: e7e5         	b	0x80132fc <__kernel_rem_pio2f+0x320> @ imm = #-0x36
 8013330: 9b06         	ldr	r3, [sp, #0x18]
 8013332: 9a02         	ldr	r2, [sp, #0x8]
 8013334: 4648         	mov	r0, r9
 8013336: 1a99         	subs	r1, r3, r2
 8013338: f000 fa80    	bl	0x801383c <scalbnf>     @ imm = #0x500
 801333c: f04f 4187    	mov.w	r1, #0x43800000
 8013340: 4680         	mov	r8, r0
 8013342: f7ed f9e1    	bl	0x8000708 <__aeabi_fcmpge> @ imm = #-0x12c3e
 8013346: b1f8         	cbz	r0, 0x8013388 <__kernel_rem_pio2f+0x3ac> @ imm = #0x3e
 8013348: f04f 516e    	mov.w	r1, #0x3b800000
 801334c: 4640         	mov	r0, r8
 801334e: f7ed f829    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x12fae
 8013352: f7ed f9ed    	bl	0x8000730 <__fixsfsi>   @ imm = #-0x12c26
 8013356: f7ec ffd1    	bl	0x80002fc <__floatsisf> @ imm = #-0x1305e
 801335a: f04f 4187    	mov.w	r1, #0x43800000
 801335e: 4681         	mov	r9, r0
 8013360: f7ed f820    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x12fc0
 8013364: 4601         	mov	r1, r0
 8013366: 4640         	mov	r0, r8
 8013368: f7ec ff12    	bl	0x8000190 <__subsf3>    @ imm = #-0x131dc
 801336c: f7ed f9e0    	bl	0x8000730 <__fixsfsi>   @ imm = #-0x12c40
 8013370: ab0a         	add	r3, sp, #0x28
 8013372: 3708         	adds	r7, #0x8
 8013374: f843 0024    	str.w	r0, [r3, r4, lsl #2]
 8013378: 3401         	adds	r4, #0x1
 801337a: 4648         	mov	r0, r9
 801337c: f7ed f9d8    	bl	0x8000730 <__fixsfsi>   @ imm = #-0x12c50
 8013380: ab0a         	add	r3, sp, #0x28
 8013382: f843 0024    	str.w	r0, [r3, r4, lsl #2]
 8013386: e744         	b	0x8013212 <__kernel_rem_pio2f+0x236> @ imm = #-0x178
 8013388: 4640         	mov	r0, r8
 801338a: e7f7         	b	0x801337c <__kernel_rem_pio2f+0x3a0> @ imm = #-0x12
 801338c: ab0a         	add	r3, sp, #0x28
 801338e: f853 002a    	ldr.w	r0, [r3, r10, lsl #2]
 8013392: f7ec ffb3    	bl	0x80002fc <__floatsisf> @ imm = #-0x1309a
 8013396: 4639         	mov	r1, r7
 8013398: f7ed f804    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x12ff8
 801339c: 4649         	mov	r1, r9
 801339e: f848 002a    	str.w	r0, [r8, r10, lsl #2]
 80133a2: 4638         	mov	r0, r7
 80133a4: f7ec fffe    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x13004
 80133a8: f10a 3aff    	add.w	r10, r10, #0xffffffff
 80133ac: 4607         	mov	r7, r0
 80133ae: e73b         	b	0x8013228 <__kernel_rem_pio2f+0x24c> @ imm = #-0x18a
 80133b0: f853 0b04    	ldr	r0, [r3], #4
 80133b4: f85b 1b04    	ldr	r1, [r11], #4
 80133b8: 9203         	str	r2, [sp, #0xc]
 80133ba: 9302         	str	r3, [sp, #0x8]
 80133bc: f7ec fff2    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x1301c
 80133c0: 4601         	mov	r1, r0
 80133c2: 4640         	mov	r0, r8
 80133c4: f7ec fee6    	bl	0x8000194 <__aeabi_fadd> @ imm = #-0x13234
 80133c8: e9dd 3202    	ldrd	r3, r2, [sp, #8]
 80133cc: 4680         	mov	r8, r0
 80133ce: f10a 0a01    	add.w	r10, r10, #0x1
 80133d2: 9901         	ldr	r1, [sp, #0x4]
 80133d4: 458a         	cmp	r10, r1
 80133d6: dc01         	bgt	0x80133dc <__kernel_rem_pio2f+0x400> @ imm = #0x2
 80133d8: 45d1         	cmp	r9, r10
 80133da: dae9         	bge	0x80133b0 <__kernel_rem_pio2f+0x3d4> @ imm = #-0x2e
 80133dc: ab5a         	add	r3, sp, #0x168
 80133de: eb03 0989    	add.w	r9, r3, r9, lsl #2
 80133e2: 3f01         	subs	r7, #0x1
 80133e4: f849 8ca0    	str	r8, [r9, #-160]
 80133e8: e724         	b	0x8013234 <__kernel_rem_pio2f+0x258> @ imm = #-0x1b8
 80133ea: 9b64         	ldr	r3, [sp, #0x190]
 80133ec: 2b02         	cmp	r3, #0x2
 80133ee: dc07         	bgt	0x8013400 <__kernel_rem_pio2f+0x424> @ imm = #0xe
 80133f0: 2b00         	cmp	r3, #0x0
 80133f2: dc4e         	bgt	0x8013492 <__kernel_rem_pio2f+0x4b6> @ imm = #0x9c
 80133f4: d02e         	beq	0x8013454 <__kernel_rem_pio2f+0x478> @ imm = #0x5c
 80133f6: f006 0007    	and	r0, r6, #0x7
 80133fa: b05b         	add	sp, #0x16c
 80133fc: e8bd 8ff0    	pop.w	{r4, r5, r6, r7, r8, r9, r10, r11, pc}
 8013400: 9b64         	ldr	r3, [sp, #0x190]
 8013402: 2b03         	cmp	r3, #0x3
 8013404: d1f7         	bne	0x80133f6 <__kernel_rem_pio2f+0x41a> @ imm = #-0x12
 8013406: f10d 0bc8    	add.w	r11, sp, #0xc8
 801340a: eb0b 0784    	add.w	r7, r11, r4, lsl #2
 801340e: 46b8         	mov	r8, r7
 8013410: 46a2         	mov	r10, r4
 8013412: f1ba 0f00    	cmp.w	r10, #0x0
 8013416: dc49         	bgt	0x80134ac <__kernel_rem_pio2f+0x4d0> @ imm = #0x92
 8013418: 46a1         	mov	r9, r4
 801341a: f1b9 0f01    	cmp.w	r9, #0x1
 801341e: dc60         	bgt	0x80134e2 <__kernel_rem_pio2f+0x506> @ imm = #0xc0
 8013420: 2000         	movs	r0, #0x0
 8013422: 2c01         	cmp	r4, #0x1
 8013424: dc76         	bgt	0x8013514 <__kernel_rem_pio2f+0x538> @ imm = #0xec
 8013426: 9a32         	ldr	r2, [sp, #0xc8]
 8013428: 9b33         	ldr	r3, [sp, #0xcc]
 801342a: 2d00         	cmp	r5, #0x0
 801342c: d178         	bne	0x8013520 <__kernel_rem_pio2f+0x544> @ imm = #0xf0
 801342e: 9900         	ldr	r1, [sp]
 8013430: 600a         	str	r2, [r1]
 8013432: 604b         	str	r3, [r1, #0x4]
 8013434: 460a         	mov	r2, r1
 8013436: 6090         	str	r0, [r2, #0x8]
 8013438: e7dd         	b	0x80133f6 <__kernel_rem_pio2f+0x41a> @ imm = #-0x46
 801343a: f857 1024    	ldr.w	r1, [r7, r4, lsl #2]
 801343e: f7ec fea9    	bl	0x8000194 <__aeabi_fadd> @ imm = #-0x132ae
 8013442: 3c01         	subs	r4, #0x1
 8013444: 2c00         	cmp	r4, #0x0
 8013446: daf8         	bge	0x801343a <__kernel_rem_pio2f+0x45e> @ imm = #-0x10
 8013448: b10d         	cbz	r5, 0x801344e <__kernel_rem_pio2f+0x472> @ imm = #0x2
 801344a: f100 4000    	add.w	r0, r0, #0x80000000
 801344e: 9b00         	ldr	r3, [sp]
 8013450: 6018         	str	r0, [r3]
 8013452: e7d0         	b	0x80133f6 <__kernel_rem_pio2f+0x41a> @ imm = #-0x60
 8013454: 2000         	movs	r0, #0x0
 8013456: af32         	add	r7, sp, #0xc8
 8013458: e7f4         	b	0x8013444 <__kernel_rem_pio2f+0x468> @ imm = #-0x18
 801345a: f857 1028    	ldr.w	r1, [r7, r8, lsl #2]
 801345e: f7ec fe99    	bl	0x8000194 <__aeabi_fadd> @ imm = #-0x132ce
 8013462: f108 38ff    	add.w	r8, r8, #0xffffffff
 8013466: f1b8 0f00    	cmp.w	r8, #0x0
 801346a: daf6         	bge	0x801345a <__kernel_rem_pio2f+0x47e> @ imm = #-0x14
 801346c: b1ad         	cbz	r5, 0x801349a <__kernel_rem_pio2f+0x4be> @ imm = #0x2a
 801346e: f100 4300    	add.w	r3, r0, #0x80000000
 8013472: 9a00         	ldr	r2, [sp]
 8013474: 4601         	mov	r1, r0
 8013476: 6013         	str	r3, [r2]
 8013478: 9832         	ldr	r0, [sp, #0xc8]
 801347a: f7ec fe89    	bl	0x8000190 <__subsf3>    @ imm = #-0x132ee
 801347e: f04f 0801    	mov.w	r8, #0x1
 8013482: 4544         	cmp	r4, r8
 8013484: da0b         	bge	0x801349e <__kernel_rem_pio2f+0x4c2> @ imm = #0x16
 8013486: b10d         	cbz	r5, 0x801348c <__kernel_rem_pio2f+0x4b0> @ imm = #0x2
 8013488: f100 4000    	add.w	r0, r0, #0x80000000
 801348c: 9b00         	ldr	r3, [sp]
 801348e: 6058         	str	r0, [r3, #0x4]
 8013490: e7b1         	b	0x80133f6 <__kernel_rem_pio2f+0x41a> @ imm = #-0x9e
 8013492: 46a0         	mov	r8, r4
 8013494: 2000         	movs	r0, #0x0
 8013496: af32         	add	r7, sp, #0xc8
 8013498: e7e5         	b	0x8013466 <__kernel_rem_pio2f+0x48a> @ imm = #-0x36
 801349a: 4603         	mov	r3, r0
 801349c: e7e9         	b	0x8013472 <__kernel_rem_pio2f+0x496> @ imm = #-0x2e
 801349e: f857 1f04    	ldr	r1, [r7, #4]!
 80134a2: f7ec fe77    	bl	0x8000194 <__aeabi_fadd> @ imm = #-0x13312
 80134a6: f108 0801    	add.w	r8, r8, #0x1
 80134aa: e7ea         	b	0x8013482 <__kernel_rem_pio2f+0x4a6> @ imm = #-0x2c
 80134ac: f8d8 3000    	ldr.w	r3, [r8]
 80134b0: f858 2c04    	ldr	r2, [r8, #-4]
 80134b4: 9302         	str	r3, [sp, #0x8]
 80134b6: 4619         	mov	r1, r3
 80134b8: 4610         	mov	r0, r2
 80134ba: 9201         	str	r2, [sp, #0x4]
 80134bc: f7ec fe6a    	bl	0x8000194 <__aeabi_fadd> @ imm = #-0x1332c
 80134c0: 9a01         	ldr	r2, [sp, #0x4]
 80134c2: 4601         	mov	r1, r0
 80134c4: 4681         	mov	r9, r0
 80134c6: 4610         	mov	r0, r2
 80134c8: f7ec fe62    	bl	0x8000190 <__subsf3>    @ imm = #-0x1333c
 80134cc: 9b02         	ldr	r3, [sp, #0x8]
 80134ce: 4619         	mov	r1, r3
 80134d0: f7ec fe60    	bl	0x8000194 <__aeabi_fadd> @ imm = #-0x13340
 80134d4: f848 0904    	str	r0, [r8], #-4
 80134d8: f10a 3aff    	add.w	r10, r10, #0xffffffff
 80134dc: f8c8 9000    	str.w	r9, [r8]
 80134e0: e797         	b	0x8013412 <__kernel_rem_pio2f+0x436> @ imm = #-0xd2
 80134e2: f857 3c04    	ldr	r3, [r7, #-4]
 80134e6: f8d7 a000    	ldr.w	r10, [r7]
 80134ea: 9301         	str	r3, [sp, #0x4]
 80134ec: 4651         	mov	r1, r10
 80134ee: 4618         	mov	r0, r3
 80134f0: f7ec fe50    	bl	0x8000194 <__aeabi_fadd> @ imm = #-0x13360
 80134f4: 9b01         	ldr	r3, [sp, #0x4]
 80134f6: 4601         	mov	r1, r0
 80134f8: 4680         	mov	r8, r0
 80134fa: 4618         	mov	r0, r3
 80134fc: f7ec fe48    	bl	0x8000190 <__subsf3>    @ imm = #-0x13370
 8013500: 4651         	mov	r1, r10
 8013502: f7ec fe47    	bl	0x8000194 <__aeabi_fadd> @ imm = #-0x13372
 8013506: f847 0904    	str	r0, [r7], #-4
 801350a: f109 39ff    	add.w	r9, r9, #0xffffffff
 801350e: f8c7 8000    	str.w	r8, [r7]
 8013512: e782         	b	0x801341a <__kernel_rem_pio2f+0x43e> @ imm = #-0xfc
 8013514: f85b 1024    	ldr.w	r1, [r11, r4, lsl #2]
 8013518: f7ec fe3c    	bl	0x8000194 <__aeabi_fadd> @ imm = #-0x13388
 801351c: 3c01         	subs	r4, #0x1
 801351e: e780         	b	0x8013422 <__kernel_rem_pio2f+0x446> @ imm = #-0x100
 8013520: 9900         	ldr	r1, [sp]
 8013522: f102 4200    	add.w	r2, r2, #0x80000000
 8013526: f103 4300    	add.w	r3, r3, #0x80000000
 801352a: 600a         	str	r2, [r1]
 801352c: 604b         	str	r3, [r1, #0x4]
 801352e: 460a         	mov	r2, r1
 8013530: f100 4000    	add.w	r0, r0, #0x80000000
 8013534: e77f         	b	0x8013436 <__kernel_rem_pio2f+0x45a> @ imm = #-0x102
 8013536: bf00         	nop

08013538 <__kernel_sinf>:
 8013538: e92d 43f8    	push.w	{r3, r4, r5, r6, r7, r8, r9, lr}
 801353c: f020 4300    	bic	r3, r0, #0x80000000
 8013540: f1b3 5f48    	cmp.w	r3, #0x32000000
 8013544: 4604         	mov	r4, r0
 8013546: 460f         	mov	r7, r1
 8013548: 4691         	mov	r9, r2
 801354a: d334         	blo	0x80135b6 <__kernel_sinf+0x7e> @ imm = #0x68
 801354c: 4601         	mov	r1, r0
 801354e: f7ec ff29    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x131ae
 8013552: 4605         	mov	r5, r0
 8013554: 4601         	mov	r1, r0
 8013556: 4620         	mov	r0, r4
 8013558: f7ec ff24    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x131b8
 801355c: 4928         	ldr	r1, [pc, #0xa0]         @ 0x8013600 <__kernel_sinf+0xc8>
 801355e: 4606         	mov	r6, r0
 8013560: 4628         	mov	r0, r5
 8013562: f7ec ff1f    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x131c2
 8013566: 4927         	ldr	r1, [pc, #0x9c]         @ 0x8013604 <__kernel_sinf+0xcc>
 8013568: f7ec fe12    	bl	0x8000190 <__subsf3>    @ imm = #-0x133dc
 801356c: 4629         	mov	r1, r5
 801356e: f7ec ff19    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x131ce
 8013572: 4925         	ldr	r1, [pc, #0x94]         @ 0x8013608 <__kernel_sinf+0xd0>
 8013574: f7ec fe0e    	bl	0x8000194 <__aeabi_fadd> @ imm = #-0x133e4
 8013578: 4629         	mov	r1, r5
 801357a: f7ec ff13    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x131da
 801357e: 4923         	ldr	r1, [pc, #0x8c]         @ 0x801360c <__kernel_sinf+0xd4>
 8013580: f7ec fe06    	bl	0x8000190 <__subsf3>    @ imm = #-0x133f4
 8013584: 4629         	mov	r1, r5
 8013586: f7ec ff0d    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x131e6
 801358a: 4921         	ldr	r1, [pc, #0x84]         @ 0x8013610 <__kernel_sinf+0xd8>
 801358c: f7ec fe02    	bl	0x8000194 <__aeabi_fadd> @ imm = #-0x133fc
 8013590: 4680         	mov	r8, r0
 8013592: f1b9 0f00    	cmp.w	r9, #0x0
 8013596: d111         	bne	0x80135bc <__kernel_sinf+0x84> @ imm = #0x22
 8013598: 4601         	mov	r1, r0
 801359a: 4628         	mov	r0, r5
 801359c: f7ec ff02    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x131fc
 80135a0: 491c         	ldr	r1, [pc, #0x70]         @ 0x8013614 <__kernel_sinf+0xdc>
 80135a2: f7ec fdf5    	bl	0x8000190 <__subsf3>    @ imm = #-0x13416
 80135a6: 4631         	mov	r1, r6
 80135a8: f7ec fefc    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x13208
 80135ac: 4601         	mov	r1, r0
 80135ae: 4620         	mov	r0, r4
 80135b0: f7ec fdf0    	bl	0x8000194 <__aeabi_fadd> @ imm = #-0x13420
 80135b4: 4604         	mov	r4, r0
 80135b6: 4620         	mov	r0, r4
 80135b8: e8bd 83f8    	pop.w	{r3, r4, r5, r6, r7, r8, r9, pc}
 80135bc: f04f 517c    	mov.w	r1, #0x3f000000
 80135c0: 4638         	mov	r0, r7
 80135c2: f7ec feef    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x13222
 80135c6: 4641         	mov	r1, r8
 80135c8: 4681         	mov	r9, r0
 80135ca: 4630         	mov	r0, r6
 80135cc: f7ec feea    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x1322c
 80135d0: 4601         	mov	r1, r0
 80135d2: 4648         	mov	r0, r9
 80135d4: f7ec fddc    	bl	0x8000190 <__subsf3>    @ imm = #-0x13448
 80135d8: 4629         	mov	r1, r5
 80135da: f7ec fee3    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x1323a
 80135de: 4639         	mov	r1, r7
 80135e0: f7ec fdd6    	bl	0x8000190 <__subsf3>    @ imm = #-0x13454
 80135e4: 490c         	ldr	r1, [pc, #0x30]         @ 0x8013618 <__kernel_sinf+0xe0>
 80135e6: 4605         	mov	r5, r0
 80135e8: 4630         	mov	r0, r6
 80135ea: f7ec fedb    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x1324a
 80135ee: 4601         	mov	r1, r0
 80135f0: 4628         	mov	r0, r5
 80135f2: f7ec fdcd    	bl	0x8000190 <__subsf3>    @ imm = #-0x13466
 80135f6: 4601         	mov	r1, r0
 80135f8: 4620         	mov	r0, r4
 80135fa: f7ec fdc9    	bl	0x8000190 <__subsf3>    @ imm = #-0x1346e
 80135fe: e7d9         	b	0x80135b4 <__kernel_sinf+0x7c> @ imm = #-0x4e

08013600 <$d>:
 8013600: d3 c9 2e 2f  	.word	0x2f2ec9d3
 8013604: 34 2f d7 32  	.word	0x32d72f34
 8013608: 1b ef 38 36  	.word	0x3638ef1b
 801360c: 01 0d 50 39  	.word	0x39500d01
 8013610: 89 88 08 3c  	.word	0x3c088889
 8013614: ab aa 2a 3e  	.word	0x3e2aaaab
 8013618: ab aa 2a be  	.word	0xbe2aaaab

0801361c <atanf>:
 801361c: f020 4300    	bic	r3, r0, #0x80000000
 8013620: f1b3 4fa1    	cmp.w	r3, #0x50800000
 8013624: e92d 41f0    	push.w	{r4, r5, r6, r7, r8, lr}
 8013628: 4604         	mov	r4, r0
 801362a: 4680         	mov	r8, r0
 801362c: d312         	blo	0x8013654 <atanf+0x38>  @ imm = #0x24
 801362e: f1b3 4fff    	cmp.w	r3, #0x7f800000
 8013632: d906         	bls	0x8013642 <atanf+0x26>  @ imm = #0xc
 8013634: 4601         	mov	r1, r0
 8013636: f7ec fdad    	bl	0x8000194 <__aeabi_fadd> @ imm = #-0x134a6
 801363a: 4604         	mov	r4, r0
 801363c: 4620         	mov	r0, r4
 801363e: e8bd 81f0    	pop.w	{r4, r5, r6, r7, r8, pc}
 8013642: 2800         	cmp	r0, #0x0
 8013644: 4968         	ldr	r1, [pc, #0x1a0]        @ 0x80137e8 <atanf+0x1cc>
 8013646: dd01         	ble	0x801364c <atanf+0x30>  @ imm = #0x2
 8013648: 4868         	ldr	r0, [pc, #0x1a0]        @ 0x80137ec <atanf+0x1d0>
 801364a: e7f4         	b	0x8013636 <atanf+0x1a>  @ imm = #-0x18
 801364c: 4868         	ldr	r0, [pc, #0x1a0]        @ 0x80137f0 <atanf+0x1d4>
 801364e: f7ec fd9f    	bl	0x8000190 <__subsf3>    @ imm = #-0x134c2
 8013652: e7f2         	b	0x801363a <atanf+0x1e>  @ imm = #-0x1c
 8013654: 4a67         	ldr	r2, [pc, #0x19c]        @ 0x80137f4 <atanf+0x1d8>
 8013656: 4293         	cmp	r3, r2
 8013658: d80e         	bhi	0x8013678 <atanf+0x5c>  @ imm = #0x1c
 801365a: f1b3 5f44    	cmp.w	r3, #0x31000000
 801365e: d208         	bhs	0x8013672 <atanf+0x56>  @ imm = #0x10
 8013660: 4965         	ldr	r1, [pc, #0x194]        @ 0x80137f8 <atanf+0x1dc>
 8013662: f7ec fd97    	bl	0x8000194 <__aeabi_fadd> @ imm = #-0x134d2
 8013666: f04f 517e    	mov.w	r1, #0x3f800000
 801366a: f7ed f857    	bl	0x800071c <__aeabi_fcmpgt> @ imm = #-0x12f52
 801366e: 2800         	cmp	r0, #0x0
 8013670: d1e4         	bne	0x801363c <atanf+0x20>  @ imm = #-0x38
 8013672: f04f 36ff    	mov.w	r6, #0xffffffff
 8013676: e01c         	b	0x80136b2 <atanf+0x96>  @ imm = #0x38
 8013678: 4a60         	ldr	r2, [pc, #0x180]        @ 0x80137fc <atanf+0x1e0>
 801367a: 4293         	cmp	r3, r2
 801367c: f020 4400    	bic	r4, r0, #0x80000000
 8013680: d87c         	bhi	0x801377c <atanf+0x160> @ imm = #0xf8
 8013682: f5a2 02d0    	sub.w	r2, r2, #0x680000
 8013686: 4293         	cmp	r3, r2
 8013688: d866         	bhi	0x8013758 <atanf+0x13c> @ imm = #0xcc
 801368a: 4621         	mov	r1, r4
 801368c: 4620         	mov	r0, r4
 801368e: f7ec fd81    	bl	0x8000194 <__aeabi_fadd> @ imm = #-0x134fe
 8013692: f04f 517e    	mov.w	r1, #0x3f800000
 8013696: f7ec fd7b    	bl	0x8000190 <__subsf3>    @ imm = #-0x1350a
 801369a: f04f 4180    	mov.w	r1, #0x40000000
 801369e: 4605         	mov	r5, r0
 80136a0: 4620         	mov	r0, r4
 80136a2: f7ec fd77    	bl	0x8000194 <__aeabi_fadd> @ imm = #-0x13512
 80136a6: 4601         	mov	r1, r0
 80136a8: 4628         	mov	r0, r5
 80136aa: f7ec ff2f    	bl	0x800050c <__divsf3>    @ imm = #-0x131a2
 80136ae: 2600         	movs	r6, #0x0
 80136b0: 4604         	mov	r4, r0
 80136b2: 4621         	mov	r1, r4
 80136b4: 4620         	mov	r0, r4
 80136b6: f7ec fe75    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x13316
 80136ba: 4601         	mov	r1, r0
 80136bc: 4607         	mov	r7, r0
 80136be: f7ec fe71    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x1331e
 80136c2: 494f         	ldr	r1, [pc, #0x13c]        @ 0x8013800 <atanf+0x1e4>
 80136c4: 4605         	mov	r5, r0
 80136c6: f7ec fe6d    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x13326
 80136ca: 494e         	ldr	r1, [pc, #0x138]        @ 0x8013804 <atanf+0x1e8>
 80136cc: f7ec fd62    	bl	0x8000194 <__aeabi_fadd> @ imm = #-0x1353c
 80136d0: 4629         	mov	r1, r5
 80136d2: f7ec fe67    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x13332
 80136d6: 494c         	ldr	r1, [pc, #0x130]        @ 0x8013808 <atanf+0x1ec>
 80136d8: f7ec fd5c    	bl	0x8000194 <__aeabi_fadd> @ imm = #-0x13548
 80136dc: 4629         	mov	r1, r5
 80136de: f7ec fe61    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x1333e
 80136e2: 494a         	ldr	r1, [pc, #0x128]        @ 0x801380c <atanf+0x1f0>
 80136e4: f7ec fd56    	bl	0x8000194 <__aeabi_fadd> @ imm = #-0x13554
 80136e8: 4629         	mov	r1, r5
 80136ea: f7ec fe5b    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x1334a
 80136ee: 4948         	ldr	r1, [pc, #0x120]        @ 0x8013810 <atanf+0x1f4>
 80136f0: f7ec fd50    	bl	0x8000194 <__aeabi_fadd> @ imm = #-0x13560
 80136f4: 4629         	mov	r1, r5
 80136f6: f7ec fe55    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x13356
 80136fa: 4946         	ldr	r1, [pc, #0x118]        @ 0x8013814 <atanf+0x1f8>
 80136fc: f7ec fd4a    	bl	0x8000194 <__aeabi_fadd> @ imm = #-0x1356c
 8013700: 4639         	mov	r1, r7
 8013702: f7ec fe4f    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x13362
 8013706: 4944         	ldr	r1, [pc, #0x110]        @ 0x8013818 <atanf+0x1fc>
 8013708: 4607         	mov	r7, r0
 801370a: 4628         	mov	r0, r5
 801370c: f7ec fe4a    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x1336c
 8013710: 4942         	ldr	r1, [pc, #0x108]        @ 0x801381c <atanf+0x200>
 8013712: f7ec fd3d    	bl	0x8000190 <__subsf3>    @ imm = #-0x13586
 8013716: 4629         	mov	r1, r5
 8013718: f7ec fe44    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x13378
 801371c: 4940         	ldr	r1, [pc, #0x100]        @ 0x8013820 <atanf+0x204>
 801371e: f7ec fd37    	bl	0x8000190 <__subsf3>    @ imm = #-0x13592
 8013722: 4629         	mov	r1, r5
 8013724: f7ec fe3e    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x13384
 8013728: 493e         	ldr	r1, [pc, #0xf8]         @ 0x8013824 <atanf+0x208>
 801372a: f7ec fd31    	bl	0x8000190 <__subsf3>    @ imm = #-0x1359e
 801372e: 4629         	mov	r1, r5
 8013730: f7ec fe38    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x13390
 8013734: 493c         	ldr	r1, [pc, #0xf0]         @ 0x8013828 <atanf+0x20c>
 8013736: f7ec fd2b    	bl	0x8000190 <__subsf3>    @ imm = #-0x135aa
 801373a: 4629         	mov	r1, r5
 801373c: f7ec fe32    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x1339c
 8013740: 4601         	mov	r1, r0
 8013742: 4638         	mov	r0, r7
 8013744: f7ec fd26    	bl	0x8000194 <__aeabi_fadd> @ imm = #-0x135b4
 8013748: 4621         	mov	r1, r4
 801374a: f7ec fe2b    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x133aa
 801374e: 1c73         	adds	r3, r6, #0x1
 8013750: 4601         	mov	r1, r0
 8013752: d133         	bne	0x80137bc <atanf+0x1a0> @ imm = #0x66
 8013754: 4620         	mov	r0, r4
 8013756: e77a         	b	0x801364e <atanf+0x32>  @ imm = #-0x10c
 8013758: f04f 517e    	mov.w	r1, #0x3f800000
 801375c: 4620         	mov	r0, r4
 801375e: f7ec fd17    	bl	0x8000190 <__subsf3>    @ imm = #-0x135d2
 8013762: f04f 517e    	mov.w	r1, #0x3f800000
 8013766: 4605         	mov	r5, r0
 8013768: 4620         	mov	r0, r4
 801376a: f7ec fd13    	bl	0x8000194 <__aeabi_fadd> @ imm = #-0x135da
 801376e: 4601         	mov	r1, r0
 8013770: 4628         	mov	r0, r5
 8013772: f7ec fecb    	bl	0x800050c <__divsf3>    @ imm = #-0x1326a
 8013776: 2601         	movs	r6, #0x1
 8013778: 4604         	mov	r4, r0
 801377a: e79a         	b	0x80136b2 <atanf+0x96>  @ imm = #-0xcc
 801377c: 4a2b         	ldr	r2, [pc, #0xac]         @ 0x801382c <atanf+0x210>
 801377e: 4293         	cmp	r3, r2
 8013780: d815         	bhi	0x80137ae <atanf+0x192> @ imm = #0x2a
 8013782: f04f 517f    	mov.w	r1, #0x3fc00000
 8013786: 4620         	mov	r0, r4
 8013788: f7ec fd02    	bl	0x8000190 <__subsf3>    @ imm = #-0x135fc
 801378c: f04f 517f    	mov.w	r1, #0x3fc00000
 8013790: 4605         	mov	r5, r0
 8013792: 4620         	mov	r0, r4
 8013794: f7ec fe06    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x133f4
 8013798: f04f 517e    	mov.w	r1, #0x3f800000
 801379c: f7ec fcfa    	bl	0x8000194 <__aeabi_fadd> @ imm = #-0x1360c
 80137a0: 4601         	mov	r1, r0
 80137a2: 4628         	mov	r0, r5
 80137a4: f7ec feb2    	bl	0x800050c <__divsf3>    @ imm = #-0x1329c
 80137a8: 2602         	movs	r6, #0x2
 80137aa: 4604         	mov	r4, r0
 80137ac: e781         	b	0x80136b2 <atanf+0x96>  @ imm = #-0xfe
 80137ae: 4621         	mov	r1, r4
 80137b0: 481f         	ldr	r0, [pc, #0x7c]         @ 0x8013830 <atanf+0x214>
 80137b2: f7ec feab    	bl	0x800050c <__divsf3>    @ imm = #-0x132aa
 80137b6: 2603         	movs	r6, #0x3
 80137b8: 4604         	mov	r4, r0
 80137ba: e77a         	b	0x80136b2 <atanf+0x96>  @ imm = #-0x10c
 80137bc: 4b1d         	ldr	r3, [pc, #0x74]         @ 0x8013834 <atanf+0x218>
 80137be: f853 1026    	ldr.w	r1, [r3, r6, lsl #2]
 80137c2: f7ec fce5    	bl	0x8000190 <__subsf3>    @ imm = #-0x13636
 80137c6: 4621         	mov	r1, r4
 80137c8: f7ec fce2    	bl	0x8000190 <__subsf3>    @ imm = #-0x1363c
 80137cc: 4b1a         	ldr	r3, [pc, #0x68]         @ 0x8013838 <atanf+0x21c>
 80137ce: 4601         	mov	r1, r0
 80137d0: f853 0026    	ldr.w	r0, [r3, r6, lsl #2]
 80137d4: f7ec fcdc    	bl	0x8000190 <__subsf3>    @ imm = #-0x13648
 80137d8: f1b8 0f00    	cmp.w	r8, #0x0
 80137dc: 4604         	mov	r4, r0
 80137de: bfb8         	it	lt
 80137e0: f100 4400    	addlt.w	r4, r0, #0x80000000
 80137e4: e72a         	b	0x801363c <atanf+0x20>  @ imm = #-0x1ac
 80137e6: bf00         	nop

080137e8 <$d>:
 80137e8: 68 21 a2 33  	.word	0x33a22168
 80137ec: da 0f c9 3f  	.word	0x3fc90fda
 80137f0: da 0f c9 bf  	.word	0xbfc90fda
 80137f4: ff ff df 3e  	.word	0x3edfffff
 80137f8: ca f2 49 71  	.word	0x7149f2ca
 80137fc: ff ff 97 3f  	.word	0x3f97ffff
 8013800: d7 69 85 3c  	.word	0x3c8569d7
 8013804: 59 da 4b 3d  	.word	0x3d4bda59
 8013808: 35 6b 88 3d  	.word	0x3d886b35
 801380c: 6e 2e ba 3d  	.word	0x3dba2e6e
 8013810: 25 49 12 3e  	.word	0x3e124925
 8013814: ab aa aa 3e  	.word	0x3eaaaaab
 8013818: 21 a2 15 bd  	.word	0xbd15a221
 801381c: 6b f1 6e 3d  	.word	0x3d6ef16b
 8013820: 95 87 9d 3d  	.word	0x3d9d8795
 8013824: 38 8e e3 3d  	.word	0x3de38e38
 8013828: cd cc 4c 3e  	.word	0x3e4ccccd
 801382c: ff ff 1b 40  	.word	0x401bffff
 8013830: 00 00 80 bf  	.word	0xbf800000
 8013834: e0 0b 02 08  	.word	0x08020be0
 8013838: f0 0b 02 08  	.word	0x08020bf0

0801383c <scalbnf>:
 801383c: b538         	push	{r3, r4, r5, lr}
 801383e: f3c0 54c7    	ubfx	r4, r0, #0x17, #0x8
 8013842: 460d         	mov	r5, r1
 8013844: 4603         	mov	r3, r0
 8013846: f020 4100    	bic	r1, r0, #0x80000000
 801384a: b984         	cbnz	r4, 0x801386e <scalbnf+0x32> @ imm = #0x20
 801384c: b341         	cbz	r1, 0x80138a0 <scalbnf+0x64> @ imm = #0x50
 801384e: f04f 4198    	mov.w	r1, #0x4c000000
 8013852: f7ec fda7    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x134b2
 8013856: 4b1a         	ldr	r3, [pc, #0x68]         @ 0x80138c0 <scalbnf+0x84>
 8013858: f3c0 54c7    	ubfx	r4, r0, #0x17, #0x8
 801385c: 429d         	cmp	r5, r3
 801385e: f1a4 0419    	sub.w	r4, r4, #0x19
 8013862: da06         	bge	0x8013872 <scalbnf+0x36> @ imm = #0xc
 8013864: e8bd 4038    	pop.w	{r3, r4, r5, lr}
 8013868: 0fc0         	lsrs	r0, r0, #0x1f
 801386a: f00a b9e4    	b.w	0x801dc36 <__math_uflowf> @ imm = #0xa3c8
 801386e: 2cff         	cmp	r4, #0xff
 8013870: d008         	beq	0x8013884 <scalbnf+0x48> @ imm = #0x10
 8013872: f24c 3350    	movw	r3, #0xc350
 8013876: 429d         	cmp	r5, r3
 8013878: dd09         	ble	0x801388e <scalbnf+0x52> @ imm = #0x12
 801387a: e8bd 4038    	pop.w	{r3, r4, r5, lr}
 801387e: 0fc0         	lsrs	r0, r0, #0x1f
 8013880: f000 b820    	b.w	0x80138c4 <__math_oflowf> @ imm = #0x40
 8013884: 4601         	mov	r1, r0
 8013886: f7ec fc85    	bl	0x8000194 <__aeabi_fadd> @ imm = #-0x136f6
 801388a: 4603         	mov	r3, r0
 801388c: e008         	b	0x80138a0 <scalbnf+0x64> @ imm = #0x10
 801388e: 192b         	adds	r3, r5, r4
 8013890: 2bfe         	cmp	r3, #0xfe
 8013892: dcf2         	bgt	0x801387a <scalbnf+0x3e> @ imm = #-0x1c
 8013894: 2b00         	cmp	r3, #0x0
 8013896: dd05         	ble	0x80138a4 <scalbnf+0x68> @ imm = #0xa
 8013898: f020 40ff    	bic	r0, r0, #0x7f800000
 801389c: ea40 53c3    	orr.w	r3, r0, r3, lsl #23
 80138a0: 4618         	mov	r0, r3
 80138a2: bd38         	pop	{r3, r4, r5, pc}
 80138a4: f113 0f18    	cmn.w	r3, #0x18
 80138a8: dbdc         	blt	0x8013864 <scalbnf+0x28> @ imm = #-0x48
 80138aa: 3319         	adds	r3, #0x19
 80138ac: f020 40ff    	bic	r0, r0, #0x7f800000
 80138b0: f04f 514c    	mov.w	r1, #0x33000000
 80138b4: ea40 50c3    	orr.w	r0, r0, r3, lsl #23
 80138b8: f7ec fd74    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x13518
 80138bc: e7e5         	b	0x801388a <scalbnf+0x4e> @ imm = #-0x36
 80138be: bf00         	nop

080138c0 <$d>:
 80138c0: b0 3c ff ff  	.word	0xffff3cb0

080138c4 <__math_oflowf>:
 80138c4: b108         	cbz	r0, 0x80138ca <__math_oflowf+0x6> @ imm = #0x2
 80138c6: 4802         	ldr	r0, [pc, #0x8]          @ 0x80138d0 <__math_oflowf+0xc>
 80138c8: 4770         	bx	lr
 80138ca: f04f 40ff    	mov.w	r0, #0x7f800000
 80138ce: 4770         	bx	lr

080138d0 <$d>:
 80138d0: 00 00 80 ff  	.word	0xff800000

080138d4 <floorf>:
 80138d4: b538         	push	{r3, r4, r5, lr}
 80138d6: f3c0 53c7    	ubfx	r3, r0, #0x17, #0x8
 80138da: 3b7f         	subs	r3, #0x7f
 80138dc: 2b16         	cmp	r3, #0x16
 80138de: 4601         	mov	r1, r0
 80138e0: f020 4500    	bic	r5, r0, #0x80000000
 80138e4: dc19         	bgt	0x801391a <floorf+0x46> @ imm = #0x32
 80138e6: 2b00         	cmp	r3, #0x0
 80138e8: 4602         	mov	r2, r0
 80138ea: da08         	bge	0x80138fe <floorf+0x2a> @ imm = #0x10
 80138ec: 2800         	cmp	r0, #0x0
 80138ee: da1b         	bge	0x8013928 <floorf+0x54> @ imm = #0x36
 80138f0: 2d00         	cmp	r5, #0x0
 80138f2: 490e         	ldr	r1, [pc, #0x38]         @ 0x801392c <floorf+0x58>
 80138f4: bf08         	it	eq
 80138f6: f04f 4100    	moveq.w	r1, #0x80000000
 80138fa: 4608         	mov	r0, r1
 80138fc: bd38         	pop	{r3, r4, r5, pc}
 80138fe: 480c         	ldr	r0, [pc, #0x30]         @ 0x8013930 <floorf+0x5c>
 8013900: 4118         	asrs	r0, r3
 8013902: 4208         	tst	r0, r1
 8013904: d0f9         	beq	0x80138fa <floorf+0x26> @ imm = #-0xe
 8013906: 2900         	cmp	r1, #0x0
 8013908: bfbe         	ittt	lt
 801390a: f44f 0100    	movlt.w	r1, #0x800000
 801390e: fa41 f303    	asrlt.w	r3, r1, r3
 8013912: 18d2         	addlt	r2, r2, r3
 8013914: ea22 0100    	bic.w	r1, r2, r0
 8013918: e7ef         	b	0x80138fa <floorf+0x26> @ imm = #-0x22
 801391a: f1b5 4fff    	cmp.w	r5, #0x7f800000
 801391e: d3ec         	blo	0x80138fa <floorf+0x26> @ imm = #-0x28
 8013920: f7ec fc38    	bl	0x8000194 <__aeabi_fadd> @ imm = #-0x13790
 8013924: 4601         	mov	r1, r0
 8013926: e7e8         	b	0x80138fa <floorf+0x26> @ imm = #-0x30
 8013928: 2100         	movs	r1, #0x0
 801392a: e7e6         	b	0x80138fa <floorf+0x26> @ imm = #-0x34

0801392c <$d>:
 801392c: 00 00 80 bf  	.word	0xbf800000
 8013930: ff ff 7f 00  	.word	0x007fffff

08013934 <_OffsetAbsSyms>:
; GEN_ABS_SYM_BEGIN(_OffsetAbsSyms)
 8013934: b480         	push	{r7}
 8013936: af00         	add	r7, sp, #0x0
; GEN_ABS_SYM_END
 8013938: bf00         	nop
 801393a: 46bd         	mov	sp, r7
 801393c: bc80         	pop	{r7}
 801393e: 4770         	bx	lr

08013940 <device_is_ready>:
; {
 8013940: b580         	push	{r7, lr}
 8013942: b082         	sub	sp, #0x8
 8013944: af00         	add	r7, sp, #0x0
 8013946: 6078         	str	r0, [r7, #0x4]
; 	return z_impl_device_is_ready(dev);
 8013948: 6878         	ldr	r0, [r7, #0x4]
 801394a: f008 f918    	bl	0x801bb7e <z_impl_device_is_ready> @ imm = #0x8230
 801394e: 4603         	mov	r3, r0
; }
 8013950: 4618         	mov	r0, r3
 8013952: 3708         	adds	r7, #0x8
 8013954: 46bd         	mov	sp, r7
 8013956: bd80         	pop	{r7, pc}

08013958 <arch_k_cycle_get_32>:
; {
 8013958: b580         	push	{r7, lr}
 801395a: af00         	add	r7, sp, #0x0
; 	return sys_clock_cycle_get_32();
 801395c: f7f9 f86c    	bl	0x800ca38 <sys_clock_cycle_get_32> @ imm = #-0x6f28
 8013960: 4603         	mov	r3, r0
; }
 8013962: 4618         	mov	r0, r3
 8013964: bd80         	pop	{r7, pc}

08013966 <k_msleep>:
; {
 8013966: e92d 4fb0    	push.w	{r4, r5, r7, r8, r9, r10, r11, lr}
 801396a: b082         	sub	sp, #0x8
 801396c: af00         	add	r7, sp, #0x0
 801396e: 6078         	str	r0, [r7, #0x4]
; 	return k_sleep(Z_TIMEOUT_MS(ms));
 8013970: 6879         	ldr	r1, [r7, #0x4]
 8013972: ea21 71e1    	bic.w	r1, r1, r1, asr #31
 8013976: 17c8         	asrs	r0, r1, #0x1f
 8013978: 4688         	mov	r8, r1
 801397a: 4681         	mov	r9, r0
 801397c: 4640         	mov	r0, r8
 801397e: 4649         	mov	r1, r9
 8013980: f04f 0400    	mov.w	r4, #0x0
 8013984: f04f 0500    	mov.w	r5, #0x0
 8013988: 008d         	lsls	r5, r1, #0x2
 801398a: ea45 7590    	orr.w	r5, r5, r0, lsr #30
 801398e: 0084         	lsls	r4, r0, #0x2
 8013990: 4620         	mov	r0, r4
 8013992: 4629         	mov	r1, r5
 8013994: eb10 0208    	adds.w	r2, r0, r8
 8013998: eb41 0309    	adc.w	r3, r1, r9
 801399c: eb12 0a02    	adds.w	r10, r2, r2
 80139a0: eb43 0b03    	adc.w	r11, r3, r3
 80139a4: 4652         	mov	r2, r10
 80139a6: 465b         	mov	r3, r11
 80139a8: 4610         	mov	r0, r2
 80139aa: 4619         	mov	r1, r3
 80139ac: f000 f82e    	bl	0x8013a0c <k_sleep>     @ imm = #0x5c
 80139b0: 4601         	mov	r1, r0
 80139b2: 460b         	mov	r3, r1
; }
 80139b4: 4618         	mov	r0, r3
 80139b6: 3708         	adds	r7, #0x8
 80139b8: 46bd         	mov	sp, r7
 80139ba: e8bd 8fb0    	pop.w	{r4, r5, r7, r8, r9, r10, r11, pc}

080139be <k_cycle_get_32>:
; {
 80139be: b580         	push	{r7, lr}
 80139c0: af00         	add	r7, sp, #0x0
; 	return arch_k_cycle_get_32();
 80139c2: f7ff ffc9    	bl	0x8013958 <arch_k_cycle_get_32> @ imm = #-0x6e
 80139c6: 4603         	mov	r3, r0
; }
 80139c8: 4618         	mov	r0, r3
 80139ca: bd80         	pop	{r7, pc}

080139cc <k_thread_create>:
; {
 80139cc: b580         	push	{r7, lr}
 80139ce: b08c         	sub	sp, #0x30
 80139d0: af08         	add	r7, sp, #0x20
 80139d2: 60f8         	str	r0, [r7, #0xc]
 80139d4: 60b9         	str	r1, [r7, #0x8]
 80139d6: 607a         	str	r2, [r7, #0x4]
 80139d8: 603b         	str	r3, [r7]
; 	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
 80139da: e9d7 230c    	ldrd	r2, r3, [r7, #48]
 80139de: e9cd 2306    	strd	r2, r3, [sp, #24]
 80139e2: 6abb         	ldr	r3, [r7, #0x28]
 80139e4: 9304         	str	r3, [sp, #0x10]
 80139e6: 6a7b         	ldr	r3, [r7, #0x24]
 80139e8: 9303         	str	r3, [sp, #0xc]
 80139ea: 6a3b         	ldr	r3, [r7, #0x20]
 80139ec: 9302         	str	r3, [sp, #0x8]
 80139ee: 69fb         	ldr	r3, [r7, #0x1c]
 80139f0: 9301         	str	r3, [sp, #0x4]
 80139f2: 69bb         	ldr	r3, [r7, #0x18]
 80139f4: 9300         	str	r3, [sp]
 80139f6: 683b         	ldr	r3, [r7]
 80139f8: 687a         	ldr	r2, [r7, #0x4]
 80139fa: 68b9         	ldr	r1, [r7, #0x8]
 80139fc: 68f8         	ldr	r0, [r7, #0xc]
 80139fe: f009 f89b    	bl	0x801cb38 <z_impl_k_thread_create> @ imm = #0x9136
 8013a02: 4603         	mov	r3, r0
; }
 8013a04: 4618         	mov	r0, r3
 8013a06: 3710         	adds	r7, #0x10
 8013a08: 46bd         	mov	sp, r7
 8013a0a: bd80         	pop	{r7, pc}

08013a0c <k_sleep>:
; {
 8013a0c: b580         	push	{r7, lr}
 8013a0e: b082         	sub	sp, #0x8
 8013a10: af00         	add	r7, sp, #0x0
 8013a12: e9c7 0100    	strd	r0, r1, [r7]
; 	return z_impl_k_sleep(timeout);
 8013a16: e9d7 0100    	ldrd	r0, r1, [r7]
 8013a1a: f7fc fcef    	bl	0x80103fc <z_impl_k_sleep> @ imm = #-0x3622
 8013a1e: 4603         	mov	r3, r0
; }
 8013a20: 4618         	mov	r0, r3
 8013a22: 3708         	adds	r7, #0x8
 8013a24: 46bd         	mov	sp, r7
 8013a26: bd80         	pop	{r7, pc}

08013a28 <sensor_trigger_set>:
; {
 8013a28: b580         	push	{r7, lr}
 8013a2a: b086         	sub	sp, #0x18
 8013a2c: af00         	add	r7, sp, #0x0
 8013a2e: 60f8         	str	r0, [r7, #0xc]
 8013a30: 60b9         	str	r1, [r7, #0x8]
 8013a32: 607a         	str	r2, [r7, #0x4]
; 	const struct sensor_driver_api *api =
 8013a34: 68fb         	ldr	r3, [r7, #0xc]
 8013a36: 689b         	ldr	r3, [r3, #0x8]
 8013a38: 617b         	str	r3, [r7, #0x14]
; 	if (api->trigger_set == NULL) {
 8013a3a: 697b         	ldr	r3, [r7, #0x14]
 8013a3c: 689b         	ldr	r3, [r3, #0x8]
 8013a3e: 2b00         	cmp	r3, #0x0
 8013a40: d102         	bne	0x8013a48 <sensor_trigger_set+0x20> @ imm = #0x4
; 		return -ENOSYS;
 8013a42: f06f 0357    	mvn	r3, #0x57
 8013a46: e006         	b	0x8013a56 <sensor_trigger_set+0x2e> @ imm = #0xc
; 	return api->trigger_set(dev, trig, handler);
 8013a48: 697b         	ldr	r3, [r7, #0x14]
 8013a4a: 689b         	ldr	r3, [r3, #0x8]
 8013a4c: 687a         	ldr	r2, [r7, #0x4]
 8013a4e: 68b9         	ldr	r1, [r7, #0x8]
 8013a50: 68f8         	ldr	r0, [r7, #0xc]
 8013a52: 4798         	blx	r3
 8013a54: 4603         	mov	r3, r0
; }
 8013a56: 4618         	mov	r0, r3
 8013a58: 3718         	adds	r7, #0x18
 8013a5a: 46bd         	mov	sp, r7
 8013a5c: bd80         	pop	{r7, pc}

08013a5e <z_impl_sensor_sample_fetch>:
; {
 8013a5e: b580         	push	{r7, lr}
 8013a60: b084         	sub	sp, #0x10
 8013a62: af00         	add	r7, sp, #0x0
 8013a64: 6078         	str	r0, [r7, #0x4]
; 	const struct sensor_driver_api *api =
 8013a66: 687b         	ldr	r3, [r7, #0x4]
 8013a68: 689b         	ldr	r3, [r3, #0x8]
 8013a6a: 60fb         	str	r3, [r7, #0xc]
; 	return api->sample_fetch(dev, SENSOR_CHAN_ALL);
 8013a6c: 68fb         	ldr	r3, [r7, #0xc]
 8013a6e: 68db         	ldr	r3, [r3, #0xc]
 8013a70: 213c         	movs	r1, #0x3c
 8013a72: 6878         	ldr	r0, [r7, #0x4]
 8013a74: 4798         	blx	r3
 8013a76: 4603         	mov	r3, r0
; }
 8013a78: 4618         	mov	r0, r3
 8013a7a: 3710         	adds	r7, #0x10
 8013a7c: 46bd         	mov	sp, r7
 8013a7e: bd80         	pop	{r7, pc}

08013a80 <z_impl_sensor_channel_get>:
; {
 8013a80: b580         	push	{r7, lr}
 8013a82: b086         	sub	sp, #0x18
 8013a84: af00         	add	r7, sp, #0x0
 8013a86: 60f8         	str	r0, [r7, #0xc]
 8013a88: 460b         	mov	r3, r1
 8013a8a: 607a         	str	r2, [r7, #0x4]
 8013a8c: 817b         	strh	r3, [r7, #0xa]
; 	const struct sensor_driver_api *api =
 8013a8e: 68fb         	ldr	r3, [r7, #0xc]
 8013a90: 689b         	ldr	r3, [r3, #0x8]
 8013a92: 617b         	str	r3, [r7, #0x14]
; 	return api->channel_get(dev, chan, val);
 8013a94: 697b         	ldr	r3, [r7, #0x14]
 8013a96: 691b         	ldr	r3, [r3, #0x10]
 8013a98: 8979         	ldrh	r1, [r7, #0xa]
 8013a9a: 687a         	ldr	r2, [r7, #0x4]
 8013a9c: 68f8         	ldr	r0, [r7, #0xc]
 8013a9e: 4798         	blx	r3
 8013aa0: 4603         	mov	r3, r0
; }
 8013aa2: 4618         	mov	r0, r3
 8013aa4: 3718         	adds	r7, #0x18
 8013aa6: 46bd         	mov	sp, r7
 8013aa8: bd80         	pop	{r7, pc}

08013aaa <sensor_sample_fetch>:
; {
 8013aaa: b580         	push	{r7, lr}
 8013aac: b082         	sub	sp, #0x8
 8013aae: af00         	add	r7, sp, #0x0
 8013ab0: 6078         	str	r0, [r7, #0x4]
; 	return z_impl_sensor_sample_fetch(dev);
 8013ab2: 6878         	ldr	r0, [r7, #0x4]
 8013ab4: f7ff ffd3    	bl	0x8013a5e <z_impl_sensor_sample_fetch> @ imm = #-0x5a
 8013ab8: 4603         	mov	r3, r0
; }
 8013aba: 4618         	mov	r0, r3
 8013abc: 3708         	adds	r7, #0x8
 8013abe: 46bd         	mov	sp, r7
 8013ac0: bd80         	pop	{r7, pc}

08013ac2 <sensor_channel_get>:
; {
 8013ac2: b580         	push	{r7, lr}
 8013ac4: b084         	sub	sp, #0x10
 8013ac6: af00         	add	r7, sp, #0x0
 8013ac8: 60f8         	str	r0, [r7, #0xc]
 8013aca: 460b         	mov	r3, r1
 8013acc: 607a         	str	r2, [r7, #0x4]
 8013ace: 817b         	strh	r3, [r7, #0xa]
; 	return z_impl_sensor_channel_get(dev, chan, val);
 8013ad0: 897b         	ldrh	r3, [r7, #0xa]
 8013ad2: 687a         	ldr	r2, [r7, #0x4]
 8013ad4: 4619         	mov	r1, r3
 8013ad6: 68f8         	ldr	r0, [r7, #0xc]
 8013ad8: f7ff ffd2    	bl	0x8013a80 <z_impl_sensor_channel_get> @ imm = #-0x5c
 8013adc: 4603         	mov	r3, r0
; }
 8013ade: 4618         	mov	r0, r3
 8013ae0: 3710         	adds	r7, #0x10
 8013ae2: 46bd         	mov	sp, r7
 8013ae4: bd80         	pop	{r7, pc}

08013ae6 <z_impl_uart_tx>:
; {
 8013ae6: b590         	push	{r4, r7, lr}
 8013ae8: b087         	sub	sp, #0x1c
 8013aea: af00         	add	r7, sp, #0x0
 8013aec: 60f8         	str	r0, [r7, #0xc]
 8013aee: 60b9         	str	r1, [r7, #0x8]
 8013af0: 607a         	str	r2, [r7, #0x4]
 8013af2: 603b         	str	r3, [r7]
; 	const struct uart_driver_api *api = (const struct uart_driver_api *)dev->api;
 8013af4: 68fb         	ldr	r3, [r7, #0xc]
 8013af6: 689b         	ldr	r3, [r3, #0x8]
 8013af8: 617b         	str	r3, [r7, #0x14]
; 	return api->tx(dev, buf, len, timeout);
 8013afa: 697b         	ldr	r3, [r7, #0x14]
 8013afc: 685c         	ldr	r4, [r3, #0x4]
 8013afe: 683b         	ldr	r3, [r7]
 8013b00: 687a         	ldr	r2, [r7, #0x4]
 8013b02: 68b9         	ldr	r1, [r7, #0x8]
 8013b04: 68f8         	ldr	r0, [r7, #0xc]
 8013b06: 47a0         	blx	r4
 8013b08: 4603         	mov	r3, r0
; }
 8013b0a: 4618         	mov	r0, r3
 8013b0c: 371c         	adds	r7, #0x1c
 8013b0e: 46bd         	mov	sp, r7
 8013b10: bd90         	pop	{r4, r7, pc}

08013b12 <uart_tx>:
; {
 8013b12: b580         	push	{r7, lr}
 8013b14: b084         	sub	sp, #0x10
 8013b16: af00         	add	r7, sp, #0x0
 8013b18: 60f8         	str	r0, [r7, #0xc]
 8013b1a: 60b9         	str	r1, [r7, #0x8]
 8013b1c: 607a         	str	r2, [r7, #0x4]
 8013b1e: 603b         	str	r3, [r7]
; 	return z_impl_uart_tx(dev, buf, len, timeout);
 8013b20: 683b         	ldr	r3, [r7]
 8013b22: 687a         	ldr	r2, [r7, #0x4]
 8013b24: 68b9         	ldr	r1, [r7, #0x8]
 8013b26: 68f8         	ldr	r0, [r7, #0xc]
 8013b28: f7ff ffdd    	bl	0x8013ae6 <z_impl_uart_tx> @ imm = #-0x46
 8013b2c: 4603         	mov	r3, r0
; }
 8013b2e: 4618         	mov	r0, r3
 8013b30: 3710         	adds	r7, #0x10
 8013b32: 46bd         	mov	sp, r7
 8013b34: bd80         	pop	{r7, pc}

08013b36 <jf_feedback>:
; {
 8013b36: b580         	push	{r7, lr}
 8013b38: b086         	sub	sp, #0x18
 8013b3a: af00         	add	r7, sp, #0x0
 8013b3c: 60f8         	str	r0, [r7, #0xc]
 8013b3e: 60b9         	str	r1, [r7, #0x8]
 8013b40: 607a         	str	r2, [r7, #0x4]
; 	int delay = (int)arg1;
 8013b42: 68fb         	ldr	r3, [r7, #0xc]
 8013b44: 617b         	str	r3, [r7, #0x14]
; 	struct JFData *data = (struct JFData *)arg2;
 8013b46: 68bb         	ldr	r3, [r7, #0x8]
 8013b48: 613b         	str	r3, [r7, #0x10]
; 		k_msleep(delay);
 8013b4a: 6978         	ldr	r0, [r7, #0x14]
 8013b4c: f7ff ff0b    	bl	0x8013966 <k_msleep>    @ imm = #-0x1ea
; 		jf_send_float(data);
 8013b50: 6938         	ldr	r0, [r7, #0x10]
 8013b52: f7ed f979    	bl	0x8000e48 <jf_send_float> @ imm = #-0x12d0e
; 		k_msleep(delay);
 8013b56: bf00         	nop
 8013b58: e7f7         	b	0x8013b4a <jf_feedback+0x14> @ imm = #-0x12

08013b5a <Kalman_Filter_xhatMinusUpdate>:
; {
 8013b5a: b580         	push	{r7, lr}
 8013b5c: b082         	sub	sp, #0x8
 8013b5e: af00         	add	r7, sp, #0x0
 8013b60: 6078         	str	r0, [r7, #0x4]
; 	if (!kf->SkipEq1) {
 8013b62: 687b         	ldr	r3, [r7, #0x4]
 8013b64: f893 3028    	ldrb.w	r3, [r3, #0x28]
 8013b68: 2b00         	cmp	r3, #0x0
 8013b6a: d158         	bne	0x8013c1e <Kalman_Filter_xhatMinusUpdate+0xc4> @ imm = #0xb0
; 		if (kf->uSize > 0) {
 8013b6c: 687b         	ldr	r3, [r7, #0x4]
 8013b6e: 7b5b         	ldrb	r3, [r3, #0xd]
 8013b70: 2b00         	cmp	r3, #0x0
 8013b72: d044         	beq	0x8013bfe <Kalman_Filter_xhatMinusUpdate+0xa4> @ imm = #0x88
; 			kf->temp_vector.numRows = kf->xhatSize;
 8013b74: 687b         	ldr	r3, [r7, #0x4]
 8013b76: 7b1b         	ldrb	r3, [r3, #0xc]
 8013b78: 461a         	mov	r2, r3
 8013b7a: 687b         	ldr	r3, [r7, #0x4]
 8013b7c: f8a3 20b8    	strh.w	r2, [r3, #0xb8]
; 			kf->temp_vector.numCols = 1;
 8013b80: 687b         	ldr	r3, [r7, #0x4]
 8013b82: 2201         	movs	r2, #0x1
 8013b84: f8a3 20ba    	strh.w	r2, [r3, #0xba]
; 			kf->MatStatus = Matrix_Multiply(&kf->F, &kf->xhat, &kf->temp_vector);
 8013b88: 687b         	ldr	r3, [r7, #0x4]
 8013b8a: f103 0060    	add.w	r0, r3, #0x60
 8013b8e: 687b         	ldr	r3, [r7, #0x4]
 8013b90: f103 0130    	add.w	r1, r3, #0x30
 8013b94: 687b         	ldr	r3, [r7, #0x4]
 8013b96: 33b8         	adds	r3, #0xb8
 8013b98: 461a         	mov	r2, r3
 8013b9a: f7f9 f989    	bl	0x800ceb0 <arm_mat_mult_f32> @ imm = #-0x6cee
 8013b9e: 4603         	mov	r3, r0
 8013ba0: 461a         	mov	r2, r3
 8013ba2: 687b         	ldr	r3, [r7, #0x4]
 8013ba4: f883 20c8    	strb.w	r2, [r3, #0xc8]
; 			kf->temp_vector1.numRows = kf->xhatSize;
 8013ba8: 687b         	ldr	r3, [r7, #0x4]
 8013baa: 7b1b         	ldrb	r3, [r3, #0xc]
 8013bac: 461a         	mov	r2, r3
 8013bae: 687b         	ldr	r3, [r7, #0x4]
 8013bb0: f8a3 20c0    	strh.w	r2, [r3, #0xc0]
; 			kf->temp_vector1.numCols = 1;
 8013bb4: 687b         	ldr	r3, [r7, #0x4]
 8013bb6: 2201         	movs	r2, #0x1
 8013bb8: f8a3 20c2    	strh.w	r2, [r3, #0xc2]
; 			kf->MatStatus = Matrix_Multiply(&kf->B, &kf->u, &kf->temp_vector1);
 8013bbc: 687b         	ldr	r3, [r7, #0x4]
 8013bbe: f103 0070    	add.w	r0, r3, #0x70
 8013bc2: 687b         	ldr	r3, [r7, #0x4]
 8013bc4: f103 0140    	add.w	r1, r3, #0x40
 8013bc8: 687b         	ldr	r3, [r7, #0x4]
 8013bca: 33c0         	adds	r3, #0xc0
 8013bcc: 461a         	mov	r2, r3
 8013bce: f7f9 f96f    	bl	0x800ceb0 <arm_mat_mult_f32> @ imm = #-0x6d22
 8013bd2: 4603         	mov	r3, r0
 8013bd4: 461a         	mov	r2, r3
 8013bd6: 687b         	ldr	r3, [r7, #0x4]
 8013bd8: f883 20c8    	strb.w	r2, [r3, #0xc8]
; 				Matrix_Add(&kf->temp_vector, &kf->temp_vector1, &kf->xhatminus);
 8013bdc: 687b         	ldr	r3, [r7, #0x4]
 8013bde: f103 00b8    	add.w	r0, r3, #0xb8
 8013be2: 687b         	ldr	r3, [r7, #0x4]
 8013be4: f103 01c0    	add.w	r1, r3, #0xc0
 8013be8: 687b         	ldr	r3, [r7, #0x4]
 8013bea: 3338         	adds	r3, #0x38
 8013bec: 461a         	mov	r2, r3
 8013bee: f7f8 ff8b    	bl	0x800cb08 <arm_mat_add_f32> @ imm = #-0x70ea
 8013bf2: 4603         	mov	r3, r0
 8013bf4: 461a         	mov	r2, r3
; 			kf->MatStatus =
 8013bf6: 687b         	ldr	r3, [r7, #0x4]
 8013bf8: f883 20c8    	strb.w	r2, [r3, #0xc8]
; }
 8013bfc: e00f         	b	0x8013c1e <Kalman_Filter_xhatMinusUpdate+0xc4> @ imm = #0x1e
; 			kf->MatStatus = Matrix_Multiply(&kf->F, &kf->xhat, &kf->xhatminus);
 8013bfe: 687b         	ldr	r3, [r7, #0x4]
 8013c00: f103 0060    	add.w	r0, r3, #0x60
 8013c04: 687b         	ldr	r3, [r7, #0x4]
 8013c06: f103 0130    	add.w	r1, r3, #0x30
 8013c0a: 687b         	ldr	r3, [r7, #0x4]
 8013c0c: 3338         	adds	r3, #0x38
 8013c0e: 461a         	mov	r2, r3
 8013c10: f7f9 f94e    	bl	0x800ceb0 <arm_mat_mult_f32> @ imm = #-0x6d64
 8013c14: 4603         	mov	r3, r0
 8013c16: 461a         	mov	r2, r3
 8013c18: 687b         	ldr	r3, [r7, #0x4]
 8013c1a: f883 20c8    	strb.w	r2, [r3, #0xc8]
; }
 8013c1e: bf00         	nop
 8013c20: 3708         	adds	r7, #0x8
 8013c22: 46bd         	mov	sp, r7
 8013c24: bd80         	pop	{r7, pc}

08013c26 <Kalman_Filter_PminusUpdate>:
; {
 8013c26: b580         	push	{r7, lr}
 8013c28: b082         	sub	sp, #0x8
 8013c2a: af00         	add	r7, sp, #0x0
 8013c2c: 6078         	str	r0, [r7, #0x4]
; 	if (!kf->SkipEq2) {
 8013c2e: 687b         	ldr	r3, [r7, #0x4]
 8013c30: f893 3029    	ldrb.w	r3, [r3, #0x29]
 8013c34: 2b00         	cmp	r3, #0x0
 8013c36: d149         	bne	0x8013ccc <Kalman_Filter_PminusUpdate+0xa6> @ imm = #0x92
; 		kf->MatStatus = Matrix_Transpose(&kf->F, &kf->FT);
 8013c38: 687b         	ldr	r3, [r7, #0x4]
 8013c3a: f103 0260    	add.w	r2, r3, #0x60
 8013c3e: 687b         	ldr	r3, [r7, #0x4]
 8013c40: 3368         	adds	r3, #0x68
 8013c42: 4619         	mov	r1, r3
 8013c44: 4610         	mov	r0, r2
 8013c46: f7f9 f9cd    	bl	0x800cfe4 <arm_mat_trans_f32> @ imm = #-0x6c66
 8013c4a: 4603         	mov	r3, r0
 8013c4c: 461a         	mov	r2, r3
 8013c4e: 687b         	ldr	r3, [r7, #0x4]
 8013c50: f883 20c8    	strb.w	r2, [r3, #0xc8]
; 		kf->MatStatus = Matrix_Multiply(&kf->F, &kf->P, &kf->Pminus);
 8013c54: 687b         	ldr	r3, [r7, #0x4]
 8013c56: f103 0060    	add.w	r0, r3, #0x60
 8013c5a: 687b         	ldr	r3, [r7, #0x4]
 8013c5c: f103 0150    	add.w	r1, r3, #0x50
 8013c60: 687b         	ldr	r3, [r7, #0x4]
 8013c62: 3358         	adds	r3, #0x58
 8013c64: 461a         	mov	r2, r3
 8013c66: f7f9 f923    	bl	0x800ceb0 <arm_mat_mult_f32> @ imm = #-0x6dba
 8013c6a: 4603         	mov	r3, r0
 8013c6c: 461a         	mov	r2, r3
 8013c6e: 687b         	ldr	r3, [r7, #0x4]
 8013c70: f883 20c8    	strb.w	r2, [r3, #0xc8]
; 		kf->temp_matrix.numRows = kf->Pminus.numRows;
 8013c74: 687b         	ldr	r3, [r7, #0x4]
 8013c76: f8b3 2058    	ldrh.w	r2, [r3, #0x58]
 8013c7a: 687b         	ldr	r3, [r7, #0x4]
 8013c7c: f8a3 20a8    	strh.w	r2, [r3, #0xa8]
; 		kf->temp_matrix.numCols = kf->FT.numCols;
 8013c80: 687b         	ldr	r3, [r7, #0x4]
 8013c82: f8b3 206a    	ldrh.w	r2, [r3, #0x6a]
 8013c86: 687b         	ldr	r3, [r7, #0x4]
 8013c88: f8a3 20aa    	strh.w	r2, [r3, #0xaa]
; 		kf->MatStatus = Matrix_Multiply(&kf->Pminus, &kf->FT,
 8013c8c: 687b         	ldr	r3, [r7, #0x4]
 8013c8e: f103 0058    	add.w	r0, r3, #0x58
 8013c92: 687b         	ldr	r3, [r7, #0x4]
 8013c94: f103 0168    	add.w	r1, r3, #0x68
 8013c98: 687b         	ldr	r3, [r7, #0x4]
 8013c9a: 33a8         	adds	r3, #0xa8
 8013c9c: 461a         	mov	r2, r3
 8013c9e: f7f9 f907    	bl	0x800ceb0 <arm_mat_mult_f32> @ imm = #-0x6df2
 8013ca2: 4603         	mov	r3, r0
 8013ca4: 461a         	mov	r2, r3
 8013ca6: 687b         	ldr	r3, [r7, #0x4]
 8013ca8: f883 20c8    	strb.w	r2, [r3, #0xc8]
; 		kf->MatStatus = Matrix_Add(&kf->temp_matrix, &kf->Q, &kf->Pminus);
 8013cac: 687b         	ldr	r3, [r7, #0x4]
 8013cae: f103 00a8    	add.w	r0, r3, #0xa8
 8013cb2: 687b         	ldr	r3, [r7, #0x4]
 8013cb4: f103 0188    	add.w	r1, r3, #0x88
 8013cb8: 687b         	ldr	r3, [r7, #0x4]
 8013cba: 3358         	adds	r3, #0x58
 8013cbc: 461a         	mov	r2, r3
 8013cbe: f7f8 ff23    	bl	0x800cb08 <arm_mat_add_f32> @ imm = #-0x71ba
 8013cc2: 4603         	mov	r3, r0
 8013cc4: 461a         	mov	r2, r3
 8013cc6: 687b         	ldr	r3, [r7, #0x4]
 8013cc8: f883 20c8    	strb.w	r2, [r3, #0xc8]
; }
 8013ccc: bf00         	nop
 8013cce: 3708         	adds	r7, #0x8
 8013cd0: 46bd         	mov	sp, r7
 8013cd2: bd80         	pop	{r7, pc}

08013cd4 <Kalman_Filter_SetK>:
; {
 8013cd4: b580         	push	{r7, lr}
 8013cd6: b082         	sub	sp, #0x8
 8013cd8: af00         	add	r7, sp, #0x0
 8013cda: 6078         	str	r0, [r7, #0x4]
; 	if (!kf->SkipEq3) {
 8013cdc: 687b         	ldr	r3, [r7, #0x4]
 8013cde: f893 302a    	ldrb.w	r3, [r3, #0x2a]
 8013ce2: 2b00         	cmp	r3, #0x0
 8013ce4: f040 809c    	bne.w	0x8013e20 <Kalman_Filter_SetK+0x14c> @ imm = #0x138
; 		kf->MatStatus = Matrix_Transpose(&kf->H, &kf->HT); // z|x => x|z
 8013ce8: 687b         	ldr	r3, [r7, #0x4]
 8013cea: f103 0278    	add.w	r2, r3, #0x78
 8013cee: 687b         	ldr	r3, [r7, #0x4]
 8013cf0: 3380         	adds	r3, #0x80
 8013cf2: 4619         	mov	r1, r3
 8013cf4: 4610         	mov	r0, r2
 8013cf6: f7f9 f975    	bl	0x800cfe4 <arm_mat_trans_f32> @ imm = #-0x6d16
 8013cfa: 4603         	mov	r3, r0
 8013cfc: 461a         	mov	r2, r3
 8013cfe: 687b         	ldr	r3, [r7, #0x4]
 8013d00: f883 20c8    	strb.w	r2, [r3, #0xc8]
; 		kf->temp_matrix.numRows = kf->H.numRows;
 8013d04: 687b         	ldr	r3, [r7, #0x4]
 8013d06: f8b3 2078    	ldrh.w	r2, [r3, #0x78]
 8013d0a: 687b         	ldr	r3, [r7, #0x4]
 8013d0c: f8a3 20a8    	strh.w	r2, [r3, #0xa8]
; 		kf->temp_matrix.numCols = kf->Pminus.numCols;
 8013d10: 687b         	ldr	r3, [r7, #0x4]
 8013d12: f8b3 205a    	ldrh.w	r2, [r3, #0x5a]
 8013d16: 687b         	ldr	r3, [r7, #0x4]
 8013d18: f8a3 20aa    	strh.w	r2, [r3, #0xaa]
; 		kf->MatStatus = Matrix_Multiply(&kf->H, &kf->Pminus,
 8013d1c: 687b         	ldr	r3, [r7, #0x4]
 8013d1e: f103 0078    	add.w	r0, r3, #0x78
 8013d22: 687b         	ldr	r3, [r7, #0x4]
 8013d24: f103 0158    	add.w	r1, r3, #0x58
 8013d28: 687b         	ldr	r3, [r7, #0x4]
 8013d2a: 33a8         	adds	r3, #0xa8
 8013d2c: 461a         	mov	r2, r3
 8013d2e: f7f9 f8bf    	bl	0x800ceb0 <arm_mat_mult_f32> @ imm = #-0x6e82
 8013d32: 4603         	mov	r3, r0
 8013d34: 461a         	mov	r2, r3
 8013d36: 687b         	ldr	r3, [r7, #0x4]
 8013d38: f883 20c8    	strb.w	r2, [r3, #0xc8]
; 		kf->temp_matrix1.numRows = kf->temp_matrix.numRows;
 8013d3c: 687b         	ldr	r3, [r7, #0x4]
 8013d3e: f8b3 20a8    	ldrh.w	r2, [r3, #0xa8]
 8013d42: 687b         	ldr	r3, [r7, #0x4]
 8013d44: f8a3 20b0    	strh.w	r2, [r3, #0xb0]
; 		kf->temp_matrix1.numCols = kf->HT.numCols;
 8013d48: 687b         	ldr	r3, [r7, #0x4]
 8013d4a: f8b3 2082    	ldrh.w	r2, [r3, #0x82]
 8013d4e: 687b         	ldr	r3, [r7, #0x4]
 8013d50: f8a3 20b2    	strh.w	r2, [r3, #0xb2]
; 		kf->MatStatus = Matrix_Multiply(&kf->temp_matrix, &kf->HT,
 8013d54: 687b         	ldr	r3, [r7, #0x4]
 8013d56: f103 00a8    	add.w	r0, r3, #0xa8
 8013d5a: 687b         	ldr	r3, [r7, #0x4]
 8013d5c: f103 0180    	add.w	r1, r3, #0x80
 8013d60: 687b         	ldr	r3, [r7, #0x4]
 8013d62: 33b0         	adds	r3, #0xb0
 8013d64: 461a         	mov	r2, r3
 8013d66: f7f9 f8a3    	bl	0x800ceb0 <arm_mat_mult_f32> @ imm = #-0x6eba
 8013d6a: 4603         	mov	r3, r0
 8013d6c: 461a         	mov	r2, r3
 8013d6e: 687b         	ldr	r3, [r7, #0x4]
 8013d70: f883 20c8    	strb.w	r2, [r3, #0xc8]
; 		kf->S.numRows = kf->R.numRows;
 8013d74: 687b         	ldr	r3, [r7, #0x4]
 8013d76: f8b3 2090    	ldrh.w	r2, [r3, #0x90]
 8013d7a: 687b         	ldr	r3, [r7, #0x4]
 8013d7c: f8a3 20a0    	strh.w	r2, [r3, #0xa0]
; 		kf->S.numCols = kf->R.numCols;
 8013d80: 687b         	ldr	r3, [r7, #0x4]
 8013d82: f8b3 2092    	ldrh.w	r2, [r3, #0x92]
 8013d86: 687b         	ldr	r3, [r7, #0x4]
 8013d88: f8a3 20a2    	strh.w	r2, [r3, #0xa2]
; 		kf->MatStatus = Matrix_Add(&kf->temp_matrix1, &kf->R, &kf->S); // S = H P'(k) HT + R
 8013d8c: 687b         	ldr	r3, [r7, #0x4]
 8013d8e: f103 00b0    	add.w	r0, r3, #0xb0
 8013d92: 687b         	ldr	r3, [r7, #0x4]
 8013d94: f103 0190    	add.w	r1, r3, #0x90
 8013d98: 687b         	ldr	r3, [r7, #0x4]
 8013d9a: 33a0         	adds	r3, #0xa0
 8013d9c: 461a         	mov	r2, r3
 8013d9e: f7f8 feb3    	bl	0x800cb08 <arm_mat_add_f32> @ imm = #-0x729a
 8013da2: 4603         	mov	r3, r0
 8013da4: 461a         	mov	r2, r3
 8013da6: 687b         	ldr	r3, [r7, #0x4]
 8013da8: f883 20c8    	strb.w	r2, [r3, #0xc8]
; 			&kf->S, &kf->temp_matrix1); // temp_matrix1 = inv(H·P'(k)·HT + R)
 8013dac: 687b         	ldr	r3, [r7, #0x4]
 8013dae: f103 02a0    	add.w	r2, r3, #0xa0
; 		kf->MatStatus = Matrix_Inverse(
 8013db2: 687b         	ldr	r3, [r7, #0x4]
 8013db4: 33b0         	adds	r3, #0xb0
 8013db6: 4619         	mov	r1, r3
 8013db8: 4610         	mov	r0, r2
 8013dba: f7f8 febf    	bl	0x800cb3c <arm_mat_inverse_f32> @ imm = #-0x7282
 8013dbe: 4603         	mov	r3, r0
 8013dc0: 461a         	mov	r2, r3
 8013dc2: 687b         	ldr	r3, [r7, #0x4]
 8013dc4: f883 20c8    	strb.w	r2, [r3, #0xc8]
; 		kf->temp_matrix.numRows = kf->Pminus.numRows;
 8013dc8: 687b         	ldr	r3, [r7, #0x4]
 8013dca: f8b3 2058    	ldrh.w	r2, [r3, #0x58]
 8013dce: 687b         	ldr	r3, [r7, #0x4]
 8013dd0: f8a3 20a8    	strh.w	r2, [r3, #0xa8]
; 		kf->temp_matrix.numCols = kf->HT.numCols;
 8013dd4: 687b         	ldr	r3, [r7, #0x4]
 8013dd6: f8b3 2082    	ldrh.w	r2, [r3, #0x82]
 8013dda: 687b         	ldr	r3, [r7, #0x4]
 8013ddc: f8a3 20aa    	strh.w	r2, [r3, #0xaa]
; 		kf->MatStatus = Matrix_Multiply(&kf->Pminus, &kf->HT,
 8013de0: 687b         	ldr	r3, [r7, #0x4]
 8013de2: f103 0058    	add.w	r0, r3, #0x58
 8013de6: 687b         	ldr	r3, [r7, #0x4]
 8013de8: f103 0180    	add.w	r1, r3, #0x80
 8013dec: 687b         	ldr	r3, [r7, #0x4]
 8013dee: 33a8         	adds	r3, #0xa8
 8013df0: 461a         	mov	r2, r3
 8013df2: f7f9 f85d    	bl	0x800ceb0 <arm_mat_mult_f32> @ imm = #-0x6f46
 8013df6: 4603         	mov	r3, r0
 8013df8: 461a         	mov	r2, r3
 8013dfa: 687b         	ldr	r3, [r7, #0x4]
 8013dfc: f883 20c8    	strb.w	r2, [r3, #0xc8]
; 		kf->MatStatus = Matrix_Multiply(&kf->temp_matrix, &kf->temp_matrix1, &kf->K);
 8013e00: 687b         	ldr	r3, [r7, #0x4]
 8013e02: f103 00a8    	add.w	r0, r3, #0xa8
 8013e06: 687b         	ldr	r3, [r7, #0x4]
 8013e08: f103 01b0    	add.w	r1, r3, #0xb0
 8013e0c: 687b         	ldr	r3, [r7, #0x4]
 8013e0e: 3398         	adds	r3, #0x98
 8013e10: 461a         	mov	r2, r3
 8013e12: f7f9 f84d    	bl	0x800ceb0 <arm_mat_mult_f32> @ imm = #-0x6f66
 8013e16: 4603         	mov	r3, r0
 8013e18: 461a         	mov	r2, r3
 8013e1a: 687b         	ldr	r3, [r7, #0x4]
 8013e1c: f883 20c8    	strb.w	r2, [r3, #0xc8]
; }
 8013e20: bf00         	nop
 8013e22: 3708         	adds	r7, #0x8
 8013e24: 46bd         	mov	sp, r7
 8013e26: bd80         	pop	{r7, pc}

08013e28 <Kalman_Filter_xhatUpdate>:
; {
 8013e28: b580         	push	{r7, lr}
 8013e2a: b082         	sub	sp, #0x8
 8013e2c: af00         	add	r7, sp, #0x0
 8013e2e: 6078         	str	r0, [r7, #0x4]
; 	if (!kf->SkipEq4) {
 8013e30: 687b         	ldr	r3, [r7, #0x4]
 8013e32: f893 302b    	ldrb.w	r3, [r3, #0x2b]
 8013e36: 2b00         	cmp	r3, #0x0
 8013e38: d15d         	bne	0x8013ef6 <Kalman_Filter_xhatUpdate+0xce> @ imm = #0xba
; 		kf->temp_vector.numRows = kf->H.numRows;
 8013e3a: 687b         	ldr	r3, [r7, #0x4]
 8013e3c: f8b3 2078    	ldrh.w	r2, [r3, #0x78]
 8013e40: 687b         	ldr	r3, [r7, #0x4]
 8013e42: f8a3 20b8    	strh.w	r2, [r3, #0xb8]
; 		kf->temp_vector.numCols = 1;
 8013e46: 687b         	ldr	r3, [r7, #0x4]
 8013e48: 2201         	movs	r2, #0x1
 8013e4a: f8a3 20ba    	strh.w	r2, [r3, #0xba]
; 		kf->MatStatus = Matrix_Multiply(&kf->H, &kf->xhatminus,
 8013e4e: 687b         	ldr	r3, [r7, #0x4]
 8013e50: f103 0078    	add.w	r0, r3, #0x78
 8013e54: 687b         	ldr	r3, [r7, #0x4]
 8013e56: f103 0138    	add.w	r1, r3, #0x38
 8013e5a: 687b         	ldr	r3, [r7, #0x4]
 8013e5c: 33b8         	adds	r3, #0xb8
 8013e5e: 461a         	mov	r2, r3
 8013e60: f7f9 f826    	bl	0x800ceb0 <arm_mat_mult_f32> @ imm = #-0x6fb4
 8013e64: 4603         	mov	r3, r0
 8013e66: 461a         	mov	r2, r3
 8013e68: 687b         	ldr	r3, [r7, #0x4]
 8013e6a: f883 20c8    	strb.w	r2, [r3, #0xc8]
; 		kf->temp_vector1.numRows = kf->z.numRows;
 8013e6e: 687b         	ldr	r3, [r7, #0x4]
 8013e70: f8b3 2048    	ldrh.w	r2, [r3, #0x48]
 8013e74: 687b         	ldr	r3, [r7, #0x4]
 8013e76: f8a3 20c0    	strh.w	r2, [r3, #0xc0]
; 		kf->temp_vector1.numCols = 1;
 8013e7a: 687b         	ldr	r3, [r7, #0x4]
 8013e7c: 2201         	movs	r2, #0x1
 8013e7e: f8a3 20c2    	strh.w	r2, [r3, #0xc2]
; 			Matrix_Subtract(&kf->z, &kf->temp_vector,
 8013e82: 687b         	ldr	r3, [r7, #0x4]
 8013e84: f103 0048    	add.w	r0, r3, #0x48
 8013e88: 687b         	ldr	r3, [r7, #0x4]
 8013e8a: f103 01b8    	add.w	r1, r3, #0xb8
 8013e8e: 687b         	ldr	r3, [r7, #0x4]
 8013e90: 33c0         	adds	r3, #0xc0
 8013e92: 461a         	mov	r2, r3
 8013e94: f7f9 f890    	bl	0x800cfb8 <arm_mat_sub_f32> @ imm = #-0x6ee0
 8013e98: 4603         	mov	r3, r0
 8013e9a: 461a         	mov	r2, r3
; 		kf->MatStatus =
 8013e9c: 687b         	ldr	r3, [r7, #0x4]
 8013e9e: f883 20c8    	strb.w	r2, [r3, #0xc8]
; 		kf->temp_vector.numRows = kf->K.numRows;
 8013ea2: 687b         	ldr	r3, [r7, #0x4]
 8013ea4: f8b3 2098    	ldrh.w	r2, [r3, #0x98]
 8013ea8: 687b         	ldr	r3, [r7, #0x4]
 8013eaa: f8a3 20b8    	strh.w	r2, [r3, #0xb8]
; 		kf->temp_vector.numCols = 1;
 8013eae: 687b         	ldr	r3, [r7, #0x4]
 8013eb0: 2201         	movs	r2, #0x1
 8013eb2: f8a3 20ba    	strh.w	r2, [r3, #0xba]
; 			Matrix_Multiply(&kf->K, &kf->temp_vector1,
 8013eb6: 687b         	ldr	r3, [r7, #0x4]
 8013eb8: f103 0098    	add.w	r0, r3, #0x98
 8013ebc: 687b         	ldr	r3, [r7, #0x4]
 8013ebe: f103 01c0    	add.w	r1, r3, #0xc0
 8013ec2: 687b         	ldr	r3, [r7, #0x4]
 8013ec4: 33b8         	adds	r3, #0xb8
 8013ec6: 461a         	mov	r2, r3
 8013ec8: f7f8 fff2    	bl	0x800ceb0 <arm_mat_mult_f32> @ imm = #-0x701c
 8013ecc: 4603         	mov	r3, r0
 8013ece: 461a         	mov	r2, r3
; 		kf->MatStatus =
 8013ed0: 687b         	ldr	r3, [r7, #0x4]
 8013ed2: f883 20c8    	strb.w	r2, [r3, #0xc8]
; 		kf->MatStatus = Matrix_Add(&kf->xhatminus, &kf->temp_vector, &kf->xhat);
 8013ed6: 687b         	ldr	r3, [r7, #0x4]
 8013ed8: f103 0038    	add.w	r0, r3, #0x38
 8013edc: 687b         	ldr	r3, [r7, #0x4]
 8013ede: f103 01b8    	add.w	r1, r3, #0xb8
 8013ee2: 687b         	ldr	r3, [r7, #0x4]
 8013ee4: 3330         	adds	r3, #0x30
 8013ee6: 461a         	mov	r2, r3
 8013ee8: f7f8 fe0e    	bl	0x800cb08 <arm_mat_add_f32> @ imm = #-0x73e4
 8013eec: 4603         	mov	r3, r0
 8013eee: 461a         	mov	r2, r3
 8013ef0: 687b         	ldr	r3, [r7, #0x4]
 8013ef2: f883 20c8    	strb.w	r2, [r3, #0xc8]
; }
 8013ef6: bf00         	nop
 8013ef8: 3708         	adds	r7, #0x8
 8013efa: 46bd         	mov	sp, r7
 8013efc: bd80         	pop	{r7, pc}

08013efe <Kalman_Filter_P_Update>:
; {
 8013efe: b580         	push	{r7, lr}
 8013f00: b082         	sub	sp, #0x8
 8013f02: af00         	add	r7, sp, #0x0
 8013f04: 6078         	str	r0, [r7, #0x4]
; 	if (!kf->SkipEq5) {
 8013f06: 687b         	ldr	r3, [r7, #0x4]
 8013f08: f893 302c    	ldrb.w	r3, [r3, #0x2c]
 8013f0c: 2b00         	cmp	r3, #0x0
 8013f0e: d147         	bne	0x8013fa0 <Kalman_Filter_P_Update+0xa2> @ imm = #0x8e
; 		kf->temp_matrix.numRows = kf->K.numRows;
 8013f10: 687b         	ldr	r3, [r7, #0x4]
 8013f12: f8b3 2098    	ldrh.w	r2, [r3, #0x98]
 8013f16: 687b         	ldr	r3, [r7, #0x4]
 8013f18: f8a3 20a8    	strh.w	r2, [r3, #0xa8]
; 		kf->temp_matrix.numCols = kf->H.numCols;
 8013f1c: 687b         	ldr	r3, [r7, #0x4]
 8013f1e: f8b3 207a    	ldrh.w	r2, [r3, #0x7a]
 8013f22: 687b         	ldr	r3, [r7, #0x4]
 8013f24: f8a3 20aa    	strh.w	r2, [r3, #0xaa]
; 		kf->temp_matrix1.numRows = kf->temp_matrix.numRows;
 8013f28: 687b         	ldr	r3, [r7, #0x4]
 8013f2a: f8b3 20a8    	ldrh.w	r2, [r3, #0xa8]
 8013f2e: 687b         	ldr	r3, [r7, #0x4]
 8013f30: f8a3 20b0    	strh.w	r2, [r3, #0xb0]
; 		kf->temp_matrix1.numCols = kf->Pminus.numCols;
 8013f34: 687b         	ldr	r3, [r7, #0x4]
 8013f36: f8b3 205a    	ldrh.w	r2, [r3, #0x5a]
 8013f3a: 687b         	ldr	r3, [r7, #0x4]
 8013f3c: f8a3 20b2    	strh.w	r2, [r3, #0xb2]
; 			Matrix_Multiply(&kf->K, &kf->H, &kf->temp_matrix); // temp_matrix = K(k)·H
 8013f40: 687b         	ldr	r3, [r7, #0x4]
 8013f42: f103 0098    	add.w	r0, r3, #0x98
 8013f46: 687b         	ldr	r3, [r7, #0x4]
 8013f48: f103 0178    	add.w	r1, r3, #0x78
 8013f4c: 687b         	ldr	r3, [r7, #0x4]
 8013f4e: 33a8         	adds	r3, #0xa8
 8013f50: 461a         	mov	r2, r3
 8013f52: f7f8 ffad    	bl	0x800ceb0 <arm_mat_mult_f32> @ imm = #-0x70a6
 8013f56: 4603         	mov	r3, r0
 8013f58: 461a         	mov	r2, r3
; 		kf->MatStatus =
 8013f5a: 687b         	ldr	r3, [r7, #0x4]
 8013f5c: f883 20c8    	strb.w	r2, [r3, #0xc8]
; 		kf->MatStatus = Matrix_Multiply(&kf->temp_matrix, &kf->Pminus,
 8013f60: 687b         	ldr	r3, [r7, #0x4]
 8013f62: f103 00a8    	add.w	r0, r3, #0xa8
 8013f66: 687b         	ldr	r3, [r7, #0x4]
 8013f68: f103 0158    	add.w	r1, r3, #0x58
 8013f6c: 687b         	ldr	r3, [r7, #0x4]
 8013f6e: 33b0         	adds	r3, #0xb0
 8013f70: 461a         	mov	r2, r3
 8013f72: f7f8 ff9d    	bl	0x800ceb0 <arm_mat_mult_f32> @ imm = #-0x70c6
 8013f76: 4603         	mov	r3, r0
 8013f78: 461a         	mov	r2, r3
 8013f7a: 687b         	ldr	r3, [r7, #0x4]
 8013f7c: f883 20c8    	strb.w	r2, [r3, #0xc8]
; 		kf->MatStatus = Matrix_Subtract(&kf->Pminus, &kf->temp_matrix1, &kf->P);
 8013f80: 687b         	ldr	r3, [r7, #0x4]
 8013f82: f103 0058    	add.w	r0, r3, #0x58
 8013f86: 687b         	ldr	r3, [r7, #0x4]
 8013f88: f103 01b0    	add.w	r1, r3, #0xb0
 8013f8c: 687b         	ldr	r3, [r7, #0x4]
 8013f8e: 3350         	adds	r3, #0x50
 8013f90: 461a         	mov	r2, r3
 8013f92: f7f9 f811    	bl	0x800cfb8 <arm_mat_sub_f32> @ imm = #-0x6fde
 8013f96: 4603         	mov	r3, r0
 8013f98: 461a         	mov	r2, r3
 8013f9a: 687b         	ldr	r3, [r7, #0x4]
 8013f9c: f883 20c8    	strb.w	r2, [r3, #0xc8]
; }
 8013fa0: bf00         	nop
 8013fa2: 3708         	adds	r7, #0x8
 8013fa4: 46bd         	mov	sp, r7
 8013fa6: bd80         	pop	{r7, pc}

08013fa8 <Norm3d>:
; {
 8013fa8: b590         	push	{r4, r7, lr}
 8013faa: b085         	sub	sp, #0x14
 8013fac: af00         	add	r7, sp, #0x0
 8013fae: 6078         	str	r0, [r7, #0x4]
; 	float len = Sqrt(v[0] * v[0] + v[1] * v[1] + v[2] * v[2]);
 8013fb0: 687b         	ldr	r3, [r7, #0x4]
 8013fb2: 681a         	ldr	r2, [r3]
 8013fb4: 687b         	ldr	r3, [r7, #0x4]
 8013fb6: 681b         	ldr	r3, [r3]
 8013fb8: 4619         	mov	r1, r3
 8013fba: 4610         	mov	r0, r2
 8013fbc: f7ec f9f2    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x13c1c
 8013fc0: 4603         	mov	r3, r0
 8013fc2: 461c         	mov	r4, r3
 8013fc4: 687b         	ldr	r3, [r7, #0x4]
 8013fc6: 3304         	adds	r3, #0x4
 8013fc8: 681a         	ldr	r2, [r3]
 8013fca: 687b         	ldr	r3, [r7, #0x4]
 8013fcc: 3304         	adds	r3, #0x4
 8013fce: 681b         	ldr	r3, [r3]
 8013fd0: 4619         	mov	r1, r3
 8013fd2: 4610         	mov	r0, r2
 8013fd4: f7ec f9e6    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x13c34
 8013fd8: 4603         	mov	r3, r0
 8013fda: 4619         	mov	r1, r3
 8013fdc: 4620         	mov	r0, r4
 8013fde: f7ec f8d9    	bl	0x8000194 <__aeabi_fadd> @ imm = #-0x13e4e
 8013fe2: 4603         	mov	r3, r0
 8013fe4: 461c         	mov	r4, r3
 8013fe6: 687b         	ldr	r3, [r7, #0x4]
 8013fe8: 3308         	adds	r3, #0x8
 8013fea: 681a         	ldr	r2, [r3]
 8013fec: 687b         	ldr	r3, [r7, #0x4]
 8013fee: 3308         	adds	r3, #0x8
 8013ff0: 681b         	ldr	r3, [r3]
 8013ff2: 4619         	mov	r1, r3
 8013ff4: 4610         	mov	r0, r2
 8013ff6: f7ec f9d5    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x13c56
 8013ffa: 4603         	mov	r3, r0
 8013ffc: 4619         	mov	r1, r3
 8013ffe: 4620         	mov	r0, r4
 8014000: f7ec f8c8    	bl	0x8000194 <__aeabi_fadd> @ imm = #-0x13e70
 8014004: 4603         	mov	r3, r0
 8014006: 4618         	mov	r0, r3
 8014008: f7ef f8e2    	bl	0x80031d0 <Sqrt>        @ imm = #-0x10e3c
 801400c: 60f8         	str	r0, [r7, #0xc]
; 	v[0] /= len;
 801400e: 687b         	ldr	r3, [r7, #0x4]
 8014010: 681b         	ldr	r3, [r3]
 8014012: 68f9         	ldr	r1, [r7, #0xc]
 8014014: 4618         	mov	r0, r3
 8014016: f7ec fa79    	bl	0x800050c <__divsf3>    @ imm = #-0x13b0e
 801401a: 4603         	mov	r3, r0
 801401c: 461a         	mov	r2, r3
 801401e: 687b         	ldr	r3, [r7, #0x4]
 8014020: 601a         	str	r2, [r3]
; 	v[1] /= len;
 8014022: 687b         	ldr	r3, [r7, #0x4]
 8014024: 3304         	adds	r3, #0x4
 8014026: 681a         	ldr	r2, [r3]
 8014028: 687b         	ldr	r3, [r7, #0x4]
 801402a: 1d1c         	adds	r4, r3, #0x4
 801402c: 68f9         	ldr	r1, [r7, #0xc]
 801402e: 4610         	mov	r0, r2
 8014030: f7ec fa6c    	bl	0x800050c <__divsf3>    @ imm = #-0x13b28
 8014034: 4603         	mov	r3, r0
 8014036: 6023         	str	r3, [r4]
; 	v[2] /= len;
 8014038: 687b         	ldr	r3, [r7, #0x4]
 801403a: 3308         	adds	r3, #0x8
 801403c: 681a         	ldr	r2, [r3]
 801403e: 687b         	ldr	r3, [r7, #0x4]
 8014040: f103 0408    	add.w	r4, r3, #0x8
 8014044: 68f9         	ldr	r1, [r7, #0xc]
 8014046: 4610         	mov	r0, r2
 8014048: f7ec fa60    	bl	0x800050c <__divsf3>    @ imm = #-0x13b40
 801404c: 4603         	mov	r3, r0
 801404e: 6023         	str	r3, [r4]
; 	return v;
 8014050: 687b         	ldr	r3, [r7, #0x4]
; }
 8014052: 4618         	mov	r0, r3
 8014054: 3714         	adds	r7, #0x14
 8014056: 46bd         	mov	sp, r7
 8014058: bd90         	pop	{r4, r7, pc}

0801405a <Cross3d>:
; {
 801405a: b5b0         	push	{r4, r5, r7, lr}
 801405c: b084         	sub	sp, #0x10
 801405e: af00         	add	r7, sp, #0x0
 8014060: 60f8         	str	r0, [r7, #0xc]
 8014062: 60b9         	str	r1, [r7, #0x8]
 8014064: 607a         	str	r2, [r7, #0x4]
; 	res[0] = v1[1] * v2[2] - v1[2] * v2[1];
 8014066: 68fb         	ldr	r3, [r7, #0xc]
 8014068: 3304         	adds	r3, #0x4
 801406a: 681a         	ldr	r2, [r3]
 801406c: 68bb         	ldr	r3, [r7, #0x8]
 801406e: 3308         	adds	r3, #0x8
 8014070: 681b         	ldr	r3, [r3]
 8014072: 4619         	mov	r1, r3
 8014074: 4610         	mov	r0, r2
 8014076: f7ec f995    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x13cd6
 801407a: 4603         	mov	r3, r0
 801407c: 461c         	mov	r4, r3
 801407e: 68fb         	ldr	r3, [r7, #0xc]
 8014080: 3308         	adds	r3, #0x8
 8014082: 681a         	ldr	r2, [r3]
 8014084: 68bb         	ldr	r3, [r7, #0x8]
 8014086: 3304         	adds	r3, #0x4
 8014088: 681b         	ldr	r3, [r3]
 801408a: 4619         	mov	r1, r3
 801408c: 4610         	mov	r0, r2
 801408e: f7ec f989    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x13cee
 8014092: 4603         	mov	r3, r0
 8014094: 4619         	mov	r1, r3
 8014096: 4620         	mov	r0, r4
 8014098: f7ec f87a    	bl	0x8000190 <__subsf3>    @ imm = #-0x13f0c
 801409c: 4603         	mov	r3, r0
 801409e: 461a         	mov	r2, r3
 80140a0: 687b         	ldr	r3, [r7, #0x4]
 80140a2: 601a         	str	r2, [r3]
; 	res[1] = v1[2] * v2[0] - v1[0] * v2[2];
 80140a4: 68fb         	ldr	r3, [r7, #0xc]
 80140a6: 3308         	adds	r3, #0x8
 80140a8: 681a         	ldr	r2, [r3]
 80140aa: 68bb         	ldr	r3, [r7, #0x8]
 80140ac: 681b         	ldr	r3, [r3]
 80140ae: 4619         	mov	r1, r3
 80140b0: 4610         	mov	r0, r2
 80140b2: f7ec f977    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x13d12
 80140b6: 4603         	mov	r3, r0
 80140b8: 461d         	mov	r5, r3
 80140ba: 68fb         	ldr	r3, [r7, #0xc]
 80140bc: 681a         	ldr	r2, [r3]
 80140be: 68bb         	ldr	r3, [r7, #0x8]
 80140c0: 3308         	adds	r3, #0x8
 80140c2: 681b         	ldr	r3, [r3]
 80140c4: 4619         	mov	r1, r3
 80140c6: 4610         	mov	r0, r2
 80140c8: f7ec f96c    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x13d28
 80140cc: 4603         	mov	r3, r0
 80140ce: 461a         	mov	r2, r3
 80140d0: 687b         	ldr	r3, [r7, #0x4]
 80140d2: 1d1c         	adds	r4, r3, #0x4
 80140d4: 4611         	mov	r1, r2
 80140d6: 4628         	mov	r0, r5
 80140d8: f7ec f85a    	bl	0x8000190 <__subsf3>    @ imm = #-0x13f4c
 80140dc: 4603         	mov	r3, r0
 80140de: 6023         	str	r3, [r4]
; 	res[2] = v1[0] * v2[1] - v1[1] * v2[0];
 80140e0: 68fb         	ldr	r3, [r7, #0xc]
 80140e2: 681a         	ldr	r2, [r3]
 80140e4: 68bb         	ldr	r3, [r7, #0x8]
 80140e6: 3304         	adds	r3, #0x4
 80140e8: 681b         	ldr	r3, [r3]
 80140ea: 4619         	mov	r1, r3
 80140ec: 4610         	mov	r0, r2
 80140ee: f7ec f959    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x13d4e
 80140f2: 4603         	mov	r3, r0
 80140f4: 461d         	mov	r5, r3
 80140f6: 68fb         	ldr	r3, [r7, #0xc]
 80140f8: 3304         	adds	r3, #0x4
 80140fa: 681a         	ldr	r2, [r3]
 80140fc: 68bb         	ldr	r3, [r7, #0x8]
 80140fe: 681b         	ldr	r3, [r3]
 8014100: 4619         	mov	r1, r3
 8014102: 4610         	mov	r0, r2
 8014104: f7ec f94e    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x13d64
 8014108: 4603         	mov	r3, r0
 801410a: 461a         	mov	r2, r3
 801410c: 687b         	ldr	r3, [r7, #0x4]
 801410e: f103 0408    	add.w	r4, r3, #0x8
 8014112: 4611         	mov	r1, r2
 8014114: 4628         	mov	r0, r5
 8014116: f7ec f83b    	bl	0x8000190 <__subsf3>    @ imm = #-0x13f8a
 801411a: 4603         	mov	r3, r0
 801411c: 6023         	str	r3, [r4]
; }
 801411e: bf00         	nop
 8014120: 3710         	adds	r7, #0x10
 8014122: 46bd         	mov	sp, r7
 8014124: bdb0         	pop	{r4, r5, r7, pc}

08014126 <Dot3d>:
; {
 8014126: b590         	push	{r4, r7, lr}
 8014128: b083         	sub	sp, #0xc
 801412a: af00         	add	r7, sp, #0x0
 801412c: 6078         	str	r0, [r7, #0x4]
 801412e: 6039         	str	r1, [r7]
; 	return v1[0] * v2[0] + v1[1] * v2[1] + v1[2] * v2[2];
 8014130: 687b         	ldr	r3, [r7, #0x4]
 8014132: 681a         	ldr	r2, [r3]
 8014134: 683b         	ldr	r3, [r7]
 8014136: 681b         	ldr	r3, [r3]
 8014138: 4619         	mov	r1, r3
 801413a: 4610         	mov	r0, r2
 801413c: f7ec f932    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x13d9c
 8014140: 4603         	mov	r3, r0
 8014142: 461c         	mov	r4, r3
 8014144: 687b         	ldr	r3, [r7, #0x4]
 8014146: 3304         	adds	r3, #0x4
 8014148: 681a         	ldr	r2, [r3]
 801414a: 683b         	ldr	r3, [r7]
 801414c: 3304         	adds	r3, #0x4
 801414e: 681b         	ldr	r3, [r3]
 8014150: 4619         	mov	r1, r3
 8014152: 4610         	mov	r0, r2
 8014154: f7ec f926    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x13db4
 8014158: 4603         	mov	r3, r0
 801415a: 4619         	mov	r1, r3
 801415c: 4620         	mov	r0, r4
 801415e: f7ec f819    	bl	0x8000194 <__aeabi_fadd> @ imm = #-0x13fce
 8014162: 4603         	mov	r3, r0
 8014164: 461c         	mov	r4, r3
 8014166: 687b         	ldr	r3, [r7, #0x4]
 8014168: 3308         	adds	r3, #0x8
 801416a: 681a         	ldr	r2, [r3]
 801416c: 683b         	ldr	r3, [r7]
 801416e: 3308         	adds	r3, #0x8
 8014170: 681b         	ldr	r3, [r3]
 8014172: 4619         	mov	r1, r3
 8014174: 4610         	mov	r0, r2
 8014176: f7ec f915    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x13dd6
 801417a: 4603         	mov	r3, r0
 801417c: 4619         	mov	r1, r3
 801417e: 4620         	mov	r0, r4
 8014180: f7ec f808    	bl	0x8000194 <__aeabi_fadd> @ imm = #-0x13ff0
 8014184: 4603         	mov	r3, r0
; }
 8014186: 4618         	mov	r0, r3
 8014188: 370c         	adds	r7, #0xc
 801418a: 46bd         	mov	sp, r7
 801418c: bd90         	pop	{r4, r7, pc}

0801418e <console_feedback>:
; {
 801418e: b580         	push	{r7, lr}
 8014190: b084         	sub	sp, #0x10
 8014192: af00         	add	r7, sp, #0x0
 8014194: 60f8         	str	r0, [r7, #0xc]
 8014196: 60b9         	str	r1, [r7, #0x8]
 8014198: 607a         	str	r2, [r7, #0x4]
; 		k_msleep(500);
 801419a: f44f 70fa    	mov.w	r0, #0x1f4
 801419e: f7ff fbe2    	bl	0x8013966 <k_msleep>    @ imm = #-0x83c
 80141a2: e7fa         	b	0x801419a <console_feedback+0xc> @ imm = #-0xc

080141a4 <big_heap_chunks>:
; {
 80141a4: b480         	push	{r7}
 80141a6: b083         	sub	sp, #0xc
 80141a8: af00         	add	r7, sp, #0x0
 80141aa: 6078         	str	r0, [r7, #0x4]
; 		return false;
 80141ac: 2300         	movs	r3, #0x0
; }
 80141ae: 4618         	mov	r0, r3
 80141b0: 370c         	adds	r7, #0xc
 80141b2: 46bd         	mov	sp, r7
 80141b4: bc80         	pop	{r7}
 80141b6: 4770         	bx	lr

080141b8 <big_heap_bytes>:
; {
 80141b8: b580         	push	{r7, lr}
 80141ba: b082         	sub	sp, #0x8
 80141bc: af00         	add	r7, sp, #0x0
 80141be: 6078         	str	r0, [r7, #0x4]
; 	return big_heap_chunks(bytes / CHUNK_UNIT);
 80141c0: 687b         	ldr	r3, [r7, #0x4]
 80141c2: 08db         	lsrs	r3, r3, #0x3
 80141c4: 4618         	mov	r0, r3
 80141c6: f7ff ffed    	bl	0x80141a4 <big_heap_chunks> @ imm = #-0x26
 80141ca: 4603         	mov	r3, r0
; }
 80141cc: 4618         	mov	r0, r3
 80141ce: 3708         	adds	r7, #0x8
 80141d0: 46bd         	mov	sp, r7
 80141d2: bd80         	pop	{r7, pc}

080141d4 <big_heap>:
; {
 80141d4: b580         	push	{r7, lr}
 80141d6: b082         	sub	sp, #0x8
 80141d8: af00         	add	r7, sp, #0x0
 80141da: 6078         	str	r0, [r7, #0x4]
; 	return big_heap_chunks(h->end_chunk);
 80141dc: 687b         	ldr	r3, [r7, #0x4]
 80141de: 689b         	ldr	r3, [r3, #0x8]
 80141e0: 4618         	mov	r0, r3
 80141e2: f7ff ffdf    	bl	0x80141a4 <big_heap_chunks> @ imm = #-0x42
 80141e6: 4603         	mov	r3, r0
; }
 80141e8: 4618         	mov	r0, r3
 80141ea: 3708         	adds	r7, #0x8
 80141ec: 46bd         	mov	sp, r7
 80141ee: bd80         	pop	{r7, pc}

080141f0 <chunk_buf>:
; {
 80141f0: b480         	push	{r7}
 80141f2: b083         	sub	sp, #0xc
 80141f4: af00         	add	r7, sp, #0x0
 80141f6: 6078         	str	r0, [r7, #0x4]
; 	return (chunk_unit_t *)h;
 80141f8: 687b         	ldr	r3, [r7, #0x4]
; }
 80141fa: 4618         	mov	r0, r3
 80141fc: 370c         	adds	r7, #0xc
 80141fe: 46bd         	mov	sp, r7
 8014200: bc80         	pop	{r7}
 8014202: 4770         	bx	lr

08014204 <chunk_field>:
; {
 8014204: b580         	push	{r7, lr}
 8014206: b086         	sub	sp, #0x18
 8014208: af00         	add	r7, sp, #0x0
 801420a: 60f8         	str	r0, [r7, #0xc]
 801420c: 60b9         	str	r1, [r7, #0x8]
 801420e: 4613         	mov	r3, r2
 8014210: 71fb         	strb	r3, [r7, #0x7]
; 	chunk_unit_t *buf = chunk_buf(h);
 8014212: 68f8         	ldr	r0, [r7, #0xc]
 8014214: f7ff ffec    	bl	0x80141f0 <chunk_buf>   @ imm = #-0x28
 8014218: 6178         	str	r0, [r7, #0x14]
; 	void *cmem = &buf[c];
 801421a: 68bb         	ldr	r3, [r7, #0x8]
 801421c: 00db         	lsls	r3, r3, #0x3
 801421e: 697a         	ldr	r2, [r7, #0x14]
 8014220: 4413         	add	r3, r2
 8014222: 613b         	str	r3, [r7, #0x10]
; 	if (big_heap(h)) {
 8014224: 68f8         	ldr	r0, [r7, #0xc]
 8014226: f7ff ffd5    	bl	0x80141d4 <big_heap>    @ imm = #-0x56
 801422a: 4603         	mov	r3, r0
 801422c: 2b00         	cmp	r3, #0x0
 801422e: d005         	beq	0x801423c <chunk_field+0x38> @ imm = #0xa
; 		return ((uint32_t *)cmem)[f];
 8014230: 79fb         	ldrb	r3, [r7, #0x7]
 8014232: 009b         	lsls	r3, r3, #0x2
 8014234: 693a         	ldr	r2, [r7, #0x10]
 8014236: 4413         	add	r3, r2
 8014238: 681b         	ldr	r3, [r3]
 801423a: e004         	b	0x8014246 <chunk_field+0x42> @ imm = #0x8
; 		return ((uint16_t *)cmem)[f];
 801423c: 79fb         	ldrb	r3, [r7, #0x7]
 801423e: 005b         	lsls	r3, r3, #0x1
 8014240: 693a         	ldr	r2, [r7, #0x10]
 8014242: 4413         	add	r3, r2
 8014244: 881b         	ldrh	r3, [r3]
; }
 8014246: 4618         	mov	r0, r3
 8014248: 3718         	adds	r7, #0x18
 801424a: 46bd         	mov	sp, r7
 801424c: bd80         	pop	{r7, pc}

0801424e <chunk_set>:
; {
 801424e: b580         	push	{r7, lr}
 8014250: b086         	sub	sp, #0x18
 8014252: af00         	add	r7, sp, #0x0
 8014254: 60f8         	str	r0, [r7, #0xc]
 8014256: 60b9         	str	r1, [r7, #0x8]
 8014258: 603b         	str	r3, [r7]
 801425a: 4613         	mov	r3, r2
 801425c: 71fb         	strb	r3, [r7, #0x7]
; 	chunk_unit_t *buf = chunk_buf(h);
 801425e: 68f8         	ldr	r0, [r7, #0xc]
 8014260: f7ff ffc6    	bl	0x80141f0 <chunk_buf>   @ imm = #-0x74
 8014264: 6178         	str	r0, [r7, #0x14]
; 	void *cmem = &buf[c];
 8014266: 68bb         	ldr	r3, [r7, #0x8]
 8014268: 00db         	lsls	r3, r3, #0x3
 801426a: 697a         	ldr	r2, [r7, #0x14]
 801426c: 4413         	add	r3, r2
 801426e: 613b         	str	r3, [r7, #0x10]
; 	if (big_heap(h)) {
 8014270: 68f8         	ldr	r0, [r7, #0xc]
 8014272: f7ff ffaf    	bl	0x80141d4 <big_heap>    @ imm = #-0xa2
 8014276: 4603         	mov	r3, r0
 8014278: 2b00         	cmp	r3, #0x0
 801427a: d006         	beq	0x801428a <chunk_set+0x3c> @ imm = #0xc
; 		((uint32_t *)cmem)[f] = val;
 801427c: 79fb         	ldrb	r3, [r7, #0x7]
 801427e: 009b         	lsls	r3, r3, #0x2
 8014280: 693a         	ldr	r2, [r7, #0x10]
 8014282: 4413         	add	r3, r2
 8014284: 683a         	ldr	r2, [r7]
 8014286: 601a         	str	r2, [r3]
; }
 8014288: e006         	b	0x8014298 <chunk_set+0x4a> @ imm = #0xc
; 		((uint16_t *)cmem)[f] = val;
 801428a: 79fb         	ldrb	r3, [r7, #0x7]
 801428c: 005b         	lsls	r3, r3, #0x1
 801428e: 693a         	ldr	r2, [r7, #0x10]
 8014290: 4413         	add	r3, r2
 8014292: 683a         	ldr	r2, [r7]
 8014294: b292         	uxth	r2, r2
 8014296: 801a         	strh	r2, [r3]
; }
 8014298: bf00         	nop
 801429a: 3718         	adds	r7, #0x18
 801429c: 46bd         	mov	sp, r7
 801429e: bd80         	pop	{r7, pc}

080142a0 <chunk_size>:
; {
 80142a0: b580         	push	{r7, lr}
 80142a2: b082         	sub	sp, #0x8
 80142a4: af00         	add	r7, sp, #0x0
 80142a6: 6078         	str	r0, [r7, #0x4]
 80142a8: 6039         	str	r1, [r7]
; 	return chunk_field(h, c, SIZE_AND_USED) >> 1;
 80142aa: 2201         	movs	r2, #0x1
 80142ac: 6839         	ldr	r1, [r7]
 80142ae: 6878         	ldr	r0, [r7, #0x4]
 80142b0: f7ff ffa8    	bl	0x8014204 <chunk_field> @ imm = #-0xb0
 80142b4: 4603         	mov	r3, r0
 80142b6: 085b         	lsrs	r3, r3, #0x1
; }
 80142b8: 4618         	mov	r0, r3
 80142ba: 3708         	adds	r7, #0x8
 80142bc: 46bd         	mov	sp, r7
 80142be: bd80         	pop	{r7, pc}

080142c0 <set_chunk_used>:
; {
 80142c0: b580         	push	{r7, lr}
 80142c2: b086         	sub	sp, #0x18
 80142c4: af00         	add	r7, sp, #0x0
 80142c6: 60f8         	str	r0, [r7, #0xc]
 80142c8: 60b9         	str	r1, [r7, #0x8]
 80142ca: 4613         	mov	r3, r2
 80142cc: 71fb         	strb	r3, [r7, #0x7]
; 	chunk_unit_t *buf = chunk_buf(h);
 80142ce: 68f8         	ldr	r0, [r7, #0xc]
 80142d0: f7ff ff8e    	bl	0x80141f0 <chunk_buf>   @ imm = #-0xe4
 80142d4: 6178         	str	r0, [r7, #0x14]
; 	void *cmem = &buf[c];
 80142d6: 68bb         	ldr	r3, [r7, #0x8]
 80142d8: 00db         	lsls	r3, r3, #0x3
 80142da: 697a         	ldr	r2, [r7, #0x14]
 80142dc: 4413         	add	r3, r2
 80142de: 613b         	str	r3, [r7, #0x10]
; 	if (big_heap(h)) {
 80142e0: 68f8         	ldr	r0, [r7, #0xc]
 80142e2: f7ff ff77    	bl	0x80141d4 <big_heap>    @ imm = #-0x112
 80142e6: 4603         	mov	r3, r0
 80142e8: 2b00         	cmp	r3, #0x0
 80142ea: d014         	beq	0x8014316 <set_chunk_used+0x56> @ imm = #0x28
; 		if (used) {
 80142ec: 79fb         	ldrb	r3, [r7, #0x7]
 80142ee: 2b00         	cmp	r3, #0x0
 80142f0: d008         	beq	0x8014304 <set_chunk_used+0x44> @ imm = #0x10
; 			((uint32_t *)cmem)[SIZE_AND_USED] |= 1U;
 80142f2: 693b         	ldr	r3, [r7, #0x10]
 80142f4: 3304         	adds	r3, #0x4
 80142f6: 681a         	ldr	r2, [r3]
 80142f8: 693b         	ldr	r3, [r7, #0x10]
 80142fa: 3304         	adds	r3, #0x4
 80142fc: f042 0201    	orr	r2, r2, #0x1
 8014300: 601a         	str	r2, [r3]
; }
 8014302: e01e         	b	0x8014342 <set_chunk_used+0x82> @ imm = #0x3c
; 			((uint32_t *)cmem)[SIZE_AND_USED] &= ~1U;
 8014304: 693b         	ldr	r3, [r7, #0x10]
 8014306: 3304         	adds	r3, #0x4
 8014308: 681a         	ldr	r2, [r3]
 801430a: 693b         	ldr	r3, [r7, #0x10]
 801430c: 3304         	adds	r3, #0x4
 801430e: f022 0201    	bic	r2, r2, #0x1
 8014312: 601a         	str	r2, [r3]
; }
 8014314: e015         	b	0x8014342 <set_chunk_used+0x82> @ imm = #0x2a
; 		if (used) {
 8014316: 79fb         	ldrb	r3, [r7, #0x7]
 8014318: 2b00         	cmp	r3, #0x0
 801431a: d009         	beq	0x8014330 <set_chunk_used+0x70> @ imm = #0x12
; 			((uint16_t *)cmem)[SIZE_AND_USED] |= 1U;
 801431c: 693b         	ldr	r3, [r7, #0x10]
 801431e: 3302         	adds	r3, #0x2
 8014320: 881a         	ldrh	r2, [r3]
 8014322: 693b         	ldr	r3, [r7, #0x10]
 8014324: 3302         	adds	r3, #0x2
 8014326: f042 0201    	orr	r2, r2, #0x1
 801432a: b292         	uxth	r2, r2
 801432c: 801a         	strh	r2, [r3]
; }
 801432e: e008         	b	0x8014342 <set_chunk_used+0x82> @ imm = #0x10
; 			((uint16_t *)cmem)[SIZE_AND_USED] &= ~1U;
 8014330: 693b         	ldr	r3, [r7, #0x10]
 8014332: 3302         	adds	r3, #0x2
 8014334: 881a         	ldrh	r2, [r3]
 8014336: 693b         	ldr	r3, [r7, #0x10]
 8014338: 3302         	adds	r3, #0x2
 801433a: f022 0201    	bic	r2, r2, #0x1
 801433e: b292         	uxth	r2, r2
 8014340: 801a         	strh	r2, [r3]
; }
 8014342: bf00         	nop
 8014344: 3718         	adds	r7, #0x18
 8014346: 46bd         	mov	sp, r7
 8014348: bd80         	pop	{r7, pc}

0801434a <set_chunk_size>:
; {
 801434a: b580         	push	{r7, lr}
 801434c: b084         	sub	sp, #0x10
 801434e: af00         	add	r7, sp, #0x0
 8014350: 60f8         	str	r0, [r7, #0xc]
 8014352: 60b9         	str	r1, [r7, #0x8]
 8014354: 607a         	str	r2, [r7, #0x4]
; 	chunk_set(h, c, SIZE_AND_USED, size << 1);
 8014356: 687b         	ldr	r3, [r7, #0x4]
 8014358: 005b         	lsls	r3, r3, #0x1
 801435a: 2201         	movs	r2, #0x1
 801435c: 68b9         	ldr	r1, [r7, #0x8]
 801435e: 68f8         	ldr	r0, [r7, #0xc]
 8014360: f7ff ff75    	bl	0x801424e <chunk_set>   @ imm = #-0x116
; }
 8014364: bf00         	nop
 8014366: 3710         	adds	r7, #0x10
 8014368: 46bd         	mov	sp, r7
 801436a: bd80         	pop	{r7, pc}

0801436c <prev_free_chunk>:
; {
 801436c: b580         	push	{r7, lr}
 801436e: b082         	sub	sp, #0x8
 8014370: af00         	add	r7, sp, #0x0
 8014372: 6078         	str	r0, [r7, #0x4]
 8014374: 6039         	str	r1, [r7]
; 	return chunk_field(h, c, FREE_PREV);
 8014376: 2202         	movs	r2, #0x2
 8014378: 6839         	ldr	r1, [r7]
 801437a: 6878         	ldr	r0, [r7, #0x4]
 801437c: f7ff ff42    	bl	0x8014204 <chunk_field> @ imm = #-0x17c
 8014380: 4603         	mov	r3, r0
; }
 8014382: 4618         	mov	r0, r3
 8014384: 3708         	adds	r7, #0x8
 8014386: 46bd         	mov	sp, r7
 8014388: bd80         	pop	{r7, pc}

0801438a <next_free_chunk>:
; {
 801438a: b580         	push	{r7, lr}
 801438c: b082         	sub	sp, #0x8
 801438e: af00         	add	r7, sp, #0x0
 8014390: 6078         	str	r0, [r7, #0x4]
 8014392: 6039         	str	r1, [r7]
; 	return chunk_field(h, c, FREE_NEXT);
 8014394: 2203         	movs	r2, #0x3
 8014396: 6839         	ldr	r1, [r7]
 8014398: 6878         	ldr	r0, [r7, #0x4]
 801439a: f7ff ff33    	bl	0x8014204 <chunk_field> @ imm = #-0x19a
 801439e: 4603         	mov	r3, r0
; }
 80143a0: 4618         	mov	r0, r3
 80143a2: 3708         	adds	r7, #0x8
 80143a4: 46bd         	mov	sp, r7
 80143a6: bd80         	pop	{r7, pc}

080143a8 <set_prev_free_chunk>:
; {
 80143a8: b580         	push	{r7, lr}
 80143aa: b084         	sub	sp, #0x10
 80143ac: af00         	add	r7, sp, #0x0
 80143ae: 60f8         	str	r0, [r7, #0xc]
 80143b0: 60b9         	str	r1, [r7, #0x8]
 80143b2: 607a         	str	r2, [r7, #0x4]
; 	chunk_set(h, c, FREE_PREV, prev);
 80143b4: 687b         	ldr	r3, [r7, #0x4]
 80143b6: 2202         	movs	r2, #0x2
 80143b8: 68b9         	ldr	r1, [r7, #0x8]
 80143ba: 68f8         	ldr	r0, [r7, #0xc]
 80143bc: f7ff ff47    	bl	0x801424e <chunk_set>   @ imm = #-0x172
; }
 80143c0: bf00         	nop
 80143c2: 3710         	adds	r7, #0x10
 80143c4: 46bd         	mov	sp, r7
 80143c6: bd80         	pop	{r7, pc}

080143c8 <set_next_free_chunk>:
; {
 80143c8: b580         	push	{r7, lr}
 80143ca: b084         	sub	sp, #0x10
 80143cc: af00         	add	r7, sp, #0x0
 80143ce: 60f8         	str	r0, [r7, #0xc]
 80143d0: 60b9         	str	r1, [r7, #0x8]
 80143d2: 607a         	str	r2, [r7, #0x4]
; 	chunk_set(h, c, FREE_NEXT, next);
 80143d4: 687b         	ldr	r3, [r7, #0x4]
 80143d6: 2203         	movs	r2, #0x3
 80143d8: 68b9         	ldr	r1, [r7, #0x8]
 80143da: 68f8         	ldr	r0, [r7, #0xc]
 80143dc: f7ff ff37    	bl	0x801424e <chunk_set>   @ imm = #-0x192
; }
 80143e0: bf00         	nop
 80143e2: 3710         	adds	r7, #0x10
 80143e4: 46bd         	mov	sp, r7
 80143e6: bd80         	pop	{r7, pc}

080143e8 <right_chunk>:
; {
 80143e8: b580         	push	{r7, lr}
 80143ea: b082         	sub	sp, #0x8
 80143ec: af00         	add	r7, sp, #0x0
 80143ee: 6078         	str	r0, [r7, #0x4]
 80143f0: 6039         	str	r1, [r7]
; 	return c + chunk_size(h, c);
 80143f2: 6839         	ldr	r1, [r7]
 80143f4: 6878         	ldr	r0, [r7, #0x4]
 80143f6: f7ff ff53    	bl	0x80142a0 <chunk_size>  @ imm = #-0x15a
 80143fa: 4602         	mov	r2, r0
 80143fc: 683b         	ldr	r3, [r7]
 80143fe: 4413         	add	r3, r2
; }
 8014400: 4618         	mov	r0, r3
 8014402: 3708         	adds	r7, #0x8
 8014404: 46bd         	mov	sp, r7
 8014406: bd80         	pop	{r7, pc}

08014408 <set_left_chunk_size>:
; {
 8014408: b580         	push	{r7, lr}
 801440a: b084         	sub	sp, #0x10
 801440c: af00         	add	r7, sp, #0x0
 801440e: 60f8         	str	r0, [r7, #0xc]
 8014410: 60b9         	str	r1, [r7, #0x8]
 8014412: 607a         	str	r2, [r7, #0x4]
; 	chunk_set(h, c, LEFT_SIZE, size);
 8014414: 687b         	ldr	r3, [r7, #0x4]
 8014416: 2200         	movs	r2, #0x0
 8014418: 68b9         	ldr	r1, [r7, #0x8]
 801441a: 68f8         	ldr	r0, [r7, #0xc]
 801441c: f7ff ff17    	bl	0x801424e <chunk_set>   @ imm = #-0x1d2
; }
 8014420: bf00         	nop
 8014422: 3710         	adds	r7, #0x10
 8014424: 46bd         	mov	sp, r7
 8014426: bd80         	pop	{r7, pc}

08014428 <solo_free_header>:
; {
 8014428: b580         	push	{r7, lr}
 801442a: b082         	sub	sp, #0x8
 801442c: af00         	add	r7, sp, #0x0
 801442e: 6078         	str	r0, [r7, #0x4]
 8014430: 6039         	str	r1, [r7]
; 	return big_heap(h) && (chunk_size(h, c) == 1U);
 8014432: 6878         	ldr	r0, [r7, #0x4]
 8014434: f7ff fece    	bl	0x80141d4 <big_heap>    @ imm = #-0x264
 8014438: 4603         	mov	r3, r0
 801443a: 2b00         	cmp	r3, #0x0
 801443c: d008         	beq	0x8014450 <solo_free_header+0x28> @ imm = #0x10
 801443e: 6839         	ldr	r1, [r7]
 8014440: 6878         	ldr	r0, [r7, #0x4]
 8014442: f7ff ff2d    	bl	0x80142a0 <chunk_size>  @ imm = #-0x1a6
 8014446: 4603         	mov	r3, r0
 8014448: 2b01         	cmp	r3, #0x1
 801444a: d101         	bne	0x8014450 <solo_free_header+0x28> @ imm = #0x2
 801444c: 2301         	movs	r3, #0x1
 801444e: e000         	b	0x8014452 <solo_free_header+0x2a> @ imm = #0x0
 8014450: 2300         	movs	r3, #0x0
 8014452: f003 0301    	and	r3, r3, #0x1
 8014456: b2db         	uxtb	r3, r3
; }
 8014458: 4618         	mov	r0, r3
 801445a: 3708         	adds	r7, #0x8
 801445c: 46bd         	mov	sp, r7
 801445e: bd80         	pop	{r7, pc}

08014460 <chunk_header_bytes>:
; {
 8014460: b580         	push	{r7, lr}
 8014462: b082         	sub	sp, #0x8
 8014464: af00         	add	r7, sp, #0x0
 8014466: 6078         	str	r0, [r7, #0x4]
; 	return big_heap(h) ? 8 : 4;
 8014468: 6878         	ldr	r0, [r7, #0x4]
 801446a: f7ff feb3    	bl	0x80141d4 <big_heap>    @ imm = #-0x29a
 801446e: 4603         	mov	r3, r0
 8014470: 2b00         	cmp	r3, #0x0
 8014472: d001         	beq	0x8014478 <chunk_header_bytes+0x18> @ imm = #0x2
 8014474: 2308         	movs	r3, #0x8
 8014476: e000         	b	0x801447a <chunk_header_bytes+0x1a> @ imm = #0x0
 8014478: 2304         	movs	r3, #0x4
; }
 801447a: 4618         	mov	r0, r3
 801447c: 3708         	adds	r7, #0x8
 801447e: 46bd         	mov	sp, r7
 8014480: bd80         	pop	{r7, pc}

08014482 <heap_footer_bytes>:
; {
 8014482: b580         	push	{r7, lr}
 8014484: b082         	sub	sp, #0x8
 8014486: af00         	add	r7, sp, #0x0
 8014488: 6078         	str	r0, [r7, #0x4]
; 	return big_heap_bytes(size) ? 8 : 4;
 801448a: 6878         	ldr	r0, [r7, #0x4]
 801448c: f7ff fe94    	bl	0x80141b8 <big_heap_bytes> @ imm = #-0x2d8
 8014490: 4603         	mov	r3, r0
 8014492: 2b00         	cmp	r3, #0x0
 8014494: d001         	beq	0x801449a <heap_footer_bytes+0x18> @ imm = #0x2
 8014496: 2308         	movs	r3, #0x8
 8014498: e000         	b	0x801449c <heap_footer_bytes+0x1a> @ imm = #0x0
 801449a: 2304         	movs	r3, #0x4
; }
 801449c: 4618         	mov	r0, r3
 801449e: 3708         	adds	r7, #0x8
 80144a0: 46bd         	mov	sp, r7
 80144a2: bd80         	pop	{r7, pc}

080144a4 <chunksz>:
; {
 80144a4: b480         	push	{r7}
 80144a6: b083         	sub	sp, #0xc
 80144a8: af00         	add	r7, sp, #0x0
 80144aa: 6078         	str	r0, [r7, #0x4]
; 	return (bytes + CHUNK_UNIT - 1U) / CHUNK_UNIT;
 80144ac: 687b         	ldr	r3, [r7, #0x4]
 80144ae: 3307         	adds	r3, #0x7
 80144b0: 08db         	lsrs	r3, r3, #0x3
; }
 80144b2: 4618         	mov	r0, r3
 80144b4: 370c         	adds	r7, #0xc
 80144b6: 46bd         	mov	sp, r7
 80144b8: bc80         	pop	{r7}
 80144ba: 4770         	bx	lr

080144bc <bytes_to_chunksz>:
; {
 80144bc: b580         	push	{r7, lr}
 80144be: b082         	sub	sp, #0x8
 80144c0: af00         	add	r7, sp, #0x0
 80144c2: 6078         	str	r0, [r7, #0x4]
 80144c4: 6039         	str	r1, [r7]
; 	return chunksz(chunk_header_bytes(h) + bytes);
 80144c6: 6878         	ldr	r0, [r7, #0x4]
 80144c8: f7ff ffca    	bl	0x8014460 <chunk_header_bytes> @ imm = #-0x6c
 80144cc: 4602         	mov	r2, r0
 80144ce: 683b         	ldr	r3, [r7]
 80144d0: 4413         	add	r3, r2
 80144d2: 4618         	mov	r0, r3
 80144d4: f7ff ffe6    	bl	0x80144a4 <chunksz>     @ imm = #-0x34
 80144d8: 4603         	mov	r3, r0
; }
 80144da: 4618         	mov	r0, r3
 80144dc: 3708         	adds	r7, #0x8
 80144de: 46bd         	mov	sp, r7
 80144e0: bd80         	pop	{r7, pc}

080144e2 <min_chunk_size>:
; {
 80144e2: b580         	push	{r7, lr}
 80144e4: b082         	sub	sp, #0x8
 80144e6: af00         	add	r7, sp, #0x0
 80144e8: 6078         	str	r0, [r7, #0x4]
; 	return bytes_to_chunksz(h, 1);
 80144ea: 2101         	movs	r1, #0x1
 80144ec: 6878         	ldr	r0, [r7, #0x4]
 80144ee: f7ff ffe5    	bl	0x80144bc <bytes_to_chunksz> @ imm = #-0x36
 80144f2: 4603         	mov	r3, r0
; }
 80144f4: 4618         	mov	r0, r3
 80144f6: 3708         	adds	r7, #0x8
 80144f8: 46bd         	mov	sp, r7
 80144fa: bd80         	pop	{r7, pc}

080144fc <bucket_idx>:
; {
 80144fc: b580         	push	{r7, lr}
 80144fe: b084         	sub	sp, #0x10
 8014500: af00         	add	r7, sp, #0x0
 8014502: 6078         	str	r0, [r7, #0x4]
 8014504: 6039         	str	r1, [r7]
; 	unsigned int usable_sz = sz - min_chunk_size(h) + 1;
 8014506: 6878         	ldr	r0, [r7, #0x4]
 8014508: f7ff ffeb    	bl	0x80144e2 <min_chunk_size> @ imm = #-0x2a
 801450c: 4602         	mov	r2, r0
 801450e: 683b         	ldr	r3, [r7]
 8014510: 1a9b         	subs	r3, r3, r2
 8014512: 3301         	adds	r3, #0x1
 8014514: 60fb         	str	r3, [r7, #0xc]
; 	return 31 - __builtin_clz(usable_sz);
 8014516: 68fb         	ldr	r3, [r7, #0xc]
 8014518: fab3 f383    	clz	r3, r3
 801451c: f1c3 031f    	rsb.w	r3, r3, #0x1f
; }
 8014520: 4618         	mov	r0, r3
 8014522: 3710         	adds	r7, #0x10
 8014524: 46bd         	mov	sp, r7
 8014526: bd80         	pop	{r7, pc}

08014528 <size_too_big>:
; {
 8014528: b480         	push	{r7}
 801452a: b083         	sub	sp, #0xc
 801452c: af00         	add	r7, sp, #0x0
 801452e: 6078         	str	r0, [r7, #0x4]
 8014530: 6039         	str	r1, [r7]
; 	return (bytes / CHUNK_UNIT) >= h->end_chunk;
 8014532: 683b         	ldr	r3, [r7]
 8014534: 08da         	lsrs	r2, r3, #0x3
 8014536: 687b         	ldr	r3, [r7, #0x4]
 8014538: 689b         	ldr	r3, [r3, #0x8]
 801453a: 429a         	cmp	r2, r3
 801453c: bf2c         	ite	hs
 801453e: 2301         	movhs	r3, #0x1
 8014540: 2300         	movlo	r3, #0x0
 8014542: b2db         	uxtb	r3, r3
; }
 8014544: 4618         	mov	r0, r3
 8014546: 370c         	adds	r7, #0xc
 8014548: 46bd         	mov	sp, r7
 801454a: bc80         	pop	{r7}
 801454c: 4770         	bx	lr

0801454e <chunk_mem>:
; {
 801454e: b590         	push	{r4, r7, lr}
 8014550: b085         	sub	sp, #0x14
 8014552: af00         	add	r7, sp, #0x0
 8014554: 6078         	str	r0, [r7, #0x4]
 8014556: 6039         	str	r1, [r7]
; 	chunk_unit_t *buf = chunk_buf(h);
 8014558: 6878         	ldr	r0, [r7, #0x4]
 801455a: f7ff fe49    	bl	0x80141f0 <chunk_buf>   @ imm = #-0x36e
 801455e: 60f8         	str	r0, [r7, #0xc]
; 	uint8_t *ret = ((uint8_t *)&buf[c]) + chunk_header_bytes(h);
 8014560: 683b         	ldr	r3, [r7]
 8014562: 00dc         	lsls	r4, r3, #0x3
 8014564: 6878         	ldr	r0, [r7, #0x4]
 8014566: f7ff ff7b    	bl	0x8014460 <chunk_header_bytes> @ imm = #-0x10a
 801456a: 4603         	mov	r3, r0
 801456c: 4423         	add	r3, r4
 801456e: 68fa         	ldr	r2, [r7, #0xc]
 8014570: 4413         	add	r3, r2
 8014572: 60bb         	str	r3, [r7, #0x8]
; 	return ret;
 8014574: 68bb         	ldr	r3, [r7, #0x8]
; }
 8014576: 4618         	mov	r0, r3
 8014578: 3714         	adds	r7, #0x14
 801457a: 46bd         	mov	sp, r7
 801457c: bd90         	pop	{r4, r7, pc}

0801457e <free_list_remove_bidx>:
; {
 801457e: b580         	push	{r7, lr}
 8014580: b088         	sub	sp, #0x20
 8014582: af00         	add	r7, sp, #0x0
 8014584: 60f8         	str	r0, [r7, #0xc]
 8014586: 60b9         	str	r1, [r7, #0x8]
 8014588: 607a         	str	r2, [r7, #0x4]
; 	struct z_heap_bucket *b = &h->buckets[bidx];
 801458a: 687b         	ldr	r3, [r7, #0x4]
 801458c: 3304         	adds	r3, #0x4
 801458e: 009b         	lsls	r3, r3, #0x2
 8014590: 68fa         	ldr	r2, [r7, #0xc]
 8014592: 4413         	add	r3, r2
 8014594: 61fb         	str	r3, [r7, #0x1c]
; 	if (next_free_chunk(h, c) == c) {
 8014596: 68b9         	ldr	r1, [r7, #0x8]
 8014598: 68f8         	ldr	r0, [r7, #0xc]
 801459a: f7ff fef6    	bl	0x801438a <next_free_chunk> @ imm = #-0x214
 801459e: 4602         	mov	r2, r0
 80145a0: 68bb         	ldr	r3, [r7, #0x8]
 80145a2: 4293         	cmp	r3, r2
 80145a4: d10d         	bne	0x80145c2 <free_list_remove_bidx+0x44> @ imm = #0x1a
; 		h->avail_buckets &= ~BIT(bidx);
 80145a6: 68fb         	ldr	r3, [r7, #0xc]
 80145a8: 68da         	ldr	r2, [r3, #0xc]
 80145aa: 2101         	movs	r1, #0x1
 80145ac: 687b         	ldr	r3, [r7, #0x4]
 80145ae: fa01 f303    	lsl.w	r3, r1, r3
 80145b2: 43db         	mvns	r3, r3
 80145b4: 401a         	ands	r2, r3
 80145b6: 68fb         	ldr	r3, [r7, #0xc]
 80145b8: 60da         	str	r2, [r3, #0xc]
; 		b->next = 0;
 80145ba: 69fb         	ldr	r3, [r7, #0x1c]
 80145bc: 2200         	movs	r2, #0x0
 80145be: 601a         	str	r2, [r3]
; }
 80145c0: e016         	b	0x80145f0 <free_list_remove_bidx+0x72> @ imm = #0x2c
; 		chunkid_t first = prev_free_chunk(h, c),
 80145c2: 68b9         	ldr	r1, [r7, #0x8]
 80145c4: 68f8         	ldr	r0, [r7, #0xc]
 80145c6: f7ff fed1    	bl	0x801436c <prev_free_chunk> @ imm = #-0x25e
 80145ca: 61b8         	str	r0, [r7, #0x18]
; 			  second = next_free_chunk(h, c);
 80145cc: 68b9         	ldr	r1, [r7, #0x8]
 80145ce: 68f8         	ldr	r0, [r7, #0xc]
 80145d0: f7ff fedb    	bl	0x801438a <next_free_chunk> @ imm = #-0x24a
 80145d4: 6178         	str	r0, [r7, #0x14]
; 		b->next = second;
 80145d6: 69fb         	ldr	r3, [r7, #0x1c]
 80145d8: 697a         	ldr	r2, [r7, #0x14]
 80145da: 601a         	str	r2, [r3]
; 		set_next_free_chunk(h, first, second);
 80145dc: 697a         	ldr	r2, [r7, #0x14]
 80145de: 69b9         	ldr	r1, [r7, #0x18]
 80145e0: 68f8         	ldr	r0, [r7, #0xc]
 80145e2: f7ff fef1    	bl	0x80143c8 <set_next_free_chunk> @ imm = #-0x21e
; 		set_prev_free_chunk(h, second, first);
 80145e6: 69ba         	ldr	r2, [r7, #0x18]
 80145e8: 6979         	ldr	r1, [r7, #0x14]
 80145ea: 68f8         	ldr	r0, [r7, #0xc]
 80145ec: f7ff fedc    	bl	0x80143a8 <set_prev_free_chunk> @ imm = #-0x248
; }
 80145f0: bf00         	nop
 80145f2: 3720         	adds	r7, #0x20
 80145f4: 46bd         	mov	sp, r7
 80145f6: bd80         	pop	{r7, pc}

080145f8 <free_list_add_bidx>:
; {
 80145f8: b580         	push	{r7, lr}
 80145fa: b088         	sub	sp, #0x20
 80145fc: af00         	add	r7, sp, #0x0
 80145fe: 60f8         	str	r0, [r7, #0xc]
 8014600: 60b9         	str	r1, [r7, #0x8]
 8014602: 607a         	str	r2, [r7, #0x4]
; 	struct z_heap_bucket *b = &h->buckets[bidx];
 8014604: 687b         	ldr	r3, [r7, #0x4]
 8014606: 3304         	adds	r3, #0x4
 8014608: 009b         	lsls	r3, r3, #0x2
 801460a: 68fa         	ldr	r2, [r7, #0xc]
 801460c: 4413         	add	r3, r2
 801460e: 61fb         	str	r3, [r7, #0x1c]
; 	if (b->next == 0U) {
 8014610: 69fb         	ldr	r3, [r7, #0x1c]
 8014612: 681b         	ldr	r3, [r3]
 8014614: 2b00         	cmp	r3, #0x0
 8014616: d116         	bne	0x8014646 <free_list_add_bidx+0x4e> @ imm = #0x2c
; 		h->avail_buckets |= BIT(bidx);
 8014618: 68fb         	ldr	r3, [r7, #0xc]
 801461a: 68da         	ldr	r2, [r3, #0xc]
 801461c: 2101         	movs	r1, #0x1
 801461e: 687b         	ldr	r3, [r7, #0x4]
 8014620: fa01 f303    	lsl.w	r3, r1, r3
 8014624: 431a         	orrs	r2, r3
 8014626: 68fb         	ldr	r3, [r7, #0xc]
 8014628: 60da         	str	r2, [r3, #0xc]
; 		b->next = c;
 801462a: 69fb         	ldr	r3, [r7, #0x1c]
 801462c: 68ba         	ldr	r2, [r7, #0x8]
 801462e: 601a         	str	r2, [r3]
; 		set_prev_free_chunk(h, c, c);
 8014630: 68ba         	ldr	r2, [r7, #0x8]
 8014632: 68b9         	ldr	r1, [r7, #0x8]
 8014634: 68f8         	ldr	r0, [r7, #0xc]
 8014636: f7ff feb7    	bl	0x80143a8 <set_prev_free_chunk> @ imm = #-0x292
; 		set_next_free_chunk(h, c, c);
 801463a: 68ba         	ldr	r2, [r7, #0x8]
 801463c: 68b9         	ldr	r1, [r7, #0x8]
 801463e: 68f8         	ldr	r0, [r7, #0xc]
 8014640: f7ff fec2    	bl	0x80143c8 <set_next_free_chunk> @ imm = #-0x27c
; }
 8014644: e01b         	b	0x801467e <free_list_add_bidx+0x86> @ imm = #0x36
; 		chunkid_t second = b->next;
 8014646: 69fb         	ldr	r3, [r7, #0x1c]
 8014648: 681b         	ldr	r3, [r3]
 801464a: 61bb         	str	r3, [r7, #0x18]
; 		chunkid_t first = prev_free_chunk(h, second);
 801464c: 69b9         	ldr	r1, [r7, #0x18]
 801464e: 68f8         	ldr	r0, [r7, #0xc]
 8014650: f7ff fe8c    	bl	0x801436c <prev_free_chunk> @ imm = #-0x2e8
 8014654: 6178         	str	r0, [r7, #0x14]
; 		set_prev_free_chunk(h, c, first);
 8014656: 697a         	ldr	r2, [r7, #0x14]
 8014658: 68b9         	ldr	r1, [r7, #0x8]
 801465a: 68f8         	ldr	r0, [r7, #0xc]
 801465c: f7ff fea4    	bl	0x80143a8 <set_prev_free_chunk> @ imm = #-0x2b8
; 		set_next_free_chunk(h, c, second);
 8014660: 69ba         	ldr	r2, [r7, #0x18]
 8014662: 68b9         	ldr	r1, [r7, #0x8]
 8014664: 68f8         	ldr	r0, [r7, #0xc]
 8014666: f7ff feaf    	bl	0x80143c8 <set_next_free_chunk> @ imm = #-0x2a2
; 		set_next_free_chunk(h, first, c);
 801466a: 68ba         	ldr	r2, [r7, #0x8]
 801466c: 6979         	ldr	r1, [r7, #0x14]
 801466e: 68f8         	ldr	r0, [r7, #0xc]
 8014670: f7ff feaa    	bl	0x80143c8 <set_next_free_chunk> @ imm = #-0x2ac
; 		set_prev_free_chunk(h, second, c);
 8014674: 68ba         	ldr	r2, [r7, #0x8]
 8014676: 69b9         	ldr	r1, [r7, #0x18]
 8014678: 68f8         	ldr	r0, [r7, #0xc]
 801467a: f7ff fe95    	bl	0x80143a8 <set_prev_free_chunk> @ imm = #-0x2d6
; }
 801467e: bf00         	nop
 8014680: 3720         	adds	r7, #0x20
 8014682: 46bd         	mov	sp, r7
 8014684: bd80         	pop	{r7, pc}

08014686 <free_list_add>:
; {
 8014686: b580         	push	{r7, lr}
 8014688: b084         	sub	sp, #0x10
 801468a: af00         	add	r7, sp, #0x0
 801468c: 6078         	str	r0, [r7, #0x4]
 801468e: 6039         	str	r1, [r7]
; 	if (!solo_free_header(h, c)) {
 8014690: 6839         	ldr	r1, [r7]
 8014692: 6878         	ldr	r0, [r7, #0x4]
 8014694: f7ff fec8    	bl	0x8014428 <solo_free_header> @ imm = #-0x270
 8014698: 4603         	mov	r3, r0
 801469a: f083 0301    	eor	r3, r3, #0x1
 801469e: b2db         	uxtb	r3, r3
 80146a0: 2b00         	cmp	r3, #0x0
 80146a2: d00e         	beq	0x80146c2 <free_list_add+0x3c> @ imm = #0x1c
; 		int bidx = bucket_idx(h, chunk_size(h, c));
 80146a4: 6839         	ldr	r1, [r7]
 80146a6: 6878         	ldr	r0, [r7, #0x4]
 80146a8: f7ff fdfa    	bl	0x80142a0 <chunk_size>  @ imm = #-0x40c
 80146ac: 4603         	mov	r3, r0
 80146ae: 4619         	mov	r1, r3
 80146b0: 6878         	ldr	r0, [r7, #0x4]
 80146b2: f7ff ff23    	bl	0x80144fc <bucket_idx>  @ imm = #-0x1ba
 80146b6: 60f8         	str	r0, [r7, #0xc]
; 		free_list_add_bidx(h, c, bidx);
 80146b8: 68fa         	ldr	r2, [r7, #0xc]
 80146ba: 6839         	ldr	r1, [r7]
 80146bc: 6878         	ldr	r0, [r7, #0x4]
 80146be: f7ff ff9b    	bl	0x80145f8 <free_list_add_bidx> @ imm = #-0xca
; }
 80146c2: bf00         	nop
 80146c4: 3710         	adds	r7, #0x10
 80146c6: 46bd         	mov	sp, r7
 80146c8: bd80         	pop	{r7, pc}

080146ca <split_chunks>:
; {
 80146ca: b580         	push	{r7, lr}
 80146cc: b088         	sub	sp, #0x20
 80146ce: af00         	add	r7, sp, #0x0
 80146d0: 60f8         	str	r0, [r7, #0xc]
 80146d2: 60b9         	str	r1, [r7, #0x8]
 80146d4: 607a         	str	r2, [r7, #0x4]
; 	chunksz_t sz0 = chunk_size(h, lc);
 80146d6: 68b9         	ldr	r1, [r7, #0x8]
 80146d8: 68f8         	ldr	r0, [r7, #0xc]
 80146da: f7ff fde1    	bl	0x80142a0 <chunk_size>  @ imm = #-0x43e
 80146de: 61f8         	str	r0, [r7, #0x1c]
; 	chunksz_t lsz = rc - lc;
 80146e0: 687a         	ldr	r2, [r7, #0x4]
 80146e2: 68bb         	ldr	r3, [r7, #0x8]
 80146e4: 1ad3         	subs	r3, r2, r3
 80146e6: 61bb         	str	r3, [r7, #0x18]
; 	chunksz_t rsz = sz0 - lsz;
 80146e8: 69fa         	ldr	r2, [r7, #0x1c]
 80146ea: 69bb         	ldr	r3, [r7, #0x18]
 80146ec: 1ad3         	subs	r3, r2, r3
 80146ee: 617b         	str	r3, [r7, #0x14]
; 	set_chunk_size(h, lc, lsz);
 80146f0: 69ba         	ldr	r2, [r7, #0x18]
 80146f2: 68b9         	ldr	r1, [r7, #0x8]
 80146f4: 68f8         	ldr	r0, [r7, #0xc]
 80146f6: f7ff fe28    	bl	0x801434a <set_chunk_size> @ imm = #-0x3b0
; 	set_chunk_size(h, rc, rsz);
 80146fa: 697a         	ldr	r2, [r7, #0x14]
 80146fc: 6879         	ldr	r1, [r7, #0x4]
 80146fe: 68f8         	ldr	r0, [r7, #0xc]
 8014700: f7ff fe23    	bl	0x801434a <set_chunk_size> @ imm = #-0x3ba
; 	set_left_chunk_size(h, rc, lsz);
 8014704: 69ba         	ldr	r2, [r7, #0x18]
 8014706: 6879         	ldr	r1, [r7, #0x4]
 8014708: 68f8         	ldr	r0, [r7, #0xc]
 801470a: f7ff fe7d    	bl	0x8014408 <set_left_chunk_size> @ imm = #-0x306
; 	set_left_chunk_size(h, right_chunk(h, rc), rsz);
 801470e: 6879         	ldr	r1, [r7, #0x4]
 8014710: 68f8         	ldr	r0, [r7, #0xc]
 8014712: f7ff fe69    	bl	0x80143e8 <right_chunk> @ imm = #-0x32e
 8014716: 4603         	mov	r3, r0
 8014718: 697a         	ldr	r2, [r7, #0x14]
 801471a: 4619         	mov	r1, r3
 801471c: 68f8         	ldr	r0, [r7, #0xc]
 801471e: f7ff fe73    	bl	0x8014408 <set_left_chunk_size> @ imm = #-0x31a
; }
 8014722: bf00         	nop
 8014724: 3720         	adds	r7, #0x20
 8014726: 46bd         	mov	sp, r7
 8014728: bd80         	pop	{r7, pc}

0801472a <mem_to_chunkid>:
; {
 801472a: b580         	push	{r7, lr}
 801472c: b084         	sub	sp, #0x10
 801472e: af00         	add	r7, sp, #0x0
 8014730: 6078         	str	r0, [r7, #0x4]
 8014732: 6039         	str	r1, [r7]
; 	uint8_t *mem = p, *base = (uint8_t *)chunk_buf(h);
 8014734: 683b         	ldr	r3, [r7]
 8014736: 60fb         	str	r3, [r7, #0xc]
 8014738: 6878         	ldr	r0, [r7, #0x4]
 801473a: f7ff fd59    	bl	0x80141f0 <chunk_buf>   @ imm = #-0x54e
 801473e: 60b8         	str	r0, [r7, #0x8]
; 	return (mem - chunk_header_bytes(h) - base) / CHUNK_UNIT;
 8014740: 6878         	ldr	r0, [r7, #0x4]
 8014742: f7ff fe8d    	bl	0x8014460 <chunk_header_bytes> @ imm = #-0x2e6
 8014746: 4603         	mov	r3, r0
 8014748: 425b         	rsbs	r3, r3, #0
 801474a: 68fa         	ldr	r2, [r7, #0xc]
 801474c: 441a         	add	r2, r3
 801474e: 68bb         	ldr	r3, [r7, #0x8]
 8014750: 1ad3         	subs	r3, r2, r3
 8014752: 08db         	lsrs	r3, r3, #0x3
; }
 8014754: 4618         	mov	r0, r3
 8014756: 3710         	adds	r7, #0x10
 8014758: 46bd         	mov	sp, r7
 801475a: bd80         	pop	{r7, pc}

0801475c <alloc_chunk>:
; {
 801475c: b580         	push	{r7, lr}
 801475e: b08a         	sub	sp, #0x28
 8014760: af00         	add	r7, sp, #0x0
 8014762: 6078         	str	r0, [r7, #0x4]
 8014764: 6039         	str	r1, [r7]
; 	int bi = bucket_idx(h, sz);
 8014766: 6839         	ldr	r1, [r7]
 8014768: 6878         	ldr	r0, [r7, #0x4]
 801476a: f7ff fec7    	bl	0x80144fc <bucket_idx>  @ imm = #-0x272
 801476e: 6238         	str	r0, [r7, #0x20]
; 	struct z_heap_bucket *b = &h->buckets[bi];
 8014770: 6a3b         	ldr	r3, [r7, #0x20]
 8014772: 3304         	adds	r3, #0x4
 8014774: 009b         	lsls	r3, r3, #0x2
 8014776: 687a         	ldr	r2, [r7, #0x4]
 8014778: 4413         	add	r3, r2
 801477a: 61fb         	str	r3, [r7, #0x1c]
; 	if (b->next != 0U) {
 801477c: 69fb         	ldr	r3, [r7, #0x1c]
 801477e: 681b         	ldr	r3, [r3]
 8014780: 2b00         	cmp	r3, #0x0
 8014782: d028         	beq	0x80147d6 <alloc_chunk+0x7a> @ imm = #0x50
; 		chunkid_t first = b->next;
 8014784: 69fb         	ldr	r3, [r7, #0x1c]
 8014786: 681b         	ldr	r3, [r3]
 8014788: 61bb         	str	r3, [r7, #0x18]
; 		int i = CONFIG_SYS_HEAP_ALLOC_LOOPS;
 801478a: 2303         	movs	r3, #0x3
 801478c: 627b         	str	r3, [r7, #0x24]
; 			chunkid_t c = b->next;
 801478e: 69fb         	ldr	r3, [r7, #0x1c]
 8014790: 681b         	ldr	r3, [r3]
 8014792: 617b         	str	r3, [r7, #0x14]
; 			if (chunk_size(h, c) >= sz) {
 8014794: 6979         	ldr	r1, [r7, #0x14]
 8014796: 6878         	ldr	r0, [r7, #0x4]
 8014798: f7ff fd82    	bl	0x80142a0 <chunk_size>  @ imm = #-0x4fc
 801479c: 4602         	mov	r2, r0
 801479e: 683b         	ldr	r3, [r7]
 80147a0: 4293         	cmp	r3, r2
 80147a2: d806         	bhi	0x80147b2 <alloc_chunk+0x56> @ imm = #0xc
; 				free_list_remove_bidx(h, c, bi);
 80147a4: 6a3a         	ldr	r2, [r7, #0x20]
 80147a6: 6979         	ldr	r1, [r7, #0x14]
 80147a8: 6878         	ldr	r0, [r7, #0x4]
 80147aa: f7ff fee8    	bl	0x801457e <free_list_remove_bidx> @ imm = #-0x230
; 				return c;
 80147ae: 697b         	ldr	r3, [r7, #0x14]
 80147b0: e032         	b	0x8014818 <alloc_chunk+0xbc> @ imm = #0x64
; 			b->next = next_free_chunk(h, c);
 80147b2: 6979         	ldr	r1, [r7, #0x14]
 80147b4: 6878         	ldr	r0, [r7, #0x4]
 80147b6: f7ff fde8    	bl	0x801438a <next_free_chunk> @ imm = #-0x430
 80147ba: 4602         	mov	r2, r0
 80147bc: 69fb         	ldr	r3, [r7, #0x1c]
 80147be: 601a         	str	r2, [r3]
; 		} while (--i && b->next != first);
 80147c0: 6a7b         	ldr	r3, [r7, #0x24]
 80147c2: 3b01         	subs	r3, #0x1
 80147c4: 627b         	str	r3, [r7, #0x24]
 80147c6: 6a7b         	ldr	r3, [r7, #0x24]
 80147c8: 2b00         	cmp	r3, #0x0
 80147ca: d004         	beq	0x80147d6 <alloc_chunk+0x7a> @ imm = #0x8
 80147cc: 69fb         	ldr	r3, [r7, #0x1c]
 80147ce: 681b         	ldr	r3, [r3]
 80147d0: 69ba         	ldr	r2, [r7, #0x18]
 80147d2: 429a         	cmp	r2, r3
 80147d4: d1db         	bne	0x801478e <alloc_chunk+0x32> @ imm = #-0x4a
; 	uint32_t bmask = h->avail_buckets & ~BIT_MASK(bi + 1);
 80147d6: 687b         	ldr	r3, [r7, #0x4]
 80147d8: 68da         	ldr	r2, [r3, #0xc]
 80147da: 6a3b         	ldr	r3, [r7, #0x20]
 80147dc: 3301         	adds	r3, #0x1
 80147de: 2101         	movs	r1, #0x1
 80147e0: fa01 f303    	lsl.w	r3, r1, r3
 80147e4: 425b         	rsbs	r3, r3, #0
 80147e6: 4013         	ands	r3, r2
 80147e8: 613b         	str	r3, [r7, #0x10]
; 	if (bmask != 0U) {
 80147ea: 693b         	ldr	r3, [r7, #0x10]
 80147ec: 2b00         	cmp	r3, #0x0
 80147ee: d012         	beq	0x8014816 <alloc_chunk+0xba> @ imm = #0x24
; 		int minbucket = __builtin_ctz(bmask);
 80147f0: 693b         	ldr	r3, [r7, #0x10]
 80147f2: fa93 f3a3    	rbit	r3, r3
 80147f6: fab3 f383    	clz	r3, r3
 80147fa: 60fb         	str	r3, [r7, #0xc]
; 		chunkid_t c = h->buckets[minbucket].next;
 80147fc: 687b         	ldr	r3, [r7, #0x4]
 80147fe: 68fa         	ldr	r2, [r7, #0xc]
 8014800: 3204         	adds	r2, #0x4
 8014802: f853 3022    	ldr.w	r3, [r3, r2, lsl #2]
 8014806: 60bb         	str	r3, [r7, #0x8]
; 		free_list_remove_bidx(h, c, minbucket);
 8014808: 68fa         	ldr	r2, [r7, #0xc]
 801480a: 68b9         	ldr	r1, [r7, #0x8]
 801480c: 6878         	ldr	r0, [r7, #0x4]
 801480e: f7ff feb6    	bl	0x801457e <free_list_remove_bidx> @ imm = #-0x294
; 		return c;
 8014812: 68bb         	ldr	r3, [r7, #0x8]
 8014814: e000         	b	0x8014818 <alloc_chunk+0xbc> @ imm = #0x0
; 	return 0;
 8014816: 2300         	movs	r3, #0x0
; }
 8014818: 4618         	mov	r0, r3
 801481a: 3728         	adds	r7, #0x28
 801481c: 46bd         	mov	sp, r7
 801481e: bd80         	pop	{r7, pc}

08014820 <sys_heap_alloc>:
; {
 8014820: b580         	push	{r7, lr}
 8014822: b086         	sub	sp, #0x18
 8014824: af00         	add	r7, sp, #0x0
 8014826: 6078         	str	r0, [r7, #0x4]
 8014828: 6039         	str	r1, [r7]
; 	struct z_heap *h = heap->heap;
 801482a: 687b         	ldr	r3, [r7, #0x4]
 801482c: 681b         	ldr	r3, [r3]
 801482e: 617b         	str	r3, [r7, #0x14]
; 	if ((bytes == 0U) || size_too_big(h, bytes)) {
 8014830: 683b         	ldr	r3, [r7]
 8014832: 2b00         	cmp	r3, #0x0
 8014834: d006         	beq	0x8014844 <sys_heap_alloc+0x24> @ imm = #0xc
 8014836: 6839         	ldr	r1, [r7]
 8014838: 6978         	ldr	r0, [r7, #0x14]
 801483a: f7ff fe75    	bl	0x8014528 <size_too_big> @ imm = #-0x316
 801483e: 4603         	mov	r3, r0
 8014840: 2b00         	cmp	r3, #0x0
 8014842: d001         	beq	0x8014848 <sys_heap_alloc+0x28> @ imm = #0x2
; 		return NULL;
 8014844: 2300         	movs	r3, #0x0
 8014846: e030         	b	0x80148aa <sys_heap_alloc+0x8a> @ imm = #0x60
; 	chunksz_t chunk_sz = bytes_to_chunksz(h, bytes);
 8014848: 6839         	ldr	r1, [r7]
 801484a: 6978         	ldr	r0, [r7, #0x14]
 801484c: f7ff fe36    	bl	0x80144bc <bytes_to_chunksz> @ imm = #-0x394
 8014850: 6138         	str	r0, [r7, #0x10]
; 	chunkid_t c = alloc_chunk(h, chunk_sz);
 8014852: 6939         	ldr	r1, [r7, #0x10]
 8014854: 6978         	ldr	r0, [r7, #0x14]
 8014856: f7ff ff81    	bl	0x801475c <alloc_chunk> @ imm = #-0xfe
 801485a: 60f8         	str	r0, [r7, #0xc]
; 	if (c == 0U) {
 801485c: 68fb         	ldr	r3, [r7, #0xc]
 801485e: 2b00         	cmp	r3, #0x0
 8014860: d101         	bne	0x8014866 <sys_heap_alloc+0x46> @ imm = #0x2
; 		return NULL;
 8014862: 2300         	movs	r3, #0x0
 8014864: e021         	b	0x80148aa <sys_heap_alloc+0x8a> @ imm = #0x42
; 	if (chunk_size(h, c) > chunk_sz) {
 8014866: 68f9         	ldr	r1, [r7, #0xc]
 8014868: 6978         	ldr	r0, [r7, #0x14]
 801486a: f7ff fd19    	bl	0x80142a0 <chunk_size>  @ imm = #-0x5ce
 801486e: 4602         	mov	r2, r0
 8014870: 693b         	ldr	r3, [r7, #0x10]
 8014872: 4293         	cmp	r3, r2
 8014874: d20e         	bhs	0x8014894 <sys_heap_alloc+0x74> @ imm = #0x1c
; 		split_chunks(h, c, c + chunk_sz);
 8014876: 68fa         	ldr	r2, [r7, #0xc]
 8014878: 693b         	ldr	r3, [r7, #0x10]
 801487a: 4413         	add	r3, r2
 801487c: 461a         	mov	r2, r3
 801487e: 68f9         	ldr	r1, [r7, #0xc]
 8014880: 6978         	ldr	r0, [r7, #0x14]
 8014882: f7ff ff22    	bl	0x80146ca <split_chunks> @ imm = #-0x1bc
; 		free_list_add(h, c + chunk_sz);
 8014886: 68fa         	ldr	r2, [r7, #0xc]
 8014888: 693b         	ldr	r3, [r7, #0x10]
 801488a: 4413         	add	r3, r2
 801488c: 4619         	mov	r1, r3
 801488e: 6978         	ldr	r0, [r7, #0x14]
 8014890: f7ff fef9    	bl	0x8014686 <free_list_add> @ imm = #-0x20e
; 	set_chunk_used(h, c, true);
 8014894: 2201         	movs	r2, #0x1
 8014896: 68f9         	ldr	r1, [r7, #0xc]
 8014898: 6978         	ldr	r0, [r7, #0x14]
 801489a: f7ff fd11    	bl	0x80142c0 <set_chunk_used> @ imm = #-0x5de
; 	mem = chunk_mem(h, c);
 801489e: 68f9         	ldr	r1, [r7, #0xc]
 80148a0: 6978         	ldr	r0, [r7, #0x14]
 80148a2: f7ff fe54    	bl	0x801454e <chunk_mem>   @ imm = #-0x358
 80148a6: 60b8         	str	r0, [r7, #0x8]
; 	return mem;
 80148a8: 68bb         	ldr	r3, [r7, #0x8]
; }
 80148aa: 4618         	mov	r0, r3
 80148ac: 3718         	adds	r7, #0x18
 80148ae: 46bd         	mov	sp, r7
 80148b0: bd80         	pop	{r7, pc}

080148b2 <sys_heap_aligned_alloc>:
; {
 80148b2: b580         	push	{r7, lr}
 80148b4: b08e         	sub	sp, #0x38
 80148b6: af00         	add	r7, sp, #0x0
 80148b8: 60f8         	str	r0, [r7, #0xc]
 80148ba: 60b9         	str	r1, [r7, #0x8]
 80148bc: 607a         	str	r2, [r7, #0x4]
; 	struct z_heap *h = heap->heap;
 80148be: 68fb         	ldr	r3, [r7, #0xc]
 80148c0: 681b         	ldr	r3, [r3]
 80148c2: 62fb         	str	r3, [r7, #0x2c]
; 	rew = align & -align;
 80148c4: 68bb         	ldr	r3, [r7, #0x8]
 80148c6: 425b         	rsbs	r3, r3, #0
 80148c8: 68ba         	ldr	r2, [r7, #0x8]
 80148ca: 4013         	ands	r3, r2
 80148cc: 633b         	str	r3, [r7, #0x30]
; 	if (align != rew) {
 80148ce: 68ba         	ldr	r2, [r7, #0x8]
 80148d0: 6b3b         	ldr	r3, [r7, #0x30]
 80148d2: 429a         	cmp	r2, r3
 80148d4: d012         	beq	0x80148fc <sys_heap_aligned_alloc+0x4a> @ imm = #0x24
; 		align -= rew;
 80148d6: 68ba         	ldr	r2, [r7, #0x8]
 80148d8: 6b3b         	ldr	r3, [r7, #0x30]
 80148da: 1ad3         	subs	r3, r2, r3
 80148dc: 60bb         	str	r3, [r7, #0x8]
; 		gap = MIN(rew, chunk_header_bytes(h));
 80148de: 6af8         	ldr	r0, [r7, #0x2c]
 80148e0: f7ff fdbe    	bl	0x8014460 <chunk_header_bytes> @ imm = #-0x484
 80148e4: 4602         	mov	r2, r0
 80148e6: 6b3b         	ldr	r3, [r7, #0x30]
 80148e8: 4293         	cmp	r3, r2
 80148ea: d304         	blo	0x80148f6 <sys_heap_aligned_alloc+0x44> @ imm = #0x8
 80148ec: 6af8         	ldr	r0, [r7, #0x2c]
 80148ee: f7ff fdb7    	bl	0x8014460 <chunk_header_bytes> @ imm = #-0x492
 80148f2: 4603         	mov	r3, r0
 80148f4: e000         	b	0x80148f8 <sys_heap_aligned_alloc+0x46> @ imm = #0x0
 80148f6: 6b3b         	ldr	r3, [r7, #0x30]
 80148f8: 637b         	str	r3, [r7, #0x34]
 80148fa: e012         	b	0x8014922 <sys_heap_aligned_alloc+0x70> @ imm = #0x24
; 		if (align <= chunk_header_bytes(h)) {
 80148fc: 6af8         	ldr	r0, [r7, #0x2c]
 80148fe: f7ff fdaf    	bl	0x8014460 <chunk_header_bytes> @ imm = #-0x4a2
 8014902: 4602         	mov	r2, r0
 8014904: 68bb         	ldr	r3, [r7, #0x8]
 8014906: 4293         	cmp	r3, r2
 8014908: d805         	bhi	0x8014916 <sys_heap_aligned_alloc+0x64> @ imm = #0xa
; 			return sys_heap_alloc(heap, bytes);
 801490a: 6879         	ldr	r1, [r7, #0x4]
 801490c: 68f8         	ldr	r0, [r7, #0xc]
 801490e: f7ff ff87    	bl	0x8014820 <sys_heap_alloc> @ imm = #-0xf2
 8014912: 4603         	mov	r3, r0
 8014914: e072         	b	0x80149fc <sys_heap_aligned_alloc+0x14a> @ imm = #0xe4
; 		rew = 0;
 8014916: 2300         	movs	r3, #0x0
 8014918: 633b         	str	r3, [r7, #0x30]
; 		gap = chunk_header_bytes(h);
 801491a: 6af8         	ldr	r0, [r7, #0x2c]
 801491c: f7ff fda0    	bl	0x8014460 <chunk_header_bytes> @ imm = #-0x4c0
 8014920: 6378         	str	r0, [r7, #0x34]
; 	if ((bytes == 0) || size_too_big(h, bytes)) {
 8014922: 687b         	ldr	r3, [r7, #0x4]
 8014924: 2b00         	cmp	r3, #0x0
 8014926: d006         	beq	0x8014936 <sys_heap_aligned_alloc+0x84> @ imm = #0xc
 8014928: 6879         	ldr	r1, [r7, #0x4]
 801492a: 6af8         	ldr	r0, [r7, #0x2c]
 801492c: f7ff fdfc    	bl	0x8014528 <size_too_big> @ imm = #-0x408
 8014930: 4603         	mov	r3, r0
 8014932: 2b00         	cmp	r3, #0x0
 8014934: d001         	beq	0x801493a <sys_heap_aligned_alloc+0x88> @ imm = #0x2
; 		return NULL;
 8014936: 2300         	movs	r3, #0x0
 8014938: e060         	b	0x80149fc <sys_heap_aligned_alloc+0x14a> @ imm = #0xc0
; 	chunksz_t padded_sz = bytes_to_chunksz(h, bytes + align - gap);
 801493a: 687a         	ldr	r2, [r7, #0x4]
 801493c: 68bb         	ldr	r3, [r7, #0x8]
 801493e: 441a         	add	r2, r3
 8014940: 6b7b         	ldr	r3, [r7, #0x34]
 8014942: 1ad3         	subs	r3, r2, r3
 8014944: 4619         	mov	r1, r3
 8014946: 6af8         	ldr	r0, [r7, #0x2c]
 8014948: f7ff fdb8    	bl	0x80144bc <bytes_to_chunksz> @ imm = #-0x490
 801494c: 62b8         	str	r0, [r7, #0x28]
; 	chunkid_t c0 = alloc_chunk(h, padded_sz);
 801494e: 6ab9         	ldr	r1, [r7, #0x28]
 8014950: 6af8         	ldr	r0, [r7, #0x2c]
 8014952: f7ff ff03    	bl	0x801475c <alloc_chunk> @ imm = #-0x1fa
 8014956: 6278         	str	r0, [r7, #0x24]
; 	if (c0 == 0) {
 8014958: 6a7b         	ldr	r3, [r7, #0x24]
 801495a: 2b00         	cmp	r3, #0x0
 801495c: d101         	bne	0x8014962 <sys_heap_aligned_alloc+0xb0> @ imm = #0x2
; 		return NULL;
 801495e: 2300         	movs	r3, #0x0
 8014960: e04c         	b	0x80149fc <sys_heap_aligned_alloc+0x14a> @ imm = #0x98
; 	uint8_t *mem = chunk_mem(h, c0);
 8014962: 6a79         	ldr	r1, [r7, #0x24]
 8014964: 6af8         	ldr	r0, [r7, #0x2c]
 8014966: f7ff fdf2    	bl	0x801454e <chunk_mem>   @ imm = #-0x41c
 801496a: 6238         	str	r0, [r7, #0x20]
; 	mem = (uint8_t *) ROUND_UP(mem + rew, align) - rew;
 801496c: 6a3a         	ldr	r2, [r7, #0x20]
 801496e: 6b3b         	ldr	r3, [r7, #0x30]
 8014970: 4413         	add	r3, r2
 8014972: 461a         	mov	r2, r3
 8014974: 68bb         	ldr	r3, [r7, #0x8]
 8014976: 4413         	add	r3, r2
 8014978: 1e5a         	subs	r2, r3, #0x1
 801497a: 68bb         	ldr	r3, [r7, #0x8]
 801497c: fbb2 f3f3    	udiv	r3, r2, r3
 8014980: 68ba         	ldr	r2, [r7, #0x8]
 8014982: fb03 f202    	mul	r2, r3, r2
 8014986: 6b3b         	ldr	r3, [r7, #0x30]
 8014988: 1ad3         	subs	r3, r2, r3
 801498a: 623b         	str	r3, [r7, #0x20]
; 	chunk_unit_t *end = (chunk_unit_t *) ROUND_UP(mem + bytes, CHUNK_UNIT);
 801498c: 6a3a         	ldr	r2, [r7, #0x20]
 801498e: 687b         	ldr	r3, [r7, #0x4]
 8014990: 4413         	add	r3, r2
 8014992: 3307         	adds	r3, #0x7
 8014994: f023 0307    	bic	r3, r3, #0x7
 8014998: 61fb         	str	r3, [r7, #0x1c]
; 	chunkid_t c = mem_to_chunkid(h, mem);
 801499a: 6a39         	ldr	r1, [r7, #0x20]
 801499c: 6af8         	ldr	r0, [r7, #0x2c]
 801499e: f7ff fec4    	bl	0x801472a <mem_to_chunkid> @ imm = #-0x278
 80149a2: 61b8         	str	r0, [r7, #0x18]
; 	chunkid_t c_end = end - chunk_buf(h);
 80149a4: 6af8         	ldr	r0, [r7, #0x2c]
 80149a6: f7ff fc23    	bl	0x80141f0 <chunk_buf>   @ imm = #-0x7ba
 80149aa: 4602         	mov	r2, r0
 80149ac: 69fb         	ldr	r3, [r7, #0x1c]
 80149ae: 1a9b         	subs	r3, r3, r2
 80149b0: 10db         	asrs	r3, r3, #0x3
 80149b2: 617b         	str	r3, [r7, #0x14]
; 	if (c > c0) {
 80149b4: 69ba         	ldr	r2, [r7, #0x18]
 80149b6: 6a7b         	ldr	r3, [r7, #0x24]
 80149b8: 429a         	cmp	r2, r3
 80149ba: d908         	bls	0x80149ce <sys_heap_aligned_alloc+0x11c> @ imm = #0x10
; 		split_chunks(h, c0, c);
 80149bc: 69ba         	ldr	r2, [r7, #0x18]
 80149be: 6a79         	ldr	r1, [r7, #0x24]
 80149c0: 6af8         	ldr	r0, [r7, #0x2c]
 80149c2: f7ff fe82    	bl	0x80146ca <split_chunks> @ imm = #-0x2fc
; 		free_list_add(h, c0);
 80149c6: 6a79         	ldr	r1, [r7, #0x24]
 80149c8: 6af8         	ldr	r0, [r7, #0x2c]
 80149ca: f7ff fe5c    	bl	0x8014686 <free_list_add> @ imm = #-0x348
; 	if (right_chunk(h, c) > c_end) {
 80149ce: 69b9         	ldr	r1, [r7, #0x18]
 80149d0: 6af8         	ldr	r0, [r7, #0x2c]
 80149d2: f7ff fd09    	bl	0x80143e8 <right_chunk> @ imm = #-0x5ee
 80149d6: 4602         	mov	r2, r0
 80149d8: 697b         	ldr	r3, [r7, #0x14]
 80149da: 4293         	cmp	r3, r2
 80149dc: d208         	bhs	0x80149f0 <sys_heap_aligned_alloc+0x13e> @ imm = #0x10
; 		split_chunks(h, c, c_end);
 80149de: 697a         	ldr	r2, [r7, #0x14]
 80149e0: 69b9         	ldr	r1, [r7, #0x18]
 80149e2: 6af8         	ldr	r0, [r7, #0x2c]
 80149e4: f7ff fe71    	bl	0x80146ca <split_chunks> @ imm = #-0x31e
; 		free_list_add(h, c_end);
 80149e8: 6979         	ldr	r1, [r7, #0x14]
 80149ea: 6af8         	ldr	r0, [r7, #0x2c]
 80149ec: f7ff fe4b    	bl	0x8014686 <free_list_add> @ imm = #-0x36a
; 	set_chunk_used(h, c, true);
 80149f0: 2201         	movs	r2, #0x1
 80149f2: 69b9         	ldr	r1, [r7, #0x18]
 80149f4: 6af8         	ldr	r0, [r7, #0x2c]
 80149f6: f7ff fc63    	bl	0x80142c0 <set_chunk_used> @ imm = #-0x73a
; 	return mem;
 80149fa: 6a3b         	ldr	r3, [r7, #0x20]
; }
 80149fc: 4618         	mov	r0, r3
 80149fe: 3738         	adds	r7, #0x38
 8014a00: 46bd         	mov	sp, r7
 8014a02: bd80         	pop	{r7, pc}

08014a04 <sys_heap_init>:
; {
 8014a04: b580         	push	{r7, lr}
 8014a06: b08c         	sub	sp, #0x30
 8014a08: af00         	add	r7, sp, #0x0
 8014a0a: 60f8         	str	r0, [r7, #0xc]
 8014a0c: 60b9         	str	r1, [r7, #0x8]
 8014a0e: 607a         	str	r2, [r7, #0x4]
; 	bytes -= heap_footer_bytes(bytes);
 8014a10: 6878         	ldr	r0, [r7, #0x4]
 8014a12: f7ff fd36    	bl	0x8014482 <heap_footer_bytes> @ imm = #-0x594
 8014a16: 4602         	mov	r2, r0
 8014a18: 687b         	ldr	r3, [r7, #0x4]
 8014a1a: 1a9b         	subs	r3, r3, r2
 8014a1c: 607b         	str	r3, [r7, #0x4]
; 	uintptr_t addr = ROUND_UP(mem, CHUNK_UNIT);
 8014a1e: 68bb         	ldr	r3, [r7, #0x8]
 8014a20: 3307         	adds	r3, #0x7
 8014a22: f023 0307    	bic	r3, r3, #0x7
 8014a26: 62bb         	str	r3, [r7, #0x28]
; 	uintptr_t end = ROUND_DOWN((uint8_t *)mem + bytes, CHUNK_UNIT);
 8014a28: 68ba         	ldr	r2, [r7, #0x8]
 8014a2a: 687b         	ldr	r3, [r7, #0x4]
 8014a2c: 4413         	add	r3, r2
 8014a2e: f023 0307    	bic	r3, r3, #0x7
 8014a32: 627b         	str	r3, [r7, #0x24]
; 	chunksz_t heap_sz = (end - addr) / CHUNK_UNIT;
 8014a34: 6a7a         	ldr	r2, [r7, #0x24]
 8014a36: 6abb         	ldr	r3, [r7, #0x28]
 8014a38: 1ad3         	subs	r3, r2, r3
 8014a3a: 08db         	lsrs	r3, r3, #0x3
 8014a3c: 623b         	str	r3, [r7, #0x20]
; 	struct z_heap *h = (struct z_heap *)addr;
 8014a3e: 6abb         	ldr	r3, [r7, #0x28]
 8014a40: 61fb         	str	r3, [r7, #0x1c]
; 	heap->heap = h;
 8014a42: 68fb         	ldr	r3, [r7, #0xc]
 8014a44: 69fa         	ldr	r2, [r7, #0x1c]
 8014a46: 601a         	str	r2, [r3]
; 	h->end_chunk = heap_sz;
 8014a48: 69fb         	ldr	r3, [r7, #0x1c]
 8014a4a: 6a3a         	ldr	r2, [r7, #0x20]
 8014a4c: 609a         	str	r2, [r3, #0x8]
; 	h->avail_buckets = 0;
 8014a4e: 69fb         	ldr	r3, [r7, #0x1c]
 8014a50: 2200         	movs	r2, #0x0
 8014a52: 60da         	str	r2, [r3, #0xc]
; 	int nb_buckets = bucket_idx(h, heap_sz) + 1;
 8014a54: 6a39         	ldr	r1, [r7, #0x20]
 8014a56: 69f8         	ldr	r0, [r7, #0x1c]
 8014a58: f7ff fd50    	bl	0x80144fc <bucket_idx>  @ imm = #-0x560
 8014a5c: 4603         	mov	r3, r0
 8014a5e: 3301         	adds	r3, #0x1
 8014a60: 61bb         	str	r3, [r7, #0x18]
; 	chunksz_t chunk0_size = chunksz(sizeof(struct z_heap) +
 8014a62: 69bb         	ldr	r3, [r7, #0x18]
 8014a64: 3304         	adds	r3, #0x4
 8014a66: 009b         	lsls	r3, r3, #0x2
 8014a68: 4618         	mov	r0, r3
 8014a6a: f7ff fd1b    	bl	0x80144a4 <chunksz>     @ imm = #-0x5ca
 8014a6e: 6178         	str	r0, [r7, #0x14]
; 	for (int i = 0; i < nb_buckets; i++) {
 8014a70: 2300         	movs	r3, #0x0
 8014a72: 62fb         	str	r3, [r7, #0x2c]
 8014a74: e008         	b	0x8014a88 <sys_heap_init+0x84> @ imm = #0x10
; 		h->buckets[i].next = 0;
 8014a76: 69fb         	ldr	r3, [r7, #0x1c]
 8014a78: 6afa         	ldr	r2, [r7, #0x2c]
 8014a7a: 3204         	adds	r2, #0x4
 8014a7c: 2100         	movs	r1, #0x0
 8014a7e: f843 1022    	str.w	r1, [r3, r2, lsl #2]
; 	for (int i = 0; i < nb_buckets; i++) {
 8014a82: 6afb         	ldr	r3, [r7, #0x2c]
 8014a84: 3301         	adds	r3, #0x1
 8014a86: 62fb         	str	r3, [r7, #0x2c]
 8014a88: 6afa         	ldr	r2, [r7, #0x2c]
 8014a8a: 69bb         	ldr	r3, [r7, #0x18]
 8014a8c: 429a         	cmp	r2, r3
 8014a8e: dbf2         	blt	0x8014a76 <sys_heap_init+0x72> @ imm = #-0x1c
; 	set_chunk_size(h, 0, chunk0_size);
 8014a90: 697a         	ldr	r2, [r7, #0x14]
 8014a92: 2100         	movs	r1, #0x0
 8014a94: 69f8         	ldr	r0, [r7, #0x1c]
 8014a96: f7ff fc58    	bl	0x801434a <set_chunk_size> @ imm = #-0x750
; 	set_left_chunk_size(h, 0, 0);
 8014a9a: 2200         	movs	r2, #0x0
 8014a9c: 2100         	movs	r1, #0x0
 8014a9e: 69f8         	ldr	r0, [r7, #0x1c]
 8014aa0: f7ff fcb2    	bl	0x8014408 <set_left_chunk_size> @ imm = #-0x69c
; 	set_chunk_used(h, 0, true);
 8014aa4: 2201         	movs	r2, #0x1
 8014aa6: 2100         	movs	r1, #0x0
 8014aa8: 69f8         	ldr	r0, [r7, #0x1c]
 8014aaa: f7ff fc09    	bl	0x80142c0 <set_chunk_used> @ imm = #-0x7ee
; 	set_chunk_size(h, chunk0_size, heap_sz - chunk0_size);
 8014aae: 6a3a         	ldr	r2, [r7, #0x20]
 8014ab0: 697b         	ldr	r3, [r7, #0x14]
 8014ab2: 1ad3         	subs	r3, r2, r3
 8014ab4: 461a         	mov	r2, r3
 8014ab6: 6979         	ldr	r1, [r7, #0x14]
 8014ab8: 69f8         	ldr	r0, [r7, #0x1c]
 8014aba: f7ff fc46    	bl	0x801434a <set_chunk_size> @ imm = #-0x774
; 	set_left_chunk_size(h, chunk0_size, chunk0_size);
 8014abe: 697a         	ldr	r2, [r7, #0x14]
 8014ac0: 6979         	ldr	r1, [r7, #0x14]
 8014ac2: 69f8         	ldr	r0, [r7, #0x1c]
 8014ac4: f7ff fca0    	bl	0x8014408 <set_left_chunk_size> @ imm = #-0x6c0
; 	set_chunk_size(h, heap_sz, 0);
 8014ac8: 2200         	movs	r2, #0x0
 8014aca: 6a39         	ldr	r1, [r7, #0x20]
 8014acc: 69f8         	ldr	r0, [r7, #0x1c]
 8014ace: f7ff fc3c    	bl	0x801434a <set_chunk_size> @ imm = #-0x788
; 	set_left_chunk_size(h, heap_sz, heap_sz - chunk0_size);
 8014ad2: 6a3a         	ldr	r2, [r7, #0x20]
 8014ad4: 697b         	ldr	r3, [r7, #0x14]
 8014ad6: 1ad3         	subs	r3, r2, r3
 8014ad8: 461a         	mov	r2, r3
 8014ada: 6a39         	ldr	r1, [r7, #0x20]
 8014adc: 69f8         	ldr	r0, [r7, #0x1c]
 8014ade: f7ff fc93    	bl	0x8014408 <set_left_chunk_size> @ imm = #-0x6da
; 	set_chunk_used(h, heap_sz, true);
 8014ae2: 2201         	movs	r2, #0x1
 8014ae4: 6a39         	ldr	r1, [r7, #0x20]
 8014ae6: 69f8         	ldr	r0, [r7, #0x1c]
 8014ae8: f7ff fbea    	bl	0x80142c0 <set_chunk_used> @ imm = #-0x82c
; 	free_list_add(h, chunk0_size);
 8014aec: 6979         	ldr	r1, [r7, #0x14]
 8014aee: 69f8         	ldr	r0, [r7, #0x1c]
 8014af0: f7ff fdc9    	bl	0x8014686 <free_list_add> @ imm = #-0x46e
; }
 8014af4: bf00         	nop
 8014af6: 3730         	adds	r7, #0x30
 8014af8: 46bd         	mov	sp, r7
 8014afa: bd80         	pop	{r7, pc}

08014afc <ptr_in_rodata>:
; {
 8014afc: b580         	push	{r7, lr}
 8014afe: b082         	sub	sp, #0x8
 8014b00: af00         	add	r7, sp, #0x0
 8014b02: 6078         	str	r0, [r7, #0x4]
; 	return linker_is_in_rodata(addr);
 8014b04: 6878         	ldr	r0, [r7, #0x4]
 8014b06: f7ee fe87    	bl	0x8003818 <linker_is_in_rodata> @ imm = #-0x112f2
 8014b0a: 4603         	mov	r3, r0
; }
 8014b0c: 4618         	mov	r0, r3
 8014b0e: 3708         	adds	r7, #0x8
 8014b10: 46bd         	mov	sp, r7
 8014b12: bd80         	pop	{r7, pc}

08014b14 <cbprintf_via_va_list>:
; {
 8014b14: b590         	push	{r4, r7, lr}
 8014b16: b087         	sub	sp, #0x1c
 8014b18: af00         	add	r7, sp, #0x0
 8014b1a: 60f8         	str	r0, [r7, #0xc]
 8014b1c: 60b9         	str	r1, [r7, #0x8]
 8014b1e: 607a         	str	r2, [r7, #0x4]
 8014b20: 603b         	str	r3, [r7]
; 	u.ptr = buf;
 8014b22: 6abb         	ldr	r3, [r7, #0x28]
 8014b24: 617b         	str	r3, [r7, #0x14]
; 	return formatter(out, ctx, fmt, u.ap);
 8014b26: 68bc         	ldr	r4, [r7, #0x8]
 8014b28: 697b         	ldr	r3, [r7, #0x14]
 8014b2a: 683a         	ldr	r2, [r7]
 8014b2c: 6879         	ldr	r1, [r7, #0x4]
 8014b2e: 68f8         	ldr	r0, [r7, #0xc]
 8014b30: 47a0         	blx	r4
 8014b32: 4603         	mov	r3, r0
; }
 8014b34: 4618         	mov	r0, r3
 8014b36: 371c         	adds	r7, #0x1c
 8014b38: 46bd         	mov	sp, r7
 8014b3a: bd90         	pop	{r4, r7, pc}

08014b3c <cbpprintf_external>:
; {
 8014b3c: b580         	push	{r7, lr}
 8014b3e: b090         	sub	sp, #0x40
 8014b40: af02         	add	r7, sp, #0x8
 8014b42: 60f8         	str	r0, [r7, #0xc]
 8014b44: 60b9         	str	r1, [r7, #0x8]
 8014b46: 607a         	str	r2, [r7, #0x4]
 8014b48: 603b         	str	r3, [r7]
; 	uint8_t *buf = packaged;
 8014b4a: 683b         	ldr	r3, [r7]
 8014b4c: 62fb         	str	r3, [r7, #0x2c]
; 	struct cbprintf_package_hdr_ext *hdr = packaged;
 8014b4e: 683b         	ldr	r3, [r7]
 8014b50: 62bb         	str	r3, [r7, #0x28]
; 	if (buf == NULL) {
 8014b52: 6afb         	ldr	r3, [r7, #0x2c]
 8014b54: 2b00         	cmp	r3, #0x0
 8014b56: d102         	bne	0x8014b5e <cbpprintf_external+0x22> @ imm = #0x4
; 		return -EINVAL;
 8014b58: f06f 0315    	mvn	r3, #0x15
 8014b5c: e043         	b	0x8014be6 <cbpprintf_external+0xaa> @ imm = #0x86
; 	args_size = hdr->hdr.desc.len * sizeof(int);
 8014b5e: 6abb         	ldr	r3, [r7, #0x28]
 8014b60: 781b         	ldrb	r3, [r3]
 8014b62: 009b         	lsls	r3, r3, #0x2
 8014b64: 627b         	str	r3, [r7, #0x24]
; 	s_nbr     = hdr->hdr.desc.str_cnt;
 8014b66: 6abb         	ldr	r3, [r7, #0x28]
 8014b68: 785b         	ldrb	r3, [r3, #0x1]
 8014b6a: 623b         	str	r3, [r7, #0x20]
; 	ros_nbr   = hdr->hdr.desc.ro_str_cnt;
 8014b6c: 6abb         	ldr	r3, [r7, #0x28]
 8014b6e: 789b         	ldrb	r3, [r3, #0x2]
 8014b70: 61fb         	str	r3, [r7, #0x1c]
; 	rws_nbr   = hdr->hdr.desc.rw_str_cnt;
 8014b72: 6abb         	ldr	r3, [r7, #0x28]
 8014b74: 78db         	ldrb	r3, [r3, #0x3]
 8014b76: 61bb         	str	r3, [r7, #0x18]
; 	s = (char *)(buf + args_size + ros_nbr + 2 * rws_nbr);
 8014b78: 6a7a         	ldr	r2, [r7, #0x24]
 8014b7a: 69fb         	ldr	r3, [r7, #0x1c]
 8014b7c: 441a         	add	r2, r3
 8014b7e: 69bb         	ldr	r3, [r7, #0x18]
 8014b80: 005b         	lsls	r3, r3, #0x1
 8014b82: 4413         	add	r3, r2
 8014b84: 6afa         	ldr	r2, [r7, #0x2c]
 8014b86: 4413         	add	r3, r2
 8014b88: 637b         	str	r3, [r7, #0x34]
; 	for (i = 0; i < s_nbr; i++) {
 8014b8a: 2300         	movs	r3, #0x0
 8014b8c: 633b         	str	r3, [r7, #0x30]
 8014b8e: e018         	b	0x8014bc2 <cbpprintf_external+0x86> @ imm = #0x30
; 		s_idx = *(uint8_t *)s;
 8014b90: 6b7b         	ldr	r3, [r7, #0x34]
 8014b92: 781b         	ldrb	r3, [r3]
 8014b94: 617b         	str	r3, [r7, #0x14]
; 		++s;
 8014b96: 6b7b         	ldr	r3, [r7, #0x34]
 8014b98: 3301         	adds	r3, #0x1
 8014b9a: 637b         	str	r3, [r7, #0x34]
; 		ps = (char **)(buf + s_idx * sizeof(int));
 8014b9c: 697b         	ldr	r3, [r7, #0x14]
 8014b9e: 009b         	lsls	r3, r3, #0x2
 8014ba0: 6afa         	ldr	r2, [r7, #0x2c]
 8014ba2: 4413         	add	r3, r2
 8014ba4: 613b         	str	r3, [r7, #0x10]
; 		*ps = s;
 8014ba6: 693b         	ldr	r3, [r7, #0x10]
 8014ba8: 6b7a         	ldr	r2, [r7, #0x34]
 8014baa: 601a         	str	r2, [r3]
; 		s += strlen(s) + 1;
 8014bac: 6b78         	ldr	r0, [r7, #0x34]
 8014bae: f7eb fe4f    	bl	0x8000850 <strlen>      @ imm = #-0x14362
 8014bb2: 4603         	mov	r3, r0
 8014bb4: 3301         	adds	r3, #0x1
 8014bb6: 6b7a         	ldr	r2, [r7, #0x34]
 8014bb8: 4413         	add	r3, r2
 8014bba: 637b         	str	r3, [r7, #0x34]
; 	for (i = 0; i < s_nbr; i++) {
 8014bbc: 6b3b         	ldr	r3, [r7, #0x30]
 8014bbe: 3301         	adds	r3, #0x1
 8014bc0: 633b         	str	r3, [r7, #0x30]
 8014bc2: 6b3a         	ldr	r2, [r7, #0x30]
 8014bc4: 6a3b         	ldr	r3, [r7, #0x20]
 8014bc6: 429a         	cmp	r2, r3
 8014bc8: d3e2         	blo	0x8014b90 <cbpprintf_external+0x54> @ imm = #-0x3c
; 	buf += sizeof(*hdr);
 8014bca: 6afb         	ldr	r3, [r7, #0x2c]
 8014bcc: 3308         	adds	r3, #0x8
 8014bce: 62fb         	str	r3, [r7, #0x2c]
; 	return cbprintf_via_va_list(out, formatter, ctx, hdr->fmt, buf);
 8014bd0: 6abb         	ldr	r3, [r7, #0x28]
 8014bd2: 685a         	ldr	r2, [r3, #0x4]
 8014bd4: 6afb         	ldr	r3, [r7, #0x2c]
 8014bd6: 9300         	str	r3, [sp]
 8014bd8: 4613         	mov	r3, r2
 8014bda: 687a         	ldr	r2, [r7, #0x4]
 8014bdc: 68b9         	ldr	r1, [r7, #0x8]
 8014bde: 68f8         	ldr	r0, [r7, #0xc]
 8014be0: f7ff ff98    	bl	0x8014b14 <cbprintf_via_va_list> @ imm = #-0xd0
 8014be4: 4603         	mov	r3, r0
; }
 8014be6: 4618         	mov	r0, r3
 8014be8: 3738         	adds	r7, #0x38
 8014bea: 46bd         	mov	sp, r7
 8014bec: bd80         	pop	{r7, pc}

08014bee <arch_printk_char_out>:
; {
 8014bee: b480         	push	{r7}
 8014bf0: b083         	sub	sp, #0xc
 8014bf2: af00         	add	r7, sp, #0x0
 8014bf4: 6078         	str	r0, [r7, #0x4]
; 	return 0;
 8014bf6: 2300         	movs	r3, #0x0
; }
 8014bf8: 4618         	mov	r0, r3
 8014bfa: 370c         	adds	r7, #0xc
 8014bfc: 46bd         	mov	sp, r7
 8014bfe: bc80         	pop	{r7}
 8014c00: 4770         	bx	lr

08014c02 <vprintk>:
; {
 8014c02: b580         	push	{r7, lr}
 8014c04: b08c         	sub	sp, #0x30
 8014c06: af00         	add	r7, sp, #0x0
 8014c08: 6078         	str	r0, [r7, #0x4]
 8014c0a: 6039         	str	r1, [r7]
; 		z_log_vprintk(fmt, ap);
 8014c0c: 6839         	ldr	r1, [r7]
 8014c0e: 6878         	ldr	r0, [r7, #0x4]
 8014c10: f000 f949    	bl	0x8014ea6 <z_log_vprintk> @ imm = #0x292
; 		return;
 8014c14: bf00         	nop
; }
 8014c16: 3730         	adds	r7, #0x30
 8014c18: 46bd         	mov	sp, r7
 8014c1a: bd80         	pop	{r7, pc}

08014c1c <printk>:
; {
 8014c1c: b40f         	push	{r0, r1, r2, r3}
 8014c1e: b580         	push	{r7, lr}
 8014c20: b082         	sub	sp, #0x8
 8014c22: af00         	add	r7, sp, #0x0
; 	va_start(ap, fmt);
 8014c24: f107 0314    	add.w	r3, r7, #0x14
 8014c28: 607b         	str	r3, [r7, #0x4]
; 	vprintk(fmt, ap);
 8014c2a: 6879         	ldr	r1, [r7, #0x4]
 8014c2c: 6938         	ldr	r0, [r7, #0x10]
 8014c2e: f7ff ffe8    	bl	0x8014c02 <vprintk>     @ imm = #-0x30
; }
 8014c32: bf00         	nop
 8014c34: 3708         	adds	r7, #0x8
 8014c36: 46bd         	mov	sp, r7
 8014c38: e8bd 4080    	pop.w	{r7, lr}
 8014c3c: b004         	add	sp, #0x10
 8014c3e: 4770         	bx	lr

08014c40 <k_sched_current_thread_query>:
; {
 8014c40: b580         	push	{r7, lr}
 8014c42: af00         	add	r7, sp, #0x0
; 	return z_impl_k_sched_current_thread_query();
 8014c44: f7fb fc1c    	bl	0x8010480 <z_impl_k_sched_current_thread_query> @ imm = #-0x47c8
 8014c48: 4603         	mov	r3, r0
; }
 8014c4a: 4618         	mov	r0, r3
 8014c4c: bd80         	pop	{r7, pc}

08014c4e <k_thread_abort>:
; {
 8014c4e: b580         	push	{r7, lr}
 8014c50: b082         	sub	sp, #0x8
 8014c52: af00         	add	r7, sp, #0x0
 8014c54: 6078         	str	r0, [r7, #0x4]
; 	z_impl_k_thread_abort(thread);
 8014c56: 6878         	ldr	r0, [r7, #0x4]
 8014c58: f7f1 f828    	bl	0x8005cac <z_impl_k_thread_abort> @ imm = #-0xefb0
; }
 8014c5c: bf00         	nop
 8014c5e: 3708         	adds	r7, #0x8
 8014c60: 46bd         	mov	sp, r7
 8014c62: bd80         	pop	{r7, pc}

08014c64 <_ConfigAbsSyms>:
; GEN_ABS_SYM_BEGIN (_ConfigAbsSyms)
 8014c64: b480         	push	{r7}
 8014c66: af00         	add	r7, sp, #0x0
; GEN_ABS_SYM_END
 8014c68: bf00         	nop
 8014c6a: 46bd         	mov	sp, r7
 8014c6c: bc80         	pop	{r7}
 8014c6e: 4770         	bx	lr

08014c70 <st_stm32_common_config>:
; {
 8014c70: b580         	push	{r7, lr}
 8014c72: af00         	add	r7, sp, #0x0
; 	LL_DBGMCU_DisableDBGStopMode();
 8014c74: f7ef f9fe    	bl	0x8004074 <LL_DBGMCU_DisableDBGStopMode> @ imm = #-0x10c04
; 	return 0;
 8014c78: 2300         	movs	r3, #0x0
; }
 8014c7a: 4618         	mov	r0, r3
 8014c7c: bd80         	pop	{r7, pc}

08014c7e <atomic_add>:
; {
 8014c7e: b490         	push	{r4, r7}
 8014c80: b082         	sub	sp, #0x8
 8014c82: af00         	add	r7, sp, #0x0
 8014c84: 6078         	str	r0, [r7, #0x4]
 8014c86: 6039         	str	r1, [r7]
; 	return __atomic_fetch_add(target, value, __ATOMIC_SEQ_CST);
 8014c88: 683a         	ldr	r2, [r7]
 8014c8a: 687b         	ldr	r3, [r7, #0x4]
 8014c8c: f3bf 8f5b    	dmb	ish
 8014c90: e853 1f00    	ldrex	r1, [r3]
 8014c94: eb01 0002    	add.w	r0, r1, r2
 8014c98: e843 0400    	strex	r4, r0, [r3]
 8014c9c: 2c00         	cmp	r4, #0x0
 8014c9e: d1f7         	bne	0x8014c90 <atomic_add+0x12> @ imm = #-0x12
 8014ca0: f3bf 8f5b    	dmb	ish
 8014ca4: 460b         	mov	r3, r1
; }
 8014ca6: 4618         	mov	r0, r3
 8014ca8: 3708         	adds	r7, #0x8
 8014caa: 46bd         	mov	sp, r7
 8014cac: bc90         	pop	{r4, r7}
 8014cae: 4770         	bx	lr

08014cb0 <atomic_sub>:
; {
 8014cb0: b490         	push	{r4, r7}
 8014cb2: b082         	sub	sp, #0x8
 8014cb4: af00         	add	r7, sp, #0x0
 8014cb6: 6078         	str	r0, [r7, #0x4]
 8014cb8: 6039         	str	r1, [r7]
; 	return __atomic_fetch_sub(target, value, __ATOMIC_SEQ_CST);
 8014cba: 683a         	ldr	r2, [r7]
 8014cbc: 687b         	ldr	r3, [r7, #0x4]
 8014cbe: f3bf 8f5b    	dmb	ish
 8014cc2: e853 1f00    	ldrex	r1, [r3]
 8014cc6: eba1 0002    	sub.w	r0, r1, r2
 8014cca: e843 0400    	strex	r4, r0, [r3]
 8014cce: 2c00         	cmp	r4, #0x0
 8014cd0: d1f7         	bne	0x8014cc2 <atomic_sub+0x12> @ imm = #-0x12
 8014cd2: f3bf 8f5b    	dmb	ish
 8014cd6: 460b         	mov	r3, r1
; }
 8014cd8: 4618         	mov	r0, r3
 8014cda: 3708         	adds	r7, #0x8
 8014cdc: 46bd         	mov	sp, r7
 8014cde: bc90         	pop	{r4, r7}
 8014ce0: 4770         	bx	lr

08014ce2 <atomic_inc>:
; {
 8014ce2: b580         	push	{r7, lr}
 8014ce4: b082         	sub	sp, #0x8
 8014ce6: af00         	add	r7, sp, #0x0
 8014ce8: 6078         	str	r0, [r7, #0x4]
; 	return atomic_add(target, 1);
 8014cea: 2101         	movs	r1, #0x1
 8014cec: 6878         	ldr	r0, [r7, #0x4]
 8014cee: f7ff ffc6    	bl	0x8014c7e <atomic_add>  @ imm = #-0x74
 8014cf2: 4603         	mov	r3, r0
; }
 8014cf4: 4618         	mov	r0, r3
 8014cf6: 3708         	adds	r7, #0x8
 8014cf8: 46bd         	mov	sp, r7
 8014cfa: bd80         	pop	{r7, pc}

08014cfc <atomic_dec>:
; {
 8014cfc: b580         	push	{r7, lr}
 8014cfe: b082         	sub	sp, #0x8
 8014d00: af00         	add	r7, sp, #0x0
 8014d02: 6078         	str	r0, [r7, #0x4]
; 	return atomic_sub(target, 1);
 8014d04: 2101         	movs	r1, #0x1
 8014d06: 6878         	ldr	r0, [r7, #0x4]
 8014d08: f7ff ffd2    	bl	0x8014cb0 <atomic_sub>  @ imm = #-0x5c
 8014d0c: 4603         	mov	r3, r0
; }
 8014d0e: 4618         	mov	r0, r3
 8014d10: 3708         	adds	r7, #0x8
 8014d12: 46bd         	mov	sp, r7
 8014d14: bd80         	pop	{r7, pc}

08014d16 <z_log_item_is_msg>:
; {
 8014d16: b480         	push	{r7}
 8014d18: b083         	sub	sp, #0xc
 8014d1a: af00         	add	r7, sp, #0x0
 8014d1c: 6078         	str	r0, [r7, #0x4]
; 	return msg->generic.type == Z_LOG_MSG_LOG;
 8014d1e: 687b         	ldr	r3, [r7, #0x4]
 8014d20: 781b         	ldrb	r3, [r3]
 8014d22: f003 0304    	and	r3, r3, #0x4
 8014d26: b2db         	uxtb	r3, r3
 8014d28: 2b00         	cmp	r3, #0x0
 8014d2a: bf0c         	ite	eq
 8014d2c: 2301         	moveq	r3, #0x1
 8014d2e: 2300         	movne	r3, #0x0
 8014d30: b2db         	uxtb	r3, r3
; }
 8014d32: 4618         	mov	r0, r3
 8014d34: 370c         	adds	r7, #0xc
 8014d36: 46bd         	mov	sp, r7
 8014d38: bc80         	pop	{r7}
 8014d3a: 4770         	bx	lr

08014d3c <k_msleep>:
; {
 8014d3c: e92d 4fb0    	push.w	{r4, r5, r7, r8, r9, r10, r11, lr}
 8014d40: b082         	sub	sp, #0x8
 8014d42: af00         	add	r7, sp, #0x0
 8014d44: 6078         	str	r0, [r7, #0x4]
; 	return k_sleep(Z_TIMEOUT_MS(ms));
 8014d46: 6879         	ldr	r1, [r7, #0x4]
 8014d48: ea21 71e1    	bic.w	r1, r1, r1, asr #31
 8014d4c: 17c8         	asrs	r0, r1, #0x1f
 8014d4e: 4688         	mov	r8, r1
 8014d50: 4681         	mov	r9, r0
 8014d52: 4640         	mov	r0, r8
 8014d54: 4649         	mov	r1, r9
 8014d56: f04f 0400    	mov.w	r4, #0x0
 8014d5a: f04f 0500    	mov.w	r5, #0x0
 8014d5e: 008d         	lsls	r5, r1, #0x2
 8014d60: ea45 7590    	orr.w	r5, r5, r0, lsr #30
 8014d64: 0084         	lsls	r4, r0, #0x2
 8014d66: 4620         	mov	r0, r4
 8014d68: 4629         	mov	r1, r5
 8014d6a: eb10 0208    	adds.w	r2, r0, r8
 8014d6e: eb41 0309    	adc.w	r3, r1, r9
 8014d72: eb12 0a02    	adds.w	r10, r2, r2
 8014d76: eb43 0b03    	adc.w	r11, r3, r3
 8014d7a: 4652         	mov	r2, r10
 8014d7c: 465b         	mov	r3, r11
 8014d7e: 4610         	mov	r0, r2
 8014d80: 4619         	mov	r1, r3
 8014d82: f000 f823    	bl	0x8014dcc <k_sleep>     @ imm = #0x46
 8014d86: 4601         	mov	r1, r0
 8014d88: 460b         	mov	r3, r1
; }
 8014d8a: 4618         	mov	r0, r3
 8014d8c: 3708         	adds	r7, #0x8
 8014d8e: 46bd         	mov	sp, r7
 8014d90: e8bd 8fb0    	pop.w	{r4, r5, r7, r8, r9, r10, r11, pc}

08014d94 <k_uptime_get>:
; {
 8014d94: b580         	push	{r7, lr}
 8014d96: af00         	add	r7, sp, #0x0
; 	return k_ticks_to_ms_floor64(k_uptime_ticks());
 8014d98: f000 f826    	bl	0x8014de8 <k_uptime_ticks> @ imm = #0x4c
 8014d9c: 4602         	mov	r2, r0
 8014d9e: 460b         	mov	r3, r1
 8014da0: 4610         	mov	r0, r2
 8014da2: 4619         	mov	r1, r3
 8014da4: f04f 020a    	mov.w	r2, #0xa
 8014da8: f04f 0300    	mov.w	r3, #0x0
 8014dac: f7eb fd36    	bl	0x800081c <__aeabi_uldivmod> @ imm = #-0x14594
 8014db0: 4602         	mov	r2, r0
 8014db2: 460b         	mov	r3, r1
; }
 8014db4: 4610         	mov	r0, r2
 8014db6: 4619         	mov	r1, r3
 8014db8: bd80         	pop	{r7, pc}

08014dba <k_uptime_get_32>:
; {
 8014dba: b580         	push	{r7, lr}
 8014dbc: af00         	add	r7, sp, #0x0
; 	return (uint32_t)k_uptime_get();
 8014dbe: f7ff ffe9    	bl	0x8014d94 <k_uptime_get> @ imm = #-0x2e
 8014dc2: 4602         	mov	r2, r0
 8014dc4: 460b         	mov	r3, r1
 8014dc6: 4613         	mov	r3, r2
; }
 8014dc8: 4618         	mov	r0, r3
 8014dca: bd80         	pop	{r7, pc}

08014dcc <k_sleep>:
; {
 8014dcc: b580         	push	{r7, lr}
 8014dce: b082         	sub	sp, #0x8
 8014dd0: af00         	add	r7, sp, #0x0
 8014dd2: e9c7 0100    	strd	r0, r1, [r7]
; 	return z_impl_k_sleep(timeout);
 8014dd6: e9d7 0100    	ldrd	r0, r1, [r7]
 8014dda: f7fb fb0f    	bl	0x80103fc <z_impl_k_sleep> @ imm = #-0x49e2
 8014dde: 4603         	mov	r3, r0
; }
 8014de0: 4618         	mov	r0, r3
 8014de2: 3708         	adds	r7, #0x8
 8014de4: 46bd         	mov	sp, r7
 8014de6: bd80         	pop	{r7, pc}

08014de8 <k_uptime_ticks>:
; {
 8014de8: b580         	push	{r7, lr}
 8014dea: af00         	add	r7, sp, #0x0
; 	return z_impl_k_uptime_ticks();
 8014dec: f008 fc84    	bl	0x801d6f8 <z_impl_k_uptime_ticks> @ imm = #0x8908
 8014df0: 4602         	mov	r2, r0
 8014df2: 460b         	mov	r3, r1
; }
 8014df4: 4610         	mov	r0, r2
 8014df6: 4619         	mov	r1, r3
 8014df8: bd80         	pop	{r7, pc}

08014dfa <log_backend_init>:
; {
 8014dfa: b580         	push	{r7, lr}
 8014dfc: b082         	sub	sp, #0x8
 8014dfe: af00         	add	r7, sp, #0x0
 8014e00: 6078         	str	r0, [r7, #0x4]
; 	if (backend->api->init) {
 8014e02: 687b         	ldr	r3, [r7, #0x4]
 8014e04: 681b         	ldr	r3, [r3]
 8014e06: 68db         	ldr	r3, [r3, #0xc]
 8014e08: 2b00         	cmp	r3, #0x0
 8014e0a: d004         	beq	0x8014e16 <log_backend_init+0x1c> @ imm = #0x8
; 		backend->api->init(backend);
 8014e0c: 687b         	ldr	r3, [r7, #0x4]
 8014e0e: 681b         	ldr	r3, [r3]
 8014e10: 68db         	ldr	r3, [r3, #0xc]
 8014e12: 6878         	ldr	r0, [r7, #0x4]
 8014e14: 4798         	blx	r3
; }
 8014e16: bf00         	nop
 8014e18: 3708         	adds	r7, #0x8
 8014e1a: 46bd         	mov	sp, r7
 8014e1c: bd80         	pop	{r7, pc}

08014e1e <log_backend_is_ready>:
; {
 8014e1e: b580         	push	{r7, lr}
 8014e20: b082         	sub	sp, #0x8
 8014e22: af00         	add	r7, sp, #0x0
 8014e24: 6078         	str	r0, [r7, #0x4]
; 	if (backend->api->is_ready != NULL) {
 8014e26: 687b         	ldr	r3, [r7, #0x4]
 8014e28: 681b         	ldr	r3, [r3]
 8014e2a: 691b         	ldr	r3, [r3, #0x10]
 8014e2c: 2b00         	cmp	r3, #0x0
 8014e2e: d006         	beq	0x8014e3e <log_backend_is_ready+0x20> @ imm = #0xc
; 		return backend->api->is_ready(backend);
 8014e30: 687b         	ldr	r3, [r7, #0x4]
 8014e32: 681b         	ldr	r3, [r3]
 8014e34: 691b         	ldr	r3, [r3, #0x10]
 8014e36: 6878         	ldr	r0, [r7, #0x4]
 8014e38: 4798         	blx	r3
 8014e3a: 4603         	mov	r3, r0
 8014e3c: e000         	b	0x8014e40 <log_backend_is_ready+0x22> @ imm = #0x0
; 	return 0;
 8014e3e: 2300         	movs	r3, #0x0
; }
 8014e40: 4618         	mov	r0, r3
 8014e42: 3708         	adds	r7, #0x8
 8014e44: 46bd         	mov	sp, r7
 8014e46: bd80         	pop	{r7, pc}

08014e48 <log_backend_msg_process>:
; {
 8014e48: b580         	push	{r7, lr}
 8014e4a: b082         	sub	sp, #0x8
 8014e4c: af00         	add	r7, sp, #0x0
 8014e4e: 6078         	str	r0, [r7, #0x4]
 8014e50: 6039         	str	r1, [r7]
; 	backend->api->process(backend, msg);
 8014e52: 687b         	ldr	r3, [r7, #0x4]
 8014e54: 681b         	ldr	r3, [r3]
 8014e56: 681b         	ldr	r3, [r3]
 8014e58: 6839         	ldr	r1, [r7]
 8014e5a: 6878         	ldr	r0, [r7, #0x4]
 8014e5c: 4798         	blx	r3
; }
 8014e5e: bf00         	nop
 8014e60: 3708         	adds	r7, #0x8
 8014e62: 46bd         	mov	sp, r7
 8014e64: bd80         	pop	{r7, pc}

08014e66 <log_backend_panic>:
; {
 8014e66: b580         	push	{r7, lr}
 8014e68: b082         	sub	sp, #0x8
 8014e6a: af00         	add	r7, sp, #0x0
 8014e6c: 6078         	str	r0, [r7, #0x4]
; 	backend->api->panic(backend);
 8014e6e: 687b         	ldr	r3, [r7, #0x4]
 8014e70: 681b         	ldr	r3, [r3]
 8014e72: 689b         	ldr	r3, [r3, #0x8]
 8014e74: 6878         	ldr	r0, [r7, #0x4]
 8014e76: 4798         	blx	r3
; }
 8014e78: bf00         	nop
 8014e7a: 3708         	adds	r7, #0x8
 8014e7c: 46bd         	mov	sp, r7
 8014e7e: bd80         	pop	{r7, pc}

08014e80 <log_backend_is_active>:
; {
 8014e80: b480         	push	{r7}
 8014e82: b083         	sub	sp, #0xc
 8014e84: af00         	add	r7, sp, #0x0
 8014e86: 6078         	str	r0, [r7, #0x4]
; 	return backend->cb->active;
 8014e88: 687b         	ldr	r3, [r7, #0x4]
 8014e8a: 685b         	ldr	r3, [r3, #0x4]
 8014e8c: 795b         	ldrb	r3, [r3, #0x5]
; }
 8014e8e: 4618         	mov	r0, r3
 8014e90: 370c         	adds	r7, #0xc
 8014e92: 46bd         	mov	sp, r7
 8014e94: bc80         	pop	{r7}
 8014e96: 4770         	bx	lr

08014e98 <dummy_timestamp>:
; {
 8014e98: b480         	push	{r7}
 8014e9a: af00         	add	r7, sp, #0x0
; 	return 0;
 8014e9c: 2300         	movs	r3, #0x0
; }
 8014e9e: 4618         	mov	r0, r3
 8014ea0: 46bd         	mov	sp, r7
 8014ea2: bc80         	pop	{r7}
 8014ea4: 4770         	bx	lr

08014ea6 <z_log_vprintk>:
; {
 8014ea6: b580         	push	{r7, lr}
 8014ea8: b086         	sub	sp, #0x18
 8014eaa: af04         	add	r7, sp, #0x10
 8014eac: 6078         	str	r0, [r7, #0x4]
 8014eae: 6039         	str	r1, [r7]
; 	z_log_msg_runtime_vcreate(Z_LOG_LOCAL_DOMAIN_ID, NULL,
 8014eb0: 683b         	ldr	r3, [r7]
 8014eb2: 9303         	str	r3, [sp, #0xc]
 8014eb4: 687b         	ldr	r3, [r7, #0x4]
 8014eb6: 9302         	str	r3, [sp, #0x8]
 8014eb8: 2300         	movs	r3, #0x0
 8014eba: 9301         	str	r3, [sp, #0x4]
 8014ebc: 2300         	movs	r3, #0x0
 8014ebe: 9300         	str	r3, [sp]
 8014ec0: 2300         	movs	r3, #0x0
 8014ec2: 2200         	movs	r2, #0x0
 8014ec4: 2100         	movs	r1, #0x0
 8014ec6: 2000         	movs	r0, #0x0
 8014ec8: f7ef fb52    	bl	0x8004570 <z_log_msg_runtime_vcreate> @ imm = #-0x1095c
; }
 8014ecc: 3708         	adds	r7, #0x8
 8014ece: 46bd         	mov	sp, r7
 8014ed0: bd80         	pop	{r7, pc}

08014ed2 <default_lf_get_timestamp>:
; {
 8014ed2: b580         	push	{r7, lr}
 8014ed4: af00         	add	r7, sp, #0x0
; 		k_uptime_get() : k_uptime_get_32();
 8014ed6: f7ff ff70    	bl	0x8014dba <k_uptime_get_32> @ imm = #-0x120
 8014eda: 4603         	mov	r3, r0
; }
 8014edc: 4618         	mov	r0, r3
 8014ede: bd80         	pop	{r7, pc}

08014ee0 <activate_foreach_backend>:
; {
 8014ee0: b580         	push	{r7, lr}
 8014ee2: b086         	sub	sp, #0x18
 8014ee4: af00         	add	r7, sp, #0x0
 8014ee6: 6078         	str	r0, [r7, #0x4]
; 	uint32_t mask_cpy = mask;
 8014ee8: 687b         	ldr	r3, [r7, #0x4]
 8014eea: 617b         	str	r3, [r7, #0x14]
; 	while (mask_cpy) {
 8014eec: e02b         	b	0x8014f46 <activate_foreach_backend+0x66> @ imm = #0x56
; 		uint32_t i = __builtin_ctz(mask_cpy);
 8014eee: 697b         	ldr	r3, [r7, #0x14]
 8014ef0: fa93 f3a3    	rbit	r3, r3
 8014ef4: fab3 f383    	clz	r3, r3
 8014ef8: 613b         	str	r3, [r7, #0x10]
; 		const struct log_backend *backend = log_backend_get(i);
 8014efa: 6938         	ldr	r0, [r7, #0x10]
 8014efc: f7ef f904    	bl	0x8004108 <log_backend_get> @ imm = #-0x10df8
 8014f00: 60f8         	str	r0, [r7, #0xc]
; 		mask_cpy &= ~BIT(i);
 8014f02: 2201         	movs	r2, #0x1
 8014f04: 693b         	ldr	r3, [r7, #0x10]
 8014f06: fa02 f303    	lsl.w	r3, r2, r3
 8014f0a: 43db         	mvns	r3, r3
 8014f0c: 697a         	ldr	r2, [r7, #0x14]
 8014f0e: 4013         	ands	r3, r2
 8014f10: 617b         	str	r3, [r7, #0x14]
; 		if (backend->autostart && (log_backend_is_ready(backend) == 0)) {
 8014f12: 68fb         	ldr	r3, [r7, #0xc]
 8014f14: 7b1b         	ldrb	r3, [r3, #0xc]
 8014f16: 2b00         	cmp	r3, #0x0
 8014f18: d015         	beq	0x8014f46 <activate_foreach_backend+0x66> @ imm = #0x2a
 8014f1a: 68f8         	ldr	r0, [r7, #0xc]
 8014f1c: f7ff ff7f    	bl	0x8014e1e <log_backend_is_ready> @ imm = #-0x102
 8014f20: 4603         	mov	r3, r0
 8014f22: 2b00         	cmp	r3, #0x0
 8014f24: d10f         	bne	0x8014f46 <activate_foreach_backend+0x66> @ imm = #0x1e
; 			mask &= ~BIT(i);
 8014f26: 2201         	movs	r2, #0x1
 8014f28: 693b         	ldr	r3, [r7, #0x10]
 8014f2a: fa02 f303    	lsl.w	r3, r2, r3
 8014f2e: 43db         	mvns	r3, r3
 8014f30: 687a         	ldr	r2, [r7, #0x4]
 8014f32: 4013         	ands	r3, r2
 8014f34: 607b         	str	r3, [r7, #0x4]
; 					   backend->cb->ctx,
 8014f36: 68fb         	ldr	r3, [r7, #0xc]
 8014f38: 685b         	ldr	r3, [r3, #0x4]
; 			log_backend_enable(backend,
 8014f3a: 681b         	ldr	r3, [r3]
 8014f3c: 2204         	movs	r2, #0x4
 8014f3e: 4619         	mov	r1, r3
 8014f40: 68f8         	ldr	r0, [r7, #0xc]
 8014f42: f000 f8c8    	bl	0x80150d6 <log_backend_enable> @ imm = #0x190
; 	while (mask_cpy) {
 8014f46: 697b         	ldr	r3, [r7, #0x14]
 8014f48: 2b00         	cmp	r3, #0x0
 8014f4a: d1d0         	bne	0x8014eee <activate_foreach_backend+0xe> @ imm = #-0x60
; 	return mask;
 8014f4c: 687b         	ldr	r3, [r7, #0x4]
; }
 8014f4e: 4618         	mov	r0, r3
 8014f50: 3718         	adds	r7, #0x18
 8014f52: 46bd         	mov	sp, r7
 8014f54: bd80         	pop	{r7, pc}

08014f56 <msg_filter_check>:
; {
 8014f56: b580         	push	{r7, lr}
 8014f58: b082         	sub	sp, #0x8
 8014f5a: af00         	add	r7, sp, #0x0
 8014f5c: 6078         	str	r0, [r7, #0x4]
 8014f5e: 6039         	str	r1, [r7]
; 	if (!z_log_item_is_msg(msg)) {
 8014f60: 6838         	ldr	r0, [r7]
 8014f62: f7ff fed8    	bl	0x8014d16 <z_log_item_is_msg> @ imm = #-0x250
 8014f66: 4603         	mov	r3, r0
 8014f68: f083 0301    	eor	r3, r3, #0x1
 8014f6c: b2db         	uxtb	r3, r3
 8014f6e: 2b00         	cmp	r3, #0x0
 8014f70: d001         	beq	0x8014f76 <msg_filter_check+0x20> @ imm = #0x2
; 		return true;
 8014f72: 2301         	movs	r3, #0x1
 8014f74: e000         	b	0x8014f78 <msg_filter_check+0x22> @ imm = #0x0
; 		return true;
 8014f76: 2301         	movs	r3, #0x1
; }
 8014f78: 4618         	mov	r0, r3
 8014f7a: 3708         	adds	r7, #0x8
 8014f7c: 46bd         	mov	sp, r7
 8014f7e: bd80         	pop	{r7, pc}

08014f80 <msg_commit>:
; {
 8014f80: b580         	push	{r7, lr}
 8014f82: b084         	sub	sp, #0x10
 8014f84: af00         	add	r7, sp, #0x0
 8014f86: 6078         	str	r0, [r7, #0x4]
 8014f88: 6039         	str	r1, [r7]
; 	union log_msg_generic *m = (union log_msg_generic *)msg;
 8014f8a: 683b         	ldr	r3, [r7]
 8014f8c: 60fb         	str	r3, [r7, #0xc]
; 		msg_process(m);
 8014f8e: 68f8         	ldr	r0, [r7, #0xc]
 8014f90: f7ef f9a6    	bl	0x80042e0 <msg_process> @ imm = #-0x10cb4
; }
 8014f94: 3710         	adds	r7, #0x10
 8014f96: 46bd         	mov	sp, r7
 8014f98: bd80         	pop	{r7, pc}

08014f9a <z_log_get_tag>:
; {
 8014f9a: b480         	push	{r7}
 8014f9c: af00         	add	r7, sp, #0x0
; 	return CONFIG_LOG_TAG_MAX_LEN > 0 ? tag : NULL;
 8014f9e: 2300         	movs	r3, #0x0
; }
 8014fa0: 4618         	mov	r0, r3
 8014fa2: 46bd         	mov	sp, r7
 8014fa4: bc80         	pop	{r7}
 8014fa6: 4770         	bx	lr

08014fa8 <enable_logger>:
; {
 8014fa8: b580         	push	{r7, lr}
 8014faa: af00         	add	r7, sp, #0x0
; 		(void)z_log_init(false, false);
 8014fac: 2100         	movs	r1, #0x0
 8014fae: 2000         	movs	r0, #0x0
 8014fb0: f7ef f8e6    	bl	0x8004180 <z_log_init>  @ imm = #-0x10e34
; 	return 0;
 8014fb4: 2300         	movs	r3, #0x0
; }
 8014fb6: 4618         	mov	r0, r3
 8014fb8: bd80         	pop	{r7, pc}

08014fba <z_log_is_local_domain>:
; {
 8014fba: b480         	push	{r7}
 8014fbc: b083         	sub	sp, #0xc
 8014fbe: af00         	add	r7, sp, #0x0
 8014fc0: 4603         	mov	r3, r0
 8014fc2: 71fb         	strb	r3, [r7, #0x7]
; 	return !IS_ENABLED(CONFIG_LOG_MULTIDOMAIN) ||
 8014fc4: 2301         	movs	r3, #0x1
; }
 8014fc6: 4618         	mov	r0, r3
 8014fc8: 370c         	adds	r7, #0xc
 8014fca: 46bd         	mov	sp, r7
 8014fcc: bc80         	pop	{r7}
 8014fce: 4770         	bx	lr

08014fd0 <log_backend_id_set>:
; {
 8014fd0: b480         	push	{r7}
 8014fd2: b083         	sub	sp, #0xc
 8014fd4: af00         	add	r7, sp, #0x0
 8014fd6: 6078         	str	r0, [r7, #0x4]
 8014fd8: 460b         	mov	r3, r1
 8014fda: 70fb         	strb	r3, [r7, #0x3]
; 	backend->cb->id = id;
 8014fdc: 687b         	ldr	r3, [r7, #0x4]
 8014fde: 685b         	ldr	r3, [r3, #0x4]
 8014fe0: 78fa         	ldrb	r2, [r7, #0x3]
 8014fe2: 711a         	strb	r2, [r3, #0x4]
; }
 8014fe4: bf00         	nop
 8014fe6: 370c         	adds	r7, #0xc
 8014fe8: 46bd         	mov	sp, r7
 8014fea: bc80         	pop	{r7}
 8014fec: 4770         	bx	lr

08014fee <log_backend_activate>:
; {
 8014fee: b480         	push	{r7}
 8014ff0: b083         	sub	sp, #0xc
 8014ff2: af00         	add	r7, sp, #0x0
 8014ff4: 6078         	str	r0, [r7, #0x4]
 8014ff6: 6039         	str	r1, [r7]
; 	backend->cb->ctx = ctx;
 8014ff8: 687b         	ldr	r3, [r7, #0x4]
 8014ffa: 685b         	ldr	r3, [r3, #0x4]
 8014ffc: 683a         	ldr	r2, [r7]
 8014ffe: 601a         	str	r2, [r3]
; 	backend->cb->active = true;
 8015000: 687b         	ldr	r3, [r7, #0x4]
 8015002: 685b         	ldr	r3, [r3, #0x4]
 8015004: 2201         	movs	r2, #0x1
 8015006: 715a         	strb	r2, [r3, #0x5]
; }
 8015008: bf00         	nop
 801500a: 370c         	adds	r7, #0xc
 801500c: 46bd         	mov	sp, r7
 801500e: bc80         	pop	{r7}
 8015010: 4770         	bx	lr

08015012 <log_link_sources_count>:
; {
 8015012: b480         	push	{r7}
 8015014: b083         	sub	sp, #0xc
 8015016: af00         	add	r7, sp, #0x0
 8015018: 6078         	str	r0, [r7, #0x4]
 801501a: 6039         	str	r1, [r7]
; 	return link->ctrl_blk->source_cnt[domain_id];
 801501c: 687b         	ldr	r3, [r7, #0x4]
 801501e: 689a         	ldr	r2, [r3, #0x8]
 8015020: 683b         	ldr	r3, [r7]
 8015022: 005b         	lsls	r3, r3, #0x1
 8015024: 4413         	add	r3, r2
 8015026: 889b         	ldrh	r3, [r3, #0x4]
; }
 8015028: 4618         	mov	r0, r3
 801502a: 370c         	adds	r7, #0xc
 801502c: 46bd         	mov	sp, r7
 801502e: bc80         	pop	{r7}
 8015030: 4770         	bx	lr

08015032 <log_link_get_source_name>:
; {
 8015032: b590         	push	{r4, r7, lr}
 8015034: b087         	sub	sp, #0x1c
 8015036: af02         	add	r7, sp, #0x8
 8015038: 60f8         	str	r0, [r7, #0xc]
 801503a: 60b9         	str	r1, [r7, #0x8]
 801503c: 603b         	str	r3, [r7]
 801503e: 4613         	mov	r3, r2
 8015040: 80fb         	strh	r3, [r7, #0x6]
; 	return link->api->get_source_name(link, domain_id, source_id,
 8015042: 68fb         	ldr	r3, [r7, #0xc]
 8015044: 681b         	ldr	r3, [r3]
 8015046: 68dc         	ldr	r4, [r3, #0xc]
 8015048: 88fa         	ldrh	r2, [r7, #0x6]
 801504a: 6a3b         	ldr	r3, [r7, #0x20]
 801504c: 9300         	str	r3, [sp]
 801504e: 683b         	ldr	r3, [r7]
 8015050: 68b9         	ldr	r1, [r7, #0x8]
 8015052: 68f8         	ldr	r0, [r7, #0xc]
 8015054: 47a0         	blx	r4
 8015056: 4603         	mov	r3, r0
; }
 8015058: 4618         	mov	r0, r3
 801505a: 3714         	adds	r7, #0x14
 801505c: 46bd         	mov	sp, r7
 801505e: bd90         	pop	{r4, r7, pc}

08015060 <link_source_count>:
; {
 8015060: b580         	push	{r7, lr}
 8015062: b084         	sub	sp, #0x10
 8015064: af00         	add	r7, sp, #0x0
 8015066: 4603         	mov	r3, r0
 8015068: 71fb         	strb	r3, [r7, #0x7]
; 	const struct log_link *link = get_link_domain(domain_id, &rel_domain_id);
 801506a: f107 020b    	add.w	r2, r7, #0xb
 801506e: 79fb         	ldrb	r3, [r7, #0x7]
 8015070: 4611         	mov	r1, r2
 8015072: 4618         	mov	r0, r3
 8015074: f7ef f9c6    	bl	0x8004404 <get_link_domain> @ imm = #-0x10c74
 8015078: 60f8         	str	r0, [r7, #0xc]
; 	return log_link_sources_count(link, rel_domain_id);
 801507a: 7afb         	ldrb	r3, [r7, #0xb]
 801507c: 4619         	mov	r1, r3
 801507e: 68f8         	ldr	r0, [r7, #0xc]
 8015080: f7ff ffc7    	bl	0x8015012 <log_link_sources_count> @ imm = #-0x72
 8015084: 4603         	mov	r3, r0
; }
 8015086: 4618         	mov	r0, r3
 8015088: 3710         	adds	r7, #0x10
 801508a: 46bd         	mov	sp, r7
 801508c: bd80         	pop	{r7, pc}

0801508e <log_src_cnt_get>:
; {
 801508e: b580         	push	{r7, lr}
 8015090: b082         	sub	sp, #0x8
 8015092: af00         	add	r7, sp, #0x0
 8015094: 6078         	str	r0, [r7, #0x4]
; 	if (z_log_is_local_domain(domain_id)) {
 8015096: 687b         	ldr	r3, [r7, #0x4]
 8015098: b2db         	uxtb	r3, r3
 801509a: 4618         	mov	r0, r3
 801509c: f7ff ff8d    	bl	0x8014fba <z_log_is_local_domain> @ imm = #-0xe6
 80150a0: 4603         	mov	r3, r0
 80150a2: 2b00         	cmp	r3, #0x0
 80150a4: d003         	beq	0x80150ae <log_src_cnt_get+0x20> @ imm = #0x6
; 		return z_log_sources_count();
 80150a6: f7ef f991    	bl	0x80043cc <z_log_sources_count> @ imm = #-0x10cde
 80150aa: 4603         	mov	r3, r0
 80150ac: e005         	b	0x80150ba <log_src_cnt_get+0x2c> @ imm = #0xa
; 	return link_source_count(domain_id);
 80150ae: 687b         	ldr	r3, [r7, #0x4]
 80150b0: b2db         	uxtb	r3, r3
 80150b2: 4618         	mov	r0, r3
 80150b4: f7ff ffd4    	bl	0x8015060 <link_source_count> @ imm = #-0x58
 80150b8: 4603         	mov	r3, r0
; }
 80150ba: 4618         	mov	r0, r3
 80150bc: 3708         	adds	r7, #0x8
 80150be: 46bd         	mov	sp, r7
 80150c0: bd80         	pop	{r7, pc}

080150c2 <backend_filter_set>:
; {
 80150c2: b480         	push	{r7}
 80150c4: b083         	sub	sp, #0xc
 80150c6: af00         	add	r7, sp, #0x0
 80150c8: 6078         	str	r0, [r7, #0x4]
 80150ca: 6039         	str	r1, [r7]
; 		return;
 80150cc: bf00         	nop
; }
 80150ce: 370c         	adds	r7, #0xc
 80150d0: 46bd         	mov	sp, r7
 80150d2: bc80         	pop	{r7}
 80150d4: 4770         	bx	lr

080150d6 <log_backend_enable>:
; {
 80150d6: b580         	push	{r7, lr}
 80150d8: b086         	sub	sp, #0x18
 80150da: af00         	add	r7, sp, #0x0
 80150dc: 60f8         	str	r0, [r7, #0xc]
 80150de: 60b9         	str	r1, [r7, #0x8]
 80150e0: 607a         	str	r2, [r7, #0x4]
; 	uint32_t id = LOG_FILTER_FIRST_BACKEND_SLOT_IDX;
 80150e2: 2301         	movs	r3, #0x1
 80150e4: 617b         	str	r3, [r7, #0x14]
; 	id += backend - log_backend_get(0);
 80150e6: 2000         	movs	r0, #0x0
 80150e8: f7ef f97a    	bl	0x80043e0 <log_backend_get> @ imm = #-0x10d0c
 80150ec: 4602         	mov	r2, r0
 80150ee: 68fb         	ldr	r3, [r7, #0xc]
 80150f0: 1a9b         	subs	r3, r3, r2
 80150f2: 111b         	asrs	r3, r3, #0x4
 80150f4: 461a         	mov	r2, r3
 80150f6: 697b         	ldr	r3, [r7, #0x14]
 80150f8: 4413         	add	r3, r2
 80150fa: 617b         	str	r3, [r7, #0x14]
; 	log_backend_id_set(backend, id);
 80150fc: 697b         	ldr	r3, [r7, #0x14]
 80150fe: b2db         	uxtb	r3, r3
 8015100: 4619         	mov	r1, r3
 8015102: 68f8         	ldr	r0, [r7, #0xc]
 8015104: f7ff ff64    	bl	0x8014fd0 <log_backend_id_set> @ imm = #-0x138
; 	backend->cb->level = level;
 8015108: 68fb         	ldr	r3, [r7, #0xc]
 801510a: 685b         	ldr	r3, [r3, #0x4]
 801510c: 687a         	ldr	r2, [r7, #0x4]
 801510e: b2d2         	uxtb	r2, r2
 8015110: 719a         	strb	r2, [r3, #0x6]
; 	backend_filter_set(backend, level);
 8015112: 6879         	ldr	r1, [r7, #0x4]
 8015114: 68f8         	ldr	r0, [r7, #0xc]
 8015116: f7ff ffd4    	bl	0x80150c2 <backend_filter_set> @ imm = #-0x58
; 	log_backend_activate(backend, ctx);
 801511a: 68b9         	ldr	r1, [r7, #0x8]
 801511c: 68f8         	ldr	r0, [r7, #0xc]
 801511e: f7ff ff66    	bl	0x8014fee <log_backend_activate> @ imm = #-0x134
; 	z_log_notify_backend_enabled();
 8015122: f7ef f90b    	bl	0x800433c <z_log_notify_backend_enabled> @ imm = #-0x10dea
; }
 8015126: bf00         	nop
 8015128: 3718         	adds	r7, #0x18
 801512a: 46bd         	mov	sp, r7
 801512c: bd80         	pop	{r7, pc}

0801512e <z_snode_next_peek>:
; {
 801512e: b480         	push	{r7}
 8015130: b083         	sub	sp, #0xc
 8015132: af00         	add	r7, sp, #0x0
 8015134: 6078         	str	r0, [r7, #0x4]
; 	return node->next;
 8015136: 687b         	ldr	r3, [r7, #0x4]
 8015138: 681b         	ldr	r3, [r3]
; }
 801513a: 4618         	mov	r0, r3
 801513c: 370c         	adds	r7, #0xc
 801513e: 46bd         	mov	sp, r7
 8015140: bc80         	pop	{r7}
 8015142: 4770         	bx	lr

08015144 <z_snode_next_set>:
; {
 8015144: b480         	push	{r7}
 8015146: b083         	sub	sp, #0xc
 8015148: af00         	add	r7, sp, #0x0
 801514a: 6078         	str	r0, [r7, #0x4]
 801514c: 6039         	str	r1, [r7]
; 	parent->next = child;
 801514e: 687b         	ldr	r3, [r7, #0x4]
 8015150: 683a         	ldr	r2, [r7]
 8015152: 601a         	str	r2, [r3]
; }
 8015154: bf00         	nop
 8015156: 370c         	adds	r7, #0xc
 8015158: 46bd         	mov	sp, r7
 801515a: bc80         	pop	{r7}
 801515c: 4770         	bx	lr

0801515e <z_slist_head_set>:
; {
 801515e: b480         	push	{r7}
 8015160: b083         	sub	sp, #0xc
 8015162: af00         	add	r7, sp, #0x0
 8015164: 6078         	str	r0, [r7, #0x4]
 8015166: 6039         	str	r1, [r7]
; 	list->head = node;
 8015168: 687b         	ldr	r3, [r7, #0x4]
 801516a: 683a         	ldr	r2, [r7]
 801516c: 601a         	str	r2, [r3]
; }
 801516e: bf00         	nop
 8015170: 370c         	adds	r7, #0xc
 8015172: 46bd         	mov	sp, r7
 8015174: bc80         	pop	{r7}
 8015176: 4770         	bx	lr

08015178 <z_slist_tail_set>:
; {
 8015178: b480         	push	{r7}
 801517a: b083         	sub	sp, #0xc
 801517c: af00         	add	r7, sp, #0x0
 801517e: 6078         	str	r0, [r7, #0x4]
 8015180: 6039         	str	r1, [r7]
; 	list->tail = node;
 8015182: 687b         	ldr	r3, [r7, #0x4]
 8015184: 683a         	ldr	r2, [r7]
 8015186: 605a         	str	r2, [r3, #0x4]
; }
 8015188: bf00         	nop
 801518a: 370c         	adds	r7, #0xc
 801518c: 46bd         	mov	sp, r7
 801518e: bc80         	pop	{r7}
 8015190: 4770         	bx	lr

08015192 <sys_slist_peek_head>:
; {
 8015192: b480         	push	{r7}
 8015194: b083         	sub	sp, #0xc
 8015196: af00         	add	r7, sp, #0x0
 8015198: 6078         	str	r0, [r7, #0x4]
; 	return list->head;
 801519a: 687b         	ldr	r3, [r7, #0x4]
 801519c: 681b         	ldr	r3, [r3]
; }
 801519e: 4618         	mov	r0, r3
 80151a0: 370c         	adds	r7, #0xc
 80151a2: 46bd         	mov	sp, r7
 80151a4: bc80         	pop	{r7}
 80151a6: 4770         	bx	lr

080151a8 <sys_slist_peek_tail>:
; {
 80151a8: b480         	push	{r7}
 80151aa: b083         	sub	sp, #0xc
 80151ac: af00         	add	r7, sp, #0x0
 80151ae: 6078         	str	r0, [r7, #0x4]
; 	return list->tail;
 80151b0: 687b         	ldr	r3, [r7, #0x4]
 80151b2: 685b         	ldr	r3, [r3, #0x4]
; }
 80151b4: 4618         	mov	r0, r3
 80151b6: 370c         	adds	r7, #0xc
 80151b8: 46bd         	mov	sp, r7
 80151ba: bc80         	pop	{r7}
 80151bc: 4770         	bx	lr

080151be <sys_slist_is_empty>:
; Z_GENLIST_IS_EMPTY(slist)
 80151be: b580         	push	{r7, lr}
 80151c0: b082         	sub	sp, #0x8
 80151c2: af00         	add	r7, sp, #0x0
 80151c4: 6078         	str	r0, [r7, #0x4]
 80151c6: 6878         	ldr	r0, [r7, #0x4]
 80151c8: f7ff ffe3    	bl	0x8015192 <sys_slist_peek_head> @ imm = #-0x3a
 80151cc: 4603         	mov	r3, r0
 80151ce: 2b00         	cmp	r3, #0x0
 80151d0: bf0c         	ite	eq
 80151d2: 2301         	moveq	r3, #0x1
 80151d4: 2300         	movne	r3, #0x0
 80151d6: b2db         	uxtb	r3, r3
 80151d8: 4618         	mov	r0, r3
 80151da: 3708         	adds	r7, #0x8
 80151dc: 46bd         	mov	sp, r7
 80151de: bd80         	pop	{r7, pc}

080151e0 <sys_slist_peek_next_no_check>:
; Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
 80151e0: b580         	push	{r7, lr}
 80151e2: b082         	sub	sp, #0x8
 80151e4: af00         	add	r7, sp, #0x0
 80151e6: 6078         	str	r0, [r7, #0x4]
 80151e8: 6878         	ldr	r0, [r7, #0x4]
 80151ea: f7ff ffa0    	bl	0x801512e <z_snode_next_peek> @ imm = #-0xc0
 80151ee: 4603         	mov	r3, r0
 80151f0: 4618         	mov	r0, r3
 80151f2: 3708         	adds	r7, #0x8
 80151f4: 46bd         	mov	sp, r7
 80151f6: bd80         	pop	{r7, pc}

080151f8 <sys_slist_peek_next>:
; Z_GENLIST_PEEK_NEXT(slist, snode)
 80151f8: b580         	push	{r7, lr}
 80151fa: b082         	sub	sp, #0x8
 80151fc: af00         	add	r7, sp, #0x0
 80151fe: 6078         	str	r0, [r7, #0x4]
 8015200: 687b         	ldr	r3, [r7, #0x4]
 8015202: 2b00         	cmp	r3, #0x0
 8015204: d004         	beq	0x8015210 <sys_slist_peek_next+0x18> @ imm = #0x8
 8015206: 6878         	ldr	r0, [r7, #0x4]
 8015208: f7ff ffea    	bl	0x80151e0 <sys_slist_peek_next_no_check> @ imm = #-0x2c
 801520c: 4603         	mov	r3, r0
 801520e: e000         	b	0x8015212 <sys_slist_peek_next+0x1a> @ imm = #0x0
 8015210: 2300         	movs	r3, #0x0
 8015212: 4618         	mov	r0, r3
 8015214: 3708         	adds	r7, #0x8
 8015216: 46bd         	mov	sp, r7
 8015218: bd80         	pop	{r7, pc}

0801521a <sys_slist_prepend>:
; Z_GENLIST_PREPEND(slist, snode)
 801521a: b580         	push	{r7, lr}
 801521c: b082         	sub	sp, #0x8
 801521e: af00         	add	r7, sp, #0x0
 8015220: 6078         	str	r0, [r7, #0x4]
 8015222: 6039         	str	r1, [r7]
 8015224: 6878         	ldr	r0, [r7, #0x4]
 8015226: f7ff ffb4    	bl	0x8015192 <sys_slist_peek_head> @ imm = #-0x98
 801522a: 4603         	mov	r3, r0
 801522c: 4619         	mov	r1, r3
 801522e: 6838         	ldr	r0, [r7]
 8015230: f7ff ff88    	bl	0x8015144 <z_snode_next_set> @ imm = #-0xf0
 8015234: 6839         	ldr	r1, [r7]
 8015236: 6878         	ldr	r0, [r7, #0x4]
 8015238: f7ff ff91    	bl	0x801515e <z_slist_head_set> @ imm = #-0xde
 801523c: 6878         	ldr	r0, [r7, #0x4]
 801523e: f7ff ffb3    	bl	0x80151a8 <sys_slist_peek_tail> @ imm = #-0x9a
 8015242: 4603         	mov	r3, r0
 8015244: 2b00         	cmp	r3, #0x0
 8015246: d107         	bne	0x8015258 <sys_slist_prepend+0x3e> @ imm = #0xe
 8015248: 6878         	ldr	r0, [r7, #0x4]
 801524a: f7ff ffa2    	bl	0x8015192 <sys_slist_peek_head> @ imm = #-0xbc
 801524e: 4603         	mov	r3, r0
 8015250: 4619         	mov	r1, r3
 8015252: 6878         	ldr	r0, [r7, #0x4]
 8015254: f7ff ff90    	bl	0x8015178 <z_slist_tail_set> @ imm = #-0xe0
 8015258: 3708         	adds	r7, #0x8
 801525a: 46bd         	mov	sp, r7
 801525c: bd80         	pop	{r7, pc}

0801525e <sys_slist_get_not_empty>:
; Z_GENLIST_GET_NOT_EMPTY(slist, snode)
 801525e: b580         	push	{r7, lr}
 8015260: b084         	sub	sp, #0x10
 8015262: af00         	add	r7, sp, #0x0
 8015264: 6078         	str	r0, [r7, #0x4]
 8015266: 6878         	ldr	r0, [r7, #0x4]
 8015268: f7ff ff93    	bl	0x8015192 <sys_slist_peek_head> @ imm = #-0xda
 801526c: 60f8         	str	r0, [r7, #0xc]
 801526e: 68f8         	ldr	r0, [r7, #0xc]
 8015270: f7ff ff5d    	bl	0x801512e <z_snode_next_peek> @ imm = #-0x146
 8015274: 4603         	mov	r3, r0
 8015276: 4619         	mov	r1, r3
 8015278: 6878         	ldr	r0, [r7, #0x4]
 801527a: f7ff ff70    	bl	0x801515e <z_slist_head_set> @ imm = #-0x120
 801527e: 6878         	ldr	r0, [r7, #0x4]
 8015280: f7ff ff92    	bl	0x80151a8 <sys_slist_peek_tail> @ imm = #-0xdc
 8015284: 4602         	mov	r2, r0
 8015286: 68fb         	ldr	r3, [r7, #0xc]
 8015288: 4293         	cmp	r3, r2
 801528a: d107         	bne	0x801529c <sys_slist_get_not_empty+0x3e> @ imm = #0xe
 801528c: 6878         	ldr	r0, [r7, #0x4]
 801528e: f7ff ff80    	bl	0x8015192 <sys_slist_peek_head> @ imm = #-0x100
 8015292: 4603         	mov	r3, r0
 8015294: 4619         	mov	r1, r3
 8015296: 6878         	ldr	r0, [r7, #0x4]
 8015298: f7ff ff6e    	bl	0x8015178 <z_slist_tail_set> @ imm = #-0x124
 801529c: 68fb         	ldr	r3, [r7, #0xc]
 801529e: 4618         	mov	r0, r3
 80152a0: 3710         	adds	r7, #0x10
 80152a2: 46bd         	mov	sp, r7
 80152a4: bd80         	pop	{r7, pc}

080152a6 <sys_slist_get>:
; Z_GENLIST_GET(slist, snode)
 80152a6: b580         	push	{r7, lr}
 80152a8: b082         	sub	sp, #0x8
 80152aa: af00         	add	r7, sp, #0x0
 80152ac: 6078         	str	r0, [r7, #0x4]
 80152ae: 6878         	ldr	r0, [r7, #0x4]
 80152b0: f7ff ff85    	bl	0x80151be <sys_slist_is_empty> @ imm = #-0xf6
 80152b4: 4603         	mov	r3, r0
 80152b6: 2b00         	cmp	r3, #0x0
 80152b8: d104         	bne	0x80152c4 <sys_slist_get+0x1e> @ imm = #0x8
 80152ba: 6878         	ldr	r0, [r7, #0x4]
 80152bc: f7ff ffcf    	bl	0x801525e <sys_slist_get_not_empty> @ imm = #-0x62
 80152c0: 4603         	mov	r3, r0
 80152c2: e000         	b	0x80152c6 <sys_slist_get+0x20> @ imm = #0x0
 80152c4: 2300         	movs	r3, #0x0
 80152c6: 4618         	mov	r0, r3
 80152c8: 3708         	adds	r7, #0x8
 80152ca: 46bd         	mov	sp, r7
 80152cc: bd80         	pop	{r7, pc}

080152ce <sys_slist_remove>:
; Z_GENLIST_REMOVE(slist, snode)
 80152ce: b580         	push	{r7, lr}
 80152d0: b084         	sub	sp, #0x10
 80152d2: af00         	add	r7, sp, #0x0
 80152d4: 60f8         	str	r0, [r7, #0xc]
 80152d6: 60b9         	str	r1, [r7, #0x8]
 80152d8: 607a         	str	r2, [r7, #0x4]
 80152da: 68bb         	ldr	r3, [r7, #0x8]
 80152dc: 2b00         	cmp	r3, #0x0
 80152de: d117         	bne	0x8015310 <sys_slist_remove+0x42> @ imm = #0x2e
 80152e0: 6878         	ldr	r0, [r7, #0x4]
 80152e2: f7ff ff24    	bl	0x801512e <z_snode_next_peek> @ imm = #-0x1b8
 80152e6: 4603         	mov	r3, r0
 80152e8: 4619         	mov	r1, r3
 80152ea: 68f8         	ldr	r0, [r7, #0xc]
 80152ec: f7ff ff37    	bl	0x801515e <z_slist_head_set> @ imm = #-0x192
 80152f0: 68f8         	ldr	r0, [r7, #0xc]
 80152f2: f7ff ff59    	bl	0x80151a8 <sys_slist_peek_tail> @ imm = #-0x14e
 80152f6: 4602         	mov	r2, r0
 80152f8: 687b         	ldr	r3, [r7, #0x4]
 80152fa: 4293         	cmp	r3, r2
 80152fc: d11b         	bne	0x8015336 <sys_slist_remove+0x68> @ imm = #0x36
 80152fe: 68f8         	ldr	r0, [r7, #0xc]
 8015300: f7ff ff47    	bl	0x8015192 <sys_slist_peek_head> @ imm = #-0x172
 8015304: 4603         	mov	r3, r0
 8015306: 4619         	mov	r1, r3
 8015308: 68f8         	ldr	r0, [r7, #0xc]
 801530a: f7ff ff35    	bl	0x8015178 <z_slist_tail_set> @ imm = #-0x196
 801530e: e012         	b	0x8015336 <sys_slist_remove+0x68> @ imm = #0x24
 8015310: 6878         	ldr	r0, [r7, #0x4]
 8015312: f7ff ff0c    	bl	0x801512e <z_snode_next_peek> @ imm = #-0x1e8
 8015316: 4603         	mov	r3, r0
 8015318: 4619         	mov	r1, r3
 801531a: 68b8         	ldr	r0, [r7, #0x8]
 801531c: f7ff ff12    	bl	0x8015144 <z_snode_next_set> @ imm = #-0x1dc
 8015320: 68f8         	ldr	r0, [r7, #0xc]
 8015322: f7ff ff41    	bl	0x80151a8 <sys_slist_peek_tail> @ imm = #-0x17e
 8015326: 4602         	mov	r2, r0
 8015328: 687b         	ldr	r3, [r7, #0x4]
 801532a: 4293         	cmp	r3, r2
 801532c: d103         	bne	0x8015336 <sys_slist_remove+0x68> @ imm = #0x6
 801532e: 68b9         	ldr	r1, [r7, #0x8]
 8015330: 68f8         	ldr	r0, [r7, #0xc]
 8015332: f7ff ff21    	bl	0x8015178 <z_slist_tail_set> @ imm = #-0x1be
 8015336: 2100         	movs	r1, #0x0
 8015338: 6878         	ldr	r0, [r7, #0x4]
 801533a: f7ff ff03    	bl	0x8015144 <z_snode_next_set> @ imm = #-0x1fa
 801533e: 3710         	adds	r7, #0x10
 8015340: 46bd         	mov	sp, r7
 8015342: bd80         	pop	{r7, pc}

08015344 <log_cache_get>:
; {
 8015344: b590         	push	{r4, r7, lr}
 8015346: b089         	sub	sp, #0x24
 8015348: af00         	add	r7, sp, #0x0
 801534a: 60f8         	str	r0, [r7, #0xc]
 801534c: 60b9         	str	r1, [r7, #0x8]
 801534e: 607a         	str	r2, [r7, #0x4]
; 	sys_snode_t *prev_node = NULL;
 8015350: 2300         	movs	r3, #0x0
 8015352: 61fb         	str	r3, [r7, #0x1c]
; 	bool hit = false;
 8015354: 2300         	movs	r3, #0x0
 8015356: 75fb         	strb	r3, [r7, #0x17]
; 	SYS_SLIST_FOR_EACH_CONTAINER(&cache->active, entry, node) {
 8015358: 68fb         	ldr	r3, [r7, #0xc]
 801535a: 4618         	mov	r0, r3
 801535c: f7ff ff19    	bl	0x8015192 <sys_slist_peek_head> @ imm = #-0x1ce
 8015360: 4603         	mov	r3, r0
 8015362: 2b00         	cmp	r3, #0x0
 8015364: d005         	beq	0x8015372 <log_cache_get+0x2e> @ imm = #0xa
 8015366: 68fb         	ldr	r3, [r7, #0xc]
 8015368: 4618         	mov	r0, r3
 801536a: f7ff ff12    	bl	0x8015192 <sys_slist_peek_head> @ imm = #-0x1dc
 801536e: 4603         	mov	r3, r0
 8015370: e000         	b	0x8015374 <log_cache_get+0x30> @ imm = #0x0
 8015372: 2300         	movs	r3, #0x0
 8015374: 61bb         	str	r3, [r7, #0x18]
 8015376: e02f         	b	0x80153d8 <log_cache_get+0x94> @ imm = #0x5e
; 		if (cache->cmp(entry->id, id)) {
 8015378: 68fb         	ldr	r3, [r7, #0xc]
 801537a: 691b         	ldr	r3, [r3, #0x10]
 801537c: 69ba         	ldr	r2, [r7, #0x18]
 801537e: 6852         	ldr	r2, [r2, #0x4]
 8015380: 68b9         	ldr	r1, [r7, #0x8]
 8015382: 4610         	mov	r0, r2
 8015384: 4798         	blx	r3
 8015386: 4603         	mov	r3, r0
 8015388: 2b00         	cmp	r3, #0x0
 801538a: d007         	beq	0x801539c <log_cache_get+0x58> @ imm = #0xe
; 			cache->hit++;
 801538c: 68fb         	ldr	r3, [r7, #0xc]
 801538e: 695b         	ldr	r3, [r3, #0x14]
 8015390: 1c5a         	adds	r2, r3, #0x1
 8015392: 68fb         	ldr	r3, [r7, #0xc]
 8015394: 615a         	str	r2, [r3, #0x14]
; 			hit = true;
 8015396: 2301         	movs	r3, #0x1
 8015398: 75fb         	strb	r3, [r7, #0x17]
; 			break;
 801539a: e022         	b	0x80153e2 <log_cache_get+0x9e> @ imm = #0x44
; 		if (&entry->node == sys_slist_peek_tail(&cache->active)) {
 801539c: 69bc         	ldr	r4, [r7, #0x18]
 801539e: 68fb         	ldr	r3, [r7, #0xc]
 80153a0: 4618         	mov	r0, r3
 80153a2: f7ff ff01    	bl	0x80151a8 <sys_slist_peek_tail> @ imm = #-0x1fe
 80153a6: 4603         	mov	r3, r0
 80153a8: 429c         	cmp	r4, r3
 80153aa: d019         	beq	0x80153e0 <log_cache_get+0x9c> @ imm = #0x32
; 		prev_node = &entry->node;
 80153ac: 69bb         	ldr	r3, [r7, #0x18]
 80153ae: 61fb         	str	r3, [r7, #0x1c]
; 	SYS_SLIST_FOR_EACH_CONTAINER(&cache->active, entry, node) {
 80153b0: 69bb         	ldr	r3, [r7, #0x18]
 80153b2: 2b00         	cmp	r3, #0x0
 80153b4: d00e         	beq	0x80153d4 <log_cache_get+0x90> @ imm = #0x1c
 80153b6: 69bb         	ldr	r3, [r7, #0x18]
 80153b8: 4618         	mov	r0, r3
 80153ba: f7ff ff1d    	bl	0x80151f8 <sys_slist_peek_next> @ imm = #-0x1c6
 80153be: 4603         	mov	r3, r0
 80153c0: 2b00         	cmp	r3, #0x0
 80153c2: d005         	beq	0x80153d0 <log_cache_get+0x8c> @ imm = #0xa
 80153c4: 69bb         	ldr	r3, [r7, #0x18]
 80153c6: 4618         	mov	r0, r3
 80153c8: f7ff ff16    	bl	0x80151f8 <sys_slist_peek_next> @ imm = #-0x1d4
 80153cc: 4603         	mov	r3, r0
 80153ce: e002         	b	0x80153d6 <log_cache_get+0x92> @ imm = #0x4
 80153d0: 2300         	movs	r3, #0x0
 80153d2: e000         	b	0x80153d6 <log_cache_get+0x92> @ imm = #0x0
 80153d4: 2300         	movs	r3, #0x0
 80153d6: 61bb         	str	r3, [r7, #0x18]
 80153d8: 69bb         	ldr	r3, [r7, #0x18]
 80153da: 2b00         	cmp	r3, #0x0
 80153dc: d1cc         	bne	0x8015378 <log_cache_get+0x34> @ imm = #-0x68
 80153de: e000         	b	0x80153e2 <log_cache_get+0x9e> @ imm = #0x0
; 			break;
 80153e0: bf00         	nop
; 	if (hit) {
 80153e2: 7dfb         	ldrb	r3, [r7, #0x17]
 80153e4: 2b00         	cmp	r3, #0x0
 80153e6: d00c         	beq	0x8015402 <log_cache_get+0xbe> @ imm = #0x18
; 		sys_slist_remove(&cache->active, prev_node, &entry->node);
 80153e8: 68fb         	ldr	r3, [r7, #0xc]
 80153ea: 69ba         	ldr	r2, [r7, #0x18]
 80153ec: 69f9         	ldr	r1, [r7, #0x1c]
 80153ee: 4618         	mov	r0, r3
 80153f0: f7ff ff6d    	bl	0x80152ce <sys_slist_remove> @ imm = #-0x126
; 		sys_slist_prepend(&cache->active, &entry->node);
 80153f4: 68fb         	ldr	r3, [r7, #0xc]
 80153f6: 69ba         	ldr	r2, [r7, #0x18]
 80153f8: 4611         	mov	r1, r2
 80153fa: 4618         	mov	r0, r3
 80153fc: f7ff ff0d    	bl	0x801521a <sys_slist_prepend> @ imm = #-0x1e6
 8015400: e016         	b	0x8015430 <log_cache_get+0xec> @ imm = #0x2c
; 		cache->miss++;
 8015402: 68fb         	ldr	r3, [r7, #0xc]
 8015404: 699b         	ldr	r3, [r3, #0x18]
 8015406: 1c5a         	adds	r2, r3, #0x1
 8015408: 68fb         	ldr	r3, [r7, #0xc]
 801540a: 619a         	str	r2, [r3, #0x18]
; 		sys_snode_t *from_idle = sys_slist_get(&cache->idle);
 801540c: 68fb         	ldr	r3, [r7, #0xc]
 801540e: 3308         	adds	r3, #0x8
 8015410: 4618         	mov	r0, r3
 8015412: f7ff ff48    	bl	0x80152a6 <sys_slist_get> @ imm = #-0x170
 8015416: 6138         	str	r0, [r7, #0x10]
; 		if (from_idle) {
 8015418: 693b         	ldr	r3, [r7, #0x10]
 801541a: 2b00         	cmp	r3, #0x0
 801541c: d002         	beq	0x8015424 <log_cache_get+0xe0> @ imm = #0x4
; 			entry = CONTAINER_OF(from_idle, struct log_cache_entry, node);
 801541e: 693b         	ldr	r3, [r7, #0x10]
 8015420: 61bb         	str	r3, [r7, #0x18]
 8015422: e005         	b	0x8015430 <log_cache_get+0xec> @ imm = #0xa
; 			sys_slist_remove(&cache->active, prev_node, &entry->node);
 8015424: 68fb         	ldr	r3, [r7, #0xc]
 8015426: 69ba         	ldr	r2, [r7, #0x18]
 8015428: 69f9         	ldr	r1, [r7, #0x1c]
 801542a: 4618         	mov	r0, r3
 801542c: f7ff ff4f    	bl	0x80152ce <sys_slist_remove> @ imm = #-0x162
; 	*data = entry->data;
 8015430: 69bb         	ldr	r3, [r7, #0x18]
 8015432: f103 0208    	add.w	r2, r3, #0x8
 8015436: 687b         	ldr	r3, [r7, #0x4]
 8015438: 601a         	str	r2, [r3]
; 	entry->id = id;
 801543a: 69bb         	ldr	r3, [r7, #0x18]
 801543c: 68ba         	ldr	r2, [r7, #0x8]
 801543e: 605a         	str	r2, [r3, #0x4]
; 	return hit;
 8015440: 7dfb         	ldrb	r3, [r7, #0x17]
; }
 8015442: 4618         	mov	r0, r3
 8015444: 3724         	adds	r7, #0x24
 8015446: 46bd         	mov	sp, r7
 8015448: bd90         	pop	{r4, r7, pc}

0801544a <log_cache_put>:
; {
 801544a: b580         	push	{r7, lr}
 801544c: b084         	sub	sp, #0x10
 801544e: af00         	add	r7, sp, #0x0
 8015450: 6078         	str	r0, [r7, #0x4]
 8015452: 6039         	str	r1, [r7]
; 	struct log_cache_entry *entry = CONTAINER_OF(data, struct log_cache_entry, data[0]);
 8015454: 683b         	ldr	r3, [r7]
 8015456: 3b08         	subs	r3, #0x8
 8015458: 60fb         	str	r3, [r7, #0xc]
; 	sys_slist_prepend(&cache->active, &entry->node);
 801545a: 687b         	ldr	r3, [r7, #0x4]
 801545c: 68fa         	ldr	r2, [r7, #0xc]
 801545e: 4611         	mov	r1, r2
 8015460: 4618         	mov	r0, r3
 8015462: f7ff feda    	bl	0x801521a <sys_slist_prepend> @ imm = #-0x24c
; }
 8015466: bf00         	nop
 8015468: 3710         	adds	r7, #0x10
 801546a: 46bd         	mov	sp, r7
 801546c: bd80         	pop	{r7, pc}

0801546e <z_log_msg_runtime_create>:
; {
 801546e: b580         	push	{r7, lr}
 8015470: b08a         	sub	sp, #0x28
 8015472: af04         	add	r7, sp, #0x10
 8015474: 60b9         	str	r1, [r7, #0x8]
 8015476: 607b         	str	r3, [r7, #0x4]
 8015478: 4603         	mov	r3, r0
 801547a: 73fb         	strb	r3, [r7, #0xf]
 801547c: 4613         	mov	r3, r2
 801547e: 73bb         	strb	r3, [r7, #0xe]
; 	va_start(ap, fmt);
 8015480: f107 032c    	add.w	r3, r7, #0x2c
 8015484: 617b         	str	r3, [r7, #0x14]
; 	z_log_msg_runtime_vcreate(domain_id, source, level,
 8015486: 7bba         	ldrb	r2, [r7, #0xe]
 8015488: 7bf8         	ldrb	r0, [r7, #0xf]
 801548a: 697b         	ldr	r3, [r7, #0x14]
 801548c: 9303         	str	r3, [sp, #0xc]
 801548e: 6abb         	ldr	r3, [r7, #0x28]
 8015490: 9302         	str	r3, [sp, #0x8]
 8015492: 6a7b         	ldr	r3, [r7, #0x24]
 8015494: 9301         	str	r3, [sp, #0x4]
 8015496: 6a3b         	ldr	r3, [r7, #0x20]
 8015498: 9300         	str	r3, [sp]
 801549a: 687b         	ldr	r3, [r7, #0x4]
 801549c: 68b9         	ldr	r1, [r7, #0x8]
 801549e: f7ef f867    	bl	0x8004570 <z_log_msg_runtime_vcreate> @ imm = #-0x10f32
; }
 80154a2: bf00         	nop
 80154a4: 3718         	adds	r7, #0x18
 80154a6: 46bd         	mov	sp, r7
 80154a8: bd80         	pop	{r7, pc}

080154aa <log_msg_get_domain>:
; {
 80154aa: b480         	push	{r7}
 80154ac: b083         	sub	sp, #0xc
 80154ae: af00         	add	r7, sp, #0x0
 80154b0: 6078         	str	r0, [r7, #0x4]
; 	return msg->hdr.desc.domain;
 80154b2: 687b         	ldr	r3, [r7, #0x4]
 80154b4: 781b         	ldrb	r3, [r3]
 80154b6: f3c3 03c2    	ubfx	r3, r3, #0x3, #0x3
 80154ba: b2db         	uxtb	r3, r3
; }
 80154bc: 4618         	mov	r0, r3
 80154be: 370c         	adds	r7, #0xc
 80154c0: 46bd         	mov	sp, r7
 80154c2: bc80         	pop	{r7}
 80154c4: 4770         	bx	lr

080154c6 <log_msg_get_source>:
; {
 80154c6: b480         	push	{r7}
 80154c8: b083         	sub	sp, #0xc
 80154ca: af00         	add	r7, sp, #0x0
 80154cc: 6078         	str	r0, [r7, #0x4]
; 	return msg->hdr.source;
 80154ce: 687b         	ldr	r3, [r7, #0x4]
 80154d0: 685b         	ldr	r3, [r3, #0x4]
; }
 80154d2: 4618         	mov	r0, r3
 80154d4: 370c         	adds	r7, #0xc
 80154d6: 46bd         	mov	sp, r7
 80154d8: bc80         	pop	{r7}
 80154da: 4770         	bx	lr

080154dc <log_source_id>:
; {
 80154dc: b580         	push	{r7, lr}
 80154de: b082         	sub	sp, #0x8
 80154e0: af00         	add	r7, sp, #0x0
 80154e2: 6078         	str	r0, [r7, #0x4]
; 		log_dynamic_source_id((struct log_source_dynamic_data *)source) :
 80154e4: 6878         	ldr	r0, [r7, #0x4]
 80154e6: f7ef f833    	bl	0x8004550 <log_const_source_id> @ imm = #-0x10f9a
 80154ea: 4603         	mov	r3, r0
; }
 80154ec: 4618         	mov	r0, r3
 80154ee: 3708         	adds	r7, #0x8
 80154f0: 46bd         	mov	sp, r7
 80154f2: bd80         	pop	{r7, pc}

080154f4 <z_log_is_local_domain>:
; {
 80154f4: b480         	push	{r7}
 80154f6: b083         	sub	sp, #0xc
 80154f8: af00         	add	r7, sp, #0x0
 80154fa: 4603         	mov	r3, r0
 80154fc: 71fb         	strb	r3, [r7, #0x7]
; 	return !IS_ENABLED(CONFIG_LOG_MULTIDOMAIN) ||
 80154fe: 2301         	movs	r3, #0x1
; }
 8015500: 4618         	mov	r0, r3
 8015502: 370c         	adds	r7, #0xc
 8015504: 46bd         	mov	sp, r7
 8015506: bc80         	pop	{r7}
 8015508: 4770         	bx	lr

0801550a <z_log_msg_finalize>:
; {
 801550a: b580         	push	{r7, lr}
 801550c: b086         	sub	sp, #0x18
 801550e: af00         	add	r7, sp, #0x0
 8015510: 60f8         	str	r0, [r7, #0xc]
 8015512: 60b9         	str	r1, [r7, #0x8]
 8015514: 607a         	str	r2, [r7, #0x4]
 8015516: 603b         	str	r3, [r7]
; 	if (!msg) {
 8015518: 68fb         	ldr	r3, [r7, #0xc]
 801551a: 2b00         	cmp	r3, #0x0
 801551c: d103         	bne	0x8015526 <z_log_msg_finalize+0x1c> @ imm = #0x6
; 		z_log_dropped(false);
 801551e: 2000         	movs	r0, #0x0
 8015520: f7ee ff18    	bl	0x8004354 <z_log_dropped> @ imm = #-0x111d0
; 		return;
 8015524: e01c         	b	0x8015560 <z_log_msg_finalize+0x56> @ imm = #0x38
; 	if (data) {
 8015526: 683b         	ldr	r3, [r7]
 8015528: 2b00         	cmp	r3, #0x0
 801552a: d010         	beq	0x801554e <z_log_msg_finalize+0x44> @ imm = #0x20
; 		uint8_t *d = msg->data + desc.package_len;
 801552c: 68fb         	ldr	r3, [r7, #0xc]
 801552e: 3310         	adds	r3, #0x10
 8015530: 687a         	ldr	r2, [r7, #0x4]
 8015532: f3c2 224a    	ubfx	r2, r2, #0x9, #0xb
 8015536: b292         	uxth	r2, r2
 8015538: 4413         	add	r3, r2
 801553a: 617b         	str	r3, [r7, #0x14]
; 		memcpy(d, data, desc.data_len);
 801553c: 88fb         	ldrh	r3, [r7, #0x6]
 801553e: f3c3 130b    	ubfx	r3, r3, #0x4, #0xc
 8015542: b29b         	uxth	r3, r3
 8015544: 461a         	mov	r2, r3
 8015546: 6839         	ldr	r1, [r7]
 8015548: 6978         	ldr	r0, [r7, #0x14]
 801554a: f008 f941    	bl	0x801d7d0 <memcpy>      @ imm = #0x8282
; 	msg->hdr.desc = desc;
 801554e: 68fb         	ldr	r3, [r7, #0xc]
 8015550: 687a         	ldr	r2, [r7, #0x4]
 8015552: 601a         	str	r2, [r3]
; 	msg->hdr.source = source;
 8015554: 68fb         	ldr	r3, [r7, #0xc]
 8015556: 68ba         	ldr	r2, [r7, #0x8]
 8015558: 605a         	str	r2, [r3, #0x4]
; 	z_log_msg_commit(msg);
 801555a: 68f8         	ldr	r0, [r7, #0xc]
 801555c: f7ee ff10    	bl	0x8004380 <z_log_msg_commit> @ imm = #-0x111e0
; }
 8015560: 3718         	adds	r7, #0x18
 8015562: 46bd         	mov	sp, r7
 8015564: bd80         	pop	{r7, pc}

08015566 <log_msg_get_source_id>:
; {
 8015566: b580         	push	{r7, lr}
 8015568: b084         	sub	sp, #0x10
 801556a: af00         	add	r7, sp, #0x0
 801556c: 6078         	str	r0, [r7, #0x4]
; 	if (!z_log_is_local_domain(log_msg_get_domain(msg))) {
 801556e: 6878         	ldr	r0, [r7, #0x4]
 8015570: f7ff ff9b    	bl	0x80154aa <log_msg_get_domain> @ imm = #-0xca
 8015574: 4603         	mov	r3, r0
 8015576: 4618         	mov	r0, r3
 8015578: f7ff ffbc    	bl	0x80154f4 <z_log_is_local_domain> @ imm = #-0x88
 801557c: 4603         	mov	r3, r0
 801557e: f083 0301    	eor	r3, r3, #0x1
 8015582: b2db         	uxtb	r3, r3
 8015584: 2b00         	cmp	r3, #0x0
 8015586: d005         	beq	0x8015594 <log_msg_get_source_id+0x2e> @ imm = #0xa
; 		return (int16_t)(uintptr_t)log_msg_get_source(msg);
 8015588: 6878         	ldr	r0, [r7, #0x4]
 801558a: f7ff ff9c    	bl	0x80154c6 <log_msg_get_source> @ imm = #-0xc8
 801558e: 4603         	mov	r3, r0
 8015590: b21b         	sxth	r3, r3
 8015592: e00e         	b	0x80155b2 <log_msg_get_source_id+0x4c> @ imm = #0x1c
; 	void *source = (void *)log_msg_get_source(msg);
 8015594: 6878         	ldr	r0, [r7, #0x4]
 8015596: f7ff ff96    	bl	0x80154c6 <log_msg_get_source> @ imm = #-0xd4
 801559a: 60f8         	str	r0, [r7, #0xc]
; 	if (source != NULL) {
 801559c: 68fb         	ldr	r3, [r7, #0xc]
 801559e: 2b00         	cmp	r3, #0x0
 80155a0: d005         	beq	0x80155ae <log_msg_get_source_id+0x48> @ imm = #0xa
; 		return log_source_id(source);
 80155a2: 68f8         	ldr	r0, [r7, #0xc]
 80155a4: f7ff ff9a    	bl	0x80154dc <log_source_id> @ imm = #-0xcc
 80155a8: 4603         	mov	r3, r0
 80155aa: b21b         	sxth	r3, r3
 80155ac: e001         	b	0x80155b2 <log_msg_get_source_id+0x4c> @ imm = #0x2
; 	return -1;
 80155ae: f04f 33ff    	mov.w	r3, #0xffffffff
; }
 80155b2: 4618         	mov	r0, r3
 80155b4: 3710         	adds	r7, #0x10
 80155b6: 46bd         	mov	sp, r7
 80155b8: bd80         	pop	{r7, pc}

080155ba <log_msg_get_domain>:
; {
 80155ba: b480         	push	{r7}
 80155bc: b083         	sub	sp, #0xc
 80155be: af00         	add	r7, sp, #0x0
 80155c0: 6078         	str	r0, [r7, #0x4]
; 	return msg->hdr.desc.domain;
 80155c2: 687b         	ldr	r3, [r7, #0x4]
 80155c4: 781b         	ldrb	r3, [r3]
 80155c6: f3c3 03c2    	ubfx	r3, r3, #0x3, #0x3
 80155ca: b2db         	uxtb	r3, r3
; }
 80155cc: 4618         	mov	r0, r3
 80155ce: 370c         	adds	r7, #0xc
 80155d0: 46bd         	mov	sp, r7
 80155d2: bc80         	pop	{r7}
 80155d4: 4770         	bx	lr

080155d6 <log_msg_get_level>:
; {
 80155d6: b480         	push	{r7}
 80155d8: b083         	sub	sp, #0xc
 80155da: af00         	add	r7, sp, #0x0
 80155dc: 6078         	str	r0, [r7, #0x4]
; 	return msg->hdr.desc.level;
 80155de: 687b         	ldr	r3, [r7, #0x4]
 80155e0: 881b         	ldrh	r3, [r3]
 80155e2: f3c3 1382    	ubfx	r3, r3, #0x6, #0x3
 80155e6: b2db         	uxtb	r3, r3
; }
 80155e8: 4618         	mov	r0, r3
 80155ea: 370c         	adds	r7, #0xc
 80155ec: 46bd         	mov	sp, r7
 80155ee: bc80         	pop	{r7}
 80155f0: 4770         	bx	lr

080155f2 <log_msg_get_timestamp>:
; {
 80155f2: b480         	push	{r7}
 80155f4: b083         	sub	sp, #0xc
 80155f6: af00         	add	r7, sp, #0x0
 80155f8: 6078         	str	r0, [r7, #0x4]
; 	return msg->hdr.timestamp;
 80155fa: 687b         	ldr	r3, [r7, #0x4]
 80155fc: 689b         	ldr	r3, [r3, #0x8]
; }
 80155fe: 4618         	mov	r0, r3
 8015600: 370c         	adds	r7, #0xc
 8015602: 46bd         	mov	sp, r7
 8015604: bc80         	pop	{r7}
 8015606: 4770         	bx	lr

08015608 <log_msg_get_tid>:
; {
 8015608: b480         	push	{r7}
 801560a: b083         	sub	sp, #0xc
 801560c: af00         	add	r7, sp, #0x0
 801560e: 6078         	str	r0, [r7, #0x4]
; 	return NULL;
 8015610: 2300         	movs	r3, #0x0
; }
 8015612: 4618         	mov	r0, r3
 8015614: 370c         	adds	r7, #0xc
 8015616: 46bd         	mov	sp, r7
 8015618: bc80         	pop	{r7}
 801561a: 4770         	bx	lr

0801561c <log_msg_get_data>:
; {
 801561c: b480         	push	{r7}
 801561e: b083         	sub	sp, #0xc
 8015620: af00         	add	r7, sp, #0x0
 8015622: 6078         	str	r0, [r7, #0x4]
 8015624: 6039         	str	r1, [r7]
; 	*len = msg->hdr.desc.data_len;
 8015626: 687b         	ldr	r3, [r7, #0x4]
 8015628: 885b         	ldrh	r3, [r3, #0x2]
 801562a: f3c3 130b    	ubfx	r3, r3, #0x4, #0xc
 801562e: b29b         	uxth	r3, r3
 8015630: 461a         	mov	r2, r3
 8015632: 683b         	ldr	r3, [r7]
 8015634: 601a         	str	r2, [r3]
; 	return msg->data + msg->hdr.desc.package_len;
 8015636: 687b         	ldr	r3, [r7, #0x4]
 8015638: 3310         	adds	r3, #0x10
 801563a: 687a         	ldr	r2, [r7, #0x4]
 801563c: 6812         	ldr	r2, [r2]
 801563e: f3c2 224a    	ubfx	r2, r2, #0x9, #0xb
 8015642: b292         	uxth	r2, r2
 8015644: 4413         	add	r3, r2
; }
 8015646: 4618         	mov	r0, r3
 8015648: 370c         	adds	r7, #0xc
 801564a: 46bd         	mov	sp, r7
 801564c: bc80         	pop	{r7}
 801564e: 4770         	bx	lr

08015650 <log_msg_get_package>:
; {
 8015650: b480         	push	{r7}
 8015652: b083         	sub	sp, #0xc
 8015654: af00         	add	r7, sp, #0x0
 8015656: 6078         	str	r0, [r7, #0x4]
 8015658: 6039         	str	r1, [r7]
; 	*len = msg->hdr.desc.package_len;
 801565a: 687b         	ldr	r3, [r7, #0x4]
 801565c: 681b         	ldr	r3, [r3]
 801565e: f3c3 234a    	ubfx	r3, r3, #0x9, #0xb
 8015662: b29b         	uxth	r3, r3
 8015664: 461a         	mov	r2, r3
 8015666: 683b         	ldr	r3, [r7]
 8015668: 601a         	str	r2, [r3]
; 	return msg->data;
 801566a: 687b         	ldr	r3, [r7, #0x4]
 801566c: 3310         	adds	r3, #0x10
; }
 801566e: 4618         	mov	r0, r3
 8015670: 370c         	adds	r7, #0xc
 8015672: 46bd         	mov	sp, r7
 8015674: bc80         	pop	{r7}
 8015676: 4770         	bx	lr

08015678 <log_output_write>:
; {
 8015678: b580         	push	{r7, lr}
 801567a: b086         	sub	sp, #0x18
 801567c: af00         	add	r7, sp, #0x0
 801567e: 60f8         	str	r0, [r7, #0xc]
 8015680: 60b9         	str	r1, [r7, #0x8]
 8015682: 607a         	str	r2, [r7, #0x4]
 8015684: 603b         	str	r3, [r7]
; 	while (len != 0) {
 8015686: e00d         	b	0x80156a4 <log_output_write+0x2c> @ imm = #0x1a
; 		processed = outf(buf, len, ctx);
 8015688: 68fb         	ldr	r3, [r7, #0xc]
 801568a: 683a         	ldr	r2, [r7]
 801568c: 6879         	ldr	r1, [r7, #0x4]
 801568e: 68b8         	ldr	r0, [r7, #0x8]
 8015690: 4798         	blx	r3
 8015692: 6178         	str	r0, [r7, #0x14]
; 		len -= processed;
 8015694: 697b         	ldr	r3, [r7, #0x14]
 8015696: 687a         	ldr	r2, [r7, #0x4]
 8015698: 1ad3         	subs	r3, r2, r3
 801569a: 607b         	str	r3, [r7, #0x4]
; 		buf += processed;
 801569c: 697b         	ldr	r3, [r7, #0x14]
 801569e: 68ba         	ldr	r2, [r7, #0x8]
 80156a0: 4413         	add	r3, r2
 80156a2: 60bb         	str	r3, [r7, #0x8]
; 	while (len != 0) {
 80156a4: 687b         	ldr	r3, [r7, #0x4]
 80156a6: 2b00         	cmp	r3, #0x0
 80156a8: d1ee         	bne	0x8015688 <log_output_write+0x10> @ imm = #-0x24
; }
 80156aa: bf00         	nop
 80156ac: bf00         	nop
 80156ae: 3718         	adds	r7, #0x18
 80156b0: 46bd         	mov	sp, r7
 80156b2: bd80         	pop	{r7, pc}

080156b4 <log_output_flush>:
; {
 80156b4: b580         	push	{r7, lr}
 80156b6: b082         	sub	sp, #0x8
 80156b8: af00         	add	r7, sp, #0x0
 80156ba: 6078         	str	r0, [r7, #0x4]
; 	log_output_write(output->func, output->buf, output->control_block->offset,
 80156bc: 687b         	ldr	r3, [r7, #0x4]
 80156be: 6818         	ldr	r0, [r3]
 80156c0: 687b         	ldr	r3, [r7, #0x4]
 80156c2: 6899         	ldr	r1, [r3, #0x8]
 80156c4: 687b         	ldr	r3, [r7, #0x4]
 80156c6: 685b         	ldr	r3, [r3, #0x4]
 80156c8: 681b         	ldr	r3, [r3]
 80156ca: 461a         	mov	r2, r3
; 			 output->control_block->ctx);
 80156cc: 687b         	ldr	r3, [r7, #0x4]
 80156ce: 685b         	ldr	r3, [r3, #0x4]
; 	log_output_write(output->func, output->buf, output->control_block->offset,
 80156d0: 685b         	ldr	r3, [r3, #0x4]
 80156d2: f7ff ffd1    	bl	0x8015678 <log_output_write> @ imm = #-0x5e
; 	output->control_block->offset = 0;
 80156d6: 687b         	ldr	r3, [r7, #0x4]
 80156d8: 685b         	ldr	r3, [r3, #0x4]
 80156da: 2200         	movs	r2, #0x0
 80156dc: 601a         	str	r2, [r3]
; }
 80156de: bf00         	nop
 80156e0: 3708         	adds	r7, #0x8
 80156e2: 46bd         	mov	sp, r7
 80156e4: bd80         	pop	{r7, pc}

080156e6 <out_func>:
; {
 80156e6: b580         	push	{r7, lr}
 80156e8: b084         	sub	sp, #0x10
 80156ea: af00         	add	r7, sp, #0x0
 80156ec: 6078         	str	r0, [r7, #0x4]
 80156ee: 6039         	str	r1, [r7]
; 	const struct log_output *out_ctx = (const struct log_output *)ctx;
 80156f0: 683b         	ldr	r3, [r7]
 80156f2: 60fb         	str	r3, [r7, #0xc]
; 		char x = (char)c;
 80156f4: 687b         	ldr	r3, [r7, #0x4]
 80156f6: b2db         	uxtb	r3, r3
 80156f8: 72fb         	strb	r3, [r7, #0xb]
; 		out_ctx->func((uint8_t *)&x, 1, out_ctx->control_block->ctx);
 80156fa: 68fb         	ldr	r3, [r7, #0xc]
 80156fc: 681b         	ldr	r3, [r3]
 80156fe: 68fa         	ldr	r2, [r7, #0xc]
 8015700: 6852         	ldr	r2, [r2, #0x4]
 8015702: 6852         	ldr	r2, [r2, #0x4]
 8015704: f107 000b    	add.w	r0, r7, #0xb
 8015708: 2101         	movs	r1, #0x1
 801570a: 4798         	blx	r3
; 		return 0;
 801570c: 2300         	movs	r3, #0x0
; }
 801570e: 4618         	mov	r0, r3
 8015710: 3710         	adds	r7, #0x10
 8015712: 46bd         	mov	sp, r7
 8015714: bd80         	pop	{r7, pc}

08015716 <cr_out_func>:
; {
 8015716: b580         	push	{r7, lr}
 8015718: b082         	sub	sp, #0x8
 801571a: af00         	add	r7, sp, #0x0
 801571c: 6078         	str	r0, [r7, #0x4]
 801571e: 6039         	str	r1, [r7]
; 	if (c == '\n') {
 8015720: 687b         	ldr	r3, [r7, #0x4]
 8015722: 2b0a         	cmp	r3, #0xa
 8015724: d103         	bne	0x801572e <cr_out_func+0x18> @ imm = #0x6
; 		out_func((int)'\r', ctx);
 8015726: 6839         	ldr	r1, [r7]
 8015728: 200d         	movs	r0, #0xd
 801572a: f7ff ffdc    	bl	0x80156e6 <out_func>    @ imm = #-0x48
; 	out_func(c, ctx);
 801572e: 6839         	ldr	r1, [r7]
 8015730: 6878         	ldr	r0, [r7, #0x4]
 8015732: f7ff ffd8    	bl	0x80156e6 <out_func>    @ imm = #-0x50
; 	return 0;
 8015736: 2300         	movs	r3, #0x0
; }
 8015738: 4618         	mov	r0, r3
 801573a: 3708         	adds	r7, #0x8
 801573c: 46bd         	mov	sp, r7
 801573e: bd80         	pop	{r7, pc}

08015740 <color_prefix>:
; {
 8015740: b580         	push	{r7, lr}
 8015742: b084         	sub	sp, #0x10
 8015744: af00         	add	r7, sp, #0x0
 8015746: 60f8         	str	r0, [r7, #0xc]
 8015748: 460b         	mov	r3, r1
 801574a: 607a         	str	r2, [r7, #0x4]
 801574c: 72fb         	strb	r3, [r7, #0xb]
; 	color_print(output, color, true, level);
 801574e: 7af9         	ldrb	r1, [r7, #0xb]
 8015750: 687b         	ldr	r3, [r7, #0x4]
 8015752: 2201         	movs	r2, #0x1
 8015754: 68f8         	ldr	r0, [r7, #0xc]
 8015756: f7ef f87b    	bl	0x8004850 <color_print> @ imm = #-0x10f0a
; }
 801575a: bf00         	nop
 801575c: 3710         	adds	r7, #0x10
 801575e: 46bd         	mov	sp, r7
 8015760: bd80         	pop	{r7, pc}

08015762 <color_postfix>:
; {
 8015762: b580         	push	{r7, lr}
 8015764: b084         	sub	sp, #0x10
 8015766: af00         	add	r7, sp, #0x0
 8015768: 60f8         	str	r0, [r7, #0xc]
 801576a: 460b         	mov	r3, r1
 801576c: 607a         	str	r2, [r7, #0x4]
 801576e: 72fb         	strb	r3, [r7, #0xb]
; 	color_print(output, color, false, level);
 8015770: 7af9         	ldrb	r1, [r7, #0xb]
 8015772: 687b         	ldr	r3, [r7, #0x4]
 8015774: 2200         	movs	r2, #0x0
 8015776: 68f8         	ldr	r0, [r7, #0xc]
 8015778: f7ef f86a    	bl	0x8004850 <color_print> @ imm = #-0x10f2c
; }
 801577c: bf00         	nop
 801577e: 3710         	adds	r7, #0x10
 8015780: 46bd         	mov	sp, r7
 8015782: bd80         	pop	{r7, pc}

08015784 <log_msg_hexdump>:
; {
 8015784: b580         	push	{r7, lr}
 8015786: b088         	sub	sp, #0x20
 8015788: af02         	add	r7, sp, #0x8
 801578a: 60f8         	str	r0, [r7, #0xc]
 801578c: 60b9         	str	r1, [r7, #0x8]
 801578e: 607a         	str	r2, [r7, #0x4]
 8015790: 603b         	str	r3, [r7]
; 		length = MIN(len, HEXDUMP_BYTES_IN_LINE);
 8015792: 687b         	ldr	r3, [r7, #0x4]
 8015794: 2b10         	cmp	r3, #0x10
 8015796: bf28         	it	hs
 8015798: 2310         	movhs	r3, #0x10
 801579a: 617b         	str	r3, [r7, #0x14]
; 		hexdump_line_print(output, data, length,
 801579c: 6a3b         	ldr	r3, [r7, #0x20]
 801579e: 9300         	str	r3, [sp]
 80157a0: 683b         	ldr	r3, [r7]
 80157a2: 697a         	ldr	r2, [r7, #0x14]
 80157a4: 68b9         	ldr	r1, [r7, #0x8]
 80157a6: 68f8         	ldr	r0, [r7, #0xc]
 80157a8: f7ef f8f0    	bl	0x800498c <hexdump_line_print> @ imm = #-0x10e20
; 		data += length;
 80157ac: 68ba         	ldr	r2, [r7, #0x8]
 80157ae: 697b         	ldr	r3, [r7, #0x14]
 80157b0: 4413         	add	r3, r2
 80157b2: 60bb         	str	r3, [r7, #0x8]
; 		len -= length;
 80157b4: 687a         	ldr	r2, [r7, #0x4]
 80157b6: 697b         	ldr	r3, [r7, #0x14]
 80157b8: 1ad3         	subs	r3, r2, r3
 80157ba: 607b         	str	r3, [r7, #0x4]
; 	} while (len);
 80157bc: 687b         	ldr	r3, [r7, #0x4]
 80157be: 2b00         	cmp	r3, #0x0
 80157c0: d1e7         	bne	0x8015792 <log_msg_hexdump+0xe> @ imm = #-0x32
; }
 80157c2: bf00         	nop
 80157c4: bf00         	nop
 80157c6: 3718         	adds	r7, #0x18
 80157c8: 46bd         	mov	sp, r7
 80157ca: bd80         	pop	{r7, pc}

080157cc <postfix_print>:
; {
 80157cc: b580         	push	{r7, lr}
 80157ce: b084         	sub	sp, #0x10
 80157d0: af00         	add	r7, sp, #0x0
 80157d2: 60f8         	str	r0, [r7, #0xc]
 80157d4: 60b9         	str	r1, [r7, #0x8]
 80157d6: 4613         	mov	r3, r2
 80157d8: 71fb         	strb	r3, [r7, #0x7]
; 	color_postfix(output, (flags & LOG_OUTPUT_FLAG_COLORS),
 80157da: 68bb         	ldr	r3, [r7, #0x8]
 80157dc: f003 0301    	and	r3, r3, #0x1
 80157e0: 2b00         	cmp	r3, #0x0
 80157e2: bf14         	ite	ne
 80157e4: 2301         	movne	r3, #0x1
 80157e6: 2300         	moveq	r3, #0x0
 80157e8: b2db         	uxtb	r3, r3
 80157ea: 79fa         	ldrb	r2, [r7, #0x7]
 80157ec: 4619         	mov	r1, r3
 80157ee: 68f8         	ldr	r0, [r7, #0xc]
 80157f0: f7ff ffb7    	bl	0x8015762 <color_postfix> @ imm = #-0x92
; 	newline_print(output, flags);
 80157f4: 68b9         	ldr	r1, [r7, #0x8]
 80157f6: 68f8         	ldr	r0, [r7, #0xc]
 80157f8: f7ef f8a6    	bl	0x8004948 <newline_print> @ imm = #-0x10eb4
; }
 80157fc: bf00         	nop
 80157fe: 3710         	adds	r7, #0x10
 8015800: 46bd         	mov	sp, r7
 8015802: bd80         	pop	{r7, pc}

08015804 <log_output_msg_process>:
; {
 8015804: b580         	push	{r7, lr}
 8015806: b092         	sub	sp, #0x48
 8015808: af06         	add	r7, sp, #0x18
 801580a: 60f8         	str	r0, [r7, #0xc]
 801580c: 60b9         	str	r1, [r7, #0x8]
 801580e: 607a         	str	r2, [r7, #0x4]
; 	log_timestamp_t timestamp = log_msg_get_timestamp(msg);
 8015810: 68b8         	ldr	r0, [r7, #0x8]
 8015812: f7ff feee    	bl	0x80155f2 <log_msg_get_timestamp> @ imm = #-0x224
 8015816: 62f8         	str	r0, [r7, #0x2c]
; 	uint8_t level = log_msg_get_level(msg);
 8015818: 68b8         	ldr	r0, [r7, #0x8]
 801581a: f7ff fedc    	bl	0x80155d6 <log_msg_get_level> @ imm = #-0x248
 801581e: 4603         	mov	r3, r0
 8015820: f887 302b    	strb.w	r3, [r7, #0x2b]
; 	uint8_t domain_id = log_msg_get_domain(msg);
 8015824: 68b8         	ldr	r0, [r7, #0x8]
 8015826: f7ff fec8    	bl	0x80155ba <log_msg_get_domain> @ imm = #-0x270
 801582a: 4603         	mov	r3, r0
 801582c: f887 302a    	strb.w	r3, [r7, #0x2a]
; 	int16_t source_id = log_msg_get_source_id(msg);
 8015830: 68b8         	ldr	r0, [r7, #0x8]
 8015832: f7ff fe98    	bl	0x8015566 <log_msg_get_source_id> @ imm = #-0x2d0
 8015836: 4603         	mov	r3, r0
 8015838: 853b         	strh	r3, [r7, #0x28]
; 	const char *sname = source_id >= 0 ? log_source_name_get(domain_id, source_id) : NULL;
 801583a: f9b7 3028    	ldrsh.w	r3, [r7, #0x28]
 801583e: 2b00         	cmp	r3, #0x0
 8015840: db09         	blt	0x8015856 <log_output_msg_process+0x52> @ imm = #0x12
 8015842: f897 302a    	ldrb.w	r3, [r7, #0x2a]
 8015846: f9b7 2028    	ldrsh.w	r2, [r7, #0x28]
 801584a: 4611         	mov	r1, r2
 801584c: 4618         	mov	r0, r3
 801584e: f7ee fe57    	bl	0x8004500 <log_source_name_get> @ imm = #-0x11352
 8015852: 4603         	mov	r3, r0
 8015854: e000         	b	0x8015858 <log_output_msg_process+0x54> @ imm = #0x0
 8015856: 2300         	movs	r3, #0x0
 8015858: 627b         	str	r3, [r7, #0x24]
; 	uint8_t *package = log_msg_get_package(msg, &plen);
 801585a: f107 0318    	add.w	r3, r7, #0x18
 801585e: 4619         	mov	r1, r3
 8015860: 68b8         	ldr	r0, [r7, #0x8]
 8015862: f7ff fef5    	bl	0x8015650 <log_msg_get_package> @ imm = #-0x216
 8015866: 6238         	str	r0, [r7, #0x20]
; 	uint8_t *data = log_msg_get_data(msg, &dlen);
 8015868: f107 0314    	add.w	r3, r7, #0x14
 801586c: 4619         	mov	r1, r3
 801586e: 68b8         	ldr	r0, [r7, #0x8]
 8015870: f7ff fed4    	bl	0x801561c <log_msg_get_data> @ imm = #-0x258
 8015874: 61f8         	str	r0, [r7, #0x1c]
; 	log_output_process(output, timestamp, NULL, sname, (k_tid_t)log_msg_get_tid(msg), level,
 8015876: 68b8         	ldr	r0, [r7, #0x8]
 8015878: f7ff fec6    	bl	0x8015608 <log_msg_get_tid> @ imm = #-0x274
; 			   plen > 0 ? package : NULL, data, dlen, flags);
 801587c: 69bb         	ldr	r3, [r7, #0x18]
; 	log_output_process(output, timestamp, NULL, sname, (k_tid_t)log_msg_get_tid(msg), level,
 801587e: 2b00         	cmp	r3, #0x0
 8015880: d001         	beq	0x8015886 <log_output_msg_process+0x82> @ imm = #0x2
 8015882: 6a3b         	ldr	r3, [r7, #0x20]
 8015884: e000         	b	0x8015888 <log_output_msg_process+0x84> @ imm = #0x0
 8015886: 2300         	movs	r3, #0x0
 8015888: 697a         	ldr	r2, [r7, #0x14]
 801588a: 6879         	ldr	r1, [r7, #0x4]
 801588c: 9105         	str	r1, [sp, #0x14]
 801588e: 9204         	str	r2, [sp, #0x10]
 8015890: 69fa         	ldr	r2, [r7, #0x1c]
 8015892: 9203         	str	r2, [sp, #0xc]
 8015894: 9302         	str	r3, [sp, #0x8]
 8015896: f897 302b    	ldrb.w	r3, [r7, #0x2b]
 801589a: 9301         	str	r3, [sp, #0x4]
 801589c: 9000         	str	r0, [sp]
 801589e: 6a7b         	ldr	r3, [r7, #0x24]
 80158a0: 2200         	movs	r2, #0x0
 80158a2: 6af9         	ldr	r1, [r7, #0x2c]
 80158a4: 68f8         	ldr	r0, [r7, #0xc]
 80158a6: f7ef f96b    	bl	0x8004b80 <log_output_process> @ imm = #-0x10d2a
; }
 80158aa: bf00         	nop
 80158ac: 3730         	adds	r7, #0x30
 80158ae: 46bd         	mov	sp, r7
 80158b0: bd80         	pop	{r7, pc}

080158b2 <log_output_write>:
; {
 80158b2: b580         	push	{r7, lr}
 80158b4: b086         	sub	sp, #0x18
 80158b6: af00         	add	r7, sp, #0x0
 80158b8: 60f8         	str	r0, [r7, #0xc]
 80158ba: 60b9         	str	r1, [r7, #0x8]
 80158bc: 607a         	str	r2, [r7, #0x4]
 80158be: 603b         	str	r3, [r7]
; 	while (len != 0) {
 80158c0: e00d         	b	0x80158de <log_output_write+0x2c> @ imm = #0x1a
; 		processed = outf(buf, len, ctx);
 80158c2: 68fb         	ldr	r3, [r7, #0xc]
 80158c4: 683a         	ldr	r2, [r7]
 80158c6: 6879         	ldr	r1, [r7, #0x4]
 80158c8: 68b8         	ldr	r0, [r7, #0x8]
 80158ca: 4798         	blx	r3
 80158cc: 6178         	str	r0, [r7, #0x14]
; 		len -= processed;
 80158ce: 697b         	ldr	r3, [r7, #0x14]
 80158d0: 687a         	ldr	r2, [r7, #0x4]
 80158d2: 1ad3         	subs	r3, r2, r3
 80158d4: 607b         	str	r3, [r7, #0x4]
; 		buf += processed;
 80158d6: 697b         	ldr	r3, [r7, #0x14]
 80158d8: 68ba         	ldr	r2, [r7, #0x8]
 80158da: 4413         	add	r3, r2
 80158dc: 60bb         	str	r3, [r7, #0x8]
; 	while (len != 0) {
 80158de: 687b         	ldr	r3, [r7, #0x4]
 80158e0: 2b00         	cmp	r3, #0x0
 80158e2: d1ee         	bne	0x80158c2 <log_output_write+0x10> @ imm = #-0x24
; }
 80158e4: bf00         	nop
 80158e6: bf00         	nop
 80158e8: 3718         	adds	r7, #0x18
 80158ea: 46bd         	mov	sp, r7
 80158ec: bd80         	pop	{r7, pc}

080158ee <log_output_flush>:
; {
 80158ee: b580         	push	{r7, lr}
 80158f0: b082         	sub	sp, #0x8
 80158f2: af00         	add	r7, sp, #0x0
 80158f4: 6078         	str	r0, [r7, #0x4]
; 	log_output_write(output->func, output->buf, output->control_block->offset,
 80158f6: 687b         	ldr	r3, [r7, #0x4]
 80158f8: 6818         	ldr	r0, [r3]
 80158fa: 687b         	ldr	r3, [r7, #0x4]
 80158fc: 6899         	ldr	r1, [r3, #0x8]
 80158fe: 687b         	ldr	r3, [r7, #0x4]
 8015900: 685b         	ldr	r3, [r3, #0x4]
 8015902: 681b         	ldr	r3, [r3]
 8015904: 461a         	mov	r2, r3
; 			 output->control_block->ctx);
 8015906: 687b         	ldr	r3, [r7, #0x4]
 8015908: 685b         	ldr	r3, [r3, #0x4]
; 	log_output_write(output->func, output->buf, output->control_block->offset,
 801590a: 685b         	ldr	r3, [r3, #0x4]
 801590c: f7ff ffd1    	bl	0x80158b2 <log_output_write> @ imm = #-0x5e
; 	output->control_block->offset = 0;
 8015910: 687b         	ldr	r3, [r7, #0x4]
 8015912: 685b         	ldr	r3, [r3, #0x4]
 8015914: 2200         	movs	r2, #0x0
 8015916: 601a         	str	r2, [r3]
; }
 8015918: bf00         	nop
 801591a: 3708         	adds	r7, #0x8
 801591c: 46bd         	mov	sp, r7
 801591e: bd80         	pop	{r7, pc}

08015920 <log_output_ctx_set>:
; {
 8015920: b480         	push	{r7}
 8015922: b083         	sub	sp, #0xc
 8015924: af00         	add	r7, sp, #0x0
 8015926: 6078         	str	r0, [r7, #0x4]
 8015928: 6039         	str	r1, [r7]
; 	output->control_block->ctx = ctx;
 801592a: 687b         	ldr	r3, [r7, #0x4]
 801592c: 685b         	ldr	r3, [r3, #0x4]
 801592e: 683a         	ldr	r2, [r7]
 8015930: 605a         	str	r2, [r3, #0x4]
; }
 8015932: bf00         	nop
 8015934: 370c         	adds	r7, #0xc
 8015936: 46bd         	mov	sp, r7
 8015938: bc80         	pop	{r7}
 801593a: 4770         	bx	lr

0801593c <log_backend_std_get_flags>:
; {
 801593c: b480         	push	{r7}
 801593e: b083         	sub	sp, #0xc
 8015940: af00         	add	r7, sp, #0x0
; 	uint32_t flags = (LOG_OUTPUT_FLAG_LEVEL | LOG_OUTPUT_FLAG_TIMESTAMP);
 8015942: 230a         	movs	r3, #0xa
 8015944: 607b         	str	r3, [r7, #0x4]
; 		flags |= LOG_OUTPUT_FLAG_COLORS;
 8015946: 687b         	ldr	r3, [r7, #0x4]
 8015948: f043 0301    	orr	r3, r3, #0x1
 801594c: 607b         	str	r3, [r7, #0x4]
; 		flags |= LOG_OUTPUT_FLAG_FORMAT_TIMESTAMP;
 801594e: 687b         	ldr	r3, [r7, #0x4]
 8015950: f043 0304    	orr	r3, r3, #0x4
 8015954: 607b         	str	r3, [r7, #0x4]
; 	return flags;
 8015956: 687b         	ldr	r3, [r7, #0x4]
; }
 8015958: 4618         	mov	r0, r3
 801595a: 370c         	adds	r7, #0xc
 801595c: 46bd         	mov	sp, r7
 801595e: bc80         	pop	{r7}
 8015960: 4770         	bx	lr

08015962 <log_backend_std_panic>:
; {
 8015962: b580         	push	{r7, lr}
 8015964: b082         	sub	sp, #0x8
 8015966: af00         	add	r7, sp, #0x0
 8015968: 6078         	str	r0, [r7, #0x4]
; 	log_output_flush(output);
 801596a: 6878         	ldr	r0, [r7, #0x4]
 801596c: f7ff ffbf    	bl	0x80158ee <log_output_flush> @ imm = #-0x82
; }
 8015970: bf00         	nop
 8015972: 3708         	adds	r7, #0x8
 8015974: 46bd         	mov	sp, r7
 8015976: bd80         	pop	{r7, pc}

08015978 <z_impl_uart_poll_out>:
; {
 8015978: b580         	push	{r7, lr}
 801597a: b084         	sub	sp, #0x10
 801597c: af00         	add	r7, sp, #0x0
 801597e: 6078         	str	r0, [r7, #0x4]
 8015980: 460b         	mov	r3, r1
 8015982: 70fb         	strb	r3, [r7, #0x3]
; 	const struct uart_driver_api *api = (const struct uart_driver_api *)dev->api;
 8015984: 687b         	ldr	r3, [r7, #0x4]
 8015986: 689b         	ldr	r3, [r3, #0x8]
 8015988: 60fb         	str	r3, [r7, #0xc]
; 	api->poll_out(dev, out_char);
 801598a: 68fb         	ldr	r3, [r7, #0xc]
 801598c: 69db         	ldr	r3, [r3, #0x1c]
 801598e: 78fa         	ldrb	r2, [r7, #0x3]
 8015990: 4611         	mov	r1, r2
 8015992: 6878         	ldr	r0, [r7, #0x4]
 8015994: 4798         	blx	r3
; }
 8015996: bf00         	nop
 8015998: 3710         	adds	r7, #0x10
 801599a: 46bd         	mov	sp, r7
 801599c: bd80         	pop	{r7, pc}

0801599e <uart_poll_out>:
; {
 801599e: b580         	push	{r7, lr}
 80159a0: b082         	sub	sp, #0x8
 80159a2: af00         	add	r7, sp, #0x0
 80159a4: 6078         	str	r0, [r7, #0x4]
 80159a6: 460b         	mov	r3, r1
 80159a8: 70fb         	strb	r3, [r7, #0x3]
; 	z_impl_uart_poll_out(dev, out_char);
 80159aa: 78fb         	ldrb	r3, [r7, #0x3]
 80159ac: 4619         	mov	r1, r3
 80159ae: 6878         	ldr	r0, [r7, #0x4]
 80159b0: f7ff ffe2    	bl	0x8015978 <z_impl_uart_poll_out> @ imm = #-0x3c
; }
 80159b4: bf00         	nop
 80159b6: 3708         	adds	r7, #0x8
 80159b8: 46bd         	mov	sp, r7
 80159ba: bd80         	pop	{r7, pc}

080159bc <pm_device_runtime_get>:
; {
 80159bc: b480         	push	{r7}
 80159be: b083         	sub	sp, #0xc
 80159c0: af00         	add	r7, sp, #0x0
 80159c2: 6078         	str	r0, [r7, #0x4]
; 	return 0;
 80159c4: 2300         	movs	r3, #0x0
; }
 80159c6: 4618         	mov	r0, r3
 80159c8: 370c         	adds	r7, #0xc
 80159ca: 46bd         	mov	sp, r7
 80159cc: bc80         	pop	{r7}
 80159ce: 4770         	bx	lr

080159d0 <pm_device_runtime_put_async>:
; {
 80159d0: b480         	push	{r7}
 80159d2: b085         	sub	sp, #0x14
 80159d4: af00         	add	r7, sp, #0x0
 80159d6: 60f8         	str	r0, [r7, #0xc]
 80159d8: e9c7 2300    	strd	r2, r3, [r7]
; 	return 0;
 80159dc: 2300         	movs	r3, #0x0
; }
 80159de: 4618         	mov	r0, r3
 80159e0: 3714         	adds	r7, #0x14
 80159e2: 46bd         	mov	sp, r7
 80159e4: bc80         	pop	{r7}
 80159e6: 4770         	bx	lr

080159e8 <process>:
; {
 80159e8: b580         	push	{r7, lr}
 80159ea: b086         	sub	sp, #0x18
 80159ec: af00         	add	r7, sp, #0x0
 80159ee: 6078         	str	r0, [r7, #0x4]
 80159f0: 6039         	str	r1, [r7]
; 	const struct lbu_cb_ctx *ctx = backend->cb->ctx;
 80159f2: 687b         	ldr	r3, [r7, #0x4]
 80159f4: 685b         	ldr	r3, [r3, #0x4]
 80159f6: 681b         	ldr	r3, [r3]
 80159f8: 617b         	str	r3, [r7, #0x14]
; 	struct lbu_data *data = ctx->data;
 80159fa: 697b         	ldr	r3, [r7, #0x14]
 80159fc: 685b         	ldr	r3, [r3, #0x4]
 80159fe: 613b         	str	r3, [r7, #0x10]
; 	uint32_t flags = log_backend_std_get_flags();
 8015a00: f7ff ff9c    	bl	0x801593c <log_backend_std_get_flags> @ imm = #-0xc8
 8015a04: 60f8         	str	r0, [r7, #0xc]
; 	log_format_func_t log_output_func = log_format_func_t_get(data->log_format_current);
 8015a06: 693b         	ldr	r3, [r7, #0x10]
 8015a08: 691b         	ldr	r3, [r3, #0x10]
 8015a0a: 4618         	mov	r0, r3
 8015a0c: f7ee fb8e    	bl	0x800412c <log_format_func_t_get> @ imm = #-0x118e4
 8015a10: 60b8         	str	r0, [r7, #0x8]
; 	log_output_func(ctx->output, &msg->log, flags);
 8015a12: 697b         	ldr	r3, [r7, #0x14]
 8015a14: 6818         	ldr	r0, [r3]
 8015a16: 6839         	ldr	r1, [r7]
 8015a18: 68bb         	ldr	r3, [r7, #0x8]
 8015a1a: 68fa         	ldr	r2, [r7, #0xc]
 8015a1c: 4798         	blx	r3
; }
 8015a1e: bf00         	nop
 8015a20: 3718         	adds	r7, #0x18
 8015a22: 46bd         	mov	sp, r7
 8015a24: bd80         	pop	{r7, pc}

08015a26 <format_set>:
; {
 8015a26: b480         	push	{r7}
 8015a28: b085         	sub	sp, #0x14
 8015a2a: af00         	add	r7, sp, #0x0
 8015a2c: 6078         	str	r0, [r7, #0x4]
 8015a2e: 6039         	str	r1, [r7]
; 	const struct lbu_cb_ctx *ctx = backend->cb->ctx;
 8015a30: 687b         	ldr	r3, [r7, #0x4]
 8015a32: 685b         	ldr	r3, [r3, #0x4]
 8015a34: 681b         	ldr	r3, [r3]
 8015a36: 60fb         	str	r3, [r7, #0xc]
; 	struct lbu_data *data = ctx->data;
 8015a38: 68fb         	ldr	r3, [r7, #0xc]
 8015a3a: 685b         	ldr	r3, [r3, #0x4]
 8015a3c: 60bb         	str	r3, [r7, #0x8]
; 	data->log_format_current = log_type;
 8015a3e: 68bb         	ldr	r3, [r7, #0x8]
 8015a40: 683a         	ldr	r2, [r7]
 8015a42: 611a         	str	r2, [r3, #0x10]
; 	return 0;
 8015a44: 2300         	movs	r3, #0x0
; }
 8015a46: 4618         	mov	r0, r3
 8015a48: 3714         	adds	r7, #0x14
 8015a4a: 46bd         	mov	sp, r7
 8015a4c: bc80         	pop	{r7}
 8015a4e: 4770         	bx	lr

08015a50 <z_log_msg_runtime_create>:
; {
 8015a50: b580         	push	{r7, lr}
 8015a52: b08a         	sub	sp, #0x28
 8015a54: af04         	add	r7, sp, #0x10
 8015a56: 60b9         	str	r1, [r7, #0x8]
 8015a58: 607b         	str	r3, [r7, #0x4]
 8015a5a: 4603         	mov	r3, r0
 8015a5c: 73fb         	strb	r3, [r7, #0xf]
 8015a5e: 4613         	mov	r3, r2
 8015a60: 73bb         	strb	r3, [r7, #0xe]
; 	va_start(ap, fmt);
 8015a62: f107 032c    	add.w	r3, r7, #0x2c
 8015a66: 617b         	str	r3, [r7, #0x14]
; 	z_log_msg_runtime_vcreate(domain_id, source, level,
 8015a68: 7bba         	ldrb	r2, [r7, #0xe]
 8015a6a: 7bf8         	ldrb	r0, [r7, #0xf]
 8015a6c: 697b         	ldr	r3, [r7, #0x14]
 8015a6e: 9303         	str	r3, [sp, #0xc]
 8015a70: 6abb         	ldr	r3, [r7, #0x28]
 8015a72: 9302         	str	r3, [sp, #0x8]
 8015a74: 6a7b         	ldr	r3, [r7, #0x24]
 8015a76: 9301         	str	r3, [sp, #0x4]
 8015a78: 6a3b         	ldr	r3, [r7, #0x20]
 8015a7a: 9300         	str	r3, [sp]
 8015a7c: 687b         	ldr	r3, [r7, #0x4]
 8015a7e: 68b9         	ldr	r1, [r7, #0x8]
 8015a80: f7ee fd76    	bl	0x8004570 <z_log_msg_runtime_vcreate> @ imm = #-0x11514
; }
 8015a84: bf00         	nop
 8015a86: 3718         	adds	r7, #0x18
 8015a88: 46bd         	mov	sp, r7
 8015a8a: bd80         	pop	{r7, pc}

08015a8c <z_do_kernel_oops>:
; {
 8015a8c: b580         	push	{r7, lr}
 8015a8e: b088         	sub	sp, #0x20
 8015a90: af00         	add	r7, sp, #0x0
 8015a92: 60f8         	str	r0, [r7, #0xc]
 8015a94: 60b9         	str	r1, [r7, #0x8]
 8015a96: 607a         	str	r2, [r7, #0x4]
; 	unsigned int reason = esf->basic.r0;
 8015a98: 68fb         	ldr	r3, [r7, #0xc]
 8015a9a: 681b         	ldr	r3, [r3]
 8015a9c: 61fb         	str	r3, [r7, #0x1c]
 8015a9e: 68fb         	ldr	r3, [r7, #0xc]
 8015aa0: 61bb         	str	r3, [r7, #0x18]
 8015aa2: 687b         	ldr	r3, [r7, #0x4]
 8015aa4: 617b         	str	r3, [r7, #0x14]
; }
 8015aa6: bf00         	nop
; 	z_arm_fatal_error(reason, esf);
 8015aa8: 68f9         	ldr	r1, [r7, #0xc]
 8015aaa: 69f8         	ldr	r0, [r7, #0x1c]
 8015aac: f7ef f9ea    	bl	0x8004e84 <z_arm_fatal_error> @ imm = #-0x10c2c
; }
 8015ab0: bf00         	nop
 8015ab2: 3720         	adds	r7, #0x20
 8015ab4: 46bd         	mov	sp, r7
 8015ab6: bd80         	pop	{r7, pc}

08015ab8 <arch_tls_stack_setup>:
; {
 8015ab8: b580         	push	{r7, lr}
 8015aba: b082         	sub	sp, #0x8
 8015abc: af00         	add	r7, sp, #0x0
 8015abe: 6078         	str	r0, [r7, #0x4]
 8015ac0: 6039         	str	r1, [r7]
; 	stack_ptr -= z_tls_data_size();
 8015ac2: f7ef fa2b    	bl	0x8004f1c <z_tls_data_size> @ imm = #-0x10baa
 8015ac6: 4603         	mov	r3, r0
 8015ac8: 425b         	rsbs	r3, r3, #0
 8015aca: 683a         	ldr	r2, [r7]
 8015acc: 4413         	add	r3, r2
 8015ace: 603b         	str	r3, [r7]
; 	z_tls_copy(stack_ptr);
 8015ad0: 6838         	ldr	r0, [r7]
 8015ad2: f7ef fa31    	bl	0x8004f38 <z_tls_copy>  @ imm = #-0x10b9e
; 	stack_ptr -= sizeof(uintptr_t) * 2;
 8015ad6: 683b         	ldr	r3, [r7]
 8015ad8: 3b08         	subs	r3, #0x8
 8015ada: 603b         	str	r3, [r7]
; 	new_thread->tls = POINTER_TO_UINT(stack_ptr);
 8015adc: 683a         	ldr	r2, [r7]
 8015ade: 687b         	ldr	r3, [r7, #0x4]
 8015ae0: f8c3 20c4    	str.w	r2, [r3, #0xc4]
; 	return (z_tls_data_size() + (sizeof(uintptr_t) * 2));
 8015ae4: f7ef fa1a    	bl	0x8004f1c <z_tls_data_size> @ imm = #-0x10bcc
 8015ae8: 4603         	mov	r3, r0
 8015aea: 3308         	adds	r3, #0x8
; }
 8015aec: 4618         	mov	r0, r3
 8015aee: 3708         	adds	r7, #0x8
 8015af0: 46bd         	mov	sp, r7
 8015af2: bd80         	pop	{r7, pc}

08015af4 <z_log_msg_runtime_create>:
; {
 8015af4: b580         	push	{r7, lr}
 8015af6: b08a         	sub	sp, #0x28
 8015af8: af04         	add	r7, sp, #0x10
 8015afa: 60b9         	str	r1, [r7, #0x8]
 8015afc: 607b         	str	r3, [r7, #0x4]
 8015afe: 4603         	mov	r3, r0
 8015b00: 73fb         	strb	r3, [r7, #0xf]
 8015b02: 4613         	mov	r3, r2
 8015b04: 73bb         	strb	r3, [r7, #0xe]
; 	va_start(ap, fmt);
 8015b06: f107 032c    	add.w	r3, r7, #0x2c
 8015b0a: 617b         	str	r3, [r7, #0x14]
; 	z_log_msg_runtime_vcreate(domain_id, source, level,
 8015b0c: 7bba         	ldrb	r2, [r7, #0xe]
 8015b0e: 7bf8         	ldrb	r0, [r7, #0xf]
 8015b10: 697b         	ldr	r3, [r7, #0x14]
 8015b12: 9303         	str	r3, [sp, #0xc]
 8015b14: 6abb         	ldr	r3, [r7, #0x28]
 8015b16: 9302         	str	r3, [sp, #0x8]
 8015b18: 6a7b         	ldr	r3, [r7, #0x24]
 8015b1a: 9301         	str	r3, [sp, #0x4]
 8015b1c: 6a3b         	ldr	r3, [r7, #0x20]
 8015b1e: 9300         	str	r3, [sp]
 8015b20: 687b         	ldr	r3, [r7, #0x4]
 8015b22: 68b9         	ldr	r1, [r7, #0x8]
 8015b24: f7ee fd24    	bl	0x8004570 <z_log_msg_runtime_vcreate> @ imm = #-0x115b8
; }
 8015b28: bf00         	nop
 8015b2a: 3718         	adds	r7, #0x18
 8015b2c: 46bd         	mov	sp, r7
 8015b2e: bd80         	pop	{r7, pc}

08015b30 <fault_show>:
; {
 8015b30: b480         	push	{r7}
 8015b32: b083         	sub	sp, #0xc
 8015b34: af00         	add	r7, sp, #0x0
 8015b36: 6078         	str	r0, [r7, #0x4]
 8015b38: 6039         	str	r1, [r7]
; }
 8015b3a: bf00         	nop
 8015b3c: 370c         	adds	r7, #0xc
 8015b3e: 46bd         	mov	sp, r7
 8015b40: bc80         	pop	{r7}
 8015b42: 4770         	bx	lr

08015b44 <memory_fault_recoverable>:
; {
 8015b44: b480         	push	{r7}
 8015b46: b083         	sub	sp, #0xc
 8015b48: af00         	add	r7, sp, #0x0
 8015b4a: 6078         	str	r0, [r7, #0x4]
 8015b4c: 460b         	mov	r3, r1
 8015b4e: 70fb         	strb	r3, [r7, #0x3]
; 	return false;
 8015b50: 2300         	movs	r3, #0x0
; }
 8015b52: 4618         	mov	r0, r3
 8015b54: 370c         	adds	r7, #0xc
 8015b56: 46bd         	mov	sp, r7
 8015b58: bc80         	pop	{r7}
 8015b5a: 4770         	bx	lr

08015b5c <arch_irq_enable>:
; {
 8015b5c: b580         	push	{r7, lr}
 8015b5e: b082         	sub	sp, #0x8
 8015b60: af00         	add	r7, sp, #0x0
 8015b62: 6078         	str	r0, [r7, #0x4]
; 	NVIC_EnableIRQ((IRQn_Type)irq);
 8015b64: 687b         	ldr	r3, [r7, #0x4]
 8015b66: b25b         	sxtb	r3, r3
 8015b68: 4618         	mov	r0, r3
 8015b6a: f7f0 f94b    	bl	0x8005e04 <__NVIC_EnableIRQ> @ imm = #-0xfd6a
; }
 8015b6e: bf00         	nop
 8015b70: 3708         	adds	r7, #0x8
 8015b72: 46bd         	mov	sp, r7
 8015b74: bd80         	pop	{r7, pc}

08015b76 <z_arm_irq_priority_set>:
; {
 8015b76: b580         	push	{r7, lr}
 8015b78: b084         	sub	sp, #0x10
 8015b7a: af00         	add	r7, sp, #0x0
 8015b7c: 60f8         	str	r0, [r7, #0xc]
 8015b7e: 60b9         	str	r1, [r7, #0x8]
 8015b80: 607a         	str	r2, [r7, #0x4]
; 		prio += _IRQ_PRIO_OFFSET;
 8015b82: 68bb         	ldr	r3, [r7, #0x8]
 8015b84: 3301         	adds	r3, #0x1
 8015b86: 60bb         	str	r3, [r7, #0x8]
; 	NVIC_SetPriority((IRQn_Type)irq, prio);
 8015b88: 68fb         	ldr	r3, [r7, #0xc]
 8015b8a: b25b         	sxtb	r3, r3
 8015b8c: 68b9         	ldr	r1, [r7, #0x8]
 8015b8e: 4618         	mov	r0, r3
 8015b90: f7f0 f954    	bl	0x8005e3c <__NVIC_SetPriority> @ imm = #-0xfd58
; }
 8015b94: bf00         	nop
 8015b96: 3710         	adds	r7, #0x10
 8015b98: 46bd         	mov	sp, r7
 8015b9a: bd80         	pop	{r7, pc}

08015b9c <z_irq_spurious>:
; {
 8015b9c: b580         	push	{r7, lr}
 8015b9e: b082         	sub	sp, #0x8
 8015ba0: af00         	add	r7, sp, #0x0
 8015ba2: 6078         	str	r0, [r7, #0x4]
; 	z_arm_fatal_error(K_ERR_SPURIOUS_IRQ, NULL);
 8015ba4: 2100         	movs	r1, #0x0
 8015ba6: 2001         	movs	r0, #0x1
 8015ba8: f7ef f96c    	bl	0x8004e84 <z_arm_fatal_error> @ imm = #-0x10d28
; }
 8015bac: bf00         	nop
 8015bae: 3708         	adds	r7, #0x8
 8015bb0: 46bd         	mov	sp, r7
 8015bb2: bd80         	pop	{r7, pc}

08015bb4 <z_prep_c>:
; {
 8015bb4: b580         	push	{r7, lr}
 8015bb6: af00         	add	r7, sp, #0x0
; 	relocate_vector_table();
 8015bb8: f7f0 f96a    	bl	0x8005e90 <relocate_vector_table> @ imm = #-0xfd2c
; 	z_arm_floating_point_init();
 8015bbc: f7f0 f982    	bl	0x8005ec4 <z_arm_floating_point_init> @ imm = #-0xfcfc
; 	z_bss_zero();
 8015bc0: f7f7 fee6    	bl	0x800d990 <z_bss_zero>  @ imm = #-0x8234
; 	z_data_copy();
 8015bc4: f7fa ffe2    	bl	0x8010b8c <z_data_copy> @ imm = #-0x503c
; 	z_arm_interrupt_init();
 8015bc8: f000 f83d    	bl	0x8015c46 <z_arm_interrupt_init> @ imm = #0x7a
; 	z_cstart();
 8015bcc: f7f8 f81a    	bl	0x800dc04 <z_cstart>    @ imm = #-0x7fcc

08015bd0 <z_arm_prepare_switch_to_main>:
; {
 8015bd0: b480         	push	{r7}
 8015bd2: af00         	add	r7, sp, #0x0
; }
 8015bd4: bf00         	nop
 8015bd6: 46bd         	mov	sp, r7
 8015bd8: bc80         	pop	{r7}
 8015bda: 4770         	bx	lr

08015bdc <arch_irq_unlock_outlined>:
; {
 8015bdc: b480         	push	{r7}
 8015bde: b085         	sub	sp, #0x14
 8015be0: af00         	add	r7, sp, #0x0
 8015be2: 6078         	str	r0, [r7, #0x4]
;   __ASM volatile ("cpsie f" : : : "memory");
 8015be4: b661         	cpsie f
; }
 8015be6: bf00         	nop
;   __ASM volatile ("cpsie i" : : : "memory");
 8015be8: b662         	cpsie i
; }
 8015bea: bf00         	nop
 8015bec: 687b         	ldr	r3, [r7, #0x4]
 8015bee: 60fb         	str	r3, [r7, #0xc]
 8015bf0: 68fb         	ldr	r3, [r7, #0xc]
 8015bf2: 60bb         	str	r3, [r7, #0x8]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8015bf4: 68bb         	ldr	r3, [r7, #0x8]
 8015bf6: f383 8811    	msr	basepri, r3
; }
 8015bfa: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8015bfc: f3bf 8f6f    	isb	sy
; }
 8015c00: bf00         	nop
; }
 8015c02: bf00         	nop
; }
 8015c04: bf00         	nop
 8015c06: 3714         	adds	r7, #0x14
 8015c08: 46bd         	mov	sp, r7
 8015c0a: bc80         	pop	{r7}
 8015c0c: 4770         	bx	lr

08015c0e <arch_cpu_idle>:
; {
 8015c0e: b480         	push	{r7}
 8015c10: b083         	sub	sp, #0xc
 8015c12: af00         	add	r7, sp, #0x0
;   __ASM volatile ("cpsid i" : : : "memory");
 8015c14: b672         	cpsid i
; }
 8015c16: bf00         	nop
 8015c18: 2300         	movs	r3, #0x0
 8015c1a: 607b         	str	r3, [r7, #0x4]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8015c1c: 687b         	ldr	r3, [r7, #0x4]
 8015c1e: f383 8811    	msr	basepri, r3
; }
 8015c22: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8015c24: f3bf 8f6f    	isb	sy
; }
 8015c28: bf00         	nop
;   __ASM volatile ("dsb 0xF":::"memory");
 8015c2a: f3bf 8f4f    	dsb	sy
; }
 8015c2e: bf00         	nop
; 	SLEEP_IF_ALLOWED(__WFI);
 8015c30: bf30         	wfi
;   __ASM volatile ("cpsie i" : : : "memory");
 8015c32: b662         	cpsie i
; }
 8015c34: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8015c36: f3bf 8f6f    	isb	sy
; }
 8015c3a: bf00         	nop
; }
 8015c3c: bf00         	nop
 8015c3e: 370c         	adds	r7, #0xc
 8015c40: 46bd         	mov	sp, r7
 8015c42: bc80         	pop	{r7}
 8015c44: 4770         	bx	lr

08015c46 <z_arm_interrupt_init>:
; {
 8015c46: b580         	push	{r7, lr}
 8015c48: b082         	sub	sp, #0x8
 8015c4a: af00         	add	r7, sp, #0x0
; 	int irq = 0;
 8015c4c: 2300         	movs	r3, #0x0
 8015c4e: 607b         	str	r3, [r7, #0x4]
; 	for (; irq < CONFIG_NUM_IRQS; irq++) {
 8015c50: e008         	b	0x8015c64 <z_arm_interrupt_init+0x1e> @ imm = #0x10
; 		NVIC_SetPriority((IRQn_Type)irq, _IRQ_PRIO_OFFSET);
 8015c52: 687b         	ldr	r3, [r7, #0x4]
 8015c54: b25b         	sxtb	r3, r3
 8015c56: 2101         	movs	r1, #0x1
 8015c58: 4618         	mov	r0, r3
 8015c5a: f7f0 f9c1    	bl	0x8005fe0 <__NVIC_SetPriority> @ imm = #-0xfc7e
; 	for (; irq < CONFIG_NUM_IRQS; irq++) {
 8015c5e: 687b         	ldr	r3, [r7, #0x4]
 8015c60: 3301         	adds	r3, #0x1
 8015c62: 607b         	str	r3, [r7, #0x4]
 8015c64: 687b         	ldr	r3, [r7, #0x4]
 8015c66: 2b51         	cmp	r3, #0x51
 8015c68: ddf3         	ble	0x8015c52 <z_arm_interrupt_init+0xc> @ imm = #-0x1a
; }
 8015c6a: bf00         	nop
 8015c6c: bf00         	nop
 8015c6e: 3708         	adds	r7, #0x8
 8015c70: 46bd         	mov	sp, r7
 8015c72: bd80         	pop	{r7, pc}

08015c74 <cbputc>:
; {
 8015c74: b580         	push	{r7, lr}
 8015c76: b084         	sub	sp, #0x10
 8015c78: af00         	add	r7, sp, #0x0
 8015c7a: 4603         	mov	r3, r0
 8015c7c: 6039         	str	r1, [r7]
 8015c7e: 71fb         	strb	r3, [r7, #0x7]
; 	struct cb_bits *s = (struct cb_bits *) _s;
 8015c80: 683b         	ldr	r3, [r7]
 8015c82: 60fb         	str	r3, [r7, #0xc]
; 	(*s->out) (c, s->ctx);
 8015c84: 68fb         	ldr	r3, [r7, #0xc]
 8015c86: 691b         	ldr	r3, [r3, #0x10]
 8015c88: 79f8         	ldrb	r0, [r7, #0x7]
 8015c8a: 68fa         	ldr	r2, [r7, #0xc]
 8015c8c: 6952         	ldr	r2, [r2, #0x14]
 8015c8e: 4611         	mov	r1, r2
 8015c90: 4798         	blx	r3
; 	return 0;
 8015c92: 2300         	movs	r3, #0x0
; }
 8015c94: 4618         	mov	r0, r3
 8015c96: 3710         	adds	r7, #0x10
 8015c98: 46bd         	mov	sp, r7
 8015c9a: bd80         	pop	{r7, pc}

08015c9c <zephyr_fputc>:
; {
 8015c9c: b580         	push	{r7, lr}
 8015c9e: b082         	sub	sp, #0x8
 8015ca0: af00         	add	r7, sp, #0x0
 8015ca2: 6078         	str	r0, [r7, #0x4]
 8015ca4: 6039         	str	r1, [r7]
; 	return z_impl_zephyr_fputc(c, stream);
 8015ca6: 6839         	ldr	r1, [r7]
 8015ca8: 6878         	ldr	r0, [r7, #0x4]
 8015caa: f7f0 fa07    	bl	0x80060bc <z_impl_zephyr_fputc> @ imm = #-0xfbf2
 8015cae: 4603         	mov	r3, r0
; }
 8015cb0: 4618         	mov	r0, r3
 8015cb2: 3708         	adds	r7, #0x8
 8015cb4: 46bd         	mov	sp, r7
 8015cb6: bd80         	pop	{r7, pc}

08015cb8 <picolibc_put>:
; {
 8015cb8: b580         	push	{r7, lr}
 8015cba: b082         	sub	sp, #0x8
 8015cbc: af00         	add	r7, sp, #0x0
 8015cbe: 4603         	mov	r3, r0
 8015cc0: 6039         	str	r1, [r7]
 8015cc2: 71fb         	strb	r3, [r7, #0x7]
; 	zephyr_fputc(a, f);
 8015cc4: 79fb         	ldrb	r3, [r7, #0x7]
 8015cc6: 6839         	ldr	r1, [r7]
 8015cc8: 4618         	mov	r0, r3
 8015cca: f7ff ffe7    	bl	0x8015c9c <zephyr_fputc> @ imm = #-0x32
; 	return 0;
 8015cce: 2300         	movs	r3, #0x0
; }
 8015cd0: 4618         	mov	r0, r3
 8015cd2: 3708         	adds	r7, #0x8
 8015cd4: 46bd         	mov	sp, r7
 8015cd6: bd80         	pop	{r7, pc}

08015cd8 <k_mutex_lock>:
; {
 8015cd8: b580         	push	{r7, lr}
 8015cda: b084         	sub	sp, #0x10
 8015cdc: af00         	add	r7, sp, #0x0
 8015cde: 60f8         	str	r0, [r7, #0xc]
 8015ce0: e9c7 2300    	strd	r2, r3, [r7]
; 	return z_impl_k_mutex_lock(mutex, timeout);
 8015ce4: e9d7 2300    	ldrd	r2, r3, [r7]
 8015ce8: 68f8         	ldr	r0, [r7, #0xc]
 8015cea: f7f8 f849    	bl	0x800dd80 <z_impl_k_mutex_lock> @ imm = #-0x7f6e
 8015cee: 4603         	mov	r3, r0
; }
 8015cf0: 4618         	mov	r0, r3
 8015cf2: 3710         	adds	r7, #0x10
 8015cf4: 46bd         	mov	sp, r7
 8015cf6: bd80         	pop	{r7, pc}

08015cf8 <k_mutex_unlock>:
; {
 8015cf8: b580         	push	{r7, lr}
 8015cfa: b082         	sub	sp, #0x8
 8015cfc: af00         	add	r7, sp, #0x0
 8015cfe: 6078         	str	r0, [r7, #0x4]
; 	return z_impl_k_mutex_unlock(mutex);
 8015d00: 6878         	ldr	r0, [r7, #0x4]
 8015d02: f7f8 fa87    	bl	0x800e214 <z_impl_k_mutex_unlock> @ imm = #-0x7af2
 8015d06: 4603         	mov	r3, r0
; }
 8015d08: 4618         	mov	r0, r3
 8015d0a: 3708         	adds	r7, #0x8
 8015d0c: 46bd         	mov	sp, r7
 8015d0e: bd80         	pop	{r7, pc}

08015d10 <sys_mutex_lock>:
; {
 8015d10: b580         	push	{r7, lr}
 8015d12: b084         	sub	sp, #0x10
 8015d14: af00         	add	r7, sp, #0x0
 8015d16: 60f8         	str	r0, [r7, #0xc]
 8015d18: e9c7 2300    	strd	r2, r3, [r7]
; 	return k_mutex_lock(&mutex->kernel_mutex, timeout);
 8015d1c: 68f9         	ldr	r1, [r7, #0xc]
 8015d1e: e9d7 2300    	ldrd	r2, r3, [r7]
 8015d22: 4608         	mov	r0, r1
 8015d24: f7ff ffd8    	bl	0x8015cd8 <k_mutex_lock> @ imm = #-0x50
 8015d28: 4603         	mov	r3, r0
; }
 8015d2a: 4618         	mov	r0, r3
 8015d2c: 3710         	adds	r7, #0x10
 8015d2e: 46bd         	mov	sp, r7
 8015d30: bd80         	pop	{r7, pc}

08015d32 <sys_mutex_unlock>:
; {
 8015d32: b580         	push	{r7, lr}
 8015d34: b082         	sub	sp, #0x8
 8015d36: af00         	add	r7, sp, #0x0
 8015d38: 6078         	str	r0, [r7, #0x4]
; 	return k_mutex_unlock(&mutex->kernel_mutex);
 8015d3a: 687b         	ldr	r3, [r7, #0x4]
 8015d3c: 4618         	mov	r0, r3
 8015d3e: f7ff ffdb    	bl	0x8015cf8 <k_mutex_unlock> @ imm = #-0x4a
 8015d42: 4603         	mov	r3, r0
; }
 8015d44: 4618         	mov	r0, r3
 8015d46: 3708         	adds	r7, #0x8
 8015d48: 46bd         	mov	sp, r7
 8015d4a: bd80         	pop	{r7, pc}

08015d4c <clock_control_on>:
; {
 8015d4c: b580         	push	{r7, lr}
 8015d4e: b084         	sub	sp, #0x10
 8015d50: af00         	add	r7, sp, #0x0
 8015d52: 6078         	str	r0, [r7, #0x4]
 8015d54: 6039         	str	r1, [r7]
; 	const struct clock_control_driver_api *api =
 8015d56: 687b         	ldr	r3, [r7, #0x4]
 8015d58: 689b         	ldr	r3, [r3, #0x8]
 8015d5a: 60fb         	str	r3, [r7, #0xc]
; 	return api->on(dev, sys);
 8015d5c: 68fb         	ldr	r3, [r7, #0xc]
 8015d5e: 681b         	ldr	r3, [r3]
 8015d60: 6839         	ldr	r1, [r7]
 8015d62: 6878         	ldr	r0, [r7, #0x4]
 8015d64: 4798         	blx	r3
 8015d66: 4603         	mov	r3, r0
; }
 8015d68: 4618         	mov	r0, r3
 8015d6a: 3710         	adds	r7, #0x10
 8015d6c: 46bd         	mov	sp, r7
 8015d6e: bd80         	pop	{r7, pc}

08015d70 <z_stm32_hsem_lock>:
; {
 8015d70: b480         	push	{r7}
 8015d72: b083         	sub	sp, #0xc
 8015d74: af00         	add	r7, sp, #0x0
 8015d76: 6078         	str	r0, [r7, #0x4]
 8015d78: 6039         	str	r1, [r7]
; }
 8015d7a: bf00         	nop
 8015d7c: 370c         	adds	r7, #0xc
 8015d7e: 46bd         	mov	sp, r7
 8015d80: bc80         	pop	{r7}
 8015d82: 4770         	bx	lr

08015d84 <z_stm32_hsem_unlock>:
; {
 8015d84: b480         	push	{r7}
 8015d86: b083         	sub	sp, #0xc
 8015d88: af00         	add	r7, sp, #0x0
 8015d8a: 6078         	str	r0, [r7, #0x4]
; }
 8015d8c: bf00         	nop
 8015d8e: 370c         	adds	r7, #0xc
 8015d90: 46bd         	mov	sp, r7
 8015d92: bc80         	pop	{r7}
 8015d94: 4770         	bx	lr

08015d96 <stm32_exti_linenum_to_src_cfg_line>:
; {
 8015d96: b480         	push	{r7}
 8015d98: b083         	sub	sp, #0xc
 8015d9a: af00         	add	r7, sp, #0x0
 8015d9c: 4603         	mov	r3, r0
 8015d9e: 71fb         	strb	r3, [r7, #0x7]
; 	return (0xF << ((linenum % 4 * 4) + 16)) | (linenum / 4);
 8015da0: 79fb         	ldrb	r3, [r7, #0x7]
 8015da2: f003 0303    	and	r3, r3, #0x3
 8015da6: 3304         	adds	r3, #0x4
 8015da8: 009b         	lsls	r3, r3, #0x2
 8015daa: 220f         	movs	r2, #0xf
 8015dac: fa02 f303    	lsl.w	r3, r2, r3
 8015db0: 79fa         	ldrb	r2, [r7, #0x7]
 8015db2: 0892         	lsrs	r2, r2, #0x2
 8015db4: b2d2         	uxtb	r2, r2
 8015db6: 4313         	orrs	r3, r2
; }
 8015db8: 4618         	mov	r0, r3
 8015dba: 370c         	adds	r7, #0xc
 8015dbc: 46bd         	mov	sp, r7
 8015dbe: bc80         	pop	{r7}
 8015dc0: 4770         	bx	lr

08015dc2 <stm32_exti_is_pending>:
; {
 8015dc2: b580         	push	{r7, lr}
 8015dc4: b082         	sub	sp, #0x8
 8015dc6: af00         	add	r7, sp, #0x0
 8015dc8: 6078         	str	r0, [r7, #0x4]
; 	return LL_EXTI_IsActiveFlag_0_31(line);
 8015dca: 6878         	ldr	r0, [r7, #0x4]
 8015dcc: f7f0 fa6c    	bl	0x80062a8 <LL_EXTI_IsActiveFlag_0_31> @ imm = #-0xfb28
 8015dd0: 4603         	mov	r3, r0
; }
 8015dd2: 4618         	mov	r0, r3
 8015dd4: 3708         	adds	r7, #0x8
 8015dd6: 46bd         	mov	sp, r7
 8015dd8: bd80         	pop	{r7, pc}

08015dda <stm32_exti_clear_pending>:
; {
 8015dda: b580         	push	{r7, lr}
 8015ddc: b082         	sub	sp, #0x8
 8015dde: af00         	add	r7, sp, #0x0
 8015de0: 6078         	str	r0, [r7, #0x4]
; 	LL_EXTI_ClearFlag_0_31(line);
 8015de2: 6878         	ldr	r0, [r7, #0x4]
 8015de4: f7f0 fa76    	bl	0x80062d4 <LL_EXTI_ClearFlag_0_31> @ imm = #-0xfb14
; }
 8015de8: bf00         	nop
 8015dea: 3708         	adds	r7, #0x8
 8015dec: 46bd         	mov	sp, r7
 8015dee: bd80         	pop	{r7, pc}

08015df0 <linenum_to_ll_exti_line>:
; {
 8015df0: b480         	push	{r7}
 8015df2: b083         	sub	sp, #0xc
 8015df4: af00         	add	r7, sp, #0x0
 8015df6: 4603         	mov	r3, r0
 8015df8: 71fb         	strb	r3, [r7, #0x7]
; 	return BIT(linenum);
 8015dfa: 79fb         	ldrb	r3, [r7, #0x7]
 8015dfc: 2201         	movs	r2, #0x1
 8015dfe: fa02 f303    	lsl.w	r3, r2, r3
; }
 8015e02: 4618         	mov	r0, r3
 8015e04: 370c         	adds	r7, #0xc
 8015e06: 46bd         	mov	sp, r7
 8015e08: bc80         	pop	{r7}
 8015e0a: 4770         	bx	lr

08015e0c <ll_exti_line_to_linenum>:
; {
 8015e0c: b480         	push	{r7}
 8015e0e: b083         	sub	sp, #0xc
 8015e10: af00         	add	r7, sp, #0x0
 8015e12: 6078         	str	r0, [r7, #0x4]
; 	return LOG2(line);
 8015e14: 687b         	ldr	r3, [r7, #0x4]
 8015e16: 2b00         	cmp	r3, #0x0
 8015e18: d007         	beq	0x8015e2a <ll_exti_line_to_linenum+0x1e> @ imm = #0xe
 8015e1a: 687b         	ldr	r3, [r7, #0x4]
 8015e1c: fab3 f383    	clz	r3, r3
 8015e20: b2db         	uxtb	r3, r3
 8015e22: f1c3 031f    	rsb.w	r3, r3, #0x1f
 8015e26: b2db         	uxtb	r3, r3
 8015e28: e000         	b	0x8015e2c <ll_exti_line_to_linenum+0x20> @ imm = #0x0
 8015e2a: 23ff         	movs	r3, #0xff
; }
 8015e2c: 4618         	mov	r0, r3
 8015e2e: 370c         	adds	r7, #0xc
 8015e30: 46bd         	mov	sp, r7
 8015e32: bc80         	pop	{r7}
 8015e34: 4770         	bx	lr

08015e36 <stm32_gpio_intc_get_pin_irq_line>:
; {
 8015e36: b580         	push	{r7, lr}
 8015e38: b082         	sub	sp, #0x8
 8015e3a: af00         	add	r7, sp, #0x0
 8015e3c: 6078         	str	r0, [r7, #0x4]
 8015e3e: 460b         	mov	r3, r1
 8015e40: 70fb         	strb	r3, [r7, #0x3]
; 	return linenum_to_ll_exti_line(pin);
 8015e42: 78fb         	ldrb	r3, [r7, #0x3]
 8015e44: 4618         	mov	r0, r3
 8015e46: f7ff ffd3    	bl	0x8015df0 <linenum_to_ll_exti_line> @ imm = #-0x5a
 8015e4a: 4603         	mov	r3, r0
; }
 8015e4c: 4618         	mov	r0, r3
 8015e4e: 3708         	adds	r7, #0x8
 8015e50: 46bd         	mov	sp, r7
 8015e52: bd80         	pop	{r7, pc}

08015e54 <stm32_gpio_intc_disable_line>:
; {
 8015e54: b580         	push	{r7, lr}
 8015e56: b082         	sub	sp, #0x8
 8015e58: af00         	add	r7, sp, #0x0
 8015e5a: 6078         	str	r0, [r7, #0x4]
; 	LL_EXTI_DisableIT_0_31(line);
 8015e5c: 6878         	ldr	r0, [r7, #0x4]
 8015e5e: f7f0 f9c9    	bl	0x80061f4 <LL_EXTI_DisableIT_0_31> @ imm = #-0xfc6e
; }
 8015e62: bf00         	nop
 8015e64: 3708         	adds	r7, #0x8
 8015e66: 46bd         	mov	sp, r7
 8015e68: bd80         	pop	{r7, pc}

08015e6a <stm32_exti_set_line_src_port>:
; {
 8015e6a: b580         	push	{r7, lr}
 8015e6c: b084         	sub	sp, #0x10
 8015e6e: af00         	add	r7, sp, #0x0
 8015e70: 4603         	mov	r3, r0
 8015e72: 6039         	str	r1, [r7]
 8015e74: 71fb         	strb	r3, [r7, #0x7]
; 	uint32_t ll_line = stm32_exti_linenum_to_src_cfg_line(line);
 8015e76: 79fb         	ldrb	r3, [r7, #0x7]
 8015e78: 4618         	mov	r0, r3
 8015e7a: f7ff ff8c    	bl	0x8015d96 <stm32_exti_linenum_to_src_cfg_line> @ imm = #-0xe8
 8015e7e: 60f8         	str	r0, [r7, #0xc]
; 	z_stm32_hsem_lock(CFG_HW_EXTI_SEMID, HSEM_LOCK_DEFAULT_RETRY);
 8015e80: f44f 1180    	mov.w	r1, #0x100000
 8015e84: 2000         	movs	r0, #0x0
 8015e86: f7ff ff73    	bl	0x8015d70 <z_stm32_hsem_lock> @ imm = #-0x11a
; 	LL_SYSCFG_SetEXTISource(port, ll_line);
 8015e8a: 68f9         	ldr	r1, [r7, #0xc]
 8015e8c: 6838         	ldr	r0, [r7]
 8015e8e: f7f0 fa2f    	bl	0x80062f0 <LL_SYSCFG_SetEXTISource> @ imm = #-0xfba2
; 	z_stm32_hsem_unlock(CFG_HW_EXTI_SEMID);
 8015e92: 2000         	movs	r0, #0x0
 8015e94: f7ff ff76    	bl	0x8015d84 <z_stm32_hsem_unlock> @ imm = #-0x114
; }
 8015e98: bf00         	nop
 8015e9a: 3710         	adds	r7, #0x10
 8015e9c: 46bd         	mov	sp, r7
 8015e9e: bd80         	pop	{r7, pc}

08015ea0 <stm32_exti_get_line_src_port>:
; {
 8015ea0: b580         	push	{r7, lr}
 8015ea2: b084         	sub	sp, #0x10
 8015ea4: af00         	add	r7, sp, #0x0
 8015ea6: 4603         	mov	r3, r0
 8015ea8: 71fb         	strb	r3, [r7, #0x7]
; 	uint32_t ll_line = stm32_exti_linenum_to_src_cfg_line(line);
 8015eaa: 79fb         	ldrb	r3, [r7, #0x7]
 8015eac: 4618         	mov	r0, r3
 8015eae: f7ff ff72    	bl	0x8015d96 <stm32_exti_linenum_to_src_cfg_line> @ imm = #-0x11c
 8015eb2: 60f8         	str	r0, [r7, #0xc]
; 	port = LL_SYSCFG_GetEXTISource(ll_line);
 8015eb4: 68f8         	ldr	r0, [r7, #0xc]
 8015eb6: f7f0 fa4f    	bl	0x8006358 <LL_SYSCFG_GetEXTISource> @ imm = #-0xfb62
 8015eba: 60b8         	str	r0, [r7, #0x8]
; 	return port;
 8015ebc: 68bb         	ldr	r3, [r7, #0x8]
; }
 8015ebe: 4618         	mov	r0, r3
 8015ec0: 3710         	adds	r7, #0x10
 8015ec2: 46bd         	mov	sp, r7
 8015ec4: bd80         	pop	{r7, pc}

08015ec6 <stm32_clock_control_mco_init>:
; {
 8015ec6: b480         	push	{r7}
 8015ec8: af00         	add	r7, sp, #0x0
; }
 8015eca: bf00         	nop
 8015ecc: 46bd         	mov	sp, r7
 8015ece: bc80         	pop	{r7}
 8015ed0: 4770         	bx	lr

08015ed2 <get_pll_div_frequency>:
; {
 8015ed2: b480         	push	{r7}
 8015ed4: b085         	sub	sp, #0x14
 8015ed6: af00         	add	r7, sp, #0x0
 8015ed8: 60f8         	str	r0, [r7, #0xc]
 8015eda: 60b9         	str	r1, [r7, #0x8]
 8015edc: 607a         	str	r2, [r7, #0x4]
 8015ede: 603b         	str	r3, [r7]
; 	return pllsrc_freq / pllm_div * plln_mul / pllout_div;
 8015ee0: 68bb         	ldr	r3, [r7, #0x8]
 8015ee2: 68fa         	ldr	r2, [r7, #0xc]
 8015ee4: fbb2 f3f3    	udiv	r3, r2, r3
 8015ee8: 687a         	ldr	r2, [r7, #0x4]
 8015eea: fb03 f202    	mul	r2, r3, r2
 8015eee: 683b         	ldr	r3, [r7]
 8015ef0: fbb2 f3f3    	udiv	r3, r2, r3
; }
 8015ef4: 4618         	mov	r0, r3
 8015ef6: 3714         	adds	r7, #0x14
 8015ef8: 46bd         	mov	sp, r7
 8015efa: bc80         	pop	{r7}
 8015efc: 4770         	bx	lr

08015efe <get_bus_clock>:
; {
 8015efe: b480         	push	{r7}
 8015f00: b083         	sub	sp, #0xc
 8015f02: af00         	add	r7, sp, #0x0
 8015f04: 6078         	str	r0, [r7, #0x4]
 8015f06: 6039         	str	r1, [r7]
; 	return clock / prescaler;
 8015f08: 687a         	ldr	r2, [r7, #0x4]
 8015f0a: 683b         	ldr	r3, [r7]
 8015f0c: fbb2 f3f3    	udiv	r3, r2, r3
; }
 8015f10: 4618         	mov	r0, r3
 8015f12: 370c         	adds	r7, #0xc
 8015f14: 46bd         	mov	sp, r7
 8015f16: bc80         	pop	{r7}
 8015f18: 4770         	bx	lr

08015f1a <stm32_clock_control_on>:
; {
 8015f1a: b480         	push	{r7}
 8015f1c: b089         	sub	sp, #0x24
 8015f1e: af00         	add	r7, sp, #0x0
 8015f20: 6078         	str	r0, [r7, #0x4]
 8015f22: 6039         	str	r1, [r7]
; 	struct stm32_pclken *pclken = (struct stm32_pclken *)(sub_system);
 8015f24: 683b         	ldr	r3, [r7]
 8015f26: 61fb         	str	r3, [r7, #0x1c]
; 	if (IN_RANGE(pclken->bus, STM32_PERIPH_BUS_MIN, STM32_PERIPH_BUS_MAX) == 0) {
 8015f28: 69fb         	ldr	r3, [r7, #0x1c]
 8015f2a: 681b         	ldr	r3, [r3]
 8015f2c: 2b2f         	cmp	r3, #0x2f
 8015f2e: d905         	bls	0x8015f3c <stm32_clock_control_on+0x22> @ imm = #0xa
 8015f30: 69fb         	ldr	r3, [r7, #0x1c]
 8015f32: 681b         	ldr	r3, [r3]
 8015f34: 2ba8         	cmp	r3, #0xa8
 8015f36: d801         	bhi	0x8015f3c <stm32_clock_control_on+0x22> @ imm = #0x2
 8015f38: 2301         	movs	r3, #0x1
 8015f3a: e000         	b	0x8015f3e <stm32_clock_control_on+0x24> @ imm = #0x0
 8015f3c: 2300         	movs	r3, #0x0
 8015f3e: 2b00         	cmp	r3, #0x0
 8015f40: d102         	bne	0x8015f48 <stm32_clock_control_on+0x2e> @ imm = #0x4
; 		return -ENOTSUP;
 8015f42: f06f 0385    	mvn	r3, #0x85
 8015f46: e01e         	b	0x8015f86 <stm32_clock_control_on+0x6c> @ imm = #0x3c
; 	sys_set_bits(DT_REG_ADDR(DT_NODELABEL(rcc)) + pclken->bus,
 8015f48: 69fb         	ldr	r3, [r7, #0x1c]
 8015f4a: 681b         	ldr	r3, [r3]
 8015f4c: f103 4380    	add.w	r3, r3, #0x40000000
 8015f50: f503 330e    	add.w	r3, r3, #0x23800
 8015f54: 69fa         	ldr	r2, [r7, #0x1c]
 8015f56: 6852         	ldr	r2, [r2, #0x4]
 8015f58: 617b         	str	r3, [r7, #0x14]
 8015f5a: 613a         	str	r2, [r7, #0x10]
; 	uint32_t temp = *(volatile uint32_t *)addr;
 8015f5c: 697b         	ldr	r3, [r7, #0x14]
 8015f5e: 681b         	ldr	r3, [r3]
 8015f60: 60fb         	str	r3, [r7, #0xc]
; 	*(volatile uint32_t *)addr = temp | mask;
 8015f62: 697b         	ldr	r3, [r7, #0x14]
 8015f64: 6939         	ldr	r1, [r7, #0x10]
 8015f66: 68fa         	ldr	r2, [r7, #0xc]
 8015f68: 430a         	orrs	r2, r1
 8015f6a: 601a         	str	r2, [r3]
; }
 8015f6c: bf00         	nop
; 	temp = sys_read32(DT_REG_ADDR(DT_NODELABEL(rcc)) + pclken->bus);
 8015f6e: 69fb         	ldr	r3, [r7, #0x1c]
 8015f70: 681b         	ldr	r3, [r3]
 8015f72: f103 4380    	add.w	r3, r3, #0x40000000
 8015f76: f503 330e    	add.w	r3, r3, #0x23800
 8015f7a: 61bb         	str	r3, [r7, #0x18]
; 	return *(volatile uint32_t *)addr;
 8015f7c: 69bb         	ldr	r3, [r7, #0x18]
 8015f7e: 681b         	ldr	r3, [r3]
; 	temp = sys_read32(DT_REG_ADDR(DT_NODELABEL(rcc)) + pclken->bus);
 8015f80: 60bb         	str	r3, [r7, #0x8]
; 	UNUSED(temp);
 8015f82: 68bb         	ldr	r3, [r7, #0x8]
; 	return 0;
 8015f84: 2300         	movs	r3, #0x0
; }
 8015f86: 4618         	mov	r0, r3
 8015f88: 3724         	adds	r7, #0x24
 8015f8a: 46bd         	mov	sp, r7
 8015f8c: bc80         	pop	{r7}
 8015f8e: 4770         	bx	lr

08015f90 <stm32_clock_control_off>:
; {
 8015f90: b480         	push	{r7}
 8015f92: b087         	sub	sp, #0x1c
 8015f94: af00         	add	r7, sp, #0x0
 8015f96: 6078         	str	r0, [r7, #0x4]
 8015f98: 6039         	str	r1, [r7]
; 	struct stm32_pclken *pclken = (struct stm32_pclken *)(sub_system);
 8015f9a: 683b         	ldr	r3, [r7]
 8015f9c: 617b         	str	r3, [r7, #0x14]
; 	if (IN_RANGE(pclken->bus, STM32_PERIPH_BUS_MIN, STM32_PERIPH_BUS_MAX) == 0) {
 8015f9e: 697b         	ldr	r3, [r7, #0x14]
 8015fa0: 681b         	ldr	r3, [r3]
 8015fa2: 2b2f         	cmp	r3, #0x2f
 8015fa4: d905         	bls	0x8015fb2 <stm32_clock_control_off+0x22> @ imm = #0xa
 8015fa6: 697b         	ldr	r3, [r7, #0x14]
 8015fa8: 681b         	ldr	r3, [r3]
 8015faa: 2ba8         	cmp	r3, #0xa8
 8015fac: d801         	bhi	0x8015fb2 <stm32_clock_control_off+0x22> @ imm = #0x2
 8015fae: 2301         	movs	r3, #0x1
 8015fb0: e000         	b	0x8015fb4 <stm32_clock_control_off+0x24> @ imm = #0x0
 8015fb2: 2300         	movs	r3, #0x0
 8015fb4: 2b00         	cmp	r3, #0x0
 8015fb6: d102         	bne	0x8015fbe <stm32_clock_control_off+0x2e> @ imm = #0x4
; 		return -ENOTSUP;
 8015fb8: f06f 0385    	mvn	r3, #0x85
 8015fbc: e014         	b	0x8015fe8 <stm32_clock_control_off+0x58> @ imm = #0x28
; 	sys_clear_bits(DT_REG_ADDR(DT_NODELABEL(rcc)) + pclken->bus,
 8015fbe: 697b         	ldr	r3, [r7, #0x14]
 8015fc0: 681b         	ldr	r3, [r3]
 8015fc2: f103 4380    	add.w	r3, r3, #0x40000000
 8015fc6: f503 330e    	add.w	r3, r3, #0x23800
 8015fca: 697a         	ldr	r2, [r7, #0x14]
 8015fcc: 6852         	ldr	r2, [r2, #0x4]
 8015fce: 613b         	str	r3, [r7, #0x10]
 8015fd0: 60fa         	str	r2, [r7, #0xc]
; 	uint32_t temp = *(volatile uint32_t *)addr;
 8015fd2: 693b         	ldr	r3, [r7, #0x10]
 8015fd4: 681b         	ldr	r3, [r3]
 8015fd6: 60bb         	str	r3, [r7, #0x8]
; 	*(volatile uint32_t *)addr = temp & ~mask;
 8015fd8: 68fb         	ldr	r3, [r7, #0xc]
 8015fda: 43d9         	mvns	r1, r3
 8015fdc: 693b         	ldr	r3, [r7, #0x10]
 8015fde: 68ba         	ldr	r2, [r7, #0x8]
 8015fe0: 400a         	ands	r2, r1
 8015fe2: 601a         	str	r2, [r3]
; }
 8015fe4: bf00         	nop
; 	return 0;
 8015fe6: 2300         	movs	r3, #0x0
; }
 8015fe8: 4618         	mov	r0, r3
 8015fea: 371c         	adds	r7, #0x1c
 8015fec: 46bd         	mov	sp, r7
 8015fee: bc80         	pop	{r7}
 8015ff0: 4770         	bx	lr

08015ff2 <stm32_clock_control_configure>:
; {
 8015ff2: b580         	push	{r7, lr}
 8015ff4: b08c         	sub	sp, #0x30
 8015ff6: af00         	add	r7, sp, #0x0
 8015ff8: 60f8         	str	r0, [r7, #0xc]
 8015ffa: 60b9         	str	r1, [r7, #0x8]
 8015ffc: 607a         	str	r2, [r7, #0x4]
; 	struct stm32_pclken *pclken = (struct stm32_pclken *)(sub_system);
 8015ffe: 68bb         	ldr	r3, [r7, #0x8]
 8016000: 62fb         	str	r3, [r7, #0x2c]
; 	err = enabled_clock(pclken->bus);
 8016002: 6afb         	ldr	r3, [r7, #0x2c]
 8016004: 681b         	ldr	r3, [r3]
 8016006: 4618         	mov	r0, r3
 8016008: f7f0 fc8e    	bl	0x8006928 <enabled_clock> @ imm = #-0xf6e4
 801600c: 62b8         	str	r0, [r7, #0x28]
; 	if (err < 0) {
 801600e: 6abb         	ldr	r3, [r7, #0x28]
 8016010: 2b00         	cmp	r3, #0x0
 8016012: da01         	bge	0x8016018 <stm32_clock_control_configure+0x26> @ imm = #0x2
; 		return err;
 8016014: 6abb         	ldr	r3, [r7, #0x28]
 8016016: e043         	b	0x80160a0 <stm32_clock_control_configure+0xae> @ imm = #0x86
; 	if (pclken->enr == NO_SEL) {
 8016018: 6afb         	ldr	r3, [r7, #0x2c]
 801601a: 685b         	ldr	r3, [r3, #0x4]
 801601c: 2bff         	cmp	r3, #0xff
 801601e: d101         	bne	0x8016024 <stm32_clock_control_configure+0x32> @ imm = #0x2
; 		return 0;
 8016020: 2300         	movs	r3, #0x0
 8016022: e03d         	b	0x80160a0 <stm32_clock_control_configure+0xae> @ imm = #0x7a
; 	sys_clear_bits(DT_REG_ADDR(DT_NODELABEL(rcc)) + STM32_CLOCK_REG_GET(pclken->enr),
 8016024: 6afb         	ldr	r3, [r7, #0x2c]
 8016026: 685b         	ldr	r3, [r3, #0x4]
 8016028: b2db         	uxtb	r3, r3
 801602a: f103 4380    	add.w	r3, r3, #0x40000000
 801602e: f503 330e    	add.w	r3, r3, #0x23800
; 		       STM32_CLOCK_MASK_GET(pclken->enr) << STM32_CLOCK_SHIFT_GET(pclken->enr));
 8016032: 6afa         	ldr	r2, [r7, #0x2c]
 8016034: 6852         	ldr	r2, [r2, #0x4]
 8016036: 0b52         	lsrs	r2, r2, #0xd
 8016038: f002 0107    	and	r1, r2, #0x7
 801603c: 6afa         	ldr	r2, [r7, #0x2c]
 801603e: 6852         	ldr	r2, [r2, #0x4]
 8016040: 0a12         	lsrs	r2, r2, #0x8
 8016042: f002 021f    	and	r2, r2, #0x1f
; 	sys_clear_bits(DT_REG_ADDR(DT_NODELABEL(rcc)) + STM32_CLOCK_REG_GET(pclken->enr),
 8016046: fa01 f202    	lsl.w	r2, r1, r2
 801604a: 61bb         	str	r3, [r7, #0x18]
 801604c: 617a         	str	r2, [r7, #0x14]
; 	uint32_t temp = *(volatile uint32_t *)addr;
 801604e: 69bb         	ldr	r3, [r7, #0x18]
 8016050: 681b         	ldr	r3, [r3]
 8016052: 613b         	str	r3, [r7, #0x10]
; 	*(volatile uint32_t *)addr = temp & ~mask;
 8016054: 697b         	ldr	r3, [r7, #0x14]
 8016056: 43d9         	mvns	r1, r3
 8016058: 69bb         	ldr	r3, [r7, #0x18]
 801605a: 693a         	ldr	r2, [r7, #0x10]
 801605c: 400a         	ands	r2, r1
 801605e: 601a         	str	r2, [r3]
; }
 8016060: bf00         	nop
; 	sys_set_bits(DT_REG_ADDR(DT_NODELABEL(rcc)) + STM32_CLOCK_REG_GET(pclken->enr),
 8016062: 6afb         	ldr	r3, [r7, #0x2c]
 8016064: 685b         	ldr	r3, [r3, #0x4]
 8016066: b2db         	uxtb	r3, r3
 8016068: f103 4380    	add.w	r3, r3, #0x40000000
 801606c: f503 330e    	add.w	r3, r3, #0x23800
; 		     STM32_CLOCK_VAL_GET(pclken->enr) << STM32_CLOCK_SHIFT_GET(pclken->enr));
 8016070: 6afa         	ldr	r2, [r7, #0x2c]
 8016072: 6852         	ldr	r2, [r2, #0x4]
 8016074: 0c12         	lsrs	r2, r2, #0x10
 8016076: f002 0107    	and	r1, r2, #0x7
 801607a: 6afa         	ldr	r2, [r7, #0x2c]
 801607c: 6852         	ldr	r2, [r2, #0x4]
 801607e: 0a12         	lsrs	r2, r2, #0x8
 8016080: f002 021f    	and	r2, r2, #0x1f
; 	sys_set_bits(DT_REG_ADDR(DT_NODELABEL(rcc)) + STM32_CLOCK_REG_GET(pclken->enr),
 8016084: fa01 f202    	lsl.w	r2, r1, r2
 8016088: 627b         	str	r3, [r7, #0x24]
 801608a: 623a         	str	r2, [r7, #0x20]
; 	uint32_t temp = *(volatile uint32_t *)addr;
 801608c: 6a7b         	ldr	r3, [r7, #0x24]
 801608e: 681b         	ldr	r3, [r3]
 8016090: 61fb         	str	r3, [r7, #0x1c]
; 	*(volatile uint32_t *)addr = temp | mask;
 8016092: 6a7b         	ldr	r3, [r7, #0x24]
 8016094: 6a39         	ldr	r1, [r7, #0x20]
 8016096: 69fa         	ldr	r2, [r7, #0x1c]
 8016098: 430a         	orrs	r2, r1
 801609a: 601a         	str	r2, [r3]
; }
 801609c: bf00         	nop
; 	return 0;
 801609e: 2300         	movs	r3, #0x0
; }
 80160a0: 4618         	mov	r0, r3
 80160a2: 3730         	adds	r7, #0x30
 80160a4: 46bd         	mov	sp, r7
 80160a6: bd80         	pop	{r7, pc}

080160a8 <stm32_clock_control_get_status>:
; {
 80160a8: b580         	push	{r7, lr}
 80160aa: b084         	sub	sp, #0x10
 80160ac: af00         	add	r7, sp, #0x0
 80160ae: 6078         	str	r0, [r7, #0x4]
 80160b0: 6039         	str	r1, [r7]
; 	struct stm32_pclken *pclken = (struct stm32_pclken *)sub_system;
 80160b2: 683b         	ldr	r3, [r7]
 80160b4: 60fb         	str	r3, [r7, #0xc]
; 	if (IN_RANGE(pclken->bus, STM32_PERIPH_BUS_MIN, STM32_PERIPH_BUS_MAX) == true) {
 80160b6: 68fb         	ldr	r3, [r7, #0xc]
 80160b8: 681b         	ldr	r3, [r3]
 80160ba: 2b2f         	cmp	r3, #0x2f
 80160bc: d905         	bls	0x80160ca <stm32_clock_control_get_status+0x22> @ imm = #0xa
 80160be: 68fb         	ldr	r3, [r7, #0xc]
 80160c0: 681b         	ldr	r3, [r3]
 80160c2: 2ba8         	cmp	r3, #0xa8
 80160c4: d801         	bhi	0x80160ca <stm32_clock_control_get_status+0x22> @ imm = #0x2
 80160c6: 2301         	movs	r3, #0x1
 80160c8: e000         	b	0x80160cc <stm32_clock_control_get_status+0x24> @ imm = #0x0
 80160ca: 2300         	movs	r3, #0x0
 80160cc: 2b01         	cmp	r3, #0x1
 80160ce: d113         	bne	0x80160f8 <stm32_clock_control_get_status+0x50> @ imm = #0x26
; 		if ((sys_read32(DT_REG_ADDR(DT_NODELABEL(rcc)) + pclken->bus) & pclken->enr)
 80160d0: 68fb         	ldr	r3, [r7, #0xc]
 80160d2: 681b         	ldr	r3, [r3]
 80160d4: f103 4380    	add.w	r3, r3, #0x40000000
 80160d8: f503 330e    	add.w	r3, r3, #0x23800
 80160dc: 60bb         	str	r3, [r7, #0x8]
; 	return *(volatile uint32_t *)addr;
 80160de: 68bb         	ldr	r3, [r7, #0x8]
 80160e0: 681a         	ldr	r2, [r3]
; 		if ((sys_read32(DT_REG_ADDR(DT_NODELABEL(rcc)) + pclken->bus) & pclken->enr)
 80160e2: 68fb         	ldr	r3, [r7, #0xc]
 80160e4: 685b         	ldr	r3, [r3, #0x4]
 80160e6: 401a         	ands	r2, r3
; 		    == pclken->enr) {
 80160e8: 68fb         	ldr	r3, [r7, #0xc]
 80160ea: 685b         	ldr	r3, [r3, #0x4]
; 		if ((sys_read32(DT_REG_ADDR(DT_NODELABEL(rcc)) + pclken->bus) & pclken->enr)
 80160ec: 429a         	cmp	r2, r3
 80160ee: d101         	bne	0x80160f4 <stm32_clock_control_get_status+0x4c> @ imm = #0x2
; 			return CLOCK_CONTROL_STATUS_ON;
 80160f0: 2302         	movs	r3, #0x2
 80160f2: e00c         	b	0x801610e <stm32_clock_control_get_status+0x66> @ imm = #0x18
; 			return CLOCK_CONTROL_STATUS_OFF;
 80160f4: 2301         	movs	r3, #0x1
 80160f6: e00a         	b	0x801610e <stm32_clock_control_get_status+0x66> @ imm = #0x14
; 		if (enabled_clock(pclken->bus) == 0) {
 80160f8: 68fb         	ldr	r3, [r7, #0xc]
 80160fa: 681b         	ldr	r3, [r3]
 80160fc: 4618         	mov	r0, r3
 80160fe: f7f0 fc13    	bl	0x8006928 <enabled_clock> @ imm = #-0xf7da
 8016102: 4603         	mov	r3, r0
 8016104: 2b00         	cmp	r3, #0x0
 8016106: d101         	bne	0x801610c <stm32_clock_control_get_status+0x64> @ imm = #0x2
; 			return CLOCK_CONTROL_STATUS_ON;
 8016108: 2302         	movs	r3, #0x2
 801610a: e000         	b	0x801610e <stm32_clock_control_get_status+0x66> @ imm = #0x0
; 			return CLOCK_CONTROL_STATUS_OFF;
 801610c: 2301         	movs	r3, #0x1
; }
 801610e: 4618         	mov	r0, r3
 8016110: 3710         	adds	r7, #0x10
 8016112: 46bd         	mov	sp, r7
 8016114: bd80         	pop	{r7, pc}

08016116 <stm32_clock_switch_to_hsi>:
; {
 8016116: b580         	push	{r7, lr}
 8016118: af00         	add	r7, sp, #0x0
; 	if (LL_RCC_HSI_IsReady() != 1) {
 801611a: f7f0 fb3d    	bl	0x8006798 <LL_RCC_HSI_IsReady> @ imm = #-0xf986
 801611e: 4603         	mov	r3, r0
 8016120: 2b01         	cmp	r3, #0x1
 8016122: d007         	beq	0x8016134 <stm32_clock_switch_to_hsi+0x1e> @ imm = #0xe
; 		LL_RCC_HSI_Enable();
 8016124: f7f0 fb2a    	bl	0x800677c <LL_RCC_HSI_Enable> @ imm = #-0xf9ac
; 		while (LL_RCC_HSI_IsReady() != 1) {
 8016128: bf00         	nop
 801612a: f7f0 fb35    	bl	0x8006798 <LL_RCC_HSI_IsReady> @ imm = #-0xf996
 801612e: 4603         	mov	r3, r0
 8016130: 2b01         	cmp	r3, #0x1
 8016132: d1fa         	bne	0x801612a <stm32_clock_switch_to_hsi+0x14> @ imm = #-0xc
; 	LL_RCC_SetSysClkSource(LL_RCC_SYS_CLKSOURCE_HSI);
 8016134: 2000         	movs	r0, #0x0
 8016136: f7f0 fb61    	bl	0x80067fc <LL_RCC_SetSysClkSource> @ imm = #-0xf93e
; 	while (LL_RCC_GetSysClkSource() != LL_RCC_SYS_CLKSOURCE_STATUS_HSI) {
 801613a: bf00         	nop
 801613c: f7f0 fb72    	bl	0x8006824 <LL_RCC_GetSysClkSource> @ imm = #-0xf91c
 8016140: 4603         	mov	r3, r0
 8016142: 2b00         	cmp	r3, #0x0
 8016144: d1fa         	bne	0x801613c <stm32_clock_switch_to_hsi+0x26> @ imm = #-0xc
; }
 8016146: bf00         	nop
 8016148: bf00         	nop
 801614a: bd80         	pop	{r7, pc}

0801614c <set_up_fixed_clock_sources>:
; {
 801614c: b580         	push	{r7, lr}
 801614e: af00         	add	r7, sp, #0x0
; 			LL_RCC_HSE_DisableBypass();
 8016150: f7f0 fae6    	bl	0x8006720 <LL_RCC_HSE_DisableBypass> @ imm = #-0xfa34
; 		LL_RCC_HSE_Enable();
 8016154: f7f0 faf2    	bl	0x800673c <LL_RCC_HSE_Enable> @ imm = #-0xfa1c
; 		while (LL_RCC_HSE_IsReady() != 1) {
 8016158: bf00         	nop
 801615a: f7f0 fafd    	bl	0x8006758 <LL_RCC_HSE_IsReady> @ imm = #-0xfa06
 801615e: 4603         	mov	r3, r0
 8016160: 2b01         	cmp	r3, #0x1
 8016162: d1fa         	bne	0x801615a <set_up_fixed_clock_sources+0xe> @ imm = #-0xc
; 		LL_RCC_LSI_Enable();
 8016164: f7f0 fb2a    	bl	0x80067bc <LL_RCC_LSI_Enable> @ imm = #-0xf9ac
; 		while (LL_RCC_LSI_IsReady() != 1) {
 8016168: bf00         	nop
 801616a: f7f0 fb35    	bl	0x80067d8 <LL_RCC_LSI_IsReady> @ imm = #-0xf996
 801616e: 4603         	mov	r3, r0
 8016170: 2b01         	cmp	r3, #0x1
 8016172: d1fa         	bne	0x801616a <set_up_fixed_clock_sources+0x1e> @ imm = #-0xc
; }
 8016174: bf00         	nop
 8016176: bf00         	nop
 8016178: bd80         	pop	{r7, pc}

0801617a <config_regulator_voltage>:
; void __weak config_regulator_voltage(uint32_t hclk_freq) {}
 801617a: b480         	push	{r7}
 801617c: b083         	sub	sp, #0xc
 801617e: af00         	add	r7, sp, #0x0
 8016180: 6078         	str	r0, [r7, #0x4]
 8016182: bf00         	nop
 8016184: 370c         	adds	r7, #0xc
 8016186: 46bd         	mov	sp, r7
 8016188: bc80         	pop	{r7}
 801618a: 4770         	bx	lr

0801618c <get_pll_source>:
; {
 801618c: b480         	push	{r7}
 801618e: af00         	add	r7, sp, #0x0
; 		return LL_RCC_PLLSOURCE_HSE;
 8016190: f44f 0380    	mov.w	r3, #0x400000
; }
 8016194: 4618         	mov	r0, r3
 8016196: 46bd         	mov	sp, r7
 8016198: bc80         	pop	{r7}
 801619a: 4770         	bx	lr

0801619c <config_pll_sysclock>:
; {
 801619c: b580         	push	{r7, lr}
 801619e: af00         	add	r7, sp, #0x0
; 	LL_RCC_PLL_ConfigDomain_SYS(get_pll_source(),
 80161a0: f7ff fff4    	bl	0x801618c <get_pll_source> @ imm = #-0x18
 80161a4: 2300         	movs	r3, #0x0
 80161a6: 22a8         	movs	r2, #0xa8
 80161a8: 2106         	movs	r1, #0x6
 80161aa: f7f0 fd8d    	bl	0x8006cc8 <LL_RCC_PLL_ConfigDomain_SYS> @ imm = #-0xf4e6
; }
 80161ae: bf00         	nop
 80161b0: bd80         	pop	{r7, pc}

080161b2 <config_enable_default_clocks>:
; {
 80161b2: b580         	push	{r7, lr}
 80161b4: af00         	add	r7, sp, #0x0
; 	LL_APB1_GRP1_EnableClock(LL_APB1_GRP1_PERIPH_PWR);
 80161b6: f04f 5080    	mov.w	r0, #0x10000000
 80161ba: f7f0 fd6d    	bl	0x8006c98 <LL_APB1_GRP1_EnableClock> @ imm = #-0xf526
; }
 80161be: bf00         	nop
 80161c0: bd80         	pop	{r7, pc}

080161c2 <device_is_ready>:
; {
 80161c2: b580         	push	{r7, lr}
 80161c4: b082         	sub	sp, #0x8
 80161c6: af00         	add	r7, sp, #0x0
 80161c8: 6078         	str	r0, [r7, #0x4]
; 	return z_impl_device_is_ready(dev);
 80161ca: 6878         	ldr	r0, [r7, #0x4]
 80161cc: f005 fcd7    	bl	0x801bb7e <z_impl_device_is_ready> @ imm = #0x59ae
 80161d0: 4603         	mov	r3, r0
; }
 80161d2: 4618         	mov	r0, r3
 80161d4: 3708         	adds	r7, #0x8
 80161d6: 46bd         	mov	sp, r7
 80161d8: bd80         	pop	{r7, pc}

080161da <z_impl_uart_poll_out>:
; {
 80161da: b580         	push	{r7, lr}
 80161dc: b084         	sub	sp, #0x10
 80161de: af00         	add	r7, sp, #0x0
 80161e0: 6078         	str	r0, [r7, #0x4]
 80161e2: 460b         	mov	r3, r1
 80161e4: 70fb         	strb	r3, [r7, #0x3]
; 	const struct uart_driver_api *api = (const struct uart_driver_api *)dev->api;
 80161e6: 687b         	ldr	r3, [r7, #0x4]
 80161e8: 689b         	ldr	r3, [r3, #0x8]
 80161ea: 60fb         	str	r3, [r7, #0xc]
; 	api->poll_out(dev, out_char);
 80161ec: 68fb         	ldr	r3, [r7, #0xc]
 80161ee: 69db         	ldr	r3, [r3, #0x1c]
 80161f0: 78fa         	ldrb	r2, [r7, #0x3]
 80161f2: 4611         	mov	r1, r2
 80161f4: 6878         	ldr	r0, [r7, #0x4]
 80161f6: 4798         	blx	r3
; }
 80161f8: bf00         	nop
 80161fa: 3710         	adds	r7, #0x10
 80161fc: 46bd         	mov	sp, r7
 80161fe: bd80         	pop	{r7, pc}

08016200 <uart_poll_out>:
; {
 8016200: b580         	push	{r7, lr}
 8016202: b082         	sub	sp, #0x8
 8016204: af00         	add	r7, sp, #0x0
 8016206: 6078         	str	r0, [r7, #0x4]
 8016208: 460b         	mov	r3, r1
 801620a: 70fb         	strb	r3, [r7, #0x3]
; 	z_impl_uart_poll_out(dev, out_char);
 801620c: 78fb         	ldrb	r3, [r7, #0x3]
 801620e: 4619         	mov	r1, r3
 8016210: 6878         	ldr	r0, [r7, #0x4]
 8016212: f7ff ffe2    	bl	0x80161da <z_impl_uart_poll_out> @ imm = #-0x3c
; }
 8016216: bf00         	nop
 8016218: 3708         	adds	r7, #0x8
 801621a: 46bd         	mov	sp, r7
 801621c: bd80         	pop	{r7, pc}

0801621e <pm_device_runtime_get>:
; {
 801621e: b480         	push	{r7}
 8016220: b083         	sub	sp, #0xc
 8016222: af00         	add	r7, sp, #0x0
 8016224: 6078         	str	r0, [r7, #0x4]
; 	return 0;
 8016226: 2300         	movs	r3, #0x0
; }
 8016228: 4618         	mov	r0, r3
 801622a: 370c         	adds	r7, #0xc
 801622c: 46bd         	mov	sp, r7
 801622e: bc80         	pop	{r7}
 8016230: 4770         	bx	lr

08016232 <pm_device_runtime_put_async>:
; {
 8016232: b480         	push	{r7}
 8016234: b085         	sub	sp, #0x14
 8016236: af00         	add	r7, sp, #0x0
 8016238: 60f8         	str	r0, [r7, #0xc]
 801623a: e9c7 2300    	strd	r2, r3, [r7]
; 	return 0;
 801623e: 2300         	movs	r3, #0x0
; }
 8016240: 4618         	mov	r0, r3
 8016242: 3714         	adds	r7, #0x14
 8016244: 46bd         	mov	sp, r7
 8016246: bc80         	pop	{r7}
 8016248: 4770         	bx	lr

0801624a <device_is_ready>:
; {
 801624a: b580         	push	{r7, lr}
 801624c: b082         	sub	sp, #0x8
 801624e: af00         	add	r7, sp, #0x0
 8016250: 6078         	str	r0, [r7, #0x4]
; 	return z_impl_device_is_ready(dev);
 8016252: 6878         	ldr	r0, [r7, #0x4]
 8016254: f005 fc93    	bl	0x801bb7e <z_impl_device_is_ready> @ imm = #0x5926
 8016258: 4603         	mov	r3, r0
; }
 801625a: 4618         	mov	r0, r3
 801625c: 3708         	adds	r7, #0x8
 801625e: 46bd         	mov	sp, r7
 8016260: bd80         	pop	{r7, pc}

08016262 <k_sleep>:
; {
 8016262: b580         	push	{r7, lr}
 8016264: b082         	sub	sp, #0x8
 8016266: af00         	add	r7, sp, #0x0
 8016268: e9c7 0100    	strd	r0, r1, [r7]
; 	return z_impl_k_sleep(timeout);
 801626c: e9d7 0100    	ldrd	r0, r1, [r7]
 8016270: f7fa f8c4    	bl	0x80103fc <z_impl_k_sleep> @ imm = #-0x5e78
 8016274: 4603         	mov	r3, r0
; }
 8016276: 4618         	mov	r0, r3
 8016278: 3708         	adds	r7, #0x8
 801627a: 46bd         	mov	sp, r7
 801627c: bd80         	pop	{r7, pc}

0801627e <clock_control_on>:
; {
 801627e: b580         	push	{r7, lr}
 8016280: b084         	sub	sp, #0x10
 8016282: af00         	add	r7, sp, #0x0
 8016284: 6078         	str	r0, [r7, #0x4]
 8016286: 6039         	str	r1, [r7]
; 	const struct clock_control_driver_api *api =
 8016288: 687b         	ldr	r3, [r7, #0x4]
 801628a: 689b         	ldr	r3, [r3, #0x8]
 801628c: 60fb         	str	r3, [r7, #0xc]
; 	return api->on(dev, sys);
 801628e: 68fb         	ldr	r3, [r7, #0xc]
 8016290: 681b         	ldr	r3, [r3]
 8016292: 6839         	ldr	r1, [r7]
 8016294: 6878         	ldr	r0, [r7, #0x4]
 8016296: 4798         	blx	r3
 8016298: 4603         	mov	r3, r0
; }
 801629a: 4618         	mov	r0, r3
 801629c: 3710         	adds	r7, #0x10
 801629e: 46bd         	mov	sp, r7
 80162a0: bd80         	pop	{r7, pc}

080162a2 <z_log_msg_runtime_create>:
; {
 80162a2: b580         	push	{r7, lr}
 80162a4: b08a         	sub	sp, #0x28
 80162a6: af04         	add	r7, sp, #0x10
 80162a8: 60b9         	str	r1, [r7, #0x8]
 80162aa: 607b         	str	r3, [r7, #0x4]
 80162ac: 4603         	mov	r3, r0
 80162ae: 73fb         	strb	r3, [r7, #0xf]
 80162b0: 4613         	mov	r3, r2
 80162b2: 73bb         	strb	r3, [r7, #0xe]
; 	va_start(ap, fmt);
 80162b4: f107 032c    	add.w	r3, r7, #0x2c
 80162b8: 617b         	str	r3, [r7, #0x14]
; 	z_log_msg_runtime_vcreate(domain_id, source, level,
 80162ba: 7bba         	ldrb	r2, [r7, #0xe]
 80162bc: 7bf8         	ldrb	r0, [r7, #0xf]
 80162be: 697b         	ldr	r3, [r7, #0x14]
 80162c0: 9303         	str	r3, [sp, #0xc]
 80162c2: 6abb         	ldr	r3, [r7, #0x28]
 80162c4: 9302         	str	r3, [sp, #0x8]
 80162c6: 6a7b         	ldr	r3, [r7, #0x24]
 80162c8: 9301         	str	r3, [sp, #0x4]
 80162ca: 6a3b         	ldr	r3, [r7, #0x20]
 80162cc: 9300         	str	r3, [sp]
 80162ce: 687b         	ldr	r3, [r7, #0x4]
 80162d0: 68b9         	ldr	r1, [r7, #0x8]
 80162d2: f7ee f94d    	bl	0x8004570 <z_log_msg_runtime_vcreate> @ imm = #-0x11d66
; }
 80162d6: bf00         	nop
 80162d8: 3718         	adds	r7, #0x18
 80162da: 46bd         	mov	sp, r7
 80162dc: bd80         	pop	{r7, pc}

080162de <dma_stm32_dump_stream_irq>:
; {
 80162de: b580         	push	{r7, lr}
 80162e0: b084         	sub	sp, #0x10
 80162e2: af00         	add	r7, sp, #0x0
 80162e4: 6078         	str	r0, [r7, #0x4]
 80162e6: 6039         	str	r1, [r7]
; 	const struct dma_stm32_config *config = dev->config;
 80162e8: 687b         	ldr	r3, [r7, #0x4]
 80162ea: 685b         	ldr	r3, [r3, #0x4]
 80162ec: 60fb         	str	r3, [r7, #0xc]
; 	DMA_TypeDef *dma = (DMA_TypeDef *)(config->base);
 80162ee: 68fb         	ldr	r3, [r7, #0xc]
 80162f0: 691b         	ldr	r3, [r3, #0x10]
 80162f2: 60bb         	str	r3, [r7, #0x8]
; 	stm32_dma_dump_stream_irq(dma, id);
 80162f4: 6839         	ldr	r1, [r7]
 80162f6: 68b8         	ldr	r0, [r7, #0x8]
 80162f8: f7f1 ff32    	bl	0x8008160 <stm32_dma_dump_stream_irq> @ imm = #-0xe19c
; }
 80162fc: bf00         	nop
 80162fe: 3710         	adds	r7, #0x10
 8016300: 46bd         	mov	sp, r7
 8016302: bd80         	pop	{r7, pc}

08016304 <dma_stm32_clear_stream_irq>:
; {
 8016304: b580         	push	{r7, lr}
 8016306: b084         	sub	sp, #0x10
 8016308: af00         	add	r7, sp, #0x0
 801630a: 6078         	str	r0, [r7, #0x4]
 801630c: 6039         	str	r1, [r7]
; 	const struct dma_stm32_config *config = dev->config;
 801630e: 687b         	ldr	r3, [r7, #0x4]
 8016310: 685b         	ldr	r3, [r3, #0x4]
 8016312: 60fb         	str	r3, [r7, #0xc]
; 	DMA_TypeDef *dma = (DMA_TypeDef *)(config->base);
 8016314: 68fb         	ldr	r3, [r7, #0xc]
 8016316: 691b         	ldr	r3, [r3, #0x10]
 8016318: 60bb         	str	r3, [r7, #0x8]
; 	dma_stm32_clear_tc(dma, id);
 801631a: 6839         	ldr	r1, [r7]
 801631c: 68b8         	ldr	r0, [r7, #0x8]
 801631e: f7f1 fe5f    	bl	0x8007fe0 <dma_stm32_clear_tc> @ imm = #-0xe342
; 	dma_stm32_clear_ht(dma, id);
 8016322: 6839         	ldr	r1, [r7]
 8016324: 68b8         	ldr	r0, [r7, #0x8]
 8016326: f7f1 fe49    	bl	0x8007fbc <dma_stm32_clear_ht> @ imm = #-0xe36e
; 	stm32_dma_clear_stream_irq(dma, id);
 801632a: 6839         	ldr	r1, [r7]
 801632c: 68b8         	ldr	r0, [r7, #0x8]
 801632e: f000 fff3    	bl	0x8017318 <stm32_dma_clear_stream_irq> @ imm = #0xfe6
; }
 8016332: bf00         	nop
 8016334: 3710         	adds	r7, #0x10
 8016336: 46bd         	mov	sp, r7
 8016338: bd80         	pop	{r7, pc}

0801633a <dma_stm32_disable_stream>:
; {
 801633a: b580         	push	{r7, lr}
 801633c: b084         	sub	sp, #0x10
 801633e: af00         	add	r7, sp, #0x0
 8016340: 6078         	str	r0, [r7, #0x4]
 8016342: 6039         	str	r1, [r7]
; 	int count = 0;
 8016344: 2300         	movs	r3, #0x0
 8016346: 60fb         	str	r3, [r7, #0xc]
; 		if (stm32_dma_disable_stream(dma, id) == 0) {
 8016348: 6839         	ldr	r1, [r7]
 801634a: 6878         	ldr	r0, [r7, #0x4]
 801634c: f001 f821    	bl	0x8017392 <stm32_dma_disable_stream> @ imm = #0x1042
 8016350: 4603         	mov	r3, r0
 8016352: 2b00         	cmp	r3, #0x0
 8016354: d101         	bne	0x801635a <dma_stm32_disable_stream+0x20> @ imm = #0x2
; 			return 0;
 8016356: 2100         	movs	r1, #0x0
 8016358: e012         	b	0x8016380 <dma_stm32_disable_stream+0x46> @ imm = #0x24
; 		if (count++ > (5 * 1000)) {
 801635a: 68fb         	ldr	r3, [r7, #0xc]
 801635c: 1c5a         	adds	r2, r3, #0x1
 801635e: 60fa         	str	r2, [r7, #0xc]
 8016360: f241 3288    	movw	r2, #0x1388
 8016364: 4293         	cmp	r3, r2
 8016366: dd02         	ble	0x801636e <dma_stm32_disable_stream+0x34> @ imm = #0x4
; 			return -EBUSY;
 8016368: f06f 010f    	mvn	r1, #0xf
 801636c: e008         	b	0x8016380 <dma_stm32_disable_stream+0x46> @ imm = #0x10
; 		k_sleep(K_MSEC(1));
 801636e: f04f 020a    	mov.w	r2, #0xa
 8016372: f04f 0300    	mov.w	r3, #0x0
 8016376: 4610         	mov	r0, r2
 8016378: 4619         	mov	r1, r3
 801637a: f7ff ff72    	bl	0x8016262 <k_sleep>     @ imm = #-0x11c
; 	for (;;) {
 801637e: e7e3         	b	0x8016348 <dma_stm32_disable_stream+0xe> @ imm = #-0x3a
; }
 8016380: 460b         	mov	r3, r1
 8016382: 4618         	mov	r0, r3
 8016384: 3710         	adds	r7, #0x10
 8016386: 46bd         	mov	sp, r7
 8016388: bd80         	pop	{r7, pc}

0801638a <dma_stm32_reload>:
; {
 801638a: b580         	push	{r7, lr}
 801638c: b088         	sub	sp, #0x20
 801638e: af00         	add	r7, sp, #0x0
 8016390: 60f8         	str	r0, [r7, #0xc]
 8016392: 60b9         	str	r1, [r7, #0x8]
 8016394: 607a         	str	r2, [r7, #0x4]
 8016396: 603b         	str	r3, [r7]
; 	const struct dma_stm32_config *config = dev->config;
 8016398: 68fb         	ldr	r3, [r7, #0xc]
 801639a: 685b         	ldr	r3, [r3, #0x4]
 801639c: 61fb         	str	r3, [r7, #0x1c]
; 	DMA_TypeDef *dma = (DMA_TypeDef *)(config->base);
 801639e: 69fb         	ldr	r3, [r7, #0x1c]
 80163a0: 691b         	ldr	r3, [r3, #0x10]
 80163a2: 61bb         	str	r3, [r7, #0x18]
; 	if (id >= config->max_streams) {
 80163a4: 69fb         	ldr	r3, [r7, #0x1c]
 80163a6: 695b         	ldr	r3, [r3, #0x14]
 80163a8: 68ba         	ldr	r2, [r7, #0x8]
 80163aa: 429a         	cmp	r2, r3
 80163ac: d302         	blo	0x80163b4 <dma_stm32_reload+0x2a> @ imm = #0x4
; 		return -EINVAL;
 80163ae: f06f 0315    	mvn	r3, #0x15
 80163b2: e06c         	b	0x801648e <dma_stm32_reload+0x104> @ imm = #0xd8
; 	stream = &config->streams[id];
 80163b4: 69fb         	ldr	r3, [r7, #0x1c]
 80163b6: 6999         	ldr	r1, [r3, #0x18]
 80163b8: 68ba         	ldr	r2, [r7, #0x8]
 80163ba: 4613         	mov	r3, r2
 80163bc: 00db         	lsls	r3, r3, #0x3
 80163be: 1a9b         	subs	r3, r3, r2
 80163c0: 009b         	lsls	r3, r3, #0x2
 80163c2: 440b         	add	r3, r1
 80163c4: 617b         	str	r3, [r7, #0x14]
; 	if (dma_stm32_disable_stream(dma, id) != 0) {
 80163c6: 68b9         	ldr	r1, [r7, #0x8]
 80163c8: 69b8         	ldr	r0, [r7, #0x18]
 80163ca: f7ff ffb6    	bl	0x801633a <dma_stm32_disable_stream> @ imm = #-0x94
 80163ce: 4603         	mov	r3, r0
 80163d0: 2b00         	cmp	r3, #0x0
 80163d2: d002         	beq	0x80163da <dma_stm32_reload+0x50> @ imm = #0x4
; 		return -EBUSY;
 80163d4: f06f 030f    	mvn	r3, #0xf
 80163d8: e059         	b	0x801648e <dma_stm32_reload+0x104> @ imm = #0xb2
; 	switch (stream->direction) {
 80163da: 697b         	ldr	r3, [r7, #0x14]
 80163dc: 681b         	ldr	r3, [r3]
 80163de: 2b02         	cmp	r3, #0x2
 80163e0: d018         	beq	0x8016414 <dma_stm32_reload+0x8a> @ imm = #0x30
 80163e2: 2b02         	cmp	r3, #0x2
 80163e4: d829         	bhi	0x801643a <dma_stm32_reload+0xb0> @ imm = #0x52
 80163e6: 2b00         	cmp	r3, #0x0
 80163e8: d014         	beq	0x8016414 <dma_stm32_reload+0x8a> @ imm = #0x28
 80163ea: 2b01         	cmp	r3, #0x1
 80163ec: d125         	bne	0x801643a <dma_stm32_reload+0xb0> @ imm = #0x4a
; 		LL_DMA_SetMemoryAddress(dma, dma_stm32_id_to_stream(id), src);
 80163ee: 68b8         	ldr	r0, [r7, #0x8]
 80163f0: f7f1 fdc4    	bl	0x8007f7c <dma_stm32_id_to_stream> @ imm = #-0xe478
 80163f4: 4603         	mov	r3, r0
 80163f6: 687a         	ldr	r2, [r7, #0x4]
 80163f8: 4619         	mov	r1, r3
 80163fa: 69b8         	ldr	r0, [r7, #0x18]
 80163fc: f7f0 fd56    	bl	0x8006eac <LL_DMA_SetMemoryAddress> @ imm = #-0xf554
; 		LL_DMA_SetPeriphAddress(dma, dma_stm32_id_to_stream(id), dst);
 8016400: 68b8         	ldr	r0, [r7, #0x8]
 8016402: f7f1 fdbb    	bl	0x8007f7c <dma_stm32_id_to_stream> @ imm = #-0xe48a
 8016406: 4603         	mov	r3, r0
 8016408: 683a         	ldr	r2, [r7]
 801640a: 4619         	mov	r1, r3
 801640c: 69b8         	ldr	r0, [r7, #0x18]
 801640e: f7f0 fd65    	bl	0x8006edc <LL_DMA_SetPeriphAddress> @ imm = #-0xf536
; 		break;
 8016412: e015         	b	0x8016440 <dma_stm32_reload+0xb6> @ imm = #0x2a
; 		LL_DMA_SetPeriphAddress(dma, dma_stm32_id_to_stream(id), src);
 8016414: 68b8         	ldr	r0, [r7, #0x8]
 8016416: f7f1 fdb1    	bl	0x8007f7c <dma_stm32_id_to_stream> @ imm = #-0xe49e
 801641a: 4603         	mov	r3, r0
 801641c: 687a         	ldr	r2, [r7, #0x4]
 801641e: 4619         	mov	r1, r3
 8016420: 69b8         	ldr	r0, [r7, #0x18]
 8016422: f7f0 fd5b    	bl	0x8006edc <LL_DMA_SetPeriphAddress> @ imm = #-0xf54a
; 		LL_DMA_SetMemoryAddress(dma, dma_stm32_id_to_stream(id), dst);
 8016426: 68b8         	ldr	r0, [r7, #0x8]
 8016428: f7f1 fda8    	bl	0x8007f7c <dma_stm32_id_to_stream> @ imm = #-0xe4b0
 801642c: 4603         	mov	r3, r0
 801642e: 683a         	ldr	r2, [r7]
 8016430: 4619         	mov	r1, r3
 8016432: 69b8         	ldr	r0, [r7, #0x18]
 8016434: f7f0 fd3a    	bl	0x8006eac <LL_DMA_SetMemoryAddress> @ imm = #-0xf58c
; 		break;
 8016438: e002         	b	0x8016440 <dma_stm32_reload+0xb6> @ imm = #0x4
; 		return -EINVAL;
 801643a: f06f 0315    	mvn	r3, #0x15
 801643e: e026         	b	0x801648e <dma_stm32_reload+0x104> @ imm = #0x4c
; 	if (stream->source_periph) {
 8016440: 697b         	ldr	r3, [r7, #0x14]
 8016442: 791b         	ldrb	r3, [r3, #0x4]
 8016444: 2b00         	cmp	r3, #0x0
 8016446: d00d         	beq	0x8016464 <dma_stm32_reload+0xda> @ imm = #0x1a
; 		LL_DMA_SetDataLength(dma, dma_stm32_id_to_stream(id),
 8016448: 68b8         	ldr	r0, [r7, #0x8]
 801644a: f7f1 fd97    	bl	0x8007f7c <dma_stm32_id_to_stream> @ imm = #-0xe4d2
 801644e: 4601         	mov	r1, r0
; 				     size / stream->src_size);
 8016450: 697b         	ldr	r3, [r7, #0x14]
 8016452: 689b         	ldr	r3, [r3, #0x8]
; 		LL_DMA_SetDataLength(dma, dma_stm32_id_to_stream(id),
 8016454: 6aba         	ldr	r2, [r7, #0x28]
 8016456: fbb2 f3f3    	udiv	r3, r2, r3
 801645a: 461a         	mov	r2, r3
 801645c: 69b8         	ldr	r0, [r7, #0x18]
 801645e: f7f0 fcb1    	bl	0x8006dc4 <LL_DMA_SetDataLength> @ imm = #-0xf69e
 8016462: e00c         	b	0x801647e <dma_stm32_reload+0xf4> @ imm = #0x18
; 		LL_DMA_SetDataLength(dma, dma_stm32_id_to_stream(id),
 8016464: 68b8         	ldr	r0, [r7, #0x8]
 8016466: f7f1 fd89    	bl	0x8007f7c <dma_stm32_id_to_stream> @ imm = #-0xe4ee
 801646a: 4601         	mov	r1, r0
; 				     size / stream->dst_size);
 801646c: 697b         	ldr	r3, [r7, #0x14]
 801646e: 68db         	ldr	r3, [r3, #0xc]
; 		LL_DMA_SetDataLength(dma, dma_stm32_id_to_stream(id),
 8016470: 6aba         	ldr	r2, [r7, #0x28]
 8016472: fbb2 f3f3    	udiv	r3, r2, r3
 8016476: 461a         	mov	r2, r3
 8016478: 69b8         	ldr	r0, [r7, #0x18]
 801647a: f7f0 fca3    	bl	0x8006dc4 <LL_DMA_SetDataLength> @ imm = #-0xf6ba
; 	stream->busy = true;
 801647e: 697b         	ldr	r3, [r7, #0x14]
 8016480: 2201         	movs	r2, #0x1
 8016482: 719a         	strb	r2, [r3, #0x6]
; 	stm32_dma_enable_stream(dma, id);
 8016484: 68b9         	ldr	r1, [r7, #0x8]
 8016486: 69b8         	ldr	r0, [r7, #0x18]
 8016488: f000 ff5b    	bl	0x8017342 <stm32_dma_enable_stream> @ imm = #0xeb6
; 	return 0;
 801648c: 2300         	movs	r3, #0x0
; }
 801648e: 4618         	mov	r0, r3
 8016490: 3720         	adds	r7, #0x20
 8016492: 46bd         	mov	sp, r7
 8016494: bd80         	pop	{r7, pc}

08016496 <dma_stm32_start>:
; {
 8016496: b580         	push	{r7, lr}
 8016498: b086         	sub	sp, #0x18
 801649a: af00         	add	r7, sp, #0x0
 801649c: 6078         	str	r0, [r7, #0x4]
 801649e: 6039         	str	r1, [r7]
; 	const struct dma_stm32_config *config = dev->config;
 80164a0: 687b         	ldr	r3, [r7, #0x4]
 80164a2: 685b         	ldr	r3, [r3, #0x4]
 80164a4: 617b         	str	r3, [r7, #0x14]
; 	DMA_TypeDef *dma = (DMA_TypeDef *)(config->base);
 80164a6: 697b         	ldr	r3, [r7, #0x14]
 80164a8: 691b         	ldr	r3, [r3, #0x10]
 80164aa: 613b         	str	r3, [r7, #0x10]
; 	if (id >= config->max_streams) {
 80164ac: 697b         	ldr	r3, [r7, #0x14]
 80164ae: 695b         	ldr	r3, [r3, #0x14]
 80164b0: 683a         	ldr	r2, [r7]
 80164b2: 429a         	cmp	r2, r3
 80164b4: d302         	blo	0x80164bc <dma_stm32_start+0x26> @ imm = #0x4
; 		return -EINVAL;
 80164b6: f06f 0315    	mvn	r3, #0x15
 80164ba: e01d         	b	0x80164f8 <dma_stm32_start+0x62> @ imm = #0x3a
; 	if (stm32_dma_is_enabled_stream(dma, id)) {
 80164bc: 6839         	ldr	r1, [r7]
 80164be: 6938         	ldr	r0, [r7, #0x10]
 80164c0: f000 ff50    	bl	0x8017364 <stm32_dma_is_enabled_stream> @ imm = #0xea0
 80164c4: 4603         	mov	r3, r0
 80164c6: 2b00         	cmp	r3, #0x0
 80164c8: d001         	beq	0x80164ce <dma_stm32_start+0x38> @ imm = #0x2
; 		return 0;
 80164ca: 2300         	movs	r3, #0x0
 80164cc: e014         	b	0x80164f8 <dma_stm32_start+0x62> @ imm = #0x28
; 	stream = &config->streams[id];
 80164ce: 697b         	ldr	r3, [r7, #0x14]
 80164d0: 6999         	ldr	r1, [r3, #0x18]
 80164d2: 683a         	ldr	r2, [r7]
 80164d4: 4613         	mov	r3, r2
 80164d6: 00db         	lsls	r3, r3, #0x3
 80164d8: 1a9b         	subs	r3, r3, r2
 80164da: 009b         	lsls	r3, r3, #0x2
 80164dc: 440b         	add	r3, r1
 80164de: 60fb         	str	r3, [r7, #0xc]
; 	stream->busy = true;
 80164e0: 68fb         	ldr	r3, [r7, #0xc]
 80164e2: 2201         	movs	r2, #0x1
 80164e4: 719a         	strb	r2, [r3, #0x6]
; 	dma_stm32_clear_stream_irq(dev, id);
 80164e6: 6839         	ldr	r1, [r7]
 80164e8: 6878         	ldr	r0, [r7, #0x4]
 80164ea: f7ff ff0b    	bl	0x8016304 <dma_stm32_clear_stream_irq> @ imm = #-0x1ea
; 	stm32_dma_enable_stream(dma, id);
 80164ee: 6839         	ldr	r1, [r7]
 80164f0: 6938         	ldr	r0, [r7, #0x10]
 80164f2: f000 ff26    	bl	0x8017342 <stm32_dma_enable_stream> @ imm = #0xe4c
; 	return 0;
 80164f6: 2300         	movs	r3, #0x0
; }
 80164f8: 4618         	mov	r0, r3
 80164fa: 3718         	adds	r7, #0x18
 80164fc: 46bd         	mov	sp, r7
 80164fe: bd80         	pop	{r7, pc}

08016500 <dma_stm32_stop>:
; {
 8016500: b580         	push	{r7, lr}
 8016502: b086         	sub	sp, #0x18
 8016504: af00         	add	r7, sp, #0x0
 8016506: 6078         	str	r0, [r7, #0x4]
 8016508: 6039         	str	r1, [r7]
; 	const struct dma_stm32_config *config = dev->config;
 801650a: 687b         	ldr	r3, [r7, #0x4]
 801650c: 685b         	ldr	r3, [r3, #0x4]
 801650e: 617b         	str	r3, [r7, #0x14]
; 	struct dma_stm32_stream *stream = &config->streams[id - STM32_DMA_STREAM_OFFSET];
 8016510: 697b         	ldr	r3, [r7, #0x14]
 8016512: 6999         	ldr	r1, [r3, #0x18]
 8016514: 683a         	ldr	r2, [r7]
 8016516: 4613         	mov	r3, r2
 8016518: 00db         	lsls	r3, r3, #0x3
 801651a: 1a9b         	subs	r3, r3, r2
 801651c: 009b         	lsls	r3, r3, #0x2
 801651e: 440b         	add	r3, r1
 8016520: 613b         	str	r3, [r7, #0x10]
; 	DMA_TypeDef *dma = (DMA_TypeDef *)(config->base);
 8016522: 697b         	ldr	r3, [r7, #0x14]
 8016524: 691b         	ldr	r3, [r3, #0x10]
 8016526: 60fb         	str	r3, [r7, #0xc]
; 	if (id >= config->max_streams) {
 8016528: 697b         	ldr	r3, [r7, #0x14]
 801652a: 695b         	ldr	r3, [r3, #0x14]
 801652c: 683a         	ldr	r2, [r7]
 801652e: 429a         	cmp	r2, r3
 8016530: d302         	blo	0x8016538 <dma_stm32_stop+0x38> @ imm = #0x4
; 		return -EINVAL;
 8016532: f06f 0315    	mvn	r3, #0x15
 8016536: e02c         	b	0x8016592 <dma_stm32_stop+0x92> @ imm = #0x58
; 	if (stream->hal_override) {
 8016538: 693b         	ldr	r3, [r7, #0x10]
 801653a: 795b         	ldrb	r3, [r3, #0x5]
 801653c: 2b00         	cmp	r3, #0x0
 801653e: d004         	beq	0x801654a <dma_stm32_stop+0x4a> @ imm = #0x8
; 		stream->busy = false;
 8016540: 693b         	ldr	r3, [r7, #0x10]
 8016542: 2200         	movs	r2, #0x0
 8016544: 719a         	strb	r2, [r3, #0x6]
; 		return 0;
 8016546: 2300         	movs	r3, #0x0
 8016548: e023         	b	0x8016592 <dma_stm32_stop+0x92> @ imm = #0x46
; 	if (!stm32_dma_is_enabled_stream(dma, id)) {
 801654a: 6839         	ldr	r1, [r7]
 801654c: 68f8         	ldr	r0, [r7, #0xc]
 801654e: f000 ff09    	bl	0x8017364 <stm32_dma_is_enabled_stream> @ imm = #0xe12
 8016552: 4603         	mov	r3, r0
 8016554: f083 0301    	eor	r3, r3, #0x1
 8016558: b2db         	uxtb	r3, r3
 801655a: 2b00         	cmp	r3, #0x0
 801655c: d001         	beq	0x8016562 <dma_stm32_stop+0x62> @ imm = #0x2
; 		return 0;
 801655e: 2300         	movs	r3, #0x0
 8016560: e017         	b	0x8016592 <dma_stm32_stop+0x92> @ imm = #0x2e
; 	LL_DMA_DisableIT_TC(dma, dma_stm32_id_to_stream(id));
 8016562: 6838         	ldr	r0, [r7]
 8016564: f7f1 fd0a    	bl	0x8007f7c <dma_stm32_id_to_stream> @ imm = #-0xe5ec
 8016568: 4603         	mov	r3, r0
 801656a: 4619         	mov	r1, r3
 801656c: 68f8         	ldr	r0, [r7, #0xc]
 801656e: f7f0 fd27    	bl	0x8006fc0 <LL_DMA_DisableIT_TC> @ imm = #-0xf5b2
; 	stm32_dma_disable_fifo_irq(dma, id);
 8016572: 6839         	ldr	r1, [r7]
 8016574: 68f8         	ldr	r0, [r7, #0xc]
 8016576: f000 ff2a    	bl	0x80173ce <stm32_dma_disable_fifo_irq> @ imm = #0xe54
; 	dma_stm32_clear_stream_irq(dev, id);
 801657a: 6839         	ldr	r1, [r7]
 801657c: 6878         	ldr	r0, [r7, #0x4]
 801657e: f7ff fec1    	bl	0x8016304 <dma_stm32_clear_stream_irq> @ imm = #-0x27e
; 	dma_stm32_disable_stream(dma, id);
 8016582: 6839         	ldr	r1, [r7]
 8016584: 68f8         	ldr	r0, [r7, #0xc]
 8016586: f7ff fed8    	bl	0x801633a <dma_stm32_disable_stream> @ imm = #-0x250
; 	stream->busy = false;
 801658a: 693b         	ldr	r3, [r7, #0x10]
 801658c: 2200         	movs	r2, #0x0
 801658e: 719a         	strb	r2, [r3, #0x6]
; 	return 0;
 8016590: 2300         	movs	r3, #0x0
; }
 8016592: 4618         	mov	r0, r3
 8016594: 3718         	adds	r7, #0x18
 8016596: 46bd         	mov	sp, r7
 8016598: bd80         	pop	{r7, pc}

0801659a <dma_stm32_get_status>:
; {
 801659a: b580         	push	{r7, lr}
 801659c: b088         	sub	sp, #0x20
 801659e: af00         	add	r7, sp, #0x0
 80165a0: 60f8         	str	r0, [r7, #0xc]
 80165a2: 60b9         	str	r1, [r7, #0x8]
 80165a4: 607a         	str	r2, [r7, #0x4]
; 	const struct dma_stm32_config *config = dev->config;
 80165a6: 68fb         	ldr	r3, [r7, #0xc]
 80165a8: 685b         	ldr	r3, [r3, #0x4]
 80165aa: 61fb         	str	r3, [r7, #0x1c]
; 	DMA_TypeDef *dma = (DMA_TypeDef *)(config->base);
 80165ac: 69fb         	ldr	r3, [r7, #0x1c]
 80165ae: 691b         	ldr	r3, [r3, #0x10]
 80165b0: 61bb         	str	r3, [r7, #0x18]
; 	if (id >= config->max_streams) {
 80165b2: 69fb         	ldr	r3, [r7, #0x1c]
 80165b4: 695b         	ldr	r3, [r3, #0x14]
 80165b6: 68ba         	ldr	r2, [r7, #0x8]
 80165b8: 429a         	cmp	r2, r3
 80165ba: d302         	blo	0x80165c2 <dma_stm32_get_status+0x28> @ imm = #0x4
; 		return -EINVAL;
 80165bc: f06f 0315    	mvn	r3, #0x15
 80165c0: e01e         	b	0x8016600 <dma_stm32_get_status+0x66> @ imm = #0x3c
; 	stream = &config->streams[id];
 80165c2: 69fb         	ldr	r3, [r7, #0x1c]
 80165c4: 6999         	ldr	r1, [r3, #0x18]
 80165c6: 68ba         	ldr	r2, [r7, #0x8]
 80165c8: 4613         	mov	r3, r2
 80165ca: 00db         	lsls	r3, r3, #0x3
 80165cc: 1a9b         	subs	r3, r3, r2
 80165ce: 009b         	lsls	r3, r3, #0x2
 80165d0: 440b         	add	r3, r1
 80165d2: 617b         	str	r3, [r7, #0x14]
; 	stat->pending_length = LL_DMA_GetDataLength(dma, dma_stm32_id_to_stream(id));
 80165d4: 68b8         	ldr	r0, [r7, #0x8]
 80165d6: f7f1 fcd1    	bl	0x8007f7c <dma_stm32_id_to_stream> @ imm = #-0xe65e
 80165da: 4603         	mov	r3, r0
 80165dc: 4619         	mov	r1, r3
 80165de: 69b8         	ldr	r0, [r7, #0x18]
 80165e0: f7f0 fc12    	bl	0x8006e08 <LL_DMA_GetDataLength> @ imm = #-0xf7dc
 80165e4: 4602         	mov	r2, r0
 80165e6: 687b         	ldr	r3, [r7, #0x4]
 80165e8: 605a         	str	r2, [r3, #0x4]
; 	stat->dir = stream->direction;
 80165ea: 697b         	ldr	r3, [r7, #0x14]
 80165ec: 681b         	ldr	r3, [r3]
 80165ee: b2da         	uxtb	r2, r3
 80165f0: 687b         	ldr	r3, [r7, #0x4]
 80165f2: 705a         	strb	r2, [r3, #0x1]
; 	stat->busy = stream->busy;
 80165f4: 697b         	ldr	r3, [r7, #0x14]
 80165f6: 799b         	ldrb	r3, [r3, #0x6]
 80165f8: b2da         	uxtb	r2, r3
 80165fa: 687b         	ldr	r3, [r7, #0x4]
 80165fc: 701a         	strb	r2, [r3]
; 	return 0;
 80165fe: 2300         	movs	r3, #0x0
; }
 8016600: 4618         	mov	r0, r3
 8016602: 3720         	adds	r7, #0x20
 8016604: 46bd         	mov	sp, r7
 8016606: bd80         	pop	{r7, pc}

08016608 <dma_stm32_irq_0_0>:
; DMA_STM32_DEFINE_IRQ_HANDLER(0, 0);
 8016608: b580         	push	{r7, lr}
 801660a: b082         	sub	sp, #0x8
 801660c: af00         	add	r7, sp, #0x0
 801660e: 6078         	str	r0, [r7, #0x4]
 8016610: 2100         	movs	r1, #0x0
 8016612: 6878         	ldr	r0, [r7, #0x4]
 8016614: f7f0 fd10    	bl	0x8007038 <dma_stm32_irq_handler> @ imm = #-0xf5e0
 8016618: 3708         	adds	r7, #0x8
 801661a: 46bd         	mov	sp, r7
 801661c: bd80         	pop	{r7, pc}

0801661e <dma_stm32_irq_0_1>:
; DMA_STM32_DEFINE_IRQ_HANDLER(0, 1);
 801661e: b580         	push	{r7, lr}
 8016620: b082         	sub	sp, #0x8
 8016622: af00         	add	r7, sp, #0x0
 8016624: 6078         	str	r0, [r7, #0x4]
 8016626: 2101         	movs	r1, #0x1
 8016628: 6878         	ldr	r0, [r7, #0x4]
 801662a: f7f0 fd05    	bl	0x8007038 <dma_stm32_irq_handler> @ imm = #-0xf5f6
 801662e: 3708         	adds	r7, #0x8
 8016630: 46bd         	mov	sp, r7
 8016632: bd80         	pop	{r7, pc}

08016634 <dma_stm32_irq_0_2>:
; DMA_STM32_DEFINE_IRQ_HANDLER(0, 2);
 8016634: b580         	push	{r7, lr}
 8016636: b082         	sub	sp, #0x8
 8016638: af00         	add	r7, sp, #0x0
 801663a: 6078         	str	r0, [r7, #0x4]
 801663c: 2102         	movs	r1, #0x2
 801663e: 6878         	ldr	r0, [r7, #0x4]
 8016640: f7f0 fcfa    	bl	0x8007038 <dma_stm32_irq_handler> @ imm = #-0xf60c
 8016644: 3708         	adds	r7, #0x8
 8016646: 46bd         	mov	sp, r7
 8016648: bd80         	pop	{r7, pc}

0801664a <dma_stm32_irq_0_3>:
; DMA_STM32_DEFINE_IRQ_HANDLER(0, 3);
 801664a: b580         	push	{r7, lr}
 801664c: b082         	sub	sp, #0x8
 801664e: af00         	add	r7, sp, #0x0
 8016650: 6078         	str	r0, [r7, #0x4]
 8016652: 2103         	movs	r1, #0x3
 8016654: 6878         	ldr	r0, [r7, #0x4]
 8016656: f7f0 fcef    	bl	0x8007038 <dma_stm32_irq_handler> @ imm = #-0xf622
 801665a: 3708         	adds	r7, #0x8
 801665c: 46bd         	mov	sp, r7
 801665e: bd80         	pop	{r7, pc}

08016660 <dma_stm32_irq_0_4>:
; DMA_STM32_DEFINE_IRQ_HANDLER(0, 4);
 8016660: b580         	push	{r7, lr}
 8016662: b082         	sub	sp, #0x8
 8016664: af00         	add	r7, sp, #0x0
 8016666: 6078         	str	r0, [r7, #0x4]
 8016668: 2104         	movs	r1, #0x4
 801666a: 6878         	ldr	r0, [r7, #0x4]
 801666c: f7f0 fce4    	bl	0x8007038 <dma_stm32_irq_handler> @ imm = #-0xf638
 8016670: 3708         	adds	r7, #0x8
 8016672: 46bd         	mov	sp, r7
 8016674: bd80         	pop	{r7, pc}

08016676 <dma_stm32_irq_0_5>:
; DMA_STM32_DEFINE_IRQ_HANDLER(0, 5);
 8016676: b580         	push	{r7, lr}
 8016678: b082         	sub	sp, #0x8
 801667a: af00         	add	r7, sp, #0x0
 801667c: 6078         	str	r0, [r7, #0x4]
 801667e: 2105         	movs	r1, #0x5
 8016680: 6878         	ldr	r0, [r7, #0x4]
 8016682: f7f0 fcd9    	bl	0x8007038 <dma_stm32_irq_handler> @ imm = #-0xf64e
 8016686: 3708         	adds	r7, #0x8
 8016688: 46bd         	mov	sp, r7
 801668a: bd80         	pop	{r7, pc}

0801668c <dma_stm32_irq_0_6>:
; DMA_STM32_DEFINE_IRQ_HANDLER(0, 6);
 801668c: b580         	push	{r7, lr}
 801668e: b082         	sub	sp, #0x8
 8016690: af00         	add	r7, sp, #0x0
 8016692: 6078         	str	r0, [r7, #0x4]
 8016694: 2106         	movs	r1, #0x6
 8016696: 6878         	ldr	r0, [r7, #0x4]
 8016698: f7f0 fcce    	bl	0x8007038 <dma_stm32_irq_handler> @ imm = #-0xf664
 801669c: 3708         	adds	r7, #0x8
 801669e: 46bd         	mov	sp, r7
 80166a0: bd80         	pop	{r7, pc}

080166a2 <dma_stm32_irq_0_7>:
; DMA_STM32_DEFINE_IRQ_HANDLER(0, 7);
 80166a2: b580         	push	{r7, lr}
 80166a4: b082         	sub	sp, #0x8
 80166a6: af00         	add	r7, sp, #0x0
 80166a8: 6078         	str	r0, [r7, #0x4]
 80166aa: 2107         	movs	r1, #0x7
 80166ac: 6878         	ldr	r0, [r7, #0x4]
 80166ae: f7f0 fcc3    	bl	0x8007038 <dma_stm32_irq_handler> @ imm = #-0xf67a
 80166b2: 3708         	adds	r7, #0x8
 80166b4: 46bd         	mov	sp, r7
 80166b6: bd80         	pop	{r7, pc}

080166b8 <dma_stm32_config_irq_0>:
; {
 80166b8: b580         	push	{r7, lr}
 80166ba: b082         	sub	sp, #0x8
 80166bc: af00         	add	r7, sp, #0x0
 80166be: 6078         	str	r0, [r7, #0x4]
; 	LISTIFY(
 80166c0: 2200         	movs	r2, #0x0
 80166c2: 2100         	movs	r1, #0x0
 80166c4: 200b         	movs	r0, #0xb
 80166c6: f7ff fa56    	bl	0x8015b76 <z_arm_irq_priority_set> @ imm = #-0xb54
 80166ca: 200b         	movs	r0, #0xb
 80166cc: f7ff fa46    	bl	0x8015b5c <arch_irq_enable> @ imm = #-0xb74
 80166d0: 2200         	movs	r2, #0x0
 80166d2: 2100         	movs	r1, #0x0
 80166d4: 200c         	movs	r0, #0xc
 80166d6: f7ff fa4e    	bl	0x8015b76 <z_arm_irq_priority_set> @ imm = #-0xb64
 80166da: 200c         	movs	r0, #0xc
 80166dc: f7ff fa3e    	bl	0x8015b5c <arch_irq_enable> @ imm = #-0xb84
 80166e0: 2200         	movs	r2, #0x0
 80166e2: 2100         	movs	r1, #0x0
 80166e4: 200d         	movs	r0, #0xd
 80166e6: f7ff fa46    	bl	0x8015b76 <z_arm_irq_priority_set> @ imm = #-0xb74
 80166ea: 200d         	movs	r0, #0xd
 80166ec: f7ff fa36    	bl	0x8015b5c <arch_irq_enable> @ imm = #-0xb94
 80166f0: 2200         	movs	r2, #0x0
 80166f2: 2100         	movs	r1, #0x0
 80166f4: 200e         	movs	r0, #0xe
 80166f6: f7ff fa3e    	bl	0x8015b76 <z_arm_irq_priority_set> @ imm = #-0xb84
 80166fa: 200e         	movs	r0, #0xe
 80166fc: f7ff fa2e    	bl	0x8015b5c <arch_irq_enable> @ imm = #-0xba4
 8016700: 2200         	movs	r2, #0x0
 8016702: 2100         	movs	r1, #0x0
 8016704: 200f         	movs	r0, #0xf
 8016706: f7ff fa36    	bl	0x8015b76 <z_arm_irq_priority_set> @ imm = #-0xb94
 801670a: 200f         	movs	r0, #0xf
 801670c: f7ff fa26    	bl	0x8015b5c <arch_irq_enable> @ imm = #-0xbb4
 8016710: 2200         	movs	r2, #0x0
 8016712: 2100         	movs	r1, #0x0
 8016714: 2010         	movs	r0, #0x10
 8016716: f7ff fa2e    	bl	0x8015b76 <z_arm_irq_priority_set> @ imm = #-0xba4
 801671a: 2010         	movs	r0, #0x10
 801671c: f7ff fa1e    	bl	0x8015b5c <arch_irq_enable> @ imm = #-0xbc4
 8016720: 2200         	movs	r2, #0x0
 8016722: 2100         	movs	r1, #0x0
 8016724: 2011         	movs	r0, #0x11
 8016726: f7ff fa26    	bl	0x8015b76 <z_arm_irq_priority_set> @ imm = #-0xbb4
 801672a: 2011         	movs	r0, #0x11
 801672c: f7ff fa16    	bl	0x8015b5c <arch_irq_enable> @ imm = #-0xbd4
 8016730: 2200         	movs	r2, #0x0
 8016732: 2100         	movs	r1, #0x0
 8016734: 202f         	movs	r0, #0x2f
 8016736: f7ff fa1e    	bl	0x8015b76 <z_arm_irq_priority_set> @ imm = #-0xbc4
 801673a: 202f         	movs	r0, #0x2f
 801673c: f7ff fa0e    	bl	0x8015b5c <arch_irq_enable> @ imm = #-0xbe4
; }
 8016740: bf00         	nop
 8016742: 3708         	adds	r7, #0x8
 8016744: 46bd         	mov	sp, r7
 8016746: bd80         	pop	{r7, pc}

08016748 <dma_stm32_irq_1_0>:
; DMA_STM32_DEFINE_IRQ_HANDLER(1, 0);
 8016748: b580         	push	{r7, lr}
 801674a: b082         	sub	sp, #0x8
 801674c: af00         	add	r7, sp, #0x0
 801674e: 6078         	str	r0, [r7, #0x4]
 8016750: 2100         	movs	r1, #0x0
 8016752: 6878         	ldr	r0, [r7, #0x4]
 8016754: f7f0 fc70    	bl	0x8007038 <dma_stm32_irq_handler> @ imm = #-0xf720
 8016758: 3708         	adds	r7, #0x8
 801675a: 46bd         	mov	sp, r7
 801675c: bd80         	pop	{r7, pc}

0801675e <dma_stm32_irq_1_1>:
; DMA_STM32_DEFINE_IRQ_HANDLER(1, 1);
 801675e: b580         	push	{r7, lr}
 8016760: b082         	sub	sp, #0x8
 8016762: af00         	add	r7, sp, #0x0
 8016764: 6078         	str	r0, [r7, #0x4]
 8016766: 2101         	movs	r1, #0x1
 8016768: 6878         	ldr	r0, [r7, #0x4]
 801676a: f7f0 fc65    	bl	0x8007038 <dma_stm32_irq_handler> @ imm = #-0xf736
 801676e: 3708         	adds	r7, #0x8
 8016770: 46bd         	mov	sp, r7
 8016772: bd80         	pop	{r7, pc}

08016774 <dma_stm32_irq_1_2>:
; DMA_STM32_DEFINE_IRQ_HANDLER(1, 2);
 8016774: b580         	push	{r7, lr}
 8016776: b082         	sub	sp, #0x8
 8016778: af00         	add	r7, sp, #0x0
 801677a: 6078         	str	r0, [r7, #0x4]
 801677c: 2102         	movs	r1, #0x2
 801677e: 6878         	ldr	r0, [r7, #0x4]
 8016780: f7f0 fc5a    	bl	0x8007038 <dma_stm32_irq_handler> @ imm = #-0xf74c
 8016784: 3708         	adds	r7, #0x8
 8016786: 46bd         	mov	sp, r7
 8016788: bd80         	pop	{r7, pc}

0801678a <dma_stm32_irq_1_3>:
; DMA_STM32_DEFINE_IRQ_HANDLER(1, 3);
 801678a: b580         	push	{r7, lr}
 801678c: b082         	sub	sp, #0x8
 801678e: af00         	add	r7, sp, #0x0
 8016790: 6078         	str	r0, [r7, #0x4]
 8016792: 2103         	movs	r1, #0x3
 8016794: 6878         	ldr	r0, [r7, #0x4]
 8016796: f7f0 fc4f    	bl	0x8007038 <dma_stm32_irq_handler> @ imm = #-0xf762
 801679a: 3708         	adds	r7, #0x8
 801679c: 46bd         	mov	sp, r7
 801679e: bd80         	pop	{r7, pc}

080167a0 <dma_stm32_irq_1_4>:
; DMA_STM32_DEFINE_IRQ_HANDLER(1, 4);
 80167a0: b580         	push	{r7, lr}
 80167a2: b082         	sub	sp, #0x8
 80167a4: af00         	add	r7, sp, #0x0
 80167a6: 6078         	str	r0, [r7, #0x4]
 80167a8: 2104         	movs	r1, #0x4
 80167aa: 6878         	ldr	r0, [r7, #0x4]
 80167ac: f7f0 fc44    	bl	0x8007038 <dma_stm32_irq_handler> @ imm = #-0xf778
 80167b0: 3708         	adds	r7, #0x8
 80167b2: 46bd         	mov	sp, r7
 80167b4: bd80         	pop	{r7, pc}

080167b6 <dma_stm32_irq_1_5>:
; DMA_STM32_DEFINE_IRQ_HANDLER(1, 5);
 80167b6: b580         	push	{r7, lr}
 80167b8: b082         	sub	sp, #0x8
 80167ba: af00         	add	r7, sp, #0x0
 80167bc: 6078         	str	r0, [r7, #0x4]
 80167be: 2105         	movs	r1, #0x5
 80167c0: 6878         	ldr	r0, [r7, #0x4]
 80167c2: f7f0 fc39    	bl	0x8007038 <dma_stm32_irq_handler> @ imm = #-0xf78e
 80167c6: 3708         	adds	r7, #0x8
 80167c8: 46bd         	mov	sp, r7
 80167ca: bd80         	pop	{r7, pc}

080167cc <dma_stm32_irq_1_6>:
; DMA_STM32_DEFINE_IRQ_HANDLER(1, 6);
 80167cc: b580         	push	{r7, lr}
 80167ce: b082         	sub	sp, #0x8
 80167d0: af00         	add	r7, sp, #0x0
 80167d2: 6078         	str	r0, [r7, #0x4]
 80167d4: 2106         	movs	r1, #0x6
 80167d6: 6878         	ldr	r0, [r7, #0x4]
 80167d8: f7f0 fc2e    	bl	0x8007038 <dma_stm32_irq_handler> @ imm = #-0xf7a4
 80167dc: 3708         	adds	r7, #0x8
 80167de: 46bd         	mov	sp, r7
 80167e0: bd80         	pop	{r7, pc}

080167e2 <dma_stm32_irq_1_7>:
; DMA_STM32_DEFINE_IRQ_HANDLER(1, 7);
 80167e2: b580         	push	{r7, lr}
 80167e4: b082         	sub	sp, #0x8
 80167e6: af00         	add	r7, sp, #0x0
 80167e8: 6078         	str	r0, [r7, #0x4]
 80167ea: 2107         	movs	r1, #0x7
 80167ec: 6878         	ldr	r0, [r7, #0x4]
 80167ee: f7f0 fc23    	bl	0x8007038 <dma_stm32_irq_handler> @ imm = #-0xf7ba
 80167f2: 3708         	adds	r7, #0x8
 80167f4: 46bd         	mov	sp, r7
 80167f6: bd80         	pop	{r7, pc}

080167f8 <dma_stm32_config_irq_1>:
; {
 80167f8: b580         	push	{r7, lr}
 80167fa: b082         	sub	sp, #0x8
 80167fc: af00         	add	r7, sp, #0x0
 80167fe: 6078         	str	r0, [r7, #0x4]
; 	LISTIFY(
 8016800: 2200         	movs	r2, #0x0
 8016802: 2100         	movs	r1, #0x0
 8016804: 2038         	movs	r0, #0x38
 8016806: f7ff f9b6    	bl	0x8015b76 <z_arm_irq_priority_set> @ imm = #-0xc94
 801680a: 2038         	movs	r0, #0x38
 801680c: f7ff f9a6    	bl	0x8015b5c <arch_irq_enable> @ imm = #-0xcb4
 8016810: 2200         	movs	r2, #0x0
 8016812: 2100         	movs	r1, #0x0
 8016814: 2039         	movs	r0, #0x39
 8016816: f7ff f9ae    	bl	0x8015b76 <z_arm_irq_priority_set> @ imm = #-0xca4
 801681a: 2039         	movs	r0, #0x39
 801681c: f7ff f99e    	bl	0x8015b5c <arch_irq_enable> @ imm = #-0xcc4
 8016820: 2200         	movs	r2, #0x0
 8016822: 2100         	movs	r1, #0x0
 8016824: 203a         	movs	r0, #0x3a
 8016826: f7ff f9a6    	bl	0x8015b76 <z_arm_irq_priority_set> @ imm = #-0xcb4
 801682a: 203a         	movs	r0, #0x3a
 801682c: f7ff f996    	bl	0x8015b5c <arch_irq_enable> @ imm = #-0xcd4
 8016830: 2200         	movs	r2, #0x0
 8016832: 2100         	movs	r1, #0x0
 8016834: 203b         	movs	r0, #0x3b
 8016836: f7ff f99e    	bl	0x8015b76 <z_arm_irq_priority_set> @ imm = #-0xcc4
 801683a: 203b         	movs	r0, #0x3b
 801683c: f7ff f98e    	bl	0x8015b5c <arch_irq_enable> @ imm = #-0xce4
 8016840: 2200         	movs	r2, #0x0
 8016842: 2100         	movs	r1, #0x0
 8016844: 203c         	movs	r0, #0x3c
 8016846: f7ff f996    	bl	0x8015b76 <z_arm_irq_priority_set> @ imm = #-0xcd4
 801684a: 203c         	movs	r0, #0x3c
 801684c: f7ff f986    	bl	0x8015b5c <arch_irq_enable> @ imm = #-0xcf4
 8016850: 2200         	movs	r2, #0x0
 8016852: 2100         	movs	r1, #0x0
 8016854: 2044         	movs	r0, #0x44
 8016856: f7ff f98e    	bl	0x8015b76 <z_arm_irq_priority_set> @ imm = #-0xce4
 801685a: 2044         	movs	r0, #0x44
 801685c: f7ff f97e    	bl	0x8015b5c <arch_irq_enable> @ imm = #-0xd04
 8016860: 2200         	movs	r2, #0x0
 8016862: 2100         	movs	r1, #0x0
 8016864: 2045         	movs	r0, #0x45
 8016866: f7ff f986    	bl	0x8015b76 <z_arm_irq_priority_set> @ imm = #-0xcf4
 801686a: 2045         	movs	r0, #0x45
 801686c: f7ff f976    	bl	0x8015b5c <arch_irq_enable> @ imm = #-0xd14
 8016870: 2200         	movs	r2, #0x0
 8016872: 2100         	movs	r1, #0x0
 8016874: 2046         	movs	r0, #0x46
 8016876: f7ff f97e    	bl	0x8015b76 <z_arm_irq_priority_set> @ imm = #-0xd04
 801687a: 2046         	movs	r0, #0x46
 801687c: f7ff f96e    	bl	0x8015b5c <arch_irq_enable> @ imm = #-0xd24
; }
 8016880: bf00         	nop
 8016882: 3708         	adds	r7, #0x8
 8016884: 46bd         	mov	sp, r7
 8016886: bd80         	pop	{r7, pc}

08016888 <LL_DMA_IsActiveFlag_HT0>:
; {
 8016888: b480         	push	{r7}
 801688a: b083         	sub	sp, #0xc
 801688c: af00         	add	r7, sp, #0x0
 801688e: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->LISR ,DMA_LISR_HTIF0)==(DMA_LISR_HTIF0));
 8016890: 687b         	ldr	r3, [r7, #0x4]
 8016892: 681b         	ldr	r3, [r3]
 8016894: f003 0310    	and	r3, r3, #0x10
 8016898: 2b10         	cmp	r3, #0x10
 801689a: bf0c         	ite	eq
 801689c: 2301         	moveq	r3, #0x1
 801689e: 2300         	movne	r3, #0x0
 80168a0: b2db         	uxtb	r3, r3
; }
 80168a2: 4618         	mov	r0, r3
 80168a4: 370c         	adds	r7, #0xc
 80168a6: 46bd         	mov	sp, r7
 80168a8: bc80         	pop	{r7}
 80168aa: 4770         	bx	lr

080168ac <LL_DMA_IsActiveFlag_HT1>:
; {
 80168ac: b480         	push	{r7}
 80168ae: b083         	sub	sp, #0xc
 80168b0: af00         	add	r7, sp, #0x0
 80168b2: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->LISR ,DMA_LISR_HTIF1)==(DMA_LISR_HTIF1));
 80168b4: 687b         	ldr	r3, [r7, #0x4]
 80168b6: 681b         	ldr	r3, [r3]
 80168b8: f403 6380    	and	r3, r3, #0x400
 80168bc: f5b3 6f80    	cmp.w	r3, #0x400
 80168c0: bf0c         	ite	eq
 80168c2: 2301         	moveq	r3, #0x1
 80168c4: 2300         	movne	r3, #0x0
 80168c6: b2db         	uxtb	r3, r3
; }
 80168c8: 4618         	mov	r0, r3
 80168ca: 370c         	adds	r7, #0xc
 80168cc: 46bd         	mov	sp, r7
 80168ce: bc80         	pop	{r7}
 80168d0: 4770         	bx	lr

080168d2 <LL_DMA_IsActiveFlag_HT2>:
; {
 80168d2: b480         	push	{r7}
 80168d4: b083         	sub	sp, #0xc
 80168d6: af00         	add	r7, sp, #0x0
 80168d8: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->LISR ,DMA_LISR_HTIF2)==(DMA_LISR_HTIF2));
 80168da: 687b         	ldr	r3, [r7, #0x4]
 80168dc: 681b         	ldr	r3, [r3]
 80168de: f403 1380    	and	r3, r3, #0x100000
 80168e2: f5b3 1f80    	cmp.w	r3, #0x100000
 80168e6: bf0c         	ite	eq
 80168e8: 2301         	moveq	r3, #0x1
 80168ea: 2300         	movne	r3, #0x0
 80168ec: b2db         	uxtb	r3, r3
; }
 80168ee: 4618         	mov	r0, r3
 80168f0: 370c         	adds	r7, #0xc
 80168f2: 46bd         	mov	sp, r7
 80168f4: bc80         	pop	{r7}
 80168f6: 4770         	bx	lr

080168f8 <LL_DMA_IsActiveFlag_HT3>:
; {
 80168f8: b480         	push	{r7}
 80168fa: b083         	sub	sp, #0xc
 80168fc: af00         	add	r7, sp, #0x0
 80168fe: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->LISR ,DMA_LISR_HTIF3)==(DMA_LISR_HTIF3));
 8016900: 687b         	ldr	r3, [r7, #0x4]
 8016902: 681b         	ldr	r3, [r3]
 8016904: f003 6380    	and	r3, r3, #0x4000000
 8016908: f1b3 6f80    	cmp.w	r3, #0x4000000
 801690c: bf0c         	ite	eq
 801690e: 2301         	moveq	r3, #0x1
 8016910: 2300         	movne	r3, #0x0
 8016912: b2db         	uxtb	r3, r3
; }
 8016914: 4618         	mov	r0, r3
 8016916: 370c         	adds	r7, #0xc
 8016918: 46bd         	mov	sp, r7
 801691a: bc80         	pop	{r7}
 801691c: 4770         	bx	lr

0801691e <LL_DMA_IsActiveFlag_HT4>:
; {
 801691e: b480         	push	{r7}
 8016920: b083         	sub	sp, #0xc
 8016922: af00         	add	r7, sp, #0x0
 8016924: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->HISR ,DMA_HISR_HTIF4)==(DMA_HISR_HTIF4));
 8016926: 687b         	ldr	r3, [r7, #0x4]
 8016928: 685b         	ldr	r3, [r3, #0x4]
 801692a: f003 0310    	and	r3, r3, #0x10
 801692e: 2b10         	cmp	r3, #0x10
 8016930: bf0c         	ite	eq
 8016932: 2301         	moveq	r3, #0x1
 8016934: 2300         	movne	r3, #0x0
 8016936: b2db         	uxtb	r3, r3
; }
 8016938: 4618         	mov	r0, r3
 801693a: 370c         	adds	r7, #0xc
 801693c: 46bd         	mov	sp, r7
 801693e: bc80         	pop	{r7}
 8016940: 4770         	bx	lr

08016942 <LL_DMA_IsActiveFlag_HT5>:
; {
 8016942: b480         	push	{r7}
 8016944: b083         	sub	sp, #0xc
 8016946: af00         	add	r7, sp, #0x0
 8016948: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->HISR ,DMA_HISR_HTIF5)==(DMA_HISR_HTIF5));
 801694a: 687b         	ldr	r3, [r7, #0x4]
 801694c: 685b         	ldr	r3, [r3, #0x4]
 801694e: f403 6380    	and	r3, r3, #0x400
 8016952: f5b3 6f80    	cmp.w	r3, #0x400
 8016956: bf0c         	ite	eq
 8016958: 2301         	moveq	r3, #0x1
 801695a: 2300         	movne	r3, #0x0
 801695c: b2db         	uxtb	r3, r3
; }
 801695e: 4618         	mov	r0, r3
 8016960: 370c         	adds	r7, #0xc
 8016962: 46bd         	mov	sp, r7
 8016964: bc80         	pop	{r7}
 8016966: 4770         	bx	lr

08016968 <LL_DMA_IsActiveFlag_HT6>:
; {
 8016968: b480         	push	{r7}
 801696a: b083         	sub	sp, #0xc
 801696c: af00         	add	r7, sp, #0x0
 801696e: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->HISR ,DMA_HISR_HTIF6)==(DMA_HISR_HTIF6));
 8016970: 687b         	ldr	r3, [r7, #0x4]
 8016972: 685b         	ldr	r3, [r3, #0x4]
 8016974: f403 1380    	and	r3, r3, #0x100000
 8016978: f5b3 1f80    	cmp.w	r3, #0x100000
 801697c: bf0c         	ite	eq
 801697e: 2301         	moveq	r3, #0x1
 8016980: 2300         	movne	r3, #0x0
 8016982: b2db         	uxtb	r3, r3
; }
 8016984: 4618         	mov	r0, r3
 8016986: 370c         	adds	r7, #0xc
 8016988: 46bd         	mov	sp, r7
 801698a: bc80         	pop	{r7}
 801698c: 4770         	bx	lr

0801698e <LL_DMA_IsActiveFlag_HT7>:
; {
 801698e: b480         	push	{r7}
 8016990: b083         	sub	sp, #0xc
 8016992: af00         	add	r7, sp, #0x0
 8016994: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->HISR ,DMA_HISR_HTIF7)==(DMA_HISR_HTIF7));
 8016996: 687b         	ldr	r3, [r7, #0x4]
 8016998: 685b         	ldr	r3, [r3, #0x4]
 801699a: f003 6380    	and	r3, r3, #0x4000000
 801699e: f1b3 6f80    	cmp.w	r3, #0x4000000
 80169a2: bf0c         	ite	eq
 80169a4: 2301         	moveq	r3, #0x1
 80169a6: 2300         	movne	r3, #0x0
 80169a8: b2db         	uxtb	r3, r3
; }
 80169aa: 4618         	mov	r0, r3
 80169ac: 370c         	adds	r7, #0xc
 80169ae: 46bd         	mov	sp, r7
 80169b0: bc80         	pop	{r7}
 80169b2: 4770         	bx	lr

080169b4 <LL_DMA_IsActiveFlag_TC0>:
; {
 80169b4: b480         	push	{r7}
 80169b6: b083         	sub	sp, #0xc
 80169b8: af00         	add	r7, sp, #0x0
 80169ba: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->LISR ,DMA_LISR_TCIF0)==(DMA_LISR_TCIF0));
 80169bc: 687b         	ldr	r3, [r7, #0x4]
 80169be: 681b         	ldr	r3, [r3]
 80169c0: f003 0320    	and	r3, r3, #0x20
 80169c4: 2b20         	cmp	r3, #0x20
 80169c6: bf0c         	ite	eq
 80169c8: 2301         	moveq	r3, #0x1
 80169ca: 2300         	movne	r3, #0x0
 80169cc: b2db         	uxtb	r3, r3
; }
 80169ce: 4618         	mov	r0, r3
 80169d0: 370c         	adds	r7, #0xc
 80169d2: 46bd         	mov	sp, r7
 80169d4: bc80         	pop	{r7}
 80169d6: 4770         	bx	lr

080169d8 <LL_DMA_IsActiveFlag_TC1>:
; {
 80169d8: b480         	push	{r7}
 80169da: b083         	sub	sp, #0xc
 80169dc: af00         	add	r7, sp, #0x0
 80169de: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->LISR ,DMA_LISR_TCIF1)==(DMA_LISR_TCIF1));
 80169e0: 687b         	ldr	r3, [r7, #0x4]
 80169e2: 681b         	ldr	r3, [r3]
 80169e4: f403 6300    	and	r3, r3, #0x800
 80169e8: f5b3 6f00    	cmp.w	r3, #0x800
 80169ec: bf0c         	ite	eq
 80169ee: 2301         	moveq	r3, #0x1
 80169f0: 2300         	movne	r3, #0x0
 80169f2: b2db         	uxtb	r3, r3
; }
 80169f4: 4618         	mov	r0, r3
 80169f6: 370c         	adds	r7, #0xc
 80169f8: 46bd         	mov	sp, r7
 80169fa: bc80         	pop	{r7}
 80169fc: 4770         	bx	lr

080169fe <LL_DMA_IsActiveFlag_TC2>:
; {
 80169fe: b480         	push	{r7}
 8016a00: b083         	sub	sp, #0xc
 8016a02: af00         	add	r7, sp, #0x0
 8016a04: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->LISR ,DMA_LISR_TCIF2)==(DMA_LISR_TCIF2));
 8016a06: 687b         	ldr	r3, [r7, #0x4]
 8016a08: 681b         	ldr	r3, [r3]
 8016a0a: f403 1300    	and	r3, r3, #0x200000
 8016a0e: f5b3 1f00    	cmp.w	r3, #0x200000
 8016a12: bf0c         	ite	eq
 8016a14: 2301         	moveq	r3, #0x1
 8016a16: 2300         	movne	r3, #0x0
 8016a18: b2db         	uxtb	r3, r3
; }
 8016a1a: 4618         	mov	r0, r3
 8016a1c: 370c         	adds	r7, #0xc
 8016a1e: 46bd         	mov	sp, r7
 8016a20: bc80         	pop	{r7}
 8016a22: 4770         	bx	lr

08016a24 <LL_DMA_IsActiveFlag_TC3>:
; {
 8016a24: b480         	push	{r7}
 8016a26: b083         	sub	sp, #0xc
 8016a28: af00         	add	r7, sp, #0x0
 8016a2a: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->LISR ,DMA_LISR_TCIF3)==(DMA_LISR_TCIF3));
 8016a2c: 687b         	ldr	r3, [r7, #0x4]
 8016a2e: 681b         	ldr	r3, [r3]
 8016a30: f003 6300    	and	r3, r3, #0x8000000
 8016a34: f1b3 6f00    	cmp.w	r3, #0x8000000
 8016a38: bf0c         	ite	eq
 8016a3a: 2301         	moveq	r3, #0x1
 8016a3c: 2300         	movne	r3, #0x0
 8016a3e: b2db         	uxtb	r3, r3
; }
 8016a40: 4618         	mov	r0, r3
 8016a42: 370c         	adds	r7, #0xc
 8016a44: 46bd         	mov	sp, r7
 8016a46: bc80         	pop	{r7}
 8016a48: 4770         	bx	lr

08016a4a <LL_DMA_IsActiveFlag_TC4>:
; {
 8016a4a: b480         	push	{r7}
 8016a4c: b083         	sub	sp, #0xc
 8016a4e: af00         	add	r7, sp, #0x0
 8016a50: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->HISR ,DMA_HISR_TCIF4)==(DMA_HISR_TCIF4));
 8016a52: 687b         	ldr	r3, [r7, #0x4]
 8016a54: 685b         	ldr	r3, [r3, #0x4]
 8016a56: f003 0320    	and	r3, r3, #0x20
 8016a5a: 2b20         	cmp	r3, #0x20
 8016a5c: bf0c         	ite	eq
 8016a5e: 2301         	moveq	r3, #0x1
 8016a60: 2300         	movne	r3, #0x0
 8016a62: b2db         	uxtb	r3, r3
; }
 8016a64: 4618         	mov	r0, r3
 8016a66: 370c         	adds	r7, #0xc
 8016a68: 46bd         	mov	sp, r7
 8016a6a: bc80         	pop	{r7}
 8016a6c: 4770         	bx	lr

08016a6e <LL_DMA_IsActiveFlag_TC5>:
; {
 8016a6e: b480         	push	{r7}
 8016a70: b083         	sub	sp, #0xc
 8016a72: af00         	add	r7, sp, #0x0
 8016a74: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->HISR ,DMA_HISR_TCIF5)==(DMA_HISR_TCIF5));
 8016a76: 687b         	ldr	r3, [r7, #0x4]
 8016a78: 685b         	ldr	r3, [r3, #0x4]
 8016a7a: f403 6300    	and	r3, r3, #0x800
 8016a7e: f5b3 6f00    	cmp.w	r3, #0x800
 8016a82: bf0c         	ite	eq
 8016a84: 2301         	moveq	r3, #0x1
 8016a86: 2300         	movne	r3, #0x0
 8016a88: b2db         	uxtb	r3, r3
; }
 8016a8a: 4618         	mov	r0, r3
 8016a8c: 370c         	adds	r7, #0xc
 8016a8e: 46bd         	mov	sp, r7
 8016a90: bc80         	pop	{r7}
 8016a92: 4770         	bx	lr

08016a94 <LL_DMA_IsActiveFlag_TC6>:
; {
 8016a94: b480         	push	{r7}
 8016a96: b083         	sub	sp, #0xc
 8016a98: af00         	add	r7, sp, #0x0
 8016a9a: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->HISR ,DMA_HISR_TCIF6)==(DMA_HISR_TCIF6));
 8016a9c: 687b         	ldr	r3, [r7, #0x4]
 8016a9e: 685b         	ldr	r3, [r3, #0x4]
 8016aa0: f403 1300    	and	r3, r3, #0x200000
 8016aa4: f5b3 1f00    	cmp.w	r3, #0x200000
 8016aa8: bf0c         	ite	eq
 8016aaa: 2301         	moveq	r3, #0x1
 8016aac: 2300         	movne	r3, #0x0
 8016aae: b2db         	uxtb	r3, r3
; }
 8016ab0: 4618         	mov	r0, r3
 8016ab2: 370c         	adds	r7, #0xc
 8016ab4: 46bd         	mov	sp, r7
 8016ab6: bc80         	pop	{r7}
 8016ab8: 4770         	bx	lr

08016aba <LL_DMA_IsActiveFlag_TC7>:
; {
 8016aba: b480         	push	{r7}
 8016abc: b083         	sub	sp, #0xc
 8016abe: af00         	add	r7, sp, #0x0
 8016ac0: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->HISR ,DMA_HISR_TCIF7)==(DMA_HISR_TCIF7));
 8016ac2: 687b         	ldr	r3, [r7, #0x4]
 8016ac4: 685b         	ldr	r3, [r3, #0x4]
 8016ac6: f003 6300    	and	r3, r3, #0x8000000
 8016aca: f1b3 6f00    	cmp.w	r3, #0x8000000
 8016ace: bf0c         	ite	eq
 8016ad0: 2301         	moveq	r3, #0x1
 8016ad2: 2300         	movne	r3, #0x0
 8016ad4: b2db         	uxtb	r3, r3
; }
 8016ad6: 4618         	mov	r0, r3
 8016ad8: 370c         	adds	r7, #0xc
 8016ada: 46bd         	mov	sp, r7
 8016adc: bc80         	pop	{r7}
 8016ade: 4770         	bx	lr

08016ae0 <LL_DMA_IsActiveFlag_TE0>:
; {
 8016ae0: b480         	push	{r7}
 8016ae2: b083         	sub	sp, #0xc
 8016ae4: af00         	add	r7, sp, #0x0
 8016ae6: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->LISR ,DMA_LISR_TEIF0)==(DMA_LISR_TEIF0));
 8016ae8: 687b         	ldr	r3, [r7, #0x4]
 8016aea: 681b         	ldr	r3, [r3]
 8016aec: f003 0308    	and	r3, r3, #0x8
 8016af0: 2b08         	cmp	r3, #0x8
 8016af2: bf0c         	ite	eq
 8016af4: 2301         	moveq	r3, #0x1
 8016af6: 2300         	movne	r3, #0x0
 8016af8: b2db         	uxtb	r3, r3
; }
 8016afa: 4618         	mov	r0, r3
 8016afc: 370c         	adds	r7, #0xc
 8016afe: 46bd         	mov	sp, r7
 8016b00: bc80         	pop	{r7}
 8016b02: 4770         	bx	lr

08016b04 <LL_DMA_IsActiveFlag_TE1>:
; {
 8016b04: b480         	push	{r7}
 8016b06: b083         	sub	sp, #0xc
 8016b08: af00         	add	r7, sp, #0x0
 8016b0a: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->LISR ,DMA_LISR_TEIF1)==(DMA_LISR_TEIF1));
 8016b0c: 687b         	ldr	r3, [r7, #0x4]
 8016b0e: 681b         	ldr	r3, [r3]
 8016b10: f403 7300    	and	r3, r3, #0x200
 8016b14: f5b3 7f00    	cmp.w	r3, #0x200
 8016b18: bf0c         	ite	eq
 8016b1a: 2301         	moveq	r3, #0x1
 8016b1c: 2300         	movne	r3, #0x0
 8016b1e: b2db         	uxtb	r3, r3
; }
 8016b20: 4618         	mov	r0, r3
 8016b22: 370c         	adds	r7, #0xc
 8016b24: 46bd         	mov	sp, r7
 8016b26: bc80         	pop	{r7}
 8016b28: 4770         	bx	lr

08016b2a <LL_DMA_IsActiveFlag_TE2>:
; {
 8016b2a: b480         	push	{r7}
 8016b2c: b083         	sub	sp, #0xc
 8016b2e: af00         	add	r7, sp, #0x0
 8016b30: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->LISR ,DMA_LISR_TEIF2)==(DMA_LISR_TEIF2));
 8016b32: 687b         	ldr	r3, [r7, #0x4]
 8016b34: 681b         	ldr	r3, [r3]
 8016b36: f403 2300    	and	r3, r3, #0x80000
 8016b3a: f5b3 2f00    	cmp.w	r3, #0x80000
 8016b3e: bf0c         	ite	eq
 8016b40: 2301         	moveq	r3, #0x1
 8016b42: 2300         	movne	r3, #0x0
 8016b44: b2db         	uxtb	r3, r3
; }
 8016b46: 4618         	mov	r0, r3
 8016b48: 370c         	adds	r7, #0xc
 8016b4a: 46bd         	mov	sp, r7
 8016b4c: bc80         	pop	{r7}
 8016b4e: 4770         	bx	lr

08016b50 <LL_DMA_IsActiveFlag_TE3>:
; {
 8016b50: b480         	push	{r7}
 8016b52: b083         	sub	sp, #0xc
 8016b54: af00         	add	r7, sp, #0x0
 8016b56: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->LISR ,DMA_LISR_TEIF3)==(DMA_LISR_TEIF3));
 8016b58: 687b         	ldr	r3, [r7, #0x4]
 8016b5a: 681b         	ldr	r3, [r3]
 8016b5c: f003 7300    	and	r3, r3, #0x2000000
 8016b60: f1b3 7f00    	cmp.w	r3, #0x2000000
 8016b64: bf0c         	ite	eq
 8016b66: 2301         	moveq	r3, #0x1
 8016b68: 2300         	movne	r3, #0x0
 8016b6a: b2db         	uxtb	r3, r3
; }
 8016b6c: 4618         	mov	r0, r3
 8016b6e: 370c         	adds	r7, #0xc
 8016b70: 46bd         	mov	sp, r7
 8016b72: bc80         	pop	{r7}
 8016b74: 4770         	bx	lr

08016b76 <LL_DMA_IsActiveFlag_TE4>:
; {
 8016b76: b480         	push	{r7}
 8016b78: b083         	sub	sp, #0xc
 8016b7a: af00         	add	r7, sp, #0x0
 8016b7c: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->HISR ,DMA_HISR_TEIF4)==(DMA_HISR_TEIF4));
 8016b7e: 687b         	ldr	r3, [r7, #0x4]
 8016b80: 685b         	ldr	r3, [r3, #0x4]
 8016b82: f003 0308    	and	r3, r3, #0x8
 8016b86: 2b08         	cmp	r3, #0x8
 8016b88: bf0c         	ite	eq
 8016b8a: 2301         	moveq	r3, #0x1
 8016b8c: 2300         	movne	r3, #0x0
 8016b8e: b2db         	uxtb	r3, r3
; }
 8016b90: 4618         	mov	r0, r3
 8016b92: 370c         	adds	r7, #0xc
 8016b94: 46bd         	mov	sp, r7
 8016b96: bc80         	pop	{r7}
 8016b98: 4770         	bx	lr

08016b9a <LL_DMA_IsActiveFlag_TE5>:
; {
 8016b9a: b480         	push	{r7}
 8016b9c: b083         	sub	sp, #0xc
 8016b9e: af00         	add	r7, sp, #0x0
 8016ba0: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->HISR ,DMA_HISR_TEIF5)==(DMA_HISR_TEIF5));
 8016ba2: 687b         	ldr	r3, [r7, #0x4]
 8016ba4: 685b         	ldr	r3, [r3, #0x4]
 8016ba6: f403 7300    	and	r3, r3, #0x200
 8016baa: f5b3 7f00    	cmp.w	r3, #0x200
 8016bae: bf0c         	ite	eq
 8016bb0: 2301         	moveq	r3, #0x1
 8016bb2: 2300         	movne	r3, #0x0
 8016bb4: b2db         	uxtb	r3, r3
; }
 8016bb6: 4618         	mov	r0, r3
 8016bb8: 370c         	adds	r7, #0xc
 8016bba: 46bd         	mov	sp, r7
 8016bbc: bc80         	pop	{r7}
 8016bbe: 4770         	bx	lr

08016bc0 <LL_DMA_IsActiveFlag_TE6>:
; {
 8016bc0: b480         	push	{r7}
 8016bc2: b083         	sub	sp, #0xc
 8016bc4: af00         	add	r7, sp, #0x0
 8016bc6: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->HISR ,DMA_HISR_TEIF6)==(DMA_HISR_TEIF6));
 8016bc8: 687b         	ldr	r3, [r7, #0x4]
 8016bca: 685b         	ldr	r3, [r3, #0x4]
 8016bcc: f403 2300    	and	r3, r3, #0x80000
 8016bd0: f5b3 2f00    	cmp.w	r3, #0x80000
 8016bd4: bf0c         	ite	eq
 8016bd6: 2301         	moveq	r3, #0x1
 8016bd8: 2300         	movne	r3, #0x0
 8016bda: b2db         	uxtb	r3, r3
; }
 8016bdc: 4618         	mov	r0, r3
 8016bde: 370c         	adds	r7, #0xc
 8016be0: 46bd         	mov	sp, r7
 8016be2: bc80         	pop	{r7}
 8016be4: 4770         	bx	lr

08016be6 <LL_DMA_IsActiveFlag_TE7>:
; {
 8016be6: b480         	push	{r7}
 8016be8: b083         	sub	sp, #0xc
 8016bea: af00         	add	r7, sp, #0x0
 8016bec: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->HISR ,DMA_HISR_TEIF7)==(DMA_HISR_TEIF7));
 8016bee: 687b         	ldr	r3, [r7, #0x4]
 8016bf0: 685b         	ldr	r3, [r3, #0x4]
 8016bf2: f003 7300    	and	r3, r3, #0x2000000
 8016bf6: f1b3 7f00    	cmp.w	r3, #0x2000000
 8016bfa: bf0c         	ite	eq
 8016bfc: 2301         	moveq	r3, #0x1
 8016bfe: 2300         	movne	r3, #0x0
 8016c00: b2db         	uxtb	r3, r3
; }
 8016c02: 4618         	mov	r0, r3
 8016c04: 370c         	adds	r7, #0xc
 8016c06: 46bd         	mov	sp, r7
 8016c08: bc80         	pop	{r7}
 8016c0a: 4770         	bx	lr

08016c0c <LL_DMA_IsActiveFlag_DME0>:
; {
 8016c0c: b480         	push	{r7}
 8016c0e: b083         	sub	sp, #0xc
 8016c10: af00         	add	r7, sp, #0x0
 8016c12: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->LISR ,DMA_LISR_DMEIF0)==(DMA_LISR_DMEIF0));
 8016c14: 687b         	ldr	r3, [r7, #0x4]
 8016c16: 681b         	ldr	r3, [r3]
 8016c18: f003 0304    	and	r3, r3, #0x4
 8016c1c: 2b04         	cmp	r3, #0x4
 8016c1e: bf0c         	ite	eq
 8016c20: 2301         	moveq	r3, #0x1
 8016c22: 2300         	movne	r3, #0x0
 8016c24: b2db         	uxtb	r3, r3
; }
 8016c26: 4618         	mov	r0, r3
 8016c28: 370c         	adds	r7, #0xc
 8016c2a: 46bd         	mov	sp, r7
 8016c2c: bc80         	pop	{r7}
 8016c2e: 4770         	bx	lr

08016c30 <LL_DMA_IsActiveFlag_DME1>:
; {
 8016c30: b480         	push	{r7}
 8016c32: b083         	sub	sp, #0xc
 8016c34: af00         	add	r7, sp, #0x0
 8016c36: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->LISR ,DMA_LISR_DMEIF1)==(DMA_LISR_DMEIF1));
 8016c38: 687b         	ldr	r3, [r7, #0x4]
 8016c3a: 681b         	ldr	r3, [r3]
 8016c3c: f403 7380    	and	r3, r3, #0x100
 8016c40: f5b3 7f80    	cmp.w	r3, #0x100
 8016c44: bf0c         	ite	eq
 8016c46: 2301         	moveq	r3, #0x1
 8016c48: 2300         	movne	r3, #0x0
 8016c4a: b2db         	uxtb	r3, r3
; }
 8016c4c: 4618         	mov	r0, r3
 8016c4e: 370c         	adds	r7, #0xc
 8016c50: 46bd         	mov	sp, r7
 8016c52: bc80         	pop	{r7}
 8016c54: 4770         	bx	lr

08016c56 <LL_DMA_IsActiveFlag_DME2>:
; {
 8016c56: b480         	push	{r7}
 8016c58: b083         	sub	sp, #0xc
 8016c5a: af00         	add	r7, sp, #0x0
 8016c5c: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->LISR ,DMA_LISR_DMEIF2)==(DMA_LISR_DMEIF2));
 8016c5e: 687b         	ldr	r3, [r7, #0x4]
 8016c60: 681b         	ldr	r3, [r3]
 8016c62: f403 2380    	and	r3, r3, #0x40000
 8016c66: f5b3 2f80    	cmp.w	r3, #0x40000
 8016c6a: bf0c         	ite	eq
 8016c6c: 2301         	moveq	r3, #0x1
 8016c6e: 2300         	movne	r3, #0x0
 8016c70: b2db         	uxtb	r3, r3
; }
 8016c72: 4618         	mov	r0, r3
 8016c74: 370c         	adds	r7, #0xc
 8016c76: 46bd         	mov	sp, r7
 8016c78: bc80         	pop	{r7}
 8016c7a: 4770         	bx	lr

08016c7c <LL_DMA_IsActiveFlag_DME3>:
; {
 8016c7c: b480         	push	{r7}
 8016c7e: b083         	sub	sp, #0xc
 8016c80: af00         	add	r7, sp, #0x0
 8016c82: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->LISR ,DMA_LISR_DMEIF3)==(DMA_LISR_DMEIF3));
 8016c84: 687b         	ldr	r3, [r7, #0x4]
 8016c86: 681b         	ldr	r3, [r3]
 8016c88: f003 7380    	and	r3, r3, #0x1000000
 8016c8c: f1b3 7f80    	cmp.w	r3, #0x1000000
 8016c90: bf0c         	ite	eq
 8016c92: 2301         	moveq	r3, #0x1
 8016c94: 2300         	movne	r3, #0x0
 8016c96: b2db         	uxtb	r3, r3
; }
 8016c98: 4618         	mov	r0, r3
 8016c9a: 370c         	adds	r7, #0xc
 8016c9c: 46bd         	mov	sp, r7
 8016c9e: bc80         	pop	{r7}
 8016ca0: 4770         	bx	lr

08016ca2 <LL_DMA_IsActiveFlag_DME4>:
; {
 8016ca2: b480         	push	{r7}
 8016ca4: b083         	sub	sp, #0xc
 8016ca6: af00         	add	r7, sp, #0x0
 8016ca8: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->HISR ,DMA_HISR_DMEIF4)==(DMA_HISR_DMEIF4));
 8016caa: 687b         	ldr	r3, [r7, #0x4]
 8016cac: 685b         	ldr	r3, [r3, #0x4]
 8016cae: f003 0304    	and	r3, r3, #0x4
 8016cb2: 2b04         	cmp	r3, #0x4
 8016cb4: bf0c         	ite	eq
 8016cb6: 2301         	moveq	r3, #0x1
 8016cb8: 2300         	movne	r3, #0x0
 8016cba: b2db         	uxtb	r3, r3
; }
 8016cbc: 4618         	mov	r0, r3
 8016cbe: 370c         	adds	r7, #0xc
 8016cc0: 46bd         	mov	sp, r7
 8016cc2: bc80         	pop	{r7}
 8016cc4: 4770         	bx	lr

08016cc6 <LL_DMA_IsActiveFlag_DME5>:
; {
 8016cc6: b480         	push	{r7}
 8016cc8: b083         	sub	sp, #0xc
 8016cca: af00         	add	r7, sp, #0x0
 8016ccc: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->HISR ,DMA_HISR_DMEIF5)==(DMA_HISR_DMEIF5));
 8016cce: 687b         	ldr	r3, [r7, #0x4]
 8016cd0: 685b         	ldr	r3, [r3, #0x4]
 8016cd2: f403 7380    	and	r3, r3, #0x100
 8016cd6: f5b3 7f80    	cmp.w	r3, #0x100
 8016cda: bf0c         	ite	eq
 8016cdc: 2301         	moveq	r3, #0x1
 8016cde: 2300         	movne	r3, #0x0
 8016ce0: b2db         	uxtb	r3, r3
; }
 8016ce2: 4618         	mov	r0, r3
 8016ce4: 370c         	adds	r7, #0xc
 8016ce6: 46bd         	mov	sp, r7
 8016ce8: bc80         	pop	{r7}
 8016cea: 4770         	bx	lr

08016cec <LL_DMA_IsActiveFlag_DME6>:
; {
 8016cec: b480         	push	{r7}
 8016cee: b083         	sub	sp, #0xc
 8016cf0: af00         	add	r7, sp, #0x0
 8016cf2: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->HISR ,DMA_HISR_DMEIF6)==(DMA_HISR_DMEIF6));
 8016cf4: 687b         	ldr	r3, [r7, #0x4]
 8016cf6: 685b         	ldr	r3, [r3, #0x4]
 8016cf8: f403 2380    	and	r3, r3, #0x40000
 8016cfc: f5b3 2f80    	cmp.w	r3, #0x40000
 8016d00: bf0c         	ite	eq
 8016d02: 2301         	moveq	r3, #0x1
 8016d04: 2300         	movne	r3, #0x0
 8016d06: b2db         	uxtb	r3, r3
; }
 8016d08: 4618         	mov	r0, r3
 8016d0a: 370c         	adds	r7, #0xc
 8016d0c: 46bd         	mov	sp, r7
 8016d0e: bc80         	pop	{r7}
 8016d10: 4770         	bx	lr

08016d12 <LL_DMA_IsActiveFlag_DME7>:
; {
 8016d12: b480         	push	{r7}
 8016d14: b083         	sub	sp, #0xc
 8016d16: af00         	add	r7, sp, #0x0
 8016d18: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->HISR ,DMA_HISR_DMEIF7)==(DMA_HISR_DMEIF7));
 8016d1a: 687b         	ldr	r3, [r7, #0x4]
 8016d1c: 685b         	ldr	r3, [r3, #0x4]
 8016d1e: f003 7380    	and	r3, r3, #0x1000000
 8016d22: f1b3 7f80    	cmp.w	r3, #0x1000000
 8016d26: bf0c         	ite	eq
 8016d28: 2301         	moveq	r3, #0x1
 8016d2a: 2300         	movne	r3, #0x0
 8016d2c: b2db         	uxtb	r3, r3
; }
 8016d2e: 4618         	mov	r0, r3
 8016d30: 370c         	adds	r7, #0xc
 8016d32: 46bd         	mov	sp, r7
 8016d34: bc80         	pop	{r7}
 8016d36: 4770         	bx	lr

08016d38 <LL_DMA_IsActiveFlag_FE0>:
; {
 8016d38: b480         	push	{r7}
 8016d3a: b083         	sub	sp, #0xc
 8016d3c: af00         	add	r7, sp, #0x0
 8016d3e: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->LISR ,DMA_LISR_FEIF0)==(DMA_LISR_FEIF0));
 8016d40: 687b         	ldr	r3, [r7, #0x4]
 8016d42: 681b         	ldr	r3, [r3]
 8016d44: f003 0301    	and	r3, r3, #0x1
 8016d48: 2b01         	cmp	r3, #0x1
 8016d4a: bf0c         	ite	eq
 8016d4c: 2301         	moveq	r3, #0x1
 8016d4e: 2300         	movne	r3, #0x0
 8016d50: b2db         	uxtb	r3, r3
; }
 8016d52: 4618         	mov	r0, r3
 8016d54: 370c         	adds	r7, #0xc
 8016d56: 46bd         	mov	sp, r7
 8016d58: bc80         	pop	{r7}
 8016d5a: 4770         	bx	lr

08016d5c <LL_DMA_IsActiveFlag_FE1>:
; {
 8016d5c: b480         	push	{r7}
 8016d5e: b083         	sub	sp, #0xc
 8016d60: af00         	add	r7, sp, #0x0
 8016d62: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->LISR ,DMA_LISR_FEIF1)==(DMA_LISR_FEIF1));
 8016d64: 687b         	ldr	r3, [r7, #0x4]
 8016d66: 681b         	ldr	r3, [r3]
 8016d68: f003 0340    	and	r3, r3, #0x40
 8016d6c: 2b40         	cmp	r3, #0x40
 8016d6e: bf0c         	ite	eq
 8016d70: 2301         	moveq	r3, #0x1
 8016d72: 2300         	movne	r3, #0x0
 8016d74: b2db         	uxtb	r3, r3
; }
 8016d76: 4618         	mov	r0, r3
 8016d78: 370c         	adds	r7, #0xc
 8016d7a: 46bd         	mov	sp, r7
 8016d7c: bc80         	pop	{r7}
 8016d7e: 4770         	bx	lr

08016d80 <LL_DMA_IsActiveFlag_FE2>:
; {
 8016d80: b480         	push	{r7}
 8016d82: b083         	sub	sp, #0xc
 8016d84: af00         	add	r7, sp, #0x0
 8016d86: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->LISR ,DMA_LISR_FEIF2)==(DMA_LISR_FEIF2));
 8016d88: 687b         	ldr	r3, [r7, #0x4]
 8016d8a: 681b         	ldr	r3, [r3]
 8016d8c: f403 3380    	and	r3, r3, #0x10000
 8016d90: f5b3 3f80    	cmp.w	r3, #0x10000
 8016d94: bf0c         	ite	eq
 8016d96: 2301         	moveq	r3, #0x1
 8016d98: 2300         	movne	r3, #0x0
 8016d9a: b2db         	uxtb	r3, r3
; }
 8016d9c: 4618         	mov	r0, r3
 8016d9e: 370c         	adds	r7, #0xc
 8016da0: 46bd         	mov	sp, r7
 8016da2: bc80         	pop	{r7}
 8016da4: 4770         	bx	lr

08016da6 <LL_DMA_IsActiveFlag_FE3>:
; {
 8016da6: b480         	push	{r7}
 8016da8: b083         	sub	sp, #0xc
 8016daa: af00         	add	r7, sp, #0x0
 8016dac: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->LISR ,DMA_LISR_FEIF3)==(DMA_LISR_FEIF3));
 8016dae: 687b         	ldr	r3, [r7, #0x4]
 8016db0: 681b         	ldr	r3, [r3]
 8016db2: f403 0380    	and	r3, r3, #0x400000
 8016db6: f5b3 0f80    	cmp.w	r3, #0x400000
 8016dba: bf0c         	ite	eq
 8016dbc: 2301         	moveq	r3, #0x1
 8016dbe: 2300         	movne	r3, #0x0
 8016dc0: b2db         	uxtb	r3, r3
; }
 8016dc2: 4618         	mov	r0, r3
 8016dc4: 370c         	adds	r7, #0xc
 8016dc6: 46bd         	mov	sp, r7
 8016dc8: bc80         	pop	{r7}
 8016dca: 4770         	bx	lr

08016dcc <LL_DMA_IsActiveFlag_FE4>:
; {
 8016dcc: b480         	push	{r7}
 8016dce: b083         	sub	sp, #0xc
 8016dd0: af00         	add	r7, sp, #0x0
 8016dd2: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->HISR ,DMA_HISR_FEIF4)==(DMA_HISR_FEIF4));
 8016dd4: 687b         	ldr	r3, [r7, #0x4]
 8016dd6: 685b         	ldr	r3, [r3, #0x4]
 8016dd8: f003 0301    	and	r3, r3, #0x1
 8016ddc: 2b01         	cmp	r3, #0x1
 8016dde: bf0c         	ite	eq
 8016de0: 2301         	moveq	r3, #0x1
 8016de2: 2300         	movne	r3, #0x0
 8016de4: b2db         	uxtb	r3, r3
; }
 8016de6: 4618         	mov	r0, r3
 8016de8: 370c         	adds	r7, #0xc
 8016dea: 46bd         	mov	sp, r7
 8016dec: bc80         	pop	{r7}
 8016dee: 4770         	bx	lr

08016df0 <LL_DMA_IsActiveFlag_FE5>:
; {
 8016df0: b480         	push	{r7}
 8016df2: b083         	sub	sp, #0xc
 8016df4: af00         	add	r7, sp, #0x0
 8016df6: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->HISR ,DMA_HISR_FEIF5)==(DMA_HISR_FEIF5));
 8016df8: 687b         	ldr	r3, [r7, #0x4]
 8016dfa: 685b         	ldr	r3, [r3, #0x4]
 8016dfc: f003 0340    	and	r3, r3, #0x40
 8016e00: 2b40         	cmp	r3, #0x40
 8016e02: bf0c         	ite	eq
 8016e04: 2301         	moveq	r3, #0x1
 8016e06: 2300         	movne	r3, #0x0
 8016e08: b2db         	uxtb	r3, r3
; }
 8016e0a: 4618         	mov	r0, r3
 8016e0c: 370c         	adds	r7, #0xc
 8016e0e: 46bd         	mov	sp, r7
 8016e10: bc80         	pop	{r7}
 8016e12: 4770         	bx	lr

08016e14 <LL_DMA_IsActiveFlag_FE6>:
; {
 8016e14: b480         	push	{r7}
 8016e16: b083         	sub	sp, #0xc
 8016e18: af00         	add	r7, sp, #0x0
 8016e1a: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->HISR ,DMA_HISR_FEIF6)==(DMA_HISR_FEIF6));
 8016e1c: 687b         	ldr	r3, [r7, #0x4]
 8016e1e: 685b         	ldr	r3, [r3, #0x4]
 8016e20: f403 3380    	and	r3, r3, #0x10000
 8016e24: f5b3 3f80    	cmp.w	r3, #0x10000
 8016e28: bf0c         	ite	eq
 8016e2a: 2301         	moveq	r3, #0x1
 8016e2c: 2300         	movne	r3, #0x0
 8016e2e: b2db         	uxtb	r3, r3
; }
 8016e30: 4618         	mov	r0, r3
 8016e32: 370c         	adds	r7, #0xc
 8016e34: 46bd         	mov	sp, r7
 8016e36: bc80         	pop	{r7}
 8016e38: 4770         	bx	lr

08016e3a <LL_DMA_IsActiveFlag_FE7>:
; {
 8016e3a: b480         	push	{r7}
 8016e3c: b083         	sub	sp, #0xc
 8016e3e: af00         	add	r7, sp, #0x0
 8016e40: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->HISR ,DMA_HISR_FEIF7)==(DMA_HISR_FEIF7));
 8016e42: 687b         	ldr	r3, [r7, #0x4]
 8016e44: 685b         	ldr	r3, [r3, #0x4]
 8016e46: f403 0380    	and	r3, r3, #0x400000
 8016e4a: f5b3 0f80    	cmp.w	r3, #0x400000
 8016e4e: bf0c         	ite	eq
 8016e50: 2301         	moveq	r3, #0x1
 8016e52: 2300         	movne	r3, #0x0
 8016e54: b2db         	uxtb	r3, r3
; }
 8016e56: 4618         	mov	r0, r3
 8016e58: 370c         	adds	r7, #0xc
 8016e5a: 46bd         	mov	sp, r7
 8016e5c: bc80         	pop	{r7}
 8016e5e: 4770         	bx	lr

08016e60 <LL_DMA_ClearFlag_HT0>:
; {
 8016e60: b480         	push	{r7}
 8016e62: b083         	sub	sp, #0xc
 8016e64: af00         	add	r7, sp, #0x0
 8016e66: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->LIFCR , DMA_LIFCR_CHTIF0);
 8016e68: 687b         	ldr	r3, [r7, #0x4]
 8016e6a: 2210         	movs	r2, #0x10
 8016e6c: 609a         	str	r2, [r3, #0x8]
; }
 8016e6e: bf00         	nop
 8016e70: 370c         	adds	r7, #0xc
 8016e72: 46bd         	mov	sp, r7
 8016e74: bc80         	pop	{r7}
 8016e76: 4770         	bx	lr

08016e78 <LL_DMA_ClearFlag_HT1>:
; {
 8016e78: b480         	push	{r7}
 8016e7a: b083         	sub	sp, #0xc
 8016e7c: af00         	add	r7, sp, #0x0
 8016e7e: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->LIFCR , DMA_LIFCR_CHTIF1);
 8016e80: 687b         	ldr	r3, [r7, #0x4]
 8016e82: f44f 6280    	mov.w	r2, #0x400
 8016e86: 609a         	str	r2, [r3, #0x8]
; }
 8016e88: bf00         	nop
 8016e8a: 370c         	adds	r7, #0xc
 8016e8c: 46bd         	mov	sp, r7
 8016e8e: bc80         	pop	{r7}
 8016e90: 4770         	bx	lr

08016e92 <LL_DMA_ClearFlag_HT2>:
; {
 8016e92: b480         	push	{r7}
 8016e94: b083         	sub	sp, #0xc
 8016e96: af00         	add	r7, sp, #0x0
 8016e98: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->LIFCR , DMA_LIFCR_CHTIF2);
 8016e9a: 687b         	ldr	r3, [r7, #0x4]
 8016e9c: f44f 1280    	mov.w	r2, #0x100000
 8016ea0: 609a         	str	r2, [r3, #0x8]
; }
 8016ea2: bf00         	nop
 8016ea4: 370c         	adds	r7, #0xc
 8016ea6: 46bd         	mov	sp, r7
 8016ea8: bc80         	pop	{r7}
 8016eaa: 4770         	bx	lr

08016eac <LL_DMA_ClearFlag_HT3>:
; {
 8016eac: b480         	push	{r7}
 8016eae: b083         	sub	sp, #0xc
 8016eb0: af00         	add	r7, sp, #0x0
 8016eb2: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->LIFCR , DMA_LIFCR_CHTIF3);
 8016eb4: 687b         	ldr	r3, [r7, #0x4]
 8016eb6: f04f 6280    	mov.w	r2, #0x4000000
 8016eba: 609a         	str	r2, [r3, #0x8]
; }
 8016ebc: bf00         	nop
 8016ebe: 370c         	adds	r7, #0xc
 8016ec0: 46bd         	mov	sp, r7
 8016ec2: bc80         	pop	{r7}
 8016ec4: 4770         	bx	lr

08016ec6 <LL_DMA_ClearFlag_HT4>:
; {
 8016ec6: b480         	push	{r7}
 8016ec8: b083         	sub	sp, #0xc
 8016eca: af00         	add	r7, sp, #0x0
 8016ecc: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->HIFCR , DMA_HIFCR_CHTIF4);
 8016ece: 687b         	ldr	r3, [r7, #0x4]
 8016ed0: 2210         	movs	r2, #0x10
 8016ed2: 60da         	str	r2, [r3, #0xc]
; }
 8016ed4: bf00         	nop
 8016ed6: 370c         	adds	r7, #0xc
 8016ed8: 46bd         	mov	sp, r7
 8016eda: bc80         	pop	{r7}
 8016edc: 4770         	bx	lr

08016ede <LL_DMA_ClearFlag_HT5>:
; {
 8016ede: b480         	push	{r7}
 8016ee0: b083         	sub	sp, #0xc
 8016ee2: af00         	add	r7, sp, #0x0
 8016ee4: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->HIFCR , DMA_HIFCR_CHTIF5);
 8016ee6: 687b         	ldr	r3, [r7, #0x4]
 8016ee8: f44f 6280    	mov.w	r2, #0x400
 8016eec: 60da         	str	r2, [r3, #0xc]
; }
 8016eee: bf00         	nop
 8016ef0: 370c         	adds	r7, #0xc
 8016ef2: 46bd         	mov	sp, r7
 8016ef4: bc80         	pop	{r7}
 8016ef6: 4770         	bx	lr

08016ef8 <LL_DMA_ClearFlag_HT6>:
; {
 8016ef8: b480         	push	{r7}
 8016efa: b083         	sub	sp, #0xc
 8016efc: af00         	add	r7, sp, #0x0
 8016efe: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->HIFCR , DMA_HIFCR_CHTIF6);
 8016f00: 687b         	ldr	r3, [r7, #0x4]
 8016f02: f44f 1280    	mov.w	r2, #0x100000
 8016f06: 60da         	str	r2, [r3, #0xc]
; }
 8016f08: bf00         	nop
 8016f0a: 370c         	adds	r7, #0xc
 8016f0c: 46bd         	mov	sp, r7
 8016f0e: bc80         	pop	{r7}
 8016f10: 4770         	bx	lr

08016f12 <LL_DMA_ClearFlag_HT7>:
; {
 8016f12: b480         	push	{r7}
 8016f14: b083         	sub	sp, #0xc
 8016f16: af00         	add	r7, sp, #0x0
 8016f18: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->HIFCR , DMA_HIFCR_CHTIF7);
 8016f1a: 687b         	ldr	r3, [r7, #0x4]
 8016f1c: f04f 6280    	mov.w	r2, #0x4000000
 8016f20: 60da         	str	r2, [r3, #0xc]
; }
 8016f22: bf00         	nop
 8016f24: 370c         	adds	r7, #0xc
 8016f26: 46bd         	mov	sp, r7
 8016f28: bc80         	pop	{r7}
 8016f2a: 4770         	bx	lr

08016f2c <LL_DMA_ClearFlag_TC0>:
; {
 8016f2c: b480         	push	{r7}
 8016f2e: b083         	sub	sp, #0xc
 8016f30: af00         	add	r7, sp, #0x0
 8016f32: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->LIFCR , DMA_LIFCR_CTCIF0);
 8016f34: 687b         	ldr	r3, [r7, #0x4]
 8016f36: 2220         	movs	r2, #0x20
 8016f38: 609a         	str	r2, [r3, #0x8]
; }
 8016f3a: bf00         	nop
 8016f3c: 370c         	adds	r7, #0xc
 8016f3e: 46bd         	mov	sp, r7
 8016f40: bc80         	pop	{r7}
 8016f42: 4770         	bx	lr

08016f44 <LL_DMA_ClearFlag_TC1>:
; {
 8016f44: b480         	push	{r7}
 8016f46: b083         	sub	sp, #0xc
 8016f48: af00         	add	r7, sp, #0x0
 8016f4a: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->LIFCR , DMA_LIFCR_CTCIF1);
 8016f4c: 687b         	ldr	r3, [r7, #0x4]
 8016f4e: f44f 6200    	mov.w	r2, #0x800
 8016f52: 609a         	str	r2, [r3, #0x8]
; }
 8016f54: bf00         	nop
 8016f56: 370c         	adds	r7, #0xc
 8016f58: 46bd         	mov	sp, r7
 8016f5a: bc80         	pop	{r7}
 8016f5c: 4770         	bx	lr

08016f5e <LL_DMA_ClearFlag_TC2>:
; {
 8016f5e: b480         	push	{r7}
 8016f60: b083         	sub	sp, #0xc
 8016f62: af00         	add	r7, sp, #0x0
 8016f64: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->LIFCR , DMA_LIFCR_CTCIF2);
 8016f66: 687b         	ldr	r3, [r7, #0x4]
 8016f68: f44f 1200    	mov.w	r2, #0x200000
 8016f6c: 609a         	str	r2, [r3, #0x8]
; }
 8016f6e: bf00         	nop
 8016f70: 370c         	adds	r7, #0xc
 8016f72: 46bd         	mov	sp, r7
 8016f74: bc80         	pop	{r7}
 8016f76: 4770         	bx	lr

08016f78 <LL_DMA_ClearFlag_TC3>:
; {
 8016f78: b480         	push	{r7}
 8016f7a: b083         	sub	sp, #0xc
 8016f7c: af00         	add	r7, sp, #0x0
 8016f7e: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->LIFCR , DMA_LIFCR_CTCIF3);
 8016f80: 687b         	ldr	r3, [r7, #0x4]
 8016f82: f04f 6200    	mov.w	r2, #0x8000000
 8016f86: 609a         	str	r2, [r3, #0x8]
; }
 8016f88: bf00         	nop
 8016f8a: 370c         	adds	r7, #0xc
 8016f8c: 46bd         	mov	sp, r7
 8016f8e: bc80         	pop	{r7}
 8016f90: 4770         	bx	lr

08016f92 <LL_DMA_ClearFlag_TC4>:
; {
 8016f92: b480         	push	{r7}
 8016f94: b083         	sub	sp, #0xc
 8016f96: af00         	add	r7, sp, #0x0
 8016f98: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->HIFCR , DMA_HIFCR_CTCIF4);
 8016f9a: 687b         	ldr	r3, [r7, #0x4]
 8016f9c: 2220         	movs	r2, #0x20
 8016f9e: 60da         	str	r2, [r3, #0xc]
; }
 8016fa0: bf00         	nop
 8016fa2: 370c         	adds	r7, #0xc
 8016fa4: 46bd         	mov	sp, r7
 8016fa6: bc80         	pop	{r7}
 8016fa8: 4770         	bx	lr

08016faa <LL_DMA_ClearFlag_TC5>:
; {
 8016faa: b480         	push	{r7}
 8016fac: b083         	sub	sp, #0xc
 8016fae: af00         	add	r7, sp, #0x0
 8016fb0: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->HIFCR , DMA_HIFCR_CTCIF5);
 8016fb2: 687b         	ldr	r3, [r7, #0x4]
 8016fb4: f44f 6200    	mov.w	r2, #0x800
 8016fb8: 60da         	str	r2, [r3, #0xc]
; }
 8016fba: bf00         	nop
 8016fbc: 370c         	adds	r7, #0xc
 8016fbe: 46bd         	mov	sp, r7
 8016fc0: bc80         	pop	{r7}
 8016fc2: 4770         	bx	lr

08016fc4 <LL_DMA_ClearFlag_TC6>:
; {
 8016fc4: b480         	push	{r7}
 8016fc6: b083         	sub	sp, #0xc
 8016fc8: af00         	add	r7, sp, #0x0
 8016fca: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->HIFCR , DMA_HIFCR_CTCIF6);
 8016fcc: 687b         	ldr	r3, [r7, #0x4]
 8016fce: f44f 1200    	mov.w	r2, #0x200000
 8016fd2: 60da         	str	r2, [r3, #0xc]
; }
 8016fd4: bf00         	nop
 8016fd6: 370c         	adds	r7, #0xc
 8016fd8: 46bd         	mov	sp, r7
 8016fda: bc80         	pop	{r7}
 8016fdc: 4770         	bx	lr

08016fde <LL_DMA_ClearFlag_TC7>:
; {
 8016fde: b480         	push	{r7}
 8016fe0: b083         	sub	sp, #0xc
 8016fe2: af00         	add	r7, sp, #0x0
 8016fe4: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->HIFCR , DMA_HIFCR_CTCIF7);
 8016fe6: 687b         	ldr	r3, [r7, #0x4]
 8016fe8: f04f 6200    	mov.w	r2, #0x8000000
 8016fec: 60da         	str	r2, [r3, #0xc]
; }
 8016fee: bf00         	nop
 8016ff0: 370c         	adds	r7, #0xc
 8016ff2: 46bd         	mov	sp, r7
 8016ff4: bc80         	pop	{r7}
 8016ff6: 4770         	bx	lr

08016ff8 <LL_DMA_ClearFlag_TE0>:
; {
 8016ff8: b480         	push	{r7}
 8016ffa: b083         	sub	sp, #0xc
 8016ffc: af00         	add	r7, sp, #0x0
 8016ffe: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->LIFCR , DMA_LIFCR_CTEIF0);
 8017000: 687b         	ldr	r3, [r7, #0x4]
 8017002: 2208         	movs	r2, #0x8
 8017004: 609a         	str	r2, [r3, #0x8]
; }
 8017006: bf00         	nop
 8017008: 370c         	adds	r7, #0xc
 801700a: 46bd         	mov	sp, r7
 801700c: bc80         	pop	{r7}
 801700e: 4770         	bx	lr

08017010 <LL_DMA_ClearFlag_TE1>:
; {
 8017010: b480         	push	{r7}
 8017012: b083         	sub	sp, #0xc
 8017014: af00         	add	r7, sp, #0x0
 8017016: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->LIFCR , DMA_LIFCR_CTEIF1);
 8017018: 687b         	ldr	r3, [r7, #0x4]
 801701a: f44f 7200    	mov.w	r2, #0x200
 801701e: 609a         	str	r2, [r3, #0x8]
; }
 8017020: bf00         	nop
 8017022: 370c         	adds	r7, #0xc
 8017024: 46bd         	mov	sp, r7
 8017026: bc80         	pop	{r7}
 8017028: 4770         	bx	lr

0801702a <LL_DMA_ClearFlag_TE2>:
; {
 801702a: b480         	push	{r7}
 801702c: b083         	sub	sp, #0xc
 801702e: af00         	add	r7, sp, #0x0
 8017030: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->LIFCR , DMA_LIFCR_CTEIF2);
 8017032: 687b         	ldr	r3, [r7, #0x4]
 8017034: f44f 2200    	mov.w	r2, #0x80000
 8017038: 609a         	str	r2, [r3, #0x8]
; }
 801703a: bf00         	nop
 801703c: 370c         	adds	r7, #0xc
 801703e: 46bd         	mov	sp, r7
 8017040: bc80         	pop	{r7}
 8017042: 4770         	bx	lr

08017044 <LL_DMA_ClearFlag_TE3>:
; {
 8017044: b480         	push	{r7}
 8017046: b083         	sub	sp, #0xc
 8017048: af00         	add	r7, sp, #0x0
 801704a: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->LIFCR , DMA_LIFCR_CTEIF3);
 801704c: 687b         	ldr	r3, [r7, #0x4]
 801704e: f04f 7200    	mov.w	r2, #0x2000000
 8017052: 609a         	str	r2, [r3, #0x8]
; }
 8017054: bf00         	nop
 8017056: 370c         	adds	r7, #0xc
 8017058: 46bd         	mov	sp, r7
 801705a: bc80         	pop	{r7}
 801705c: 4770         	bx	lr

0801705e <LL_DMA_ClearFlag_TE4>:
; {
 801705e: b480         	push	{r7}
 8017060: b083         	sub	sp, #0xc
 8017062: af00         	add	r7, sp, #0x0
 8017064: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->HIFCR , DMA_HIFCR_CTEIF4);
 8017066: 687b         	ldr	r3, [r7, #0x4]
 8017068: 2208         	movs	r2, #0x8
 801706a: 60da         	str	r2, [r3, #0xc]
; }
 801706c: bf00         	nop
 801706e: 370c         	adds	r7, #0xc
 8017070: 46bd         	mov	sp, r7
 8017072: bc80         	pop	{r7}
 8017074: 4770         	bx	lr

08017076 <LL_DMA_ClearFlag_TE5>:
; {
 8017076: b480         	push	{r7}
 8017078: b083         	sub	sp, #0xc
 801707a: af00         	add	r7, sp, #0x0
 801707c: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->HIFCR , DMA_HIFCR_CTEIF5);
 801707e: 687b         	ldr	r3, [r7, #0x4]
 8017080: f44f 7200    	mov.w	r2, #0x200
 8017084: 60da         	str	r2, [r3, #0xc]
; }
 8017086: bf00         	nop
 8017088: 370c         	adds	r7, #0xc
 801708a: 46bd         	mov	sp, r7
 801708c: bc80         	pop	{r7}
 801708e: 4770         	bx	lr

08017090 <LL_DMA_ClearFlag_TE6>:
; {
 8017090: b480         	push	{r7}
 8017092: b083         	sub	sp, #0xc
 8017094: af00         	add	r7, sp, #0x0
 8017096: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->HIFCR , DMA_HIFCR_CTEIF6);
 8017098: 687b         	ldr	r3, [r7, #0x4]
 801709a: f44f 2200    	mov.w	r2, #0x80000
 801709e: 60da         	str	r2, [r3, #0xc]
; }
 80170a0: bf00         	nop
 80170a2: 370c         	adds	r7, #0xc
 80170a4: 46bd         	mov	sp, r7
 80170a6: bc80         	pop	{r7}
 80170a8: 4770         	bx	lr

080170aa <LL_DMA_ClearFlag_TE7>:
; {
 80170aa: b480         	push	{r7}
 80170ac: b083         	sub	sp, #0xc
 80170ae: af00         	add	r7, sp, #0x0
 80170b0: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->HIFCR , DMA_HIFCR_CTEIF7);
 80170b2: 687b         	ldr	r3, [r7, #0x4]
 80170b4: f04f 7200    	mov.w	r2, #0x2000000
 80170b8: 60da         	str	r2, [r3, #0xc]
; }
 80170ba: bf00         	nop
 80170bc: 370c         	adds	r7, #0xc
 80170be: 46bd         	mov	sp, r7
 80170c0: bc80         	pop	{r7}
 80170c2: 4770         	bx	lr

080170c4 <LL_DMA_ClearFlag_DME0>:
; {
 80170c4: b480         	push	{r7}
 80170c6: b083         	sub	sp, #0xc
 80170c8: af00         	add	r7, sp, #0x0
 80170ca: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->LIFCR , DMA_LIFCR_CDMEIF0);
 80170cc: 687b         	ldr	r3, [r7, #0x4]
 80170ce: 2204         	movs	r2, #0x4
 80170d0: 609a         	str	r2, [r3, #0x8]
; }
 80170d2: bf00         	nop
 80170d4: 370c         	adds	r7, #0xc
 80170d6: 46bd         	mov	sp, r7
 80170d8: bc80         	pop	{r7}
 80170da: 4770         	bx	lr

080170dc <LL_DMA_ClearFlag_DME1>:
; {
 80170dc: b480         	push	{r7}
 80170de: b083         	sub	sp, #0xc
 80170e0: af00         	add	r7, sp, #0x0
 80170e2: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->LIFCR , DMA_LIFCR_CDMEIF1);
 80170e4: 687b         	ldr	r3, [r7, #0x4]
 80170e6: f44f 7280    	mov.w	r2, #0x100
 80170ea: 609a         	str	r2, [r3, #0x8]
; }
 80170ec: bf00         	nop
 80170ee: 370c         	adds	r7, #0xc
 80170f0: 46bd         	mov	sp, r7
 80170f2: bc80         	pop	{r7}
 80170f4: 4770         	bx	lr

080170f6 <LL_DMA_ClearFlag_DME2>:
; {
 80170f6: b480         	push	{r7}
 80170f8: b083         	sub	sp, #0xc
 80170fa: af00         	add	r7, sp, #0x0
 80170fc: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->LIFCR , DMA_LIFCR_CDMEIF2);
 80170fe: 687b         	ldr	r3, [r7, #0x4]
 8017100: f44f 2280    	mov.w	r2, #0x40000
 8017104: 609a         	str	r2, [r3, #0x8]
; }
 8017106: bf00         	nop
 8017108: 370c         	adds	r7, #0xc
 801710a: 46bd         	mov	sp, r7
 801710c: bc80         	pop	{r7}
 801710e: 4770         	bx	lr

08017110 <LL_DMA_ClearFlag_DME3>:
; {
 8017110: b480         	push	{r7}
 8017112: b083         	sub	sp, #0xc
 8017114: af00         	add	r7, sp, #0x0
 8017116: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->LIFCR , DMA_LIFCR_CDMEIF3);
 8017118: 687b         	ldr	r3, [r7, #0x4]
 801711a: f04f 7280    	mov.w	r2, #0x1000000
 801711e: 609a         	str	r2, [r3, #0x8]
; }
 8017120: bf00         	nop
 8017122: 370c         	adds	r7, #0xc
 8017124: 46bd         	mov	sp, r7
 8017126: bc80         	pop	{r7}
 8017128: 4770         	bx	lr

0801712a <LL_DMA_ClearFlag_DME4>:
; {
 801712a: b480         	push	{r7}
 801712c: b083         	sub	sp, #0xc
 801712e: af00         	add	r7, sp, #0x0
 8017130: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->HIFCR , DMA_HIFCR_CDMEIF4);
 8017132: 687b         	ldr	r3, [r7, #0x4]
 8017134: 2204         	movs	r2, #0x4
 8017136: 60da         	str	r2, [r3, #0xc]
; }
 8017138: bf00         	nop
 801713a: 370c         	adds	r7, #0xc
 801713c: 46bd         	mov	sp, r7
 801713e: bc80         	pop	{r7}
 8017140: 4770         	bx	lr

08017142 <LL_DMA_ClearFlag_DME5>:
; {
 8017142: b480         	push	{r7}
 8017144: b083         	sub	sp, #0xc
 8017146: af00         	add	r7, sp, #0x0
 8017148: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->HIFCR , DMA_HIFCR_CDMEIF5);
 801714a: 687b         	ldr	r3, [r7, #0x4]
 801714c: f44f 7280    	mov.w	r2, #0x100
 8017150: 60da         	str	r2, [r3, #0xc]
; }
 8017152: bf00         	nop
 8017154: 370c         	adds	r7, #0xc
 8017156: 46bd         	mov	sp, r7
 8017158: bc80         	pop	{r7}
 801715a: 4770         	bx	lr

0801715c <LL_DMA_ClearFlag_DME6>:
; {
 801715c: b480         	push	{r7}
 801715e: b083         	sub	sp, #0xc
 8017160: af00         	add	r7, sp, #0x0
 8017162: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->HIFCR , DMA_HIFCR_CDMEIF6);
 8017164: 687b         	ldr	r3, [r7, #0x4]
 8017166: f44f 2280    	mov.w	r2, #0x40000
 801716a: 60da         	str	r2, [r3, #0xc]
; }
 801716c: bf00         	nop
 801716e: 370c         	adds	r7, #0xc
 8017170: 46bd         	mov	sp, r7
 8017172: bc80         	pop	{r7}
 8017174: 4770         	bx	lr

08017176 <LL_DMA_ClearFlag_DME7>:
; {
 8017176: b480         	push	{r7}
 8017178: b083         	sub	sp, #0xc
 801717a: af00         	add	r7, sp, #0x0
 801717c: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->HIFCR , DMA_HIFCR_CDMEIF7);
 801717e: 687b         	ldr	r3, [r7, #0x4]
 8017180: f04f 7280    	mov.w	r2, #0x1000000
 8017184: 60da         	str	r2, [r3, #0xc]
; }
 8017186: bf00         	nop
 8017188: 370c         	adds	r7, #0xc
 801718a: 46bd         	mov	sp, r7
 801718c: bc80         	pop	{r7}
 801718e: 4770         	bx	lr

08017190 <LL_DMA_ClearFlag_FE0>:
; {
 8017190: b480         	push	{r7}
 8017192: b083         	sub	sp, #0xc
 8017194: af00         	add	r7, sp, #0x0
 8017196: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->LIFCR , DMA_LIFCR_CFEIF0);
 8017198: 687b         	ldr	r3, [r7, #0x4]
 801719a: 2201         	movs	r2, #0x1
 801719c: 609a         	str	r2, [r3, #0x8]
; }
 801719e: bf00         	nop
 80171a0: 370c         	adds	r7, #0xc
 80171a2: 46bd         	mov	sp, r7
 80171a4: bc80         	pop	{r7}
 80171a6: 4770         	bx	lr

080171a8 <LL_DMA_ClearFlag_FE1>:
; {
 80171a8: b480         	push	{r7}
 80171aa: b083         	sub	sp, #0xc
 80171ac: af00         	add	r7, sp, #0x0
 80171ae: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->LIFCR , DMA_LIFCR_CFEIF1);
 80171b0: 687b         	ldr	r3, [r7, #0x4]
 80171b2: 2240         	movs	r2, #0x40
 80171b4: 609a         	str	r2, [r3, #0x8]
; }
 80171b6: bf00         	nop
 80171b8: 370c         	adds	r7, #0xc
 80171ba: 46bd         	mov	sp, r7
 80171bc: bc80         	pop	{r7}
 80171be: 4770         	bx	lr

080171c0 <LL_DMA_ClearFlag_FE2>:
; {
 80171c0: b480         	push	{r7}
 80171c2: b083         	sub	sp, #0xc
 80171c4: af00         	add	r7, sp, #0x0
 80171c6: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->LIFCR , DMA_LIFCR_CFEIF2);
 80171c8: 687b         	ldr	r3, [r7, #0x4]
 80171ca: f44f 3280    	mov.w	r2, #0x10000
 80171ce: 609a         	str	r2, [r3, #0x8]
; }
 80171d0: bf00         	nop
 80171d2: 370c         	adds	r7, #0xc
 80171d4: 46bd         	mov	sp, r7
 80171d6: bc80         	pop	{r7}
 80171d8: 4770         	bx	lr

080171da <LL_DMA_ClearFlag_FE3>:
; {
 80171da: b480         	push	{r7}
 80171dc: b083         	sub	sp, #0xc
 80171de: af00         	add	r7, sp, #0x0
 80171e0: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->LIFCR , DMA_LIFCR_CFEIF3);
 80171e2: 687b         	ldr	r3, [r7, #0x4]
 80171e4: f44f 0280    	mov.w	r2, #0x400000
 80171e8: 609a         	str	r2, [r3, #0x8]
; }
 80171ea: bf00         	nop
 80171ec: 370c         	adds	r7, #0xc
 80171ee: 46bd         	mov	sp, r7
 80171f0: bc80         	pop	{r7}
 80171f2: 4770         	bx	lr

080171f4 <LL_DMA_ClearFlag_FE4>:
; {
 80171f4: b480         	push	{r7}
 80171f6: b083         	sub	sp, #0xc
 80171f8: af00         	add	r7, sp, #0x0
 80171fa: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->HIFCR , DMA_HIFCR_CFEIF4);
 80171fc: 687b         	ldr	r3, [r7, #0x4]
 80171fe: 2201         	movs	r2, #0x1
 8017200: 60da         	str	r2, [r3, #0xc]
; }
 8017202: bf00         	nop
 8017204: 370c         	adds	r7, #0xc
 8017206: 46bd         	mov	sp, r7
 8017208: bc80         	pop	{r7}
 801720a: 4770         	bx	lr

0801720c <LL_DMA_ClearFlag_FE5>:
; {
 801720c: b480         	push	{r7}
 801720e: b083         	sub	sp, #0xc
 8017210: af00         	add	r7, sp, #0x0
 8017212: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->HIFCR , DMA_HIFCR_CFEIF5);
 8017214: 687b         	ldr	r3, [r7, #0x4]
 8017216: 2240         	movs	r2, #0x40
 8017218: 60da         	str	r2, [r3, #0xc]
; }
 801721a: bf00         	nop
 801721c: 370c         	adds	r7, #0xc
 801721e: 46bd         	mov	sp, r7
 8017220: bc80         	pop	{r7}
 8017222: 4770         	bx	lr

08017224 <LL_DMA_ClearFlag_FE6>:
; {
 8017224: b480         	push	{r7}
 8017226: b083         	sub	sp, #0xc
 8017228: af00         	add	r7, sp, #0x0
 801722a: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->HIFCR , DMA_HIFCR_CFEIF6);
 801722c: 687b         	ldr	r3, [r7, #0x4]
 801722e: f44f 3280    	mov.w	r2, #0x10000
 8017232: 60da         	str	r2, [r3, #0xc]
; }
 8017234: bf00         	nop
 8017236: 370c         	adds	r7, #0xc
 8017238: 46bd         	mov	sp, r7
 801723a: bc80         	pop	{r7}
 801723c: 4770         	bx	lr

0801723e <LL_DMA_ClearFlag_FE7>:
; {
 801723e: b480         	push	{r7}
 8017240: b083         	sub	sp, #0xc
 8017242: af00         	add	r7, sp, #0x0
 8017244: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->HIFCR , DMA_HIFCR_CFEIF7);
 8017246: 687b         	ldr	r3, [r7, #0x4]
 8017248: f44f 0280    	mov.w	r2, #0x400000
 801724c: 60da         	str	r2, [r3, #0xc]
; }
 801724e: bf00         	nop
 8017250: 370c         	adds	r7, #0xc
 8017252: 46bd         	mov	sp, r7
 8017254: bc80         	pop	{r7}
 8017256: 4770         	bx	lr

08017258 <z_log_msg_runtime_create>:
; {
 8017258: b580         	push	{r7, lr}
 801725a: b08a         	sub	sp, #0x28
 801725c: af04         	add	r7, sp, #0x10
 801725e: 60b9         	str	r1, [r7, #0x8]
 8017260: 607b         	str	r3, [r7, #0x4]
 8017262: 4603         	mov	r3, r0
 8017264: 73fb         	strb	r3, [r7, #0xf]
 8017266: 4613         	mov	r3, r2
 8017268: 73bb         	strb	r3, [r7, #0xe]
; 	va_start(ap, fmt);
 801726a: f107 032c    	add.w	r3, r7, #0x2c
 801726e: 617b         	str	r3, [r7, #0x14]
; 	z_log_msg_runtime_vcreate(domain_id, source, level,
 8017270: 7bba         	ldrb	r2, [r7, #0xe]
 8017272: 7bf8         	ldrb	r0, [r7, #0xf]
 8017274: 697b         	ldr	r3, [r7, #0x14]
 8017276: 9303         	str	r3, [sp, #0xc]
 8017278: 6abb         	ldr	r3, [r7, #0x28]
 801727a: 9302         	str	r3, [sp, #0x8]
 801727c: 6a7b         	ldr	r3, [r7, #0x24]
 801727e: 9301         	str	r3, [sp, #0x4]
 8017280: 6a3b         	ldr	r3, [r7, #0x20]
 8017282: 9300         	str	r3, [sp]
 8017284: 687b         	ldr	r3, [r7, #0x4]
 8017286: 68b9         	ldr	r1, [r7, #0x8]
 8017288: f7ed f972    	bl	0x8004570 <z_log_msg_runtime_vcreate> @ imm = #-0x12d1c
; }
 801728c: bf00         	nop
 801728e: 3718         	adds	r7, #0x18
 8017290: 46bd         	mov	sp, r7
 8017292: bd80         	pop	{r7, pc}

08017294 <stm32_dma_is_tc_irq_active>:
; {
 8017294: b580         	push	{r7, lr}
 8017296: b082         	sub	sp, #0x8
 8017298: af00         	add	r7, sp, #0x0
 801729a: 6078         	str	r0, [r7, #0x4]
 801729c: 6039         	str	r1, [r7]
; 	return LL_DMA_IsEnabledIT_TC(dma, dma_stm32_id_to_stream(id)) &&
 801729e: 6838         	ldr	r0, [r7]
 80172a0: f7f0 fe6c    	bl	0x8007f7c <dma_stm32_id_to_stream> @ imm = #-0xf328
 80172a4: 4603         	mov	r3, r0
 80172a6: 4619         	mov	r1, r3
 80172a8: 6878         	ldr	r0, [r7, #0x4]
 80172aa: f7f0 fe2f    	bl	0x8007f0c <LL_DMA_IsEnabledIT_TC> @ imm = #-0xf3a2
 80172ae: 4603         	mov	r3, r0
 80172b0: 2b00         	cmp	r3, #0x0
 80172b2: d008         	beq	0x80172c6 <stm32_dma_is_tc_irq_active+0x32> @ imm = #0x10
; 	       dma_stm32_is_tc_active(dma, id);
 80172b4: 6839         	ldr	r1, [r7]
 80172b6: 6878         	ldr	r0, [r7, #0x4]
 80172b8: f7f0 febc    	bl	0x8008034 <dma_stm32_is_tc_active> @ imm = #-0xf288
 80172bc: 4603         	mov	r3, r0
; 	return LL_DMA_IsEnabledIT_TC(dma, dma_stm32_id_to_stream(id)) &&
 80172be: 2b00         	cmp	r3, #0x0
 80172c0: d001         	beq	0x80172c6 <stm32_dma_is_tc_irq_active+0x32> @ imm = #0x2
 80172c2: 2301         	movs	r3, #0x1
 80172c4: e000         	b	0x80172c8 <stm32_dma_is_tc_irq_active+0x34> @ imm = #0x0
 80172c6: 2300         	movs	r3, #0x0
 80172c8: f003 0301    	and	r3, r3, #0x1
 80172cc: b2db         	uxtb	r3, r3
; }
 80172ce: 4618         	mov	r0, r3
 80172d0: 3708         	adds	r7, #0x8
 80172d2: 46bd         	mov	sp, r7
 80172d4: bd80         	pop	{r7, pc}

080172d6 <stm32_dma_is_ht_irq_active>:
; {
 80172d6: b580         	push	{r7, lr}
 80172d8: b082         	sub	sp, #0x8
 80172da: af00         	add	r7, sp, #0x0
 80172dc: 6078         	str	r0, [r7, #0x4]
 80172de: 6039         	str	r1, [r7]
; 	return LL_DMA_IsEnabledIT_HT(dma, dma_stm32_id_to_stream(id)) &&
 80172e0: 6838         	ldr	r0, [r7]
 80172e2: f7f0 fe4b    	bl	0x8007f7c <dma_stm32_id_to_stream> @ imm = #-0xf36a
 80172e6: 4603         	mov	r3, r0
 80172e8: 4619         	mov	r1, r3
 80172ea: 6878         	ldr	r0, [r7, #0x4]
 80172ec: f7f0 fdf2    	bl	0x8007ed4 <LL_DMA_IsEnabledIT_HT> @ imm = #-0xf41c
 80172f0: 4603         	mov	r3, r0
 80172f2: 2b00         	cmp	r3, #0x0
 80172f4: d008         	beq	0x8017308 <stm32_dma_is_ht_irq_active+0x32> @ imm = #0x10
; 	       dma_stm32_is_ht_active(dma, id);
 80172f6: 6839         	ldr	r1, [r7]
 80172f8: 6878         	ldr	r0, [r7, #0x4]
 80172fa: f7f0 fe83    	bl	0x8008004 <dma_stm32_is_ht_active> @ imm = #-0xf2fa
 80172fe: 4603         	mov	r3, r0
; 	return LL_DMA_IsEnabledIT_HT(dma, dma_stm32_id_to_stream(id)) &&
 8017300: 2b00         	cmp	r3, #0x0
 8017302: d001         	beq	0x8017308 <stm32_dma_is_ht_irq_active+0x32> @ imm = #0x2
 8017304: 2301         	movs	r3, #0x1
 8017306: e000         	b	0x801730a <stm32_dma_is_ht_irq_active+0x34> @ imm = #0x0
 8017308: 2300         	movs	r3, #0x0
 801730a: f003 0301    	and	r3, r3, #0x1
 801730e: b2db         	uxtb	r3, r3
; }
 8017310: 4618         	mov	r0, r3
 8017312: 3708         	adds	r7, #0x8
 8017314: 46bd         	mov	sp, r7
 8017316: bd80         	pop	{r7, pc}

08017318 <stm32_dma_clear_stream_irq>:
; {
 8017318: b580         	push	{r7, lr}
 801731a: b082         	sub	sp, #0x8
 801731c: af00         	add	r7, sp, #0x0
 801731e: 6078         	str	r0, [r7, #0x4]
 8017320: 6039         	str	r1, [r7]
; 	dma_stm32_clear_te(dma, id);
 8017322: 6839         	ldr	r1, [r7]
 8017324: 6878         	ldr	r0, [r7, #0x4]
 8017326: f7f0 fe9d    	bl	0x8008064 <dma_stm32_clear_te> @ imm = #-0xf2c6
; 	dma_stm32_clear_dme(dma, id);
 801732a: 6839         	ldr	r1, [r7]
 801732c: 6878         	ldr	r0, [r7, #0x4]
 801732e: f7f0 feab    	bl	0x8008088 <dma_stm32_clear_dme> @ imm = #-0xf2aa
; 	dma_stm32_clear_fe(dma, id);
 8017332: 6839         	ldr	r1, [r7]
 8017334: 6878         	ldr	r0, [r7, #0x4]
 8017336: f7f0 feb9    	bl	0x80080ac <dma_stm32_clear_fe> @ imm = #-0xf28e
; }
 801733a: bf00         	nop
 801733c: 3708         	adds	r7, #0x8
 801733e: 46bd         	mov	sp, r7
 8017340: bd80         	pop	{r7, pc}

08017342 <stm32_dma_enable_stream>:
; {
 8017342: b580         	push	{r7, lr}
 8017344: b082         	sub	sp, #0x8
 8017346: af00         	add	r7, sp, #0x0
 8017348: 6078         	str	r0, [r7, #0x4]
 801734a: 6039         	str	r1, [r7]
; 	LL_DMA_EnableStream(dma, dma_stm32_id_to_stream(id));
 801734c: 6838         	ldr	r0, [r7]
 801734e: f7f0 fe15    	bl	0x8007f7c <dma_stm32_id_to_stream> @ imm = #-0xf3d6
 8017352: 4603         	mov	r3, r0
 8017354: 4619         	mov	r1, r3
 8017356: 6878         	ldr	r0, [r7, #0x4]
 8017358: f7f0 fd46    	bl	0x8007de8 <LL_DMA_EnableStream> @ imm = #-0xf574
; }
 801735c: bf00         	nop
 801735e: 3708         	adds	r7, #0x8
 8017360: 46bd         	mov	sp, r7
 8017362: bd80         	pop	{r7, pc}

08017364 <stm32_dma_is_enabled_stream>:
; {
 8017364: b580         	push	{r7, lr}
 8017366: b082         	sub	sp, #0x8
 8017368: af00         	add	r7, sp, #0x0
 801736a: 6078         	str	r0, [r7, #0x4]
 801736c: 6039         	str	r1, [r7]
; 	if (LL_DMA_IsEnabledStream(dma, dma_stm32_id_to_stream(id)) == 1) {
 801736e: 6838         	ldr	r0, [r7]
 8017370: f7f0 fe04    	bl	0x8007f7c <dma_stm32_id_to_stream> @ imm = #-0xf3f8
 8017374: 4603         	mov	r3, r0
 8017376: 4619         	mov	r1, r3
 8017378: 6878         	ldr	r0, [r7, #0x4]
 801737a: f7f0 fd71    	bl	0x8007e60 <LL_DMA_IsEnabledStream> @ imm = #-0xf51e
 801737e: 4603         	mov	r3, r0
 8017380: 2b01         	cmp	r3, #0x1
 8017382: d101         	bne	0x8017388 <stm32_dma_is_enabled_stream+0x24> @ imm = #0x2
; 		return true;
 8017384: 2301         	movs	r3, #0x1
 8017386: e000         	b	0x801738a <stm32_dma_is_enabled_stream+0x26> @ imm = #0x0
; 	return false;
 8017388: 2300         	movs	r3, #0x0
; }
 801738a: 4618         	mov	r0, r3
 801738c: 3708         	adds	r7, #0x8
 801738e: 46bd         	mov	sp, r7
 8017390: bd80         	pop	{r7, pc}

08017392 <stm32_dma_disable_stream>:
; {
 8017392: b580         	push	{r7, lr}
 8017394: b082         	sub	sp, #0x8
 8017396: af00         	add	r7, sp, #0x0
 8017398: 6078         	str	r0, [r7, #0x4]
 801739a: 6039         	str	r1, [r7]
; 	LL_DMA_DisableStream(dma, dma_stm32_id_to_stream(id));
 801739c: 6838         	ldr	r0, [r7]
 801739e: f7f0 fded    	bl	0x8007f7c <dma_stm32_id_to_stream> @ imm = #-0xf426
 80173a2: 4603         	mov	r3, r0
 80173a4: 4619         	mov	r1, r3
 80173a6: 6878         	ldr	r0, [r7, #0x4]
 80173a8: f7f0 fd3c    	bl	0x8007e24 <LL_DMA_DisableStream> @ imm = #-0xf588
; 	while (stm32_dma_is_enabled_stream(dma, id)) {
 80173ac: bf00         	nop
 80173ae: 6839         	ldr	r1, [r7]
 80173b0: 6878         	ldr	r0, [r7, #0x4]
 80173b2: f7ff ffd7    	bl	0x8017364 <stm32_dma_is_enabled_stream> @ imm = #-0x52
 80173b6: 4603         	mov	r3, r0
 80173b8: 2b00         	cmp	r3, #0x0
 80173ba: d1f8         	bne	0x80173ae <stm32_dma_disable_stream+0x1c> @ imm = #-0x10
; 	dma_stm32_clear_tc(dma, id);
 80173bc: 6839         	ldr	r1, [r7]
 80173be: 6878         	ldr	r0, [r7, #0x4]
 80173c0: f7f0 fe0e    	bl	0x8007fe0 <dma_stm32_clear_tc> @ imm = #-0xf3e4
; 	return 0;
 80173c4: 2300         	movs	r3, #0x0
; }
 80173c6: 4618         	mov	r0, r3
 80173c8: 3708         	adds	r7, #0x8
 80173ca: 46bd         	mov	sp, r7
 80173cc: bd80         	pop	{r7, pc}

080173ce <stm32_dma_disable_fifo_irq>:
; {
 80173ce: b580         	push	{r7, lr}
 80173d0: b082         	sub	sp, #0x8
 80173d2: af00         	add	r7, sp, #0x0
 80173d4: 6078         	str	r0, [r7, #0x4]
 80173d6: 6039         	str	r1, [r7]
; 	LL_DMA_DisableIT_FE(dma, dma_stm32_id_to_stream(id));
 80173d8: 6838         	ldr	r0, [r7]
 80173da: f7f0 fdcf    	bl	0x8007f7c <dma_stm32_id_to_stream> @ imm = #-0xf462
 80173de: 4603         	mov	r3, r0
 80173e0: 4619         	mov	r1, r3
 80173e2: 6878         	ldr	r0, [r7, #0x4]
 80173e4: f7f0 fd58    	bl	0x8007e98 <LL_DMA_DisableIT_FE> @ imm = #-0xf550
; }
 80173e8: bf00         	nop
 80173ea: 3708         	adds	r7, #0x8
 80173ec: 46bd         	mov	sp, r7
 80173ee: bd80         	pop	{r7, pc}

080173f0 <stm32_dma_check_fifo_mburst>:
; {
 80173f0: b480         	push	{r7}
 80173f2: b087         	sub	sp, #0x1c
 80173f4: af00         	add	r7, sp, #0x0
 80173f6: 6078         	str	r0, [r7, #0x4]
; 	uint32_t msize = DMAx->MemoryOrM2MDstDataSize;
 80173f8: 687b         	ldr	r3, [r7, #0x4]
 80173fa: 69db         	ldr	r3, [r3, #0x1c]
 80173fc: 617b         	str	r3, [r7, #0x14]
; 	uint32_t fifo_level = DMAx->FIFOThreshold;
 80173fe: 687b         	ldr	r3, [r7, #0x4]
 8017400: 6b1b         	ldr	r3, [r3, #0x30]
 8017402: 613b         	str	r3, [r7, #0x10]
; 	uint32_t mburst = DMAx->MemBurst;
 8017404: 687b         	ldr	r3, [r7, #0x4]
 8017406: 6b5b         	ldr	r3, [r3, #0x34]
 8017408: 60fb         	str	r3, [r7, #0xc]
; 	switch (msize) {
 801740a: 697b         	ldr	r3, [r7, #0x14]
 801740c: f5b3 4f80    	cmp.w	r3, #0x4000
 8017410: d049         	beq	0x80174a6 <stm32_dma_check_fifo_mburst+0xb6> @ imm = #0x92
 8017412: 697b         	ldr	r3, [r7, #0x14]
 8017414: f5b3 4f80    	cmp.w	r3, #0x4000
 8017418: d84f         	bhi	0x80174ba <stm32_dma_check_fifo_mburst+0xca> @ imm = #0x9e
 801741a: 697b         	ldr	r3, [r7, #0x14]
 801741c: 2b00         	cmp	r3, #0x0
 801741e: d004         	beq	0x801742a <stm32_dma_check_fifo_mburst+0x3a> @ imm = #0x8
 8017420: 697b         	ldr	r3, [r7, #0x14]
 8017422: f5b3 5f00    	cmp.w	r3, #0x2000
 8017426: d024         	beq	0x8017472 <stm32_dma_check_fifo_mburst+0x82> @ imm = #0x48
 8017428: e047         	b	0x80174ba <stm32_dma_check_fifo_mburst+0xca> @ imm = #0x8e
 801742a: 68fb         	ldr	r3, [r7, #0xc]
 801742c: f1b3 7fc0    	cmp.w	r3, #0x1800000
 8017430: d016         	beq	0x8017460 <stm32_dma_check_fifo_mburst+0x70> @ imm = #0x2c
 8017432: 68fb         	ldr	r3, [r7, #0xc]
 8017434: f1b3 7fc0    	cmp.w	r3, #0x1800000
 8017438: d83e         	bhi	0x80174b8 <stm32_dma_check_fifo_mburst+0xc8> @ imm = #0x7c
 801743a: 68fb         	ldr	r3, [r7, #0xc]
 801743c: f5b3 0f00    	cmp.w	r3, #0x800000
 8017440: d004         	beq	0x801744c <stm32_dma_check_fifo_mburst+0x5c> @ imm = #0x8
 8017442: 68fb         	ldr	r3, [r7, #0xc]
 8017444: f1b3 7f80    	cmp.w	r3, #0x1000000
 8017448: d002         	beq	0x8017450 <stm32_dma_check_fifo_mburst+0x60> @ imm = #0x4
; 		break;
 801744a: e035         	b	0x80174b8 <stm32_dma_check_fifo_mburst+0xc8> @ imm = #0x6a
; 			return true;
 801744c: 2301         	movs	r3, #0x1
 801744e: e035         	b	0x80174bc <stm32_dma_check_fifo_mburst+0xcc> @ imm = #0x6a
; 			if (fifo_level == LL_DMA_FIFOTHRESHOLD_1_2 ||
 8017450: 693b         	ldr	r3, [r7, #0x10]
 8017452: 2b01         	cmp	r3, #0x1
 8017454: d002         	beq	0x801745c <stm32_dma_check_fifo_mburst+0x6c> @ imm = #0x4
 8017456: 693b         	ldr	r3, [r7, #0x10]
 8017458: 2b03         	cmp	r3, #0x3
 801745a: d106         	bne	0x801746a <stm32_dma_check_fifo_mburst+0x7a> @ imm = #0xc
; 				return true;
 801745c: 2301         	movs	r3, #0x1
 801745e: e02d         	b	0x80174bc <stm32_dma_check_fifo_mburst+0xcc> @ imm = #0x5a
; 			if (fifo_level == LL_DMA_FIFOTHRESHOLD_FULL) {
 8017460: 693b         	ldr	r3, [r7, #0x10]
 8017462: 2b03         	cmp	r3, #0x3
 8017464: d103         	bne	0x801746e <stm32_dma_check_fifo_mburst+0x7e> @ imm = #0x6
; 				return true;
 8017466: 2301         	movs	r3, #0x1
 8017468: e028         	b	0x80174bc <stm32_dma_check_fifo_mburst+0xcc> @ imm = #0x50
; 			break;
 801746a: bf00         	nop
 801746c: e024         	b	0x80174b8 <stm32_dma_check_fifo_mburst+0xc8> @ imm = #0x48
; 			break;
 801746e: bf00         	nop
; 		break;
 8017470: e022         	b	0x80174b8 <stm32_dma_check_fifo_mburst+0xc8> @ imm = #0x44
 8017472: 68fb         	ldr	r3, [r7, #0xc]
 8017474: f5b3 0f00    	cmp.w	r3, #0x800000
 8017478: d004         	beq	0x8017484 <stm32_dma_check_fifo_mburst+0x94> @ imm = #0x8
 801747a: 68fb         	ldr	r3, [r7, #0xc]
 801747c: f1b3 7f80    	cmp.w	r3, #0x1000000
 8017480: d008         	beq	0x8017494 <stm32_dma_check_fifo_mburst+0xa4> @ imm = #0x10
; 		break;
 8017482: e01a         	b	0x80174ba <stm32_dma_check_fifo_mburst+0xca> @ imm = #0x34
; 			if (fifo_level == LL_DMA_FIFOTHRESHOLD_1_2 ||
 8017484: 693b         	ldr	r3, [r7, #0x10]
 8017486: 2b01         	cmp	r3, #0x1
 8017488: d002         	beq	0x8017490 <stm32_dma_check_fifo_mburst+0xa0> @ imm = #0x4
 801748a: 693b         	ldr	r3, [r7, #0x10]
 801748c: 2b03         	cmp	r3, #0x3
 801748e: d106         	bne	0x801749e <stm32_dma_check_fifo_mburst+0xae> @ imm = #0xc
; 				return true;
 8017490: 2301         	movs	r3, #0x1
 8017492: e013         	b	0x80174bc <stm32_dma_check_fifo_mburst+0xcc> @ imm = #0x26
; 			if (fifo_level == LL_DMA_FIFOTHRESHOLD_FULL) {
 8017494: 693b         	ldr	r3, [r7, #0x10]
 8017496: 2b03         	cmp	r3, #0x3
 8017498: d103         	bne	0x80174a2 <stm32_dma_check_fifo_mburst+0xb2> @ imm = #0x6
; 				return true;
 801749a: 2301         	movs	r3, #0x1
 801749c: e00e         	b	0x80174bc <stm32_dma_check_fifo_mburst+0xcc> @ imm = #0x1c
; 			break;
 801749e: bf00         	nop
 80174a0: e00b         	b	0x80174ba <stm32_dma_check_fifo_mburst+0xca> @ imm = #0x16
; 			break;
 80174a2: bf00         	nop
; 		break;
 80174a4: e009         	b	0x80174ba <stm32_dma_check_fifo_mburst+0xca> @ imm = #0x12
; 		if (mburst == LL_DMA_MBURST_INC4 &&
 80174a6: 68fb         	ldr	r3, [r7, #0xc]
 80174a8: f5b3 0f00    	cmp.w	r3, #0x800000
 80174ac: d105         	bne	0x80174ba <stm32_dma_check_fifo_mburst+0xca> @ imm = #0xa
 80174ae: 693b         	ldr	r3, [r7, #0x10]
 80174b0: 2b03         	cmp	r3, #0x3
 80174b2: d102         	bne	0x80174ba <stm32_dma_check_fifo_mburst+0xca> @ imm = #0x4
; 			return true;
 80174b4: 2301         	movs	r3, #0x1
 80174b6: e001         	b	0x80174bc <stm32_dma_check_fifo_mburst+0xcc> @ imm = #0x2
; 		break;
 80174b8: bf00         	nop
; 	return false;
 80174ba: 2300         	movs	r3, #0x0
; }
 80174bc: 4618         	mov	r0, r3
 80174be: 371c         	adds	r7, #0x1c
 80174c0: 46bd         	mov	sp, r7
 80174c2: bc80         	pop	{r7}
 80174c4: 4770         	bx	lr

080174c6 <z_snode_next_peek>:
; {
 80174c6: b480         	push	{r7}
 80174c8: b083         	sub	sp, #0xc
 80174ca: af00         	add	r7, sp, #0x0
 80174cc: 6078         	str	r0, [r7, #0x4]
; 	return node->next;
 80174ce: 687b         	ldr	r3, [r7, #0x4]
 80174d0: 681b         	ldr	r3, [r3]
; }
 80174d2: 4618         	mov	r0, r3
 80174d4: 370c         	adds	r7, #0xc
 80174d6: 46bd         	mov	sp, r7
 80174d8: bc80         	pop	{r7}
 80174da: 4770         	bx	lr

080174dc <z_snode_next_set>:
; {
 80174dc: b480         	push	{r7}
 80174de: b083         	sub	sp, #0xc
 80174e0: af00         	add	r7, sp, #0x0
 80174e2: 6078         	str	r0, [r7, #0x4]
 80174e4: 6039         	str	r1, [r7]
; 	parent->next = child;
 80174e6: 687b         	ldr	r3, [r7, #0x4]
 80174e8: 683a         	ldr	r2, [r7]
 80174ea: 601a         	str	r2, [r3]
; }
 80174ec: bf00         	nop
 80174ee: 370c         	adds	r7, #0xc
 80174f0: 46bd         	mov	sp, r7
 80174f2: bc80         	pop	{r7}
 80174f4: 4770         	bx	lr

080174f6 <z_slist_head_set>:
; {
 80174f6: b480         	push	{r7}
 80174f8: b083         	sub	sp, #0xc
 80174fa: af00         	add	r7, sp, #0x0
 80174fc: 6078         	str	r0, [r7, #0x4]
 80174fe: 6039         	str	r1, [r7]
; 	list->head = node;
 8017500: 687b         	ldr	r3, [r7, #0x4]
 8017502: 683a         	ldr	r2, [r7]
 8017504: 601a         	str	r2, [r3]
; }
 8017506: bf00         	nop
 8017508: 370c         	adds	r7, #0xc
 801750a: 46bd         	mov	sp, r7
 801750c: bc80         	pop	{r7}
 801750e: 4770         	bx	lr

08017510 <z_slist_tail_set>:
; {
 8017510: b480         	push	{r7}
 8017512: b083         	sub	sp, #0xc
 8017514: af00         	add	r7, sp, #0x0
 8017516: 6078         	str	r0, [r7, #0x4]
 8017518: 6039         	str	r1, [r7]
; 	list->tail = node;
 801751a: 687b         	ldr	r3, [r7, #0x4]
 801751c: 683a         	ldr	r2, [r7]
 801751e: 605a         	str	r2, [r3, #0x4]
; }
 8017520: bf00         	nop
 8017522: 370c         	adds	r7, #0xc
 8017524: 46bd         	mov	sp, r7
 8017526: bc80         	pop	{r7}
 8017528: 4770         	bx	lr

0801752a <sys_slist_peek_head>:
; {
 801752a: b480         	push	{r7}
 801752c: b083         	sub	sp, #0xc
 801752e: af00         	add	r7, sp, #0x0
 8017530: 6078         	str	r0, [r7, #0x4]
; 	return list->head;
 8017532: 687b         	ldr	r3, [r7, #0x4]
 8017534: 681b         	ldr	r3, [r3]
; }
 8017536: 4618         	mov	r0, r3
 8017538: 370c         	adds	r7, #0xc
 801753a: 46bd         	mov	sp, r7
 801753c: bc80         	pop	{r7}
 801753e: 4770         	bx	lr

08017540 <sys_slist_peek_tail>:
; {
 8017540: b480         	push	{r7}
 8017542: b083         	sub	sp, #0xc
 8017544: af00         	add	r7, sp, #0x0
 8017546: 6078         	str	r0, [r7, #0x4]
; 	return list->tail;
 8017548: 687b         	ldr	r3, [r7, #0x4]
 801754a: 685b         	ldr	r3, [r3, #0x4]
; }
 801754c: 4618         	mov	r0, r3
 801754e: 370c         	adds	r7, #0xc
 8017550: 46bd         	mov	sp, r7
 8017552: bc80         	pop	{r7}
 8017554: 4770         	bx	lr

08017556 <sys_slist_is_empty>:
; Z_GENLIST_IS_EMPTY(slist)
 8017556: b580         	push	{r7, lr}
 8017558: b082         	sub	sp, #0x8
 801755a: af00         	add	r7, sp, #0x0
 801755c: 6078         	str	r0, [r7, #0x4]
 801755e: 6878         	ldr	r0, [r7, #0x4]
 8017560: f7ff ffe3    	bl	0x801752a <sys_slist_peek_head> @ imm = #-0x3a
 8017564: 4603         	mov	r3, r0
 8017566: 2b00         	cmp	r3, #0x0
 8017568: bf0c         	ite	eq
 801756a: 2301         	moveq	r3, #0x1
 801756c: 2300         	movne	r3, #0x0
 801756e: b2db         	uxtb	r3, r3
 8017570: 4618         	mov	r0, r3
 8017572: 3708         	adds	r7, #0x8
 8017574: 46bd         	mov	sp, r7
 8017576: bd80         	pop	{r7, pc}

08017578 <sys_slist_peek_next_no_check>:
; Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
 8017578: b580         	push	{r7, lr}
 801757a: b082         	sub	sp, #0x8
 801757c: af00         	add	r7, sp, #0x0
 801757e: 6078         	str	r0, [r7, #0x4]
 8017580: 6878         	ldr	r0, [r7, #0x4]
 8017582: f7ff ffa0    	bl	0x80174c6 <z_snode_next_peek> @ imm = #-0xc0
 8017586: 4603         	mov	r3, r0
 8017588: 4618         	mov	r0, r3
 801758a: 3708         	adds	r7, #0x8
 801758c: 46bd         	mov	sp, r7
 801758e: bd80         	pop	{r7, pc}

08017590 <sys_slist_peek_next>:
; Z_GENLIST_PEEK_NEXT(slist, snode)
 8017590: b580         	push	{r7, lr}
 8017592: b082         	sub	sp, #0x8
 8017594: af00         	add	r7, sp, #0x0
 8017596: 6078         	str	r0, [r7, #0x4]
 8017598: 687b         	ldr	r3, [r7, #0x4]
 801759a: 2b00         	cmp	r3, #0x0
 801759c: d004         	beq	0x80175a8 <sys_slist_peek_next+0x18> @ imm = #0x8
 801759e: 6878         	ldr	r0, [r7, #0x4]
 80175a0: f7ff ffea    	bl	0x8017578 <sys_slist_peek_next_no_check> @ imm = #-0x2c
 80175a4: 4603         	mov	r3, r0
 80175a6: e000         	b	0x80175aa <sys_slist_peek_next+0x1a> @ imm = #0x0
 80175a8: 2300         	movs	r3, #0x0
 80175aa: 4618         	mov	r0, r3
 80175ac: 3708         	adds	r7, #0x8
 80175ae: 46bd         	mov	sp, r7
 80175b0: bd80         	pop	{r7, pc}

080175b2 <sys_slist_prepend>:
; Z_GENLIST_PREPEND(slist, snode)
 80175b2: b580         	push	{r7, lr}
 80175b4: b082         	sub	sp, #0x8
 80175b6: af00         	add	r7, sp, #0x0
 80175b8: 6078         	str	r0, [r7, #0x4]
 80175ba: 6039         	str	r1, [r7]
 80175bc: 6878         	ldr	r0, [r7, #0x4]
 80175be: f7ff ffb4    	bl	0x801752a <sys_slist_peek_head> @ imm = #-0x98
 80175c2: 4603         	mov	r3, r0
 80175c4: 4619         	mov	r1, r3
 80175c6: 6838         	ldr	r0, [r7]
 80175c8: f7ff ff88    	bl	0x80174dc <z_snode_next_set> @ imm = #-0xf0
 80175cc: 6839         	ldr	r1, [r7]
 80175ce: 6878         	ldr	r0, [r7, #0x4]
 80175d0: f7ff ff91    	bl	0x80174f6 <z_slist_head_set> @ imm = #-0xde
 80175d4: 6878         	ldr	r0, [r7, #0x4]
 80175d6: f7ff ffb3    	bl	0x8017540 <sys_slist_peek_tail> @ imm = #-0x9a
 80175da: 4603         	mov	r3, r0
 80175dc: 2b00         	cmp	r3, #0x0
 80175de: d107         	bne	0x80175f0 <sys_slist_prepend+0x3e> @ imm = #0xe
 80175e0: 6878         	ldr	r0, [r7, #0x4]
 80175e2: f7ff ffa2    	bl	0x801752a <sys_slist_peek_head> @ imm = #-0xbc
 80175e6: 4603         	mov	r3, r0
 80175e8: 4619         	mov	r1, r3
 80175ea: 6878         	ldr	r0, [r7, #0x4]
 80175ec: f7ff ff90    	bl	0x8017510 <z_slist_tail_set> @ imm = #-0xe0
 80175f0: 3708         	adds	r7, #0x8
 80175f2: 46bd         	mov	sp, r7
 80175f4: bd80         	pop	{r7, pc}

080175f6 <sys_slist_remove>:
; Z_GENLIST_REMOVE(slist, snode)
 80175f6: b580         	push	{r7, lr}
 80175f8: b084         	sub	sp, #0x10
 80175fa: af00         	add	r7, sp, #0x0
 80175fc: 60f8         	str	r0, [r7, #0xc]
 80175fe: 60b9         	str	r1, [r7, #0x8]
 8017600: 607a         	str	r2, [r7, #0x4]
 8017602: 68bb         	ldr	r3, [r7, #0x8]
 8017604: 2b00         	cmp	r3, #0x0
 8017606: d117         	bne	0x8017638 <sys_slist_remove+0x42> @ imm = #0x2e
 8017608: 6878         	ldr	r0, [r7, #0x4]
 801760a: f7ff ff5c    	bl	0x80174c6 <z_snode_next_peek> @ imm = #-0x148
 801760e: 4603         	mov	r3, r0
 8017610: 4619         	mov	r1, r3
 8017612: 68f8         	ldr	r0, [r7, #0xc]
 8017614: f7ff ff6f    	bl	0x80174f6 <z_slist_head_set> @ imm = #-0x122
 8017618: 68f8         	ldr	r0, [r7, #0xc]
 801761a: f7ff ff91    	bl	0x8017540 <sys_slist_peek_tail> @ imm = #-0xde
 801761e: 4602         	mov	r2, r0
 8017620: 687b         	ldr	r3, [r7, #0x4]
 8017622: 4293         	cmp	r3, r2
 8017624: d11b         	bne	0x801765e <sys_slist_remove+0x68> @ imm = #0x36
 8017626: 68f8         	ldr	r0, [r7, #0xc]
 8017628: f7ff ff7f    	bl	0x801752a <sys_slist_peek_head> @ imm = #-0x102
 801762c: 4603         	mov	r3, r0
 801762e: 4619         	mov	r1, r3
 8017630: 68f8         	ldr	r0, [r7, #0xc]
 8017632: f7ff ff6d    	bl	0x8017510 <z_slist_tail_set> @ imm = #-0x126
 8017636: e012         	b	0x801765e <sys_slist_remove+0x68> @ imm = #0x24
 8017638: 6878         	ldr	r0, [r7, #0x4]
 801763a: f7ff ff44    	bl	0x80174c6 <z_snode_next_peek> @ imm = #-0x178
 801763e: 4603         	mov	r3, r0
 8017640: 4619         	mov	r1, r3
 8017642: 68b8         	ldr	r0, [r7, #0x8]
 8017644: f7ff ff4a    	bl	0x80174dc <z_snode_next_set> @ imm = #-0x16c
 8017648: 68f8         	ldr	r0, [r7, #0xc]
 801764a: f7ff ff79    	bl	0x8017540 <sys_slist_peek_tail> @ imm = #-0x10e
 801764e: 4602         	mov	r2, r0
 8017650: 687b         	ldr	r3, [r7, #0x4]
 8017652: 4293         	cmp	r3, r2
 8017654: d103         	bne	0x801765e <sys_slist_remove+0x68> @ imm = #0x6
 8017656: 68b9         	ldr	r1, [r7, #0x8]
 8017658: 68f8         	ldr	r0, [r7, #0xc]
 801765a: f7ff ff59    	bl	0x8017510 <z_slist_tail_set> @ imm = #-0x14e
 801765e: 2100         	movs	r1, #0x0
 8017660: 6878         	ldr	r0, [r7, #0x4]
 8017662: f7ff ff3b    	bl	0x80174dc <z_snode_next_set> @ imm = #-0x18a
 8017666: 3710         	adds	r7, #0x10
 8017668: 46bd         	mov	sp, r7
 801766a: bd80         	pop	{r7, pc}

0801766c <sys_slist_find_and_remove>:
; Z_GENLIST_FIND_AND_REMOVE(slist, snode)
 801766c: b580         	push	{r7, lr}
 801766e: b084         	sub	sp, #0x10
 8017670: af00         	add	r7, sp, #0x0
 8017672: 6078         	str	r0, [r7, #0x4]
 8017674: 6039         	str	r1, [r7]
 8017676: 2300         	movs	r3, #0x0
 8017678: 60fb         	str	r3, [r7, #0xc]
 801767a: 6878         	ldr	r0, [r7, #0x4]
 801767c: f7ff ff55    	bl	0x801752a <sys_slist_peek_head> @ imm = #-0x156
 8017680: 60b8         	str	r0, [r7, #0x8]
 8017682: e010         	b	0x80176a6 <sys_slist_find_and_remove+0x3a> @ imm = #0x20
 8017684: 68ba         	ldr	r2, [r7, #0x8]
 8017686: 683b         	ldr	r3, [r7]
 8017688: 429a         	cmp	r2, r3
 801768a: d106         	bne	0x801769a <sys_slist_find_and_remove+0x2e> @ imm = #0xc
 801768c: 683a         	ldr	r2, [r7]
 801768e: 68f9         	ldr	r1, [r7, #0xc]
 8017690: 6878         	ldr	r0, [r7, #0x4]
 8017692: f7ff ffb0    	bl	0x80175f6 <sys_slist_remove> @ imm = #-0xa0
 8017696: 2301         	movs	r3, #0x1
 8017698: e009         	b	0x80176ae <sys_slist_find_and_remove+0x42> @ imm = #0x12
 801769a: 68bb         	ldr	r3, [r7, #0x8]
 801769c: 60fb         	str	r3, [r7, #0xc]
 801769e: 68b8         	ldr	r0, [r7, #0x8]
 80176a0: f7ff ff76    	bl	0x8017590 <sys_slist_peek_next> @ imm = #-0x114
 80176a4: 60b8         	str	r0, [r7, #0x8]
 80176a6: 68bb         	ldr	r3, [r7, #0x8]
 80176a8: 2b00         	cmp	r3, #0x0
 80176aa: d1eb         	bne	0x8017684 <sys_slist_find_and_remove+0x18> @ imm = #-0x2a
 80176ac: 2300         	movs	r3, #0x0
 80176ae: 4618         	mov	r0, r3
 80176b0: 3710         	adds	r7, #0x10
 80176b2: 46bd         	mov	sp, r7
 80176b4: bd80         	pop	{r7, pc}

080176b6 <device_is_ready>:
; {
 80176b6: b580         	push	{r7, lr}
 80176b8: b082         	sub	sp, #0x8
 80176ba: af00         	add	r7, sp, #0x0
 80176bc: 6078         	str	r0, [r7, #0x4]
; 	return z_impl_device_is_ready(dev);
 80176be: 6878         	ldr	r0, [r7, #0x4]
 80176c0: f004 fa5d    	bl	0x801bb7e <z_impl_device_is_ready> @ imm = #0x44ba
 80176c4: 4603         	mov	r3, r0
; }
 80176c6: 4618         	mov	r0, r3
 80176c8: 3708         	adds	r7, #0x8
 80176ca: 46bd         	mov	sp, r7
 80176cc: bd80         	pop	{r7, pc}

080176ce <LL_GPIO_SetPinMode>:
; {
 80176ce: b480         	push	{r7}
 80176d0: b08b         	sub	sp, #0x2c
 80176d2: af00         	add	r7, sp, #0x0
 80176d4: 60f8         	str	r0, [r7, #0xc]
 80176d6: 60b9         	str	r1, [r7, #0x8]
 80176d8: 607a         	str	r2, [r7, #0x4]
;   MODIFY_REG(GPIOx->MODER, (GPIO_MODER_MODER0 << (POSITION_VAL(Pin) * 2U)), (Mode << (POSITION_VAL(Pin) * 2U)));
 80176da: 68fb         	ldr	r3, [r7, #0xc]
 80176dc: 681a         	ldr	r2, [r3]
 80176de: 68bb         	ldr	r3, [r7, #0x8]
 80176e0: 617b         	str	r3, [r7, #0x14]
;    __ASM ("rbit %0, %1" : "=r" (result) : "r" (value) );
 80176e2: 697b         	ldr	r3, [r7, #0x14]
 80176e4: fa93 f3a3    	rbit	r3, r3
 80176e8: 613b         	str	r3, [r7, #0x10]
;   return result;
 80176ea: 693b         	ldr	r3, [r7, #0x10]
 80176ec: 61bb         	str	r3, [r7, #0x18]
;   if (value == 0U)
 80176ee: 69bb         	ldr	r3, [r7, #0x18]
 80176f0: 2b00         	cmp	r3, #0x0
 80176f2: d101         	bne	0x80176f8 <LL_GPIO_SetPinMode+0x2a> @ imm = #0x2
;     return 32U;
 80176f4: 2320         	movs	r3, #0x20
 80176f6: e003         	b	0x8017700 <LL_GPIO_SetPinMode+0x32> @ imm = #0x6
;   return __builtin_clz(value);
 80176f8: 69bb         	ldr	r3, [r7, #0x18]
 80176fa: fab3 f383    	clz	r3, r3
 80176fe: b2db         	uxtb	r3, r3
;   MODIFY_REG(GPIOx->MODER, (GPIO_MODER_MODER0 << (POSITION_VAL(Pin) * 2U)), (Mode << (POSITION_VAL(Pin) * 2U)));
 8017700: 005b         	lsls	r3, r3, #0x1
 8017702: 2103         	movs	r1, #0x3
 8017704: fa01 f303    	lsl.w	r3, r1, r3
 8017708: 43db         	mvns	r3, r3
 801770a: 401a         	ands	r2, r3
 801770c: 68bb         	ldr	r3, [r7, #0x8]
 801770e: 623b         	str	r3, [r7, #0x20]
;    __ASM ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8017710: 6a3b         	ldr	r3, [r7, #0x20]
 8017712: fa93 f3a3    	rbit	r3, r3
 8017716: 61fb         	str	r3, [r7, #0x1c]
;   return result;
 8017718: 69fb         	ldr	r3, [r7, #0x1c]
 801771a: 627b         	str	r3, [r7, #0x24]
;   if (value == 0U)
 801771c: 6a7b         	ldr	r3, [r7, #0x24]
 801771e: 2b00         	cmp	r3, #0x0
 8017720: d101         	bne	0x8017726 <LL_GPIO_SetPinMode+0x58> @ imm = #0x2
;     return 32U;
 8017722: 2320         	movs	r3, #0x20
 8017724: e003         	b	0x801772e <LL_GPIO_SetPinMode+0x60> @ imm = #0x6
;   return __builtin_clz(value);
 8017726: 6a7b         	ldr	r3, [r7, #0x24]
 8017728: fab3 f383    	clz	r3, r3
 801772c: b2db         	uxtb	r3, r3
;   MODIFY_REG(GPIOx->MODER, (GPIO_MODER_MODER0 << (POSITION_VAL(Pin) * 2U)), (Mode << (POSITION_VAL(Pin) * 2U)));
 801772e: 005b         	lsls	r3, r3, #0x1
 8017730: 6879         	ldr	r1, [r7, #0x4]
 8017732: fa01 f303    	lsl.w	r3, r1, r3
 8017736: 431a         	orrs	r2, r3
 8017738: 68fb         	ldr	r3, [r7, #0xc]
 801773a: 601a         	str	r2, [r3]
; }
 801773c: bf00         	nop
 801773e: 372c         	adds	r7, #0x2c
 8017740: 46bd         	mov	sp, r7
 8017742: bc80         	pop	{r7}
 8017744: 4770         	bx	lr

08017746 <LL_GPIO_SetPinOutputType>:
; {
 8017746: b480         	push	{r7}
 8017748: b085         	sub	sp, #0x14
 801774a: af00         	add	r7, sp, #0x0
 801774c: 60f8         	str	r0, [r7, #0xc]
 801774e: 60b9         	str	r1, [r7, #0x8]
 8017750: 607a         	str	r2, [r7, #0x4]
;   MODIFY_REG(GPIOx->OTYPER, PinMask, (PinMask * OutputType));
 8017752: 68fb         	ldr	r3, [r7, #0xc]
 8017754: 685a         	ldr	r2, [r3, #0x4]
 8017756: 68bb         	ldr	r3, [r7, #0x8]
 8017758: 43db         	mvns	r3, r3
 801775a: 401a         	ands	r2, r3
 801775c: 68bb         	ldr	r3, [r7, #0x8]
 801775e: 6879         	ldr	r1, [r7, #0x4]
 8017760: fb01 f303    	mul	r3, r1, r3
 8017764: 431a         	orrs	r2, r3
 8017766: 68fb         	ldr	r3, [r7, #0xc]
 8017768: 605a         	str	r2, [r3, #0x4]
; }
 801776a: bf00         	nop
 801776c: 3714         	adds	r7, #0x14
 801776e: 46bd         	mov	sp, r7
 8017770: bc80         	pop	{r7}
 8017772: 4770         	bx	lr

08017774 <LL_GPIO_SetPinSpeed>:
; {
 8017774: b480         	push	{r7}
 8017776: b08b         	sub	sp, #0x2c
 8017778: af00         	add	r7, sp, #0x0
 801777a: 60f8         	str	r0, [r7, #0xc]
 801777c: 60b9         	str	r1, [r7, #0x8]
 801777e: 607a         	str	r2, [r7, #0x4]
;   MODIFY_REG(GPIOx->OSPEEDR, (GPIO_OSPEEDER_OSPEEDR0 << (POSITION_VAL(Pin) * 2U)),
 8017780: 68fb         	ldr	r3, [r7, #0xc]
 8017782: 689a         	ldr	r2, [r3, #0x8]
 8017784: 68bb         	ldr	r3, [r7, #0x8]
 8017786: 617b         	str	r3, [r7, #0x14]
;    __ASM ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8017788: 697b         	ldr	r3, [r7, #0x14]
 801778a: fa93 f3a3    	rbit	r3, r3
 801778e: 613b         	str	r3, [r7, #0x10]
;   return result;
 8017790: 693b         	ldr	r3, [r7, #0x10]
 8017792: 61bb         	str	r3, [r7, #0x18]
;   if (value == 0U)
 8017794: 69bb         	ldr	r3, [r7, #0x18]
 8017796: 2b00         	cmp	r3, #0x0
 8017798: d101         	bne	0x801779e <LL_GPIO_SetPinSpeed+0x2a> @ imm = #0x2
;     return 32U;
 801779a: 2320         	movs	r3, #0x20
 801779c: e003         	b	0x80177a6 <LL_GPIO_SetPinSpeed+0x32> @ imm = #0x6
;   return __builtin_clz(value);
 801779e: 69bb         	ldr	r3, [r7, #0x18]
 80177a0: fab3 f383    	clz	r3, r3
 80177a4: b2db         	uxtb	r3, r3
;   MODIFY_REG(GPIOx->OSPEEDR, (GPIO_OSPEEDER_OSPEEDR0 << (POSITION_VAL(Pin) * 2U)),
 80177a6: 005b         	lsls	r3, r3, #0x1
 80177a8: 2103         	movs	r1, #0x3
 80177aa: fa01 f303    	lsl.w	r3, r1, r3
 80177ae: 43db         	mvns	r3, r3
 80177b0: 401a         	ands	r2, r3
 80177b2: 68bb         	ldr	r3, [r7, #0x8]
 80177b4: 623b         	str	r3, [r7, #0x20]
;    __ASM ("rbit %0, %1" : "=r" (result) : "r" (value) );
 80177b6: 6a3b         	ldr	r3, [r7, #0x20]
 80177b8: fa93 f3a3    	rbit	r3, r3
 80177bc: 61fb         	str	r3, [r7, #0x1c]
;   return result;
 80177be: 69fb         	ldr	r3, [r7, #0x1c]
 80177c0: 627b         	str	r3, [r7, #0x24]
;   if (value == 0U)
 80177c2: 6a7b         	ldr	r3, [r7, #0x24]
 80177c4: 2b00         	cmp	r3, #0x0
 80177c6: d101         	bne	0x80177cc <LL_GPIO_SetPinSpeed+0x58> @ imm = #0x2
;     return 32U;
 80177c8: 2320         	movs	r3, #0x20
 80177ca: e003         	b	0x80177d4 <LL_GPIO_SetPinSpeed+0x60> @ imm = #0x6
;   return __builtin_clz(value);
 80177cc: 6a7b         	ldr	r3, [r7, #0x24]
 80177ce: fab3 f383    	clz	r3, r3
 80177d2: b2db         	uxtb	r3, r3
;   MODIFY_REG(GPIOx->OSPEEDR, (GPIO_OSPEEDER_OSPEEDR0 << (POSITION_VAL(Pin) * 2U)),
 80177d4: 005b         	lsls	r3, r3, #0x1
 80177d6: 6879         	ldr	r1, [r7, #0x4]
 80177d8: fa01 f303    	lsl.w	r3, r1, r3
 80177dc: 431a         	orrs	r2, r3
 80177de: 68fb         	ldr	r3, [r7, #0xc]
 80177e0: 609a         	str	r2, [r3, #0x8]
; }
 80177e2: bf00         	nop
 80177e4: 372c         	adds	r7, #0x2c
 80177e6: 46bd         	mov	sp, r7
 80177e8: bc80         	pop	{r7}
 80177ea: 4770         	bx	lr

080177ec <LL_GPIO_SetPinPull>:
; {
 80177ec: b480         	push	{r7}
 80177ee: b08b         	sub	sp, #0x2c
 80177f0: af00         	add	r7, sp, #0x0
 80177f2: 60f8         	str	r0, [r7, #0xc]
 80177f4: 60b9         	str	r1, [r7, #0x8]
 80177f6: 607a         	str	r2, [r7, #0x4]
;   MODIFY_REG(GPIOx->PUPDR, (GPIO_PUPDR_PUPDR0 << (POSITION_VAL(Pin) * 2U)), (Pull << (POSITION_VAL(Pin) * 2U)));
 80177f8: 68fb         	ldr	r3, [r7, #0xc]
 80177fa: 68da         	ldr	r2, [r3, #0xc]
 80177fc: 68bb         	ldr	r3, [r7, #0x8]
 80177fe: 617b         	str	r3, [r7, #0x14]
;    __ASM ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8017800: 697b         	ldr	r3, [r7, #0x14]
 8017802: fa93 f3a3    	rbit	r3, r3
 8017806: 613b         	str	r3, [r7, #0x10]
;   return result;
 8017808: 693b         	ldr	r3, [r7, #0x10]
 801780a: 61bb         	str	r3, [r7, #0x18]
;   if (value == 0U)
 801780c: 69bb         	ldr	r3, [r7, #0x18]
 801780e: 2b00         	cmp	r3, #0x0
 8017810: d101         	bne	0x8017816 <LL_GPIO_SetPinPull+0x2a> @ imm = #0x2
;     return 32U;
 8017812: 2320         	movs	r3, #0x20
 8017814: e003         	b	0x801781e <LL_GPIO_SetPinPull+0x32> @ imm = #0x6
;   return __builtin_clz(value);
 8017816: 69bb         	ldr	r3, [r7, #0x18]
 8017818: fab3 f383    	clz	r3, r3
 801781c: b2db         	uxtb	r3, r3
;   MODIFY_REG(GPIOx->PUPDR, (GPIO_PUPDR_PUPDR0 << (POSITION_VAL(Pin) * 2U)), (Pull << (POSITION_VAL(Pin) * 2U)));
 801781e: 005b         	lsls	r3, r3, #0x1
 8017820: 2103         	movs	r1, #0x3
 8017822: fa01 f303    	lsl.w	r3, r1, r3
 8017826: 43db         	mvns	r3, r3
 8017828: 401a         	ands	r2, r3
 801782a: 68bb         	ldr	r3, [r7, #0x8]
 801782c: 623b         	str	r3, [r7, #0x20]
;    __ASM ("rbit %0, %1" : "=r" (result) : "r" (value) );
 801782e: 6a3b         	ldr	r3, [r7, #0x20]
 8017830: fa93 f3a3    	rbit	r3, r3
 8017834: 61fb         	str	r3, [r7, #0x1c]
;   return result;
 8017836: 69fb         	ldr	r3, [r7, #0x1c]
 8017838: 627b         	str	r3, [r7, #0x24]
;   if (value == 0U)
 801783a: 6a7b         	ldr	r3, [r7, #0x24]
 801783c: 2b00         	cmp	r3, #0x0
 801783e: d101         	bne	0x8017844 <LL_GPIO_SetPinPull+0x58> @ imm = #0x2
;     return 32U;
 8017840: 2320         	movs	r3, #0x20
 8017842: e003         	b	0x801784c <LL_GPIO_SetPinPull+0x60> @ imm = #0x6
;   return __builtin_clz(value);
 8017844: 6a7b         	ldr	r3, [r7, #0x24]
 8017846: fab3 f383    	clz	r3, r3
 801784a: b2db         	uxtb	r3, r3
;   MODIFY_REG(GPIOx->PUPDR, (GPIO_PUPDR_PUPDR0 << (POSITION_VAL(Pin) * 2U)), (Pull << (POSITION_VAL(Pin) * 2U)));
 801784c: 005b         	lsls	r3, r3, #0x1
 801784e: 6879         	ldr	r1, [r7, #0x4]
 8017850: fa01 f303    	lsl.w	r3, r1, r3
 8017854: 431a         	orrs	r2, r3
 8017856: 68fb         	ldr	r3, [r7, #0xc]
 8017858: 60da         	str	r2, [r3, #0xc]
; }
 801785a: bf00         	nop
 801785c: 372c         	adds	r7, #0x2c
 801785e: 46bd         	mov	sp, r7
 8017860: bc80         	pop	{r7}
 8017862: 4770         	bx	lr

08017864 <LL_GPIO_SetAFPin_0_7>:
; {
 8017864: b480         	push	{r7}
 8017866: b08b         	sub	sp, #0x2c
 8017868: af00         	add	r7, sp, #0x0
 801786a: 60f8         	str	r0, [r7, #0xc]
 801786c: 60b9         	str	r1, [r7, #0x8]
 801786e: 607a         	str	r2, [r7, #0x4]
;   MODIFY_REG(GPIOx->AFR[0], (GPIO_AFRL_AFSEL0 << (POSITION_VAL(Pin) * 4U)),
 8017870: 68fb         	ldr	r3, [r7, #0xc]
 8017872: 6a1a         	ldr	r2, [r3, #0x20]
 8017874: 68bb         	ldr	r3, [r7, #0x8]
 8017876: 617b         	str	r3, [r7, #0x14]
;    __ASM ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8017878: 697b         	ldr	r3, [r7, #0x14]
 801787a: fa93 f3a3    	rbit	r3, r3
 801787e: 613b         	str	r3, [r7, #0x10]
;   return result;
 8017880: 693b         	ldr	r3, [r7, #0x10]
 8017882: 61bb         	str	r3, [r7, #0x18]
;   if (value == 0U)
 8017884: 69bb         	ldr	r3, [r7, #0x18]
 8017886: 2b00         	cmp	r3, #0x0
 8017888: d101         	bne	0x801788e <LL_GPIO_SetAFPin_0_7+0x2a> @ imm = #0x2
;     return 32U;
 801788a: 2320         	movs	r3, #0x20
 801788c: e003         	b	0x8017896 <LL_GPIO_SetAFPin_0_7+0x32> @ imm = #0x6
;   return __builtin_clz(value);
 801788e: 69bb         	ldr	r3, [r7, #0x18]
 8017890: fab3 f383    	clz	r3, r3
 8017894: b2db         	uxtb	r3, r3
;   MODIFY_REG(GPIOx->AFR[0], (GPIO_AFRL_AFSEL0 << (POSITION_VAL(Pin) * 4U)),
 8017896: 009b         	lsls	r3, r3, #0x2
 8017898: 210f         	movs	r1, #0xf
 801789a: fa01 f303    	lsl.w	r3, r1, r3
 801789e: 43db         	mvns	r3, r3
 80178a0: 401a         	ands	r2, r3
 80178a2: 68bb         	ldr	r3, [r7, #0x8]
 80178a4: 623b         	str	r3, [r7, #0x20]
;    __ASM ("rbit %0, %1" : "=r" (result) : "r" (value) );
 80178a6: 6a3b         	ldr	r3, [r7, #0x20]
 80178a8: fa93 f3a3    	rbit	r3, r3
 80178ac: 61fb         	str	r3, [r7, #0x1c]
;   return result;
 80178ae: 69fb         	ldr	r3, [r7, #0x1c]
 80178b0: 627b         	str	r3, [r7, #0x24]
;   if (value == 0U)
 80178b2: 6a7b         	ldr	r3, [r7, #0x24]
 80178b4: 2b00         	cmp	r3, #0x0
 80178b6: d101         	bne	0x80178bc <LL_GPIO_SetAFPin_0_7+0x58> @ imm = #0x2
;     return 32U;
 80178b8: 2320         	movs	r3, #0x20
 80178ba: e003         	b	0x80178c4 <LL_GPIO_SetAFPin_0_7+0x60> @ imm = #0x6
;   return __builtin_clz(value);
 80178bc: 6a7b         	ldr	r3, [r7, #0x24]
 80178be: fab3 f383    	clz	r3, r3
 80178c2: b2db         	uxtb	r3, r3
;   MODIFY_REG(GPIOx->AFR[0], (GPIO_AFRL_AFSEL0 << (POSITION_VAL(Pin) * 4U)),
 80178c4: 009b         	lsls	r3, r3, #0x2
 80178c6: 6879         	ldr	r1, [r7, #0x4]
 80178c8: fa01 f303    	lsl.w	r3, r1, r3
 80178cc: 431a         	orrs	r2, r3
 80178ce: 68fb         	ldr	r3, [r7, #0xc]
 80178d0: 621a         	str	r2, [r3, #0x20]
; }
 80178d2: bf00         	nop
 80178d4: 372c         	adds	r7, #0x2c
 80178d6: 46bd         	mov	sp, r7
 80178d8: bc80         	pop	{r7}
 80178da: 4770         	bx	lr

080178dc <LL_GPIO_SetAFPin_8_15>:
; {
 80178dc: b480         	push	{r7}
 80178de: b08b         	sub	sp, #0x2c
 80178e0: af00         	add	r7, sp, #0x0
 80178e2: 60f8         	str	r0, [r7, #0xc]
 80178e4: 60b9         	str	r1, [r7, #0x8]
 80178e6: 607a         	str	r2, [r7, #0x4]
;   MODIFY_REG(GPIOx->AFR[1], (GPIO_AFRH_AFSEL8 << (POSITION_VAL(Pin >> 8U) * 4U)),
 80178e8: 68fb         	ldr	r3, [r7, #0xc]
 80178ea: 6a5a         	ldr	r2, [r3, #0x24]
 80178ec: 68bb         	ldr	r3, [r7, #0x8]
 80178ee: 0a1b         	lsrs	r3, r3, #0x8
 80178f0: 617b         	str	r3, [r7, #0x14]
;    __ASM ("rbit %0, %1" : "=r" (result) : "r" (value) );
 80178f2: 697b         	ldr	r3, [r7, #0x14]
 80178f4: fa93 f3a3    	rbit	r3, r3
 80178f8: 613b         	str	r3, [r7, #0x10]
;   return result;
 80178fa: 693b         	ldr	r3, [r7, #0x10]
 80178fc: 61bb         	str	r3, [r7, #0x18]
;   if (value == 0U)
 80178fe: 69bb         	ldr	r3, [r7, #0x18]
 8017900: 2b00         	cmp	r3, #0x0
 8017902: d101         	bne	0x8017908 <LL_GPIO_SetAFPin_8_15+0x2c> @ imm = #0x2
;     return 32U;
 8017904: 2320         	movs	r3, #0x20
 8017906: e003         	b	0x8017910 <LL_GPIO_SetAFPin_8_15+0x34> @ imm = #0x6
;   return __builtin_clz(value);
 8017908: 69bb         	ldr	r3, [r7, #0x18]
 801790a: fab3 f383    	clz	r3, r3
 801790e: b2db         	uxtb	r3, r3
;   MODIFY_REG(GPIOx->AFR[1], (GPIO_AFRH_AFSEL8 << (POSITION_VAL(Pin >> 8U) * 4U)),
 8017910: 009b         	lsls	r3, r3, #0x2
 8017912: 210f         	movs	r1, #0xf
 8017914: fa01 f303    	lsl.w	r3, r1, r3
 8017918: 43db         	mvns	r3, r3
 801791a: 401a         	ands	r2, r3
 801791c: 68bb         	ldr	r3, [r7, #0x8]
 801791e: 0a1b         	lsrs	r3, r3, #0x8
 8017920: 623b         	str	r3, [r7, #0x20]
;    __ASM ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8017922: 6a3b         	ldr	r3, [r7, #0x20]
 8017924: fa93 f3a3    	rbit	r3, r3
 8017928: 61fb         	str	r3, [r7, #0x1c]
;   return result;
 801792a: 69fb         	ldr	r3, [r7, #0x1c]
 801792c: 627b         	str	r3, [r7, #0x24]
;   if (value == 0U)
 801792e: 6a7b         	ldr	r3, [r7, #0x24]
 8017930: 2b00         	cmp	r3, #0x0
 8017932: d101         	bne	0x8017938 <LL_GPIO_SetAFPin_8_15+0x5c> @ imm = #0x2
;     return 32U;
 8017934: 2320         	movs	r3, #0x20
 8017936: e003         	b	0x8017940 <LL_GPIO_SetAFPin_8_15+0x64> @ imm = #0x6
;   return __builtin_clz(value);
 8017938: 6a7b         	ldr	r3, [r7, #0x24]
 801793a: fab3 f383    	clz	r3, r3
 801793e: b2db         	uxtb	r3, r3
;   MODIFY_REG(GPIOx->AFR[1], (GPIO_AFRH_AFSEL8 << (POSITION_VAL(Pin >> 8U) * 4U)),
 8017940: 009b         	lsls	r3, r3, #0x2
 8017942: 6879         	ldr	r1, [r7, #0x4]
 8017944: fa01 f303    	lsl.w	r3, r1, r3
 8017948: 431a         	orrs	r2, r3
 801794a: 68fb         	ldr	r3, [r7, #0xc]
 801794c: 625a         	str	r2, [r3, #0x24]
; }
 801794e: bf00         	nop
 8017950: 372c         	adds	r7, #0x2c
 8017952: 46bd         	mov	sp, r7
 8017954: bc80         	pop	{r7}
 8017956: 4770         	bx	lr

08017958 <LL_GPIO_ReadInputPort>:
; {
 8017958: b480         	push	{r7}
 801795a: b083         	sub	sp, #0xc
 801795c: af00         	add	r7, sp, #0x0
 801795e: 6078         	str	r0, [r7, #0x4]
;   return (uint32_t)(READ_REG(GPIOx->IDR));
 8017960: 687b         	ldr	r3, [r7, #0x4]
 8017962: 691b         	ldr	r3, [r3, #0x10]
; }
 8017964: 4618         	mov	r0, r3
 8017966: 370c         	adds	r7, #0xc
 8017968: 46bd         	mov	sp, r7
 801796a: bc80         	pop	{r7}
 801796c: 4770         	bx	lr

0801796e <LL_GPIO_WriteOutputPort>:
; {
 801796e: b480         	push	{r7}
 8017970: b083         	sub	sp, #0xc
 8017972: af00         	add	r7, sp, #0x0
 8017974: 6078         	str	r0, [r7, #0x4]
 8017976: 6039         	str	r1, [r7]
;   WRITE_REG(GPIOx->ODR, PortValue);
 8017978: 687b         	ldr	r3, [r7, #0x4]
 801797a: 683a         	ldr	r2, [r7]
 801797c: 615a         	str	r2, [r3, #0x14]
; }
 801797e: bf00         	nop
 8017980: 370c         	adds	r7, #0xc
 8017982: 46bd         	mov	sp, r7
 8017984: bc80         	pop	{r7}
 8017986: 4770         	bx	lr

08017988 <LL_GPIO_ReadOutputPort>:
; {
 8017988: b480         	push	{r7}
 801798a: b083         	sub	sp, #0xc
 801798c: af00         	add	r7, sp, #0x0
 801798e: 6078         	str	r0, [r7, #0x4]
;   return (uint32_t)(READ_REG(GPIOx->ODR));
 8017990: 687b         	ldr	r3, [r7, #0x4]
 8017992: 695b         	ldr	r3, [r3, #0x14]
; }
 8017994: 4618         	mov	r0, r3
 8017996: 370c         	adds	r7, #0xc
 8017998: 46bd         	mov	sp, r7
 801799a: bc80         	pop	{r7}
 801799c: 4770         	bx	lr

0801799e <LL_GPIO_ResetOutputPin>:
; {
 801799e: b480         	push	{r7}
 80179a0: b083         	sub	sp, #0xc
 80179a2: af00         	add	r7, sp, #0x0
 80179a4: 6078         	str	r0, [r7, #0x4]
 80179a6: 6039         	str	r1, [r7]
;   WRITE_REG(GPIOx->BSRR, (PinMask << 16));
 80179a8: 683b         	ldr	r3, [r7]
 80179aa: 041a         	lsls	r2, r3, #0x10
 80179ac: 687b         	ldr	r3, [r7, #0x4]
 80179ae: 619a         	str	r2, [r3, #0x18]
; }
 80179b0: bf00         	nop
 80179b2: 370c         	adds	r7, #0xc
 80179b4: 46bd         	mov	sp, r7
 80179b6: bc80         	pop	{r7}
 80179b8: 4770         	bx	lr

080179ba <clock_control_on>:
; {
 80179ba: b580         	push	{r7, lr}
 80179bc: b084         	sub	sp, #0x10
 80179be: af00         	add	r7, sp, #0x0
 80179c0: 6078         	str	r0, [r7, #0x4]
 80179c2: 6039         	str	r1, [r7]
; 	const struct clock_control_driver_api *api =
 80179c4: 687b         	ldr	r3, [r7, #0x4]
 80179c6: 689b         	ldr	r3, [r3, #0x8]
 80179c8: 60fb         	str	r3, [r7, #0xc]
; 	return api->on(dev, sys);
 80179ca: 68fb         	ldr	r3, [r7, #0xc]
 80179cc: 681b         	ldr	r3, [r3]
 80179ce: 6839         	ldr	r1, [r7]
 80179d0: 6878         	ldr	r0, [r7, #0x4]
 80179d2: 4798         	blx	r3
 80179d4: 4603         	mov	r3, r0
; }
 80179d6: 4618         	mov	r0, r3
 80179d8: 3710         	adds	r7, #0x10
 80179da: 46bd         	mov	sp, r7
 80179dc: bd80         	pop	{r7, pc}

080179de <clock_control_off>:
; {
 80179de: b580         	push	{r7, lr}
 80179e0: b084         	sub	sp, #0x10
 80179e2: af00         	add	r7, sp, #0x0
 80179e4: 6078         	str	r0, [r7, #0x4]
 80179e6: 6039         	str	r1, [r7]
; 	const struct clock_control_driver_api *api =
 80179e8: 687b         	ldr	r3, [r7, #0x4]
 80179ea: 689b         	ldr	r3, [r3, #0x8]
 80179ec: 60fb         	str	r3, [r7, #0xc]
; 	return api->off(dev, sys);
 80179ee: 68fb         	ldr	r3, [r7, #0xc]
 80179f0: 685b         	ldr	r3, [r3, #0x4]
 80179f2: 6839         	ldr	r1, [r7]
 80179f4: 6878         	ldr	r0, [r7, #0x4]
 80179f6: 4798         	blx	r3
 80179f8: 4603         	mov	r3, r0
; }
 80179fa: 4618         	mov	r0, r3
 80179fc: 3710         	adds	r7, #0x10
 80179fe: 46bd         	mov	sp, r7
 8017a00: bd80         	pop	{r7, pc}

08017a02 <pm_device_runtime_enable>:
; {
 8017a02: b480         	push	{r7}
 8017a04: b083         	sub	sp, #0xc
 8017a06: af00         	add	r7, sp, #0x0
 8017a08: 6078         	str	r0, [r7, #0x4]
; 	return 0;
 8017a0a: 2300         	movs	r3, #0x0
; }
 8017a0c: 4618         	mov	r0, r3
 8017a0e: 370c         	adds	r7, #0xc
 8017a10: 46bd         	mov	sp, r7
 8017a12: bc80         	pop	{r7}
 8017a14: 4770         	bx	lr

08017a16 <pm_device_runtime_get>:
; {
 8017a16: b480         	push	{r7}
 8017a18: b083         	sub	sp, #0xc
 8017a1a: af00         	add	r7, sp, #0x0
 8017a1c: 6078         	str	r0, [r7, #0x4]
; 	return 0;
 8017a1e: 2300         	movs	r3, #0x0
; }
 8017a20: 4618         	mov	r0, r3
 8017a22: 370c         	adds	r7, #0xc
 8017a24: 46bd         	mov	sp, r7
 8017a26: bc80         	pop	{r7}
 8017a28: 4770         	bx	lr

08017a2a <pm_device_runtime_put>:
; {
 8017a2a: b480         	push	{r7}
 8017a2c: b083         	sub	sp, #0xc
 8017a2e: af00         	add	r7, sp, #0x0
 8017a30: 6078         	str	r0, [r7, #0x4]
; 	return 0;
 8017a32: 2300         	movs	r3, #0x0
; }
 8017a34: 4618         	mov	r0, r3
 8017a36: 370c         	adds	r7, #0xc
 8017a38: 46bd         	mov	sp, r7
 8017a3a: bc80         	pop	{r7}
 8017a3c: 4770         	bx	lr

08017a3e <z_stm32_hsem_lock>:
; {
 8017a3e: b480         	push	{r7}
 8017a40: b083         	sub	sp, #0xc
 8017a42: af00         	add	r7, sp, #0x0
 8017a44: 6078         	str	r0, [r7, #0x4]
 8017a46: 6039         	str	r1, [r7]
; }
 8017a48: bf00         	nop
 8017a4a: 370c         	adds	r7, #0xc
 8017a4c: 46bd         	mov	sp, r7
 8017a4e: bc80         	pop	{r7}
 8017a50: 4770         	bx	lr

08017a52 <z_stm32_hsem_unlock>:
; {
 8017a52: b480         	push	{r7}
 8017a54: b083         	sub	sp, #0xc
 8017a56: af00         	add	r7, sp, #0x0
 8017a58: 6078         	str	r0, [r7, #0x4]
; }
 8017a5a: bf00         	nop
 8017a5c: 370c         	adds	r7, #0xc
 8017a5e: 46bd         	mov	sp, r7
 8017a60: bc80         	pop	{r7}
 8017a62: 4770         	bx	lr

08017a64 <gpio_manage_callback>:
; {
 8017a64: b580         	push	{r7, lr}
 8017a66: b084         	sub	sp, #0x10
 8017a68: af00         	add	r7, sp, #0x0
 8017a6a: 60f8         	str	r0, [r7, #0xc]
 8017a6c: 60b9         	str	r1, [r7, #0x8]
 8017a6e: 4613         	mov	r3, r2
 8017a70: 71fb         	strb	r3, [r7, #0x7]
; 	if (!sys_slist_is_empty(callbacks)) {
 8017a72: 68f8         	ldr	r0, [r7, #0xc]
 8017a74: f7ff fd6f    	bl	0x8017556 <sys_slist_is_empty> @ imm = #-0x522
 8017a78: 4603         	mov	r3, r0
 8017a7a: f083 0301    	eor	r3, r3, #0x1
 8017a7e: b2db         	uxtb	r3, r3
 8017a80: 2b00         	cmp	r3, #0x0
 8017a82: d013         	beq	0x8017aac <gpio_manage_callback+0x48> @ imm = #0x26
; 		if (!sys_slist_find_and_remove(callbacks, &callback->node)) {
 8017a84: 68bb         	ldr	r3, [r7, #0x8]
 8017a86: 4619         	mov	r1, r3
 8017a88: 68f8         	ldr	r0, [r7, #0xc]
 8017a8a: f7ff fdef    	bl	0x801766c <sys_slist_find_and_remove> @ imm = #-0x422
 8017a8e: 4603         	mov	r3, r0
 8017a90: f083 0301    	eor	r3, r3, #0x1
 8017a94: b2db         	uxtb	r3, r3
 8017a96: 2b00         	cmp	r3, #0x0
 8017a98: d011         	beq	0x8017abe <gpio_manage_callback+0x5a> @ imm = #0x22
; 			if (!set) {
 8017a9a: 79fb         	ldrb	r3, [r7, #0x7]
 8017a9c: f083 0301    	eor	r3, r3, #0x1
 8017aa0: b2db         	uxtb	r3, r3
 8017aa2: 2b00         	cmp	r3, #0x0
 8017aa4: d00b         	beq	0x8017abe <gpio_manage_callback+0x5a> @ imm = #0x16
; 				return -EINVAL;
 8017aa6: f06f 0315    	mvn	r3, #0x15
 8017aaa: e011         	b	0x8017ad0 <gpio_manage_callback+0x6c> @ imm = #0x22
; 	} else if (!set) {
 8017aac: 79fb         	ldrb	r3, [r7, #0x7]
 8017aae: f083 0301    	eor	r3, r3, #0x1
 8017ab2: b2db         	uxtb	r3, r3
 8017ab4: 2b00         	cmp	r3, #0x0
 8017ab6: d002         	beq	0x8017abe <gpio_manage_callback+0x5a> @ imm = #0x4
; 		return -EINVAL;
 8017ab8: f06f 0315    	mvn	r3, #0x15
 8017abc: e008         	b	0x8017ad0 <gpio_manage_callback+0x6c> @ imm = #0x10
; 	if (set) {
 8017abe: 79fb         	ldrb	r3, [r7, #0x7]
 8017ac0: 2b00         	cmp	r3, #0x0
 8017ac2: d004         	beq	0x8017ace <gpio_manage_callback+0x6a> @ imm = #0x8
; 		sys_slist_prepend(callbacks, &callback->node);
 8017ac4: 68bb         	ldr	r3, [r7, #0x8]
 8017ac6: 4619         	mov	r1, r3
 8017ac8: 68f8         	ldr	r0, [r7, #0xc]
 8017aca: f7ff fd72    	bl	0x80175b2 <sys_slist_prepend> @ imm = #-0x51c
; 	return 0;
 8017ace: 2300         	movs	r3, #0x0
; }
 8017ad0: 4618         	mov	r0, r3
 8017ad2: 3710         	adds	r7, #0x10
 8017ad4: 46bd         	mov	sp, r7
 8017ad6: bd80         	pop	{r7, pc}

08017ad8 <gpio_fire_callbacks>:
; {
 8017ad8: b580         	push	{r7, lr}
 8017ada: b086         	sub	sp, #0x18
 8017adc: af00         	add	r7, sp, #0x0
 8017ade: 60f8         	str	r0, [r7, #0xc]
 8017ae0: 60b9         	str	r1, [r7, #0x8]
 8017ae2: 607a         	str	r2, [r7, #0x4]
; 	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(list, cb, tmp, node) {
 8017ae4: 68f8         	ldr	r0, [r7, #0xc]
 8017ae6: f7ff fd20    	bl	0x801752a <sys_slist_peek_head> @ imm = #-0x5c0
 8017aea: 4603         	mov	r3, r0
 8017aec: 2b00         	cmp	r3, #0x0
 8017aee: d004         	beq	0x8017afa <gpio_fire_callbacks+0x22> @ imm = #0x8
 8017af0: 68f8         	ldr	r0, [r7, #0xc]
 8017af2: f7ff fd1a    	bl	0x801752a <sys_slist_peek_head> @ imm = #-0x5cc
 8017af6: 4603         	mov	r3, r0
 8017af8: e000         	b	0x8017afc <gpio_fire_callbacks+0x24> @ imm = #0x0
 8017afa: 2300         	movs	r3, #0x0
 8017afc: 617b         	str	r3, [r7, #0x14]
 8017afe: 697b         	ldr	r3, [r7, #0x14]
 8017b00: 2b00         	cmp	r3, #0x0
 8017b02: d00e         	beq	0x8017b22 <gpio_fire_callbacks+0x4a> @ imm = #0x1c
 8017b04: 697b         	ldr	r3, [r7, #0x14]
 8017b06: 4618         	mov	r0, r3
 8017b08: f7ff fd42    	bl	0x8017590 <sys_slist_peek_next> @ imm = #-0x57c
 8017b0c: 4603         	mov	r3, r0
 8017b0e: 2b00         	cmp	r3, #0x0
 8017b10: d005         	beq	0x8017b1e <gpio_fire_callbacks+0x46> @ imm = #0xa
 8017b12: 697b         	ldr	r3, [r7, #0x14]
 8017b14: 4618         	mov	r0, r3
 8017b16: f7ff fd3b    	bl	0x8017590 <sys_slist_peek_next> @ imm = #-0x58a
 8017b1a: 4603         	mov	r3, r0
 8017b1c: e002         	b	0x8017b24 <gpio_fire_callbacks+0x4c> @ imm = #0x4
 8017b1e: 2300         	movs	r3, #0x0
 8017b20: e000         	b	0x8017b24 <gpio_fire_callbacks+0x4c> @ imm = #0x0
 8017b22: 2300         	movs	r3, #0x0
 8017b24: 613b         	str	r3, [r7, #0x10]
 8017b26: e024         	b	0x8017b72 <gpio_fire_callbacks+0x9a> @ imm = #0x48
; 		if (cb->pin_mask & pins) {
 8017b28: 697b         	ldr	r3, [r7, #0x14]
 8017b2a: 689a         	ldr	r2, [r3, #0x8]
 8017b2c: 687b         	ldr	r3, [r7, #0x4]
 8017b2e: 4013         	ands	r3, r2
 8017b30: 2b00         	cmp	r3, #0x0
 8017b32: d008         	beq	0x8017b46 <gpio_fire_callbacks+0x6e> @ imm = #0x10
; 			cb->handler(port, cb, cb->pin_mask & pins);
 8017b34: 697b         	ldr	r3, [r7, #0x14]
 8017b36: 685b         	ldr	r3, [r3, #0x4]
 8017b38: 697a         	ldr	r2, [r7, #0x14]
 8017b3a: 6891         	ldr	r1, [r2, #0x8]
 8017b3c: 687a         	ldr	r2, [r7, #0x4]
 8017b3e: 400a         	ands	r2, r1
 8017b40: 6979         	ldr	r1, [r7, #0x14]
 8017b42: 68b8         	ldr	r0, [r7, #0x8]
 8017b44: 4798         	blx	r3
; 	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(list, cb, tmp, node) {
 8017b46: 693b         	ldr	r3, [r7, #0x10]
 8017b48: 617b         	str	r3, [r7, #0x14]
 8017b4a: 697b         	ldr	r3, [r7, #0x14]
 8017b4c: 2b00         	cmp	r3, #0x0
 8017b4e: d00e         	beq	0x8017b6e <gpio_fire_callbacks+0x96> @ imm = #0x1c
 8017b50: 697b         	ldr	r3, [r7, #0x14]
 8017b52: 4618         	mov	r0, r3
 8017b54: f7ff fd1c    	bl	0x8017590 <sys_slist_peek_next> @ imm = #-0x5c8
 8017b58: 4603         	mov	r3, r0
 8017b5a: 2b00         	cmp	r3, #0x0
 8017b5c: d005         	beq	0x8017b6a <gpio_fire_callbacks+0x92> @ imm = #0xa
 8017b5e: 697b         	ldr	r3, [r7, #0x14]
 8017b60: 4618         	mov	r0, r3
 8017b62: f7ff fd15    	bl	0x8017590 <sys_slist_peek_next> @ imm = #-0x5d6
 8017b66: 4603         	mov	r3, r0
 8017b68: e002         	b	0x8017b70 <gpio_fire_callbacks+0x98> @ imm = #0x4
 8017b6a: 2300         	movs	r3, #0x0
 8017b6c: e000         	b	0x8017b70 <gpio_fire_callbacks+0x98> @ imm = #0x0
 8017b6e: 2300         	movs	r3, #0x0
 8017b70: 613b         	str	r3, [r7, #0x10]
 8017b72: 697b         	ldr	r3, [r7, #0x14]
 8017b74: 2b00         	cmp	r3, #0x0
 8017b76: d1d7         	bne	0x8017b28 <gpio_fire_callbacks+0x50> @ imm = #-0x52
; }
 8017b78: bf00         	nop
 8017b7a: bf00         	nop
 8017b7c: 3718         	adds	r7, #0x18
 8017b7e: 46bd         	mov	sp, r7
 8017b80: bd80         	pop	{r7, pc}

08017b82 <gpio_stm32_isr>:
; {
 8017b82: b580         	push	{r7, lr}
 8017b84: b084         	sub	sp, #0x10
 8017b86: af00         	add	r7, sp, #0x0
 8017b88: 6078         	str	r0, [r7, #0x4]
 8017b8a: 6039         	str	r1, [r7]
; 	struct gpio_stm32_data *data = arg;
 8017b8c: 683b         	ldr	r3, [r7]
 8017b8e: 60fb         	str	r3, [r7, #0xc]
; 	gpio_fire_callbacks(&data->cb, data->dev, pin);
 8017b90: 68fb         	ldr	r3, [r7, #0xc]
 8017b92: f103 0008    	add.w	r0, r3, #0x8
 8017b96: 68fb         	ldr	r3, [r7, #0xc]
 8017b98: 685b         	ldr	r3, [r3, #0x4]
 8017b9a: 687a         	ldr	r2, [r7, #0x4]
 8017b9c: 4619         	mov	r1, r3
 8017b9e: f7ff ff9b    	bl	0x8017ad8 <gpio_fire_callbacks> @ imm = #-0xca
; }
 8017ba2: bf00         	nop
 8017ba4: 3710         	adds	r7, #0x10
 8017ba6: 46bd         	mov	sp, r7
 8017ba8: bd80         	pop	{r7, pc}

08017baa <gpio_stm32_flags_to_conf>:
; {
 8017baa: b480         	push	{r7}
 8017bac: b083         	sub	sp, #0xc
 8017bae: af00         	add	r7, sp, #0x0
 8017bb0: 6078         	str	r0, [r7, #0x4]
 8017bb2: 6039         	str	r1, [r7]
; 	if ((flags & GPIO_OUTPUT) != 0) {
 8017bb4: 687b         	ldr	r3, [r7, #0x4]
 8017bb6: f403 3300    	and	r3, r3, #0x20000
 8017bba: 2b00         	cmp	r3, #0x0
 8017bbc: d032         	beq	0x8017c24 <gpio_stm32_flags_to_conf+0x7a> @ imm = #0x64
; 		*pincfg = STM32_PINCFG_MODE_OUTPUT;
 8017bbe: 683b         	ldr	r3, [r7]
 8017bc0: 2210         	movs	r2, #0x10
 8017bc2: 601a         	str	r2, [r3]
; 		if ((flags & GPIO_SINGLE_ENDED) != 0) {
 8017bc4: 687b         	ldr	r3, [r7, #0x4]
 8017bc6: f003 0302    	and	r3, r3, #0x2
 8017bca: 2b00         	cmp	r3, #0x0
 8017bcc: d00e         	beq	0x8017bec <gpio_stm32_flags_to_conf+0x42> @ imm = #0x1c
; 			if (flags & GPIO_LINE_OPEN_DRAIN) {
 8017bce: 687b         	ldr	r3, [r7, #0x4]
 8017bd0: f003 0304    	and	r3, r3, #0x4
 8017bd4: 2b00         	cmp	r3, #0x0
 8017bd6: d006         	beq	0x8017be6 <gpio_stm32_flags_to_conf+0x3c> @ imm = #0xc
; 				*pincfg |= STM32_PINCFG_OPEN_DRAIN;
 8017bd8: 683b         	ldr	r3, [r7]
 8017bda: 681b         	ldr	r3, [r3]
 8017bdc: f043 0240    	orr	r2, r3, #0x40
 8017be0: 683b         	ldr	r3, [r7]
 8017be2: 601a         	str	r2, [r3]
 8017be4: e006         	b	0x8017bf4 <gpio_stm32_flags_to_conf+0x4a> @ imm = #0xc
; 				return -ENOTSUP;
 8017be6: f06f 0385    	mvn	r3, #0x85
 8017bea: e044         	b	0x8017c76 <gpio_stm32_flags_to_conf+0xcc> @ imm = #0x88
; 			*pincfg |= STM32_PINCFG_PUSH_PULL;
 8017bec: 683b         	ldr	r3, [r7]
 8017bee: 681a         	ldr	r2, [r3]
 8017bf0: 683b         	ldr	r3, [r7]
 8017bf2: 601a         	str	r2, [r3]
; 		if ((flags & GPIO_PULL_UP) != 0) {
 8017bf4: 687b         	ldr	r3, [r7, #0x4]
 8017bf6: f003 0310    	and	r3, r3, #0x10
 8017bfa: 2b00         	cmp	r3, #0x0
 8017bfc: d006         	beq	0x8017c0c <gpio_stm32_flags_to_conf+0x62> @ imm = #0xc
; 			*pincfg |= STM32_PINCFG_PULL_UP;
 8017bfe: 683b         	ldr	r3, [r7]
 8017c00: 681b         	ldr	r3, [r3]
 8017c02: f443 7200    	orr	r2, r3, #0x200
 8017c06: 683b         	ldr	r3, [r7]
 8017c08: 601a         	str	r2, [r3]
 8017c0a: e033         	b	0x8017c74 <gpio_stm32_flags_to_conf+0xca> @ imm = #0x66
; 		} else if ((flags & GPIO_PULL_DOWN) != 0) {
 8017c0c: 687b         	ldr	r3, [r7, #0x4]
 8017c0e: f003 0320    	and	r3, r3, #0x20
 8017c12: 2b00         	cmp	r3, #0x0
 8017c14: d02e         	beq	0x8017c74 <gpio_stm32_flags_to_conf+0xca> @ imm = #0x5c
; 			*pincfg |= STM32_PINCFG_PULL_DOWN;
 8017c16: 683b         	ldr	r3, [r7]
 8017c18: 681b         	ldr	r3, [r3]
 8017c1a: f443 6280    	orr	r2, r3, #0x400
 8017c1e: 683b         	ldr	r3, [r7]
 8017c20: 601a         	str	r2, [r3]
 8017c22: e027         	b	0x8017c74 <gpio_stm32_flags_to_conf+0xca> @ imm = #0x4e
; 	} else if  ((flags & GPIO_INPUT) != 0) {
 8017c24: 687b         	ldr	r3, [r7, #0x4]
 8017c26: f403 3380    	and	r3, r3, #0x10000
 8017c2a: 2b00         	cmp	r3, #0x0
 8017c2c: d01f         	beq	0x8017c6e <gpio_stm32_flags_to_conf+0xc4> @ imm = #0x3e
; 		*pincfg = STM32_PINCFG_MODE_INPUT;
 8017c2e: 683b         	ldr	r3, [r7]
 8017c30: 2200         	movs	r2, #0x0
 8017c32: 601a         	str	r2, [r3]
; 		if ((flags & GPIO_PULL_UP) != 0) {
 8017c34: 687b         	ldr	r3, [r7, #0x4]
 8017c36: f003 0310    	and	r3, r3, #0x10
 8017c3a: 2b00         	cmp	r3, #0x0
 8017c3c: d006         	beq	0x8017c4c <gpio_stm32_flags_to_conf+0xa2> @ imm = #0xc
; 			*pincfg |= STM32_PINCFG_PULL_UP;
 8017c3e: 683b         	ldr	r3, [r7]
 8017c40: 681b         	ldr	r3, [r3]
 8017c42: f443 7200    	orr	r2, r3, #0x200
 8017c46: 683b         	ldr	r3, [r7]
 8017c48: 601a         	str	r2, [r3]
 8017c4a: e013         	b	0x8017c74 <gpio_stm32_flags_to_conf+0xca> @ imm = #0x26
; 		} else if ((flags & GPIO_PULL_DOWN) != 0) {
 8017c4c: 687b         	ldr	r3, [r7, #0x4]
 8017c4e: f003 0320    	and	r3, r3, #0x20
 8017c52: 2b00         	cmp	r3, #0x0
 8017c54: d006         	beq	0x8017c64 <gpio_stm32_flags_to_conf+0xba> @ imm = #0xc
; 			*pincfg |= STM32_PINCFG_PULL_DOWN;
 8017c56: 683b         	ldr	r3, [r7]
 8017c58: 681b         	ldr	r3, [r3]
 8017c5a: f443 6280    	orr	r2, r3, #0x400
 8017c5e: 683b         	ldr	r3, [r7]
 8017c60: 601a         	str	r2, [r3]
 8017c62: e007         	b	0x8017c74 <gpio_stm32_flags_to_conf+0xca> @ imm = #0xe
; 			*pincfg |= STM32_PINCFG_FLOATING;
 8017c64: 683b         	ldr	r3, [r7]
 8017c66: 681a         	ldr	r2, [r3]
 8017c68: 683b         	ldr	r3, [r7]
 8017c6a: 601a         	str	r2, [r3]
 8017c6c: e002         	b	0x8017c74 <gpio_stm32_flags_to_conf+0xca> @ imm = #0x4
; 		*pincfg = STM32_PINCFG_MODE_ANALOG;
 8017c6e: 683b         	ldr	r3, [r7]
 8017c70: 2230         	movs	r2, #0x30
 8017c72: 601a         	str	r2, [r3]
; 	return 0;
 8017c74: 2300         	movs	r3, #0x0
; }
 8017c76: 4618         	mov	r0, r3
 8017c78: 370c         	adds	r7, #0xc
 8017c7a: 46bd         	mov	sp, r7
 8017c7c: bc80         	pop	{r7}
 8017c7e: 4770         	bx	lr

08017c80 <stm32_pinval_get>:
; {
 8017c80: b480         	push	{r7}
 8017c82: b085         	sub	sp, #0x14
 8017c84: af00         	add	r7, sp, #0x0
 8017c86: 4603         	mov	r3, r0
 8017c88: 71fb         	strb	r3, [r7, #0x7]
; 	pinval = 1 << pin;
 8017c8a: 79fb         	ldrb	r3, [r7, #0x7]
 8017c8c: 2201         	movs	r2, #0x1
 8017c8e: fa02 f303    	lsl.w	r3, r2, r3
 8017c92: 60fb         	str	r3, [r7, #0xc]
; 	return pinval;
 8017c94: 68fb         	ldr	r3, [r7, #0xc]
; }
 8017c96: 4618         	mov	r0, r3
 8017c98: 3714         	adds	r7, #0x14
 8017c9a: 46bd         	mov	sp, r7
 8017c9c: bc80         	pop	{r7}
 8017c9e: 4770         	bx	lr

08017ca0 <ll_gpio_set_pin_pull>:
; {
 8017ca0: b580         	push	{r7, lr}
 8017ca2: b084         	sub	sp, #0x10
 8017ca4: af00         	add	r7, sp, #0x0
 8017ca6: 60f8         	str	r0, [r7, #0xc]
 8017ca8: 60b9         	str	r1, [r7, #0x8]
 8017caa: 607a         	str	r2, [r7, #0x4]
; 	LL_GPIO_SetPinPull(GPIOx, Pin, Pull);
 8017cac: 687a         	ldr	r2, [r7, #0x4]
 8017cae: 68b9         	ldr	r1, [r7, #0x8]
 8017cb0: 68f8         	ldr	r0, [r7, #0xc]
 8017cb2: f7ff fd9b    	bl	0x80177ec <LL_GPIO_SetPinPull> @ imm = #-0x4ca
; }
 8017cb6: bf00         	nop
 8017cb8: 3710         	adds	r7, #0x10
 8017cba: 46bd         	mov	sp, r7
 8017cbc: bd80         	pop	{r7, pc}

08017cbe <gpio_stm32_disable_pin_irqs>:
; {
 8017cbe: b580         	push	{r7, lr}
 8017cc0: b084         	sub	sp, #0x10
 8017cc2: af00         	add	r7, sp, #0x0
 8017cc4: 6078         	str	r0, [r7, #0x4]
 8017cc6: 460b         	mov	r3, r1
 8017cc8: 70fb         	strb	r3, [r7, #0x3]
; 	if (port != stm32_exti_get_line_src_port(pin)) {
 8017cca: 78fb         	ldrb	r3, [r7, #0x3]
 8017ccc: 4618         	mov	r0, r3
 8017cce: f7fe f8e7    	bl	0x8015ea0 <stm32_exti_get_line_src_port> @ imm = #-0x1e32
 8017cd2: 4602         	mov	r2, r0
 8017cd4: 687b         	ldr	r3, [r7, #0x4]
 8017cd6: 4293         	cmp	r3, r2
 8017cd8: d110         	bne	0x8017cfc <gpio_stm32_disable_pin_irqs+0x3e> @ imm = #0x20
; 	stm32_gpio_irq_line_t irq_line = stm32_gpio_intc_get_pin_irq_line(port, pin);
 8017cda: 78fb         	ldrb	r3, [r7, #0x3]
 8017cdc: 4619         	mov	r1, r3
 8017cde: 6878         	ldr	r0, [r7, #0x4]
 8017ce0: f7fe f8a9    	bl	0x8015e36 <stm32_gpio_intc_get_pin_irq_line> @ imm = #-0x1eae
 8017ce4: 60f8         	str	r0, [r7, #0xc]
; 	stm32_gpio_intc_disable_line(irq_line);
 8017ce6: 68f8         	ldr	r0, [r7, #0xc]
 8017ce8: f7fe f8b4    	bl	0x8015e54 <stm32_gpio_intc_disable_line> @ imm = #-0x1e98
; 	stm32_gpio_intc_remove_irq_callback(irq_line);
 8017cec: 68f8         	ldr	r0, [r7, #0xc]
 8017cee: f7ee fcf7    	bl	0x80066e0 <stm32_gpio_intc_remove_irq_callback> @ imm = #-0x11612
; 	stm32_gpio_intc_select_line_trigger(irq_line, STM32_GPIO_IRQ_TRIG_NONE);
 8017cf2: 2100         	movs	r1, #0x0
 8017cf4: 68f8         	ldr	r0, [r7, #0xc]
 8017cf6: f7ee fc7b    	bl	0x80065f0 <stm32_gpio_intc_select_line_trigger> @ imm = #-0x1170a
 8017cfa: e000         	b	0x8017cfe <gpio_stm32_disable_pin_irqs+0x40> @ imm = #0x0
; 		return;
 8017cfc: bf00         	nop
; }
 8017cfe: 3710         	adds	r7, #0x10
 8017d00: 46bd         	mov	sp, r7
 8017d02: bd80         	pop	{r7, pc}

08017d04 <gpio_stm32_configure_raw>:
; {
 8017d04: b580         	push	{r7, lr}
 8017d06: b08c         	sub	sp, #0x30
 8017d08: af00         	add	r7, sp, #0x0
 8017d0a: 60f8         	str	r0, [r7, #0xc]
 8017d0c: 607a         	str	r2, [r7, #0x4]
 8017d0e: 603b         	str	r3, [r7]
 8017d10: 460b         	mov	r3, r1
 8017d12: 72fb         	strb	r3, [r7, #0xb]
; 	const struct gpio_stm32_config *cfg = dev->config;
 8017d14: 68fb         	ldr	r3, [r7, #0xc]
 8017d16: 685b         	ldr	r3, [r3, #0x4]
 8017d18: 62fb         	str	r3, [r7, #0x2c]
; 	GPIO_TypeDef *gpio = (GPIO_TypeDef *)cfg->base;
 8017d1a: 6afb         	ldr	r3, [r7, #0x2c]
 8017d1c: 685b         	ldr	r3, [r3, #0x4]
 8017d1e: 62bb         	str	r3, [r7, #0x28]
; 	uint32_t pin_ll = stm32_pinval_get(pin);
 8017d20: 7afb         	ldrb	r3, [r7, #0xb]
 8017d22: 4618         	mov	r0, r3
 8017d24: f7ff ffac    	bl	0x8017c80 <stm32_pinval_get> @ imm = #-0xa8
 8017d28: 6278         	str	r0, [r7, #0x24]
; 	mode = conf & (STM32_MODER_MASK << STM32_MODER_SHIFT);
 8017d2a: 687b         	ldr	r3, [r7, #0x4]
 8017d2c: f003 0330    	and	r3, r3, #0x30
 8017d30: 623b         	str	r3, [r7, #0x20]
; 	otype = conf & (STM32_OTYPER_MASK << STM32_OTYPER_SHIFT);
 8017d32: 687b         	ldr	r3, [r7, #0x4]
 8017d34: f003 0340    	and	r3, r3, #0x40
 8017d38: 61fb         	str	r3, [r7, #0x1c]
; 	ospeed = conf & (STM32_OSPEEDR_MASK << STM32_OSPEEDR_SHIFT);
 8017d3a: 687b         	ldr	r3, [r7, #0x4]
 8017d3c: f403 73c0    	and	r3, r3, #0x180
 8017d40: 61bb         	str	r3, [r7, #0x18]
; 	pupd = conf & (STM32_PUPDR_MASK << STM32_PUPDR_SHIFT);
 8017d42: 687b         	ldr	r3, [r7, #0x4]
 8017d44: f403 63c0    	and	r3, r3, #0x600
 8017d48: 617b         	str	r3, [r7, #0x14]
; 	z_stm32_hsem_lock(CFG_HW_GPIO_SEMID, HSEM_LOCK_DEFAULT_RETRY);
 8017d4a: f44f 1180    	mov.w	r1, #0x100000
 8017d4e: 2000         	movs	r0, #0x0
 8017d50: f7ff fe75    	bl	0x8017a3e <z_stm32_hsem_lock> @ imm = #-0x316
; 	LL_GPIO_SetPinOutputType(gpio, pin_ll, otype >> STM32_OTYPER_SHIFT);
 8017d54: 69fb         	ldr	r3, [r7, #0x1c]
 8017d56: 099b         	lsrs	r3, r3, #0x6
 8017d58: 461a         	mov	r2, r3
 8017d5a: 6a79         	ldr	r1, [r7, #0x24]
 8017d5c: 6ab8         	ldr	r0, [r7, #0x28]
 8017d5e: f7ff fcf2    	bl	0x8017746 <LL_GPIO_SetPinOutputType> @ imm = #-0x61c
; 	LL_GPIO_SetPinSpeed(gpio, pin_ll, ospeed >> STM32_OSPEEDR_SHIFT);
 8017d62: 69bb         	ldr	r3, [r7, #0x18]
 8017d64: 09db         	lsrs	r3, r3, #0x7
 8017d66: 461a         	mov	r2, r3
 8017d68: 6a79         	ldr	r1, [r7, #0x24]
 8017d6a: 6ab8         	ldr	r0, [r7, #0x28]
 8017d6c: f7ff fd02    	bl	0x8017774 <LL_GPIO_SetPinSpeed> @ imm = #-0x5fc
; 	ll_gpio_set_pin_pull(gpio, pin_ll, pupd >> STM32_PUPDR_SHIFT);
 8017d70: 697b         	ldr	r3, [r7, #0x14]
 8017d72: 0a5b         	lsrs	r3, r3, #0x9
 8017d74: 461a         	mov	r2, r3
 8017d76: 6a79         	ldr	r1, [r7, #0x24]
 8017d78: 6ab8         	ldr	r0, [r7, #0x28]
 8017d7a: f7ff ff91    	bl	0x8017ca0 <ll_gpio_set_pin_pull> @ imm = #-0xde
; 	if (mode == STM32_MODER_ALT_MODE) {
 8017d7e: 6a3b         	ldr	r3, [r7, #0x20]
 8017d80: 2b20         	cmp	r3, #0x20
 8017d82: d10d         	bne	0x8017da0 <gpio_stm32_configure_raw+0x9c> @ imm = #0x1a
; 		if (pin < 8) {
 8017d84: 7afb         	ldrb	r3, [r7, #0xb]
 8017d86: 2b07         	cmp	r3, #0x7
 8017d88: d805         	bhi	0x8017d96 <gpio_stm32_configure_raw+0x92> @ imm = #0xa
; 			LL_GPIO_SetAFPin_0_7(gpio, pin_ll, func);
 8017d8a: 683a         	ldr	r2, [r7]
 8017d8c: 6a79         	ldr	r1, [r7, #0x24]
 8017d8e: 6ab8         	ldr	r0, [r7, #0x28]
 8017d90: f7ff fd68    	bl	0x8017864 <LL_GPIO_SetAFPin_0_7> @ imm = #-0x530
 8017d94: e004         	b	0x8017da0 <gpio_stm32_configure_raw+0x9c> @ imm = #0x8
; 			LL_GPIO_SetAFPin_8_15(gpio, pin_ll, func);
 8017d96: 683a         	ldr	r2, [r7]
 8017d98: 6a79         	ldr	r1, [r7, #0x24]
 8017d9a: 6ab8         	ldr	r0, [r7, #0x28]
 8017d9c: f7ff fd9e    	bl	0x80178dc <LL_GPIO_SetAFPin_8_15> @ imm = #-0x4c4
; 	LL_GPIO_SetPinMode(gpio, pin_ll, mode >> STM32_MODER_SHIFT);
 8017da0: 6a3b         	ldr	r3, [r7, #0x20]
 8017da2: 091b         	lsrs	r3, r3, #0x4
 8017da4: 461a         	mov	r2, r3
 8017da6: 6a79         	ldr	r1, [r7, #0x24]
 8017da8: 6ab8         	ldr	r0, [r7, #0x28]
 8017daa: f7ff fc90    	bl	0x80176ce <LL_GPIO_SetPinMode> @ imm = #-0x6e0
; 	z_stm32_hsem_unlock(CFG_HW_GPIO_SEMID);
 8017dae: 2000         	movs	r0, #0x0
 8017db0: f7ff fe4f    	bl	0x8017a52 <z_stm32_hsem_unlock> @ imm = #-0x362
; }
 8017db4: bf00         	nop
 8017db6: 3730         	adds	r7, #0x30
 8017db8: 46bd         	mov	sp, r7
 8017dba: bd80         	pop	{r7, pc}

08017dbc <gpio_stm32_port_get_raw>:
; {
 8017dbc: b580         	push	{r7, lr}
 8017dbe: b084         	sub	sp, #0x10
 8017dc0: af00         	add	r7, sp, #0x0
 8017dc2: 6078         	str	r0, [r7, #0x4]
 8017dc4: 6039         	str	r1, [r7]
; 	const struct gpio_stm32_config *cfg = dev->config;
 8017dc6: 687b         	ldr	r3, [r7, #0x4]
 8017dc8: 685b         	ldr	r3, [r3, #0x4]
 8017dca: 60fb         	str	r3, [r7, #0xc]
; 	GPIO_TypeDef *gpio = (GPIO_TypeDef *)cfg->base;
 8017dcc: 68fb         	ldr	r3, [r7, #0xc]
 8017dce: 685b         	ldr	r3, [r3, #0x4]
 8017dd0: 60bb         	str	r3, [r7, #0x8]
; 	*value = LL_GPIO_ReadInputPort(gpio);
 8017dd2: 68b8         	ldr	r0, [r7, #0x8]
 8017dd4: f7ff fdc0    	bl	0x8017958 <LL_GPIO_ReadInputPort> @ imm = #-0x480
 8017dd8: 4602         	mov	r2, r0
 8017dda: 683b         	ldr	r3, [r7]
 8017ddc: 601a         	str	r2, [r3]
; 	return 0;
 8017dde: 2300         	movs	r3, #0x0
; }
 8017de0: 4618         	mov	r0, r3
 8017de2: 3710         	adds	r7, #0x10
 8017de4: 46bd         	mov	sp, r7
 8017de6: bd80         	pop	{r7, pc}

08017de8 <gpio_stm32_port_set_masked_raw>:
; {
 8017de8: b580         	push	{r7, lr}
 8017dea: b088         	sub	sp, #0x20
 8017dec: af00         	add	r7, sp, #0x0
 8017dee: 60f8         	str	r0, [r7, #0xc]
 8017df0: 60b9         	str	r1, [r7, #0x8]
 8017df2: 607a         	str	r2, [r7, #0x4]
; 	const struct gpio_stm32_config *cfg = dev->config;
 8017df4: 68fb         	ldr	r3, [r7, #0xc]
 8017df6: 685b         	ldr	r3, [r3, #0x4]
 8017df8: 61fb         	str	r3, [r7, #0x1c]
; 	GPIO_TypeDef *gpio = (GPIO_TypeDef *)cfg->base;
 8017dfa: 69fb         	ldr	r3, [r7, #0x1c]
 8017dfc: 685b         	ldr	r3, [r3, #0x4]
 8017dfe: 61bb         	str	r3, [r7, #0x18]
; 	z_stm32_hsem_lock(CFG_HW_GPIO_SEMID, HSEM_LOCK_DEFAULT_RETRY);
 8017e00: f44f 1180    	mov.w	r1, #0x100000
 8017e04: 2000         	movs	r0, #0x0
 8017e06: f7ff fe1a    	bl	0x8017a3e <z_stm32_hsem_lock> @ imm = #-0x3cc
; 	port_value = LL_GPIO_ReadOutputPort(gpio);
 8017e0a: 69b8         	ldr	r0, [r7, #0x18]
 8017e0c: f7ff fdbc    	bl	0x8017988 <LL_GPIO_ReadOutputPort> @ imm = #-0x488
 8017e10: 6178         	str	r0, [r7, #0x14]
; 	LL_GPIO_WriteOutputPort(gpio, (port_value & ~mask) | (mask & value));
 8017e12: 68bb         	ldr	r3, [r7, #0x8]
 8017e14: 43da         	mvns	r2, r3
 8017e16: 697b         	ldr	r3, [r7, #0x14]
 8017e18: 401a         	ands	r2, r3
 8017e1a: 68b9         	ldr	r1, [r7, #0x8]
 8017e1c: 687b         	ldr	r3, [r7, #0x4]
 8017e1e: 400b         	ands	r3, r1
 8017e20: 4313         	orrs	r3, r2
 8017e22: 4619         	mov	r1, r3
 8017e24: 69b8         	ldr	r0, [r7, #0x18]
 8017e26: f7ff fda2    	bl	0x801796e <LL_GPIO_WriteOutputPort> @ imm = #-0x4bc
; 	z_stm32_hsem_unlock(CFG_HW_GPIO_SEMID);
 8017e2a: 2000         	movs	r0, #0x0
 8017e2c: f7ff fe11    	bl	0x8017a52 <z_stm32_hsem_unlock> @ imm = #-0x3de
; 	return 0;
 8017e30: 2300         	movs	r3, #0x0
; }
 8017e32: 4618         	mov	r0, r3
 8017e34: 3720         	adds	r7, #0x20
 8017e36: 46bd         	mov	sp, r7
 8017e38: bd80         	pop	{r7, pc}

08017e3a <gpio_stm32_port_set_bits_raw>:
; {
 8017e3a: b480         	push	{r7}
 8017e3c: b085         	sub	sp, #0x14
 8017e3e: af00         	add	r7, sp, #0x0
 8017e40: 6078         	str	r0, [r7, #0x4]
 8017e42: 6039         	str	r1, [r7]
; 	const struct gpio_stm32_config *cfg = dev->config;
 8017e44: 687b         	ldr	r3, [r7, #0x4]
 8017e46: 685b         	ldr	r3, [r3, #0x4]
 8017e48: 60fb         	str	r3, [r7, #0xc]
; 	GPIO_TypeDef *gpio = (GPIO_TypeDef *)cfg->base;
 8017e4a: 68fb         	ldr	r3, [r7, #0xc]
 8017e4c: 685b         	ldr	r3, [r3, #0x4]
 8017e4e: 60bb         	str	r3, [r7, #0x8]
; 	WRITE_REG(gpio->BSRR, pins);
 8017e50: 68bb         	ldr	r3, [r7, #0x8]
 8017e52: 683a         	ldr	r2, [r7]
 8017e54: 619a         	str	r2, [r3, #0x18]
; 	return 0;
 8017e56: 2300         	movs	r3, #0x0
; }
 8017e58: 4618         	mov	r0, r3
 8017e5a: 3714         	adds	r7, #0x14
 8017e5c: 46bd         	mov	sp, r7
 8017e5e: bc80         	pop	{r7}
 8017e60: 4770         	bx	lr

08017e62 <gpio_stm32_port_clear_bits_raw>:
; {
 8017e62: b580         	push	{r7, lr}
 8017e64: b084         	sub	sp, #0x10
 8017e66: af00         	add	r7, sp, #0x0
 8017e68: 6078         	str	r0, [r7, #0x4]
 8017e6a: 6039         	str	r1, [r7]
; 	const struct gpio_stm32_config *cfg = dev->config;
 8017e6c: 687b         	ldr	r3, [r7, #0x4]
 8017e6e: 685b         	ldr	r3, [r3, #0x4]
 8017e70: 60fb         	str	r3, [r7, #0xc]
; 	GPIO_TypeDef *gpio = (GPIO_TypeDef *)cfg->base;
 8017e72: 68fb         	ldr	r3, [r7, #0xc]
 8017e74: 685b         	ldr	r3, [r3, #0x4]
 8017e76: 60bb         	str	r3, [r7, #0x8]
; 	LL_GPIO_ResetOutputPin(gpio, pins);
 8017e78: 6839         	ldr	r1, [r7]
 8017e7a: 68b8         	ldr	r0, [r7, #0x8]
 8017e7c: f7ff fd8f    	bl	0x801799e <LL_GPIO_ResetOutputPin> @ imm = #-0x4e2
; 	return 0;
 8017e80: 2300         	movs	r3, #0x0
; }
 8017e82: 4618         	mov	r0, r3
 8017e84: 3710         	adds	r7, #0x10
 8017e86: 46bd         	mov	sp, r7
 8017e88: bd80         	pop	{r7, pc}

08017e8a <gpio_stm32_port_toggle_bits>:
; {
 8017e8a: b580         	push	{r7, lr}
 8017e8c: b084         	sub	sp, #0x10
 8017e8e: af00         	add	r7, sp, #0x0
 8017e90: 6078         	str	r0, [r7, #0x4]
 8017e92: 6039         	str	r1, [r7]
; 	const struct gpio_stm32_config *cfg = dev->config;
 8017e94: 687b         	ldr	r3, [r7, #0x4]
 8017e96: 685b         	ldr	r3, [r3, #0x4]
 8017e98: 60fb         	str	r3, [r7, #0xc]
; 	GPIO_TypeDef *gpio = (GPIO_TypeDef *)cfg->base;
 8017e9a: 68fb         	ldr	r3, [r7, #0xc]
 8017e9c: 685b         	ldr	r3, [r3, #0x4]
 8017e9e: 60bb         	str	r3, [r7, #0x8]
; 	z_stm32_hsem_lock(CFG_HW_GPIO_SEMID, HSEM_LOCK_DEFAULT_RETRY);
 8017ea0: f44f 1180    	mov.w	r1, #0x100000
 8017ea4: 2000         	movs	r0, #0x0
 8017ea6: f7ff fdca    	bl	0x8017a3e <z_stm32_hsem_lock> @ imm = #-0x46c
; 	WRITE_REG(gpio->ODR, READ_REG(gpio->ODR) ^ pins);
 8017eaa: 68bb         	ldr	r3, [r7, #0x8]
 8017eac: 695a         	ldr	r2, [r3, #0x14]
 8017eae: 683b         	ldr	r3, [r7]
 8017eb0: 405a         	eors	r2, r3
 8017eb2: 68bb         	ldr	r3, [r7, #0x8]
 8017eb4: 615a         	str	r2, [r3, #0x14]
; 	z_stm32_hsem_unlock(CFG_HW_GPIO_SEMID);
 8017eb6: 2000         	movs	r0, #0x0
 8017eb8: f7ff fdcb    	bl	0x8017a52 <z_stm32_hsem_unlock> @ imm = #-0x46a
; 	return 0;
 8017ebc: 2300         	movs	r3, #0x0
; }
 8017ebe: 4618         	mov	r0, r3
 8017ec0: 3710         	adds	r7, #0x10
 8017ec2: 46bd         	mov	sp, r7
 8017ec4: bd80         	pop	{r7, pc}

08017ec6 <gpio_stm32_configure>:
; {
 8017ec6: b580         	push	{r7, lr}
 8017ec8: b086         	sub	sp, #0x18
 8017eca: af00         	add	r7, sp, #0x0
 8017ecc: 60f8         	str	r0, [r7, #0xc]
 8017ece: 607a         	str	r2, [r7, #0x4]
 8017ed0: 603b         	str	r3, [r7]
 8017ed2: 460b         	mov	r3, r1
 8017ed4: 72fb         	strb	r3, [r7, #0xb]
; 	ret = pm_device_runtime_get(dev);
 8017ed6: 68f8         	ldr	r0, [r7, #0xc]
 8017ed8: f7ff fd9d    	bl	0x8017a16 <pm_device_runtime_get> @ imm = #-0x4c6
 8017edc: 6178         	str	r0, [r7, #0x14]
; 	if (ret < 0) {
 8017ede: 697b         	ldr	r3, [r7, #0x14]
 8017ee0: 2b00         	cmp	r3, #0x0
 8017ee2: da01         	bge	0x8017ee8 <gpio_stm32_configure+0x22> @ imm = #0x2
; 		return ret;
 8017ee4: 697b         	ldr	r3, [r7, #0x14]
 8017ee6: e028         	b	0x8017f3a <gpio_stm32_configure+0x74> @ imm = #0x50
; 	gpio_stm32_configure_raw(dev, pin, conf, func);
 8017ee8: 7af9         	ldrb	r1, [r7, #0xb]
 8017eea: 683b         	ldr	r3, [r7]
 8017eec: 687a         	ldr	r2, [r7, #0x4]
 8017eee: 68f8         	ldr	r0, [r7, #0xc]
 8017ef0: f7ff ff08    	bl	0x8017d04 <gpio_stm32_configure_raw> @ imm = #-0x1f0
; 	if (func == IS_GPIO_OUT) {
 8017ef4: 683b         	ldr	r3, [r7]
 8017ef6: 2b11         	cmp	r3, #0x11
 8017ef8: d11b         	bne	0x8017f32 <gpio_stm32_configure+0x6c> @ imm = #0x36
; 		uint32_t gpio_out = conf & (STM32_ODR_MASK << STM32_ODR_SHIFT);
 8017efa: 687b         	ldr	r3, [r7, #0x4]
 8017efc: f403 6300    	and	r3, r3, #0x800
 8017f00: 613b         	str	r3, [r7, #0x10]
; 		if (gpio_out == STM32_ODR_1) {
 8017f02: 693b         	ldr	r3, [r7, #0x10]
 8017f04: f5b3 6f00    	cmp.w	r3, #0x800
 8017f08: d108         	bne	0x8017f1c <gpio_stm32_configure+0x56> @ imm = #0x10
; 			gpio_stm32_port_set_bits_raw(dev, BIT(pin));
 8017f0a: 7afb         	ldrb	r3, [r7, #0xb]
 8017f0c: 2201         	movs	r2, #0x1
 8017f0e: fa02 f303    	lsl.w	r3, r2, r3
 8017f12: 4619         	mov	r1, r3
 8017f14: 68f8         	ldr	r0, [r7, #0xc]
 8017f16: f7ff ff90    	bl	0x8017e3a <gpio_stm32_port_set_bits_raw> @ imm = #-0xe0
 8017f1a: e00a         	b	0x8017f32 <gpio_stm32_configure+0x6c> @ imm = #0x14
; 		} else if (gpio_out == STM32_ODR_0) {
 8017f1c: 693b         	ldr	r3, [r7, #0x10]
 8017f1e: 2b00         	cmp	r3, #0x0
 8017f20: d107         	bne	0x8017f32 <gpio_stm32_configure+0x6c> @ imm = #0xe
; 			gpio_stm32_port_clear_bits_raw(dev, BIT(pin));
 8017f22: 7afb         	ldrb	r3, [r7, #0xb]
 8017f24: 2201         	movs	r2, #0x1
 8017f26: fa02 f303    	lsl.w	r3, r2, r3
 8017f2a: 4619         	mov	r1, r3
 8017f2c: 68f8         	ldr	r0, [r7, #0xc]
 8017f2e: f7ff ff98    	bl	0x8017e62 <gpio_stm32_port_clear_bits_raw> @ imm = #-0xd0
; 	return pm_device_runtime_put(dev);
 8017f32: 68f8         	ldr	r0, [r7, #0xc]
 8017f34: f7ff fd79    	bl	0x8017a2a <pm_device_runtime_put> @ imm = #-0x50e
 8017f38: 4603         	mov	r3, r0
; }
 8017f3a: 4618         	mov	r0, r3
 8017f3c: 3718         	adds	r7, #0x18
 8017f3e: 46bd         	mov	sp, r7
 8017f40: bd80         	pop	{r7, pc}

08017f42 <gpio_stm32_config>:
; {
 8017f42: b580         	push	{r7, lr}
 8017f44: b088         	sub	sp, #0x20
 8017f46: af00         	add	r7, sp, #0x0
 8017f48: 60f8         	str	r0, [r7, #0xc]
 8017f4a: 460b         	mov	r3, r1
 8017f4c: 607a         	str	r2, [r7, #0x4]
 8017f4e: 72fb         	strb	r3, [r7, #0xb]
; 	struct gpio_stm32_data *data = dev->data;
 8017f50: 68fb         	ldr	r3, [r7, #0xc]
 8017f52: 691b         	ldr	r3, [r3, #0x10]
 8017f54: 61fb         	str	r3, [r7, #0x1c]
; 	err = gpio_stm32_flags_to_conf(flags, &pincfg);
 8017f56: f107 0314    	add.w	r3, r7, #0x14
 8017f5a: 4619         	mov	r1, r3
 8017f5c: 6878         	ldr	r0, [r7, #0x4]
 8017f5e: f7ff fe24    	bl	0x8017baa <gpio_stm32_flags_to_conf> @ imm = #-0x3b8
 8017f62: 61b8         	str	r0, [r7, #0x18]
; 	if (err != 0) {
 8017f64: 69bb         	ldr	r3, [r7, #0x18]
 8017f66: 2b00         	cmp	r3, #0x0
 8017f68: d001         	beq	0x8017f6e <gpio_stm32_config+0x2c> @ imm = #0x2
; 		return err;
 8017f6a: 69bb         	ldr	r3, [r7, #0x18]
 8017f6c: e071         	b	0x8018052 <gpio_stm32_config+0x110> @ imm = #0xe2
; 	if ((((flags & GPIO_OUTPUT) != 0) || ((flags & GPIO_INPUT) != 0)) &&
 8017f6e: 687b         	ldr	r3, [r7, #0x4]
 8017f70: f403 3300    	and	r3, r3, #0x20000
 8017f74: 2b00         	cmp	r3, #0x0
 8017f76: d104         	bne	0x8017f82 <gpio_stm32_config+0x40> @ imm = #0x8
 8017f78: 687b         	ldr	r3, [r7, #0x4]
 8017f7a: f403 3380    	and	r3, r3, #0x10000
 8017f7e: 2b00         	cmp	r3, #0x0
 8017f80: d01a         	beq	0x8017fb8 <gpio_stm32_config+0x76> @ imm = #0x34
; 	    !(data->pin_has_clock_enabled & BIT(pin))) {
 8017f82: 69fb         	ldr	r3, [r7, #0x1c]
 8017f84: 691a         	ldr	r2, [r3, #0x10]
 8017f86: 7afb         	ldrb	r3, [r7, #0xb]
 8017f88: fa22 f303    	lsr.w	r3, r2, r3
 8017f8c: f003 0301    	and	r3, r3, #0x1
; 	if ((((flags & GPIO_OUTPUT) != 0) || ((flags & GPIO_INPUT) != 0)) &&
 8017f90: 2b00         	cmp	r3, #0x0
 8017f92: d111         	bne	0x8017fb8 <gpio_stm32_config+0x76> @ imm = #0x22
; 		err = pm_device_runtime_get(dev);
 8017f94: 68f8         	ldr	r0, [r7, #0xc]
 8017f96: f7ff fd3e    	bl	0x8017a16 <pm_device_runtime_get> @ imm = #-0x584
 8017f9a: 61b8         	str	r0, [r7, #0x18]
; 		if (err < 0) {
 8017f9c: 69bb         	ldr	r3, [r7, #0x18]
 8017f9e: 2b00         	cmp	r3, #0x0
 8017fa0: da01         	bge	0x8017fa6 <gpio_stm32_config+0x64> @ imm = #0x2
; 			return err;
 8017fa2: 69bb         	ldr	r3, [r7, #0x18]
 8017fa4: e055         	b	0x8018052 <gpio_stm32_config+0x110> @ imm = #0xaa
; 		data->pin_has_clock_enabled |= BIT(pin);
 8017fa6: 69fb         	ldr	r3, [r7, #0x1c]
 8017fa8: 691a         	ldr	r2, [r3, #0x10]
 8017faa: 7afb         	ldrb	r3, [r7, #0xb]
 8017fac: 2101         	movs	r1, #0x1
 8017fae: fa01 f303    	lsl.w	r3, r1, r3
 8017fb2: 431a         	orrs	r2, r3
 8017fb4: 69fb         	ldr	r3, [r7, #0x1c]
 8017fb6: 611a         	str	r2, [r3, #0x10]
; 	if ((flags & GPIO_OUTPUT) != 0) {
 8017fb8: 687b         	ldr	r3, [r7, #0x4]
 8017fba: f403 3300    	and	r3, r3, #0x20000
 8017fbe: 2b00         	cmp	r3, #0x0
 8017fc0: d01a         	beq	0x8017ff8 <gpio_stm32_config+0xb6> @ imm = #0x34
; 		if ((flags & GPIO_OUTPUT_INIT_HIGH) != 0) {
 8017fc2: 687b         	ldr	r3, [r7, #0x4]
 8017fc4: f403 2300    	and	r3, r3, #0x80000
 8017fc8: 2b00         	cmp	r3, #0x0
 8017fca: d008         	beq	0x8017fde <gpio_stm32_config+0x9c> @ imm = #0x10
; 			gpio_stm32_port_set_bits_raw(dev, BIT(pin));
 8017fcc: 7afb         	ldrb	r3, [r7, #0xb]
 8017fce: 2201         	movs	r2, #0x1
 8017fd0: fa02 f303    	lsl.w	r3, r2, r3
 8017fd4: 4619         	mov	r1, r3
 8017fd6: 68f8         	ldr	r0, [r7, #0xc]
 8017fd8: f7ff ff2f    	bl	0x8017e3a <gpio_stm32_port_set_bits_raw> @ imm = #-0x1a2
 8017fdc: e00c         	b	0x8017ff8 <gpio_stm32_config+0xb6> @ imm = #0x18
; 		} else if ((flags & GPIO_OUTPUT_INIT_LOW) != 0) {
 8017fde: 687b         	ldr	r3, [r7, #0x4]
 8017fe0: f403 2380    	and	r3, r3, #0x40000
 8017fe4: 2b00         	cmp	r3, #0x0
 8017fe6: d007         	beq	0x8017ff8 <gpio_stm32_config+0xb6> @ imm = #0xe
; 			gpio_stm32_port_clear_bits_raw(dev, BIT(pin));
 8017fe8: 7afb         	ldrb	r3, [r7, #0xb]
 8017fea: 2201         	movs	r2, #0x1
 8017fec: fa02 f303    	lsl.w	r3, r2, r3
 8017ff0: 4619         	mov	r1, r3
 8017ff2: 68f8         	ldr	r0, [r7, #0xc]
 8017ff4: f7ff ff35    	bl	0x8017e62 <gpio_stm32_port_clear_bits_raw> @ imm = #-0x196
; 	gpio_stm32_configure_raw(dev, pin, pincfg, 0);
 8017ff8: 697a         	ldr	r2, [r7, #0x14]
 8017ffa: 7af9         	ldrb	r1, [r7, #0xb]
 8017ffc: 2300         	movs	r3, #0x0
 8017ffe: 68f8         	ldr	r0, [r7, #0xc]
 8018000: f7ff fe80    	bl	0x8017d04 <gpio_stm32_configure_raw> @ imm = #-0x300
; 	if (((flags & GPIO_OUTPUT) == 0) && ((flags & GPIO_INPUT) == 0) &&
 8018004: 687b         	ldr	r3, [r7, #0x4]
 8018006: f403 3300    	and	r3, r3, #0x20000
 801800a: 2b00         	cmp	r3, #0x0
 801800c: d120         	bne	0x8018050 <gpio_stm32_config+0x10e> @ imm = #0x40
 801800e: 687b         	ldr	r3, [r7, #0x4]
 8018010: f403 3380    	and	r3, r3, #0x10000
 8018014: 2b00         	cmp	r3, #0x0
 8018016: d11b         	bne	0x8018050 <gpio_stm32_config+0x10e> @ imm = #0x36
; 	    (data->pin_has_clock_enabled & BIT(pin))) {
 8018018: 69fb         	ldr	r3, [r7, #0x1c]
 801801a: 691a         	ldr	r2, [r3, #0x10]
; 	if (((flags & GPIO_OUTPUT) == 0) && ((flags & GPIO_INPUT) == 0) &&
 801801c: 7afb         	ldrb	r3, [r7, #0xb]
 801801e: fa22 f303    	lsr.w	r3, r2, r3
 8018022: f003 0301    	and	r3, r3, #0x1
 8018026: 2b00         	cmp	r3, #0x0
 8018028: d012         	beq	0x8018050 <gpio_stm32_config+0x10e> @ imm = #0x24
; 		err = pm_device_runtime_put(dev);
 801802a: 68f8         	ldr	r0, [r7, #0xc]
 801802c: f7ff fcfd    	bl	0x8017a2a <pm_device_runtime_put> @ imm = #-0x606
 8018030: 61b8         	str	r0, [r7, #0x18]
; 		if (err < 0) {
 8018032: 69bb         	ldr	r3, [r7, #0x18]
 8018034: 2b00         	cmp	r3, #0x0
 8018036: da01         	bge	0x801803c <gpio_stm32_config+0xfa> @ imm = #0x2
; 			return err;
 8018038: 69bb         	ldr	r3, [r7, #0x18]
 801803a: e00a         	b	0x8018052 <gpio_stm32_config+0x110> @ imm = #0x14
; 		data->pin_has_clock_enabled &= ~BIT(pin);
 801803c: 69fb         	ldr	r3, [r7, #0x1c]
 801803e: 691a         	ldr	r2, [r3, #0x10]
 8018040: 7afb         	ldrb	r3, [r7, #0xb]
 8018042: 2101         	movs	r1, #0x1
 8018044: fa01 f303    	lsl.w	r3, r1, r3
 8018048: 43db         	mvns	r3, r3
 801804a: 401a         	ands	r2, r3
 801804c: 69fb         	ldr	r3, [r7, #0x1c]
 801804e: 611a         	str	r2, [r3, #0x10]
; 	return 0;
 8018050: 2300         	movs	r3, #0x0
; }
 8018052: 4618         	mov	r0, r3
 8018054: 3720         	adds	r7, #0x20
 8018056: 46bd         	mov	sp, r7
 8018058: bd80         	pop	{r7, pc}

0801805a <gpio_stm32_manage_callback>:
; {
 801805a: b580         	push	{r7, lr}
 801805c: b086         	sub	sp, #0x18
 801805e: af00         	add	r7, sp, #0x0
 8018060: 60f8         	str	r0, [r7, #0xc]
 8018062: 60b9         	str	r1, [r7, #0x8]
 8018064: 4613         	mov	r3, r2
 8018066: 71fb         	strb	r3, [r7, #0x7]
; 	struct gpio_stm32_data *data = dev->data;
 8018068: 68fb         	ldr	r3, [r7, #0xc]
 801806a: 691b         	ldr	r3, [r3, #0x10]
 801806c: 617b         	str	r3, [r7, #0x14]
; 	return gpio_manage_callback(&data->cb, callback, set);
 801806e: 697b         	ldr	r3, [r7, #0x14]
 8018070: 3308         	adds	r3, #0x8
 8018072: 79fa         	ldrb	r2, [r7, #0x7]
 8018074: 68b9         	ldr	r1, [r7, #0x8]
 8018076: 4618         	mov	r0, r3
 8018078: f7ff fcf4    	bl	0x8017a64 <gpio_manage_callback> @ imm = #-0x618
 801807c: 4603         	mov	r3, r0
; }
 801807e: 4618         	mov	r0, r3
 8018080: 3718         	adds	r7, #0x18
 8018082: 46bd         	mov	sp, r7
 8018084: bd80         	pop	{r7, pc}

08018086 <pinctrl_lookup_state>:
; {
 8018086: b480         	push	{r7}
 8018088: b085         	sub	sp, #0x14
 801808a: af00         	add	r7, sp, #0x0
 801808c: 60f8         	str	r0, [r7, #0xc]
 801808e: 460b         	mov	r3, r1
 8018090: 607a         	str	r2, [r7, #0x4]
 8018092: 72fb         	strb	r3, [r7, #0xb]
; 	*state = &config->states[0];
 8018094: 68fb         	ldr	r3, [r7, #0xc]
 8018096: 681a         	ldr	r2, [r3]
 8018098: 687b         	ldr	r3, [r7, #0x4]
 801809a: 601a         	str	r2, [r3]
; 	while (*state < &config->states[config->state_cnt]) {
 801809c: e00d         	b	0x80180ba <pinctrl_lookup_state+0x34> @ imm = #0x1a
; 		if (id == (*state)->id) {
 801809e: 687b         	ldr	r3, [r7, #0x4]
 80180a0: 681b         	ldr	r3, [r3]
 80180a2: 795b         	ldrb	r3, [r3, #0x5]
 80180a4: 7afa         	ldrb	r2, [r7, #0xb]
 80180a6: 429a         	cmp	r2, r3
 80180a8: d101         	bne	0x80180ae <pinctrl_lookup_state+0x28> @ imm = #0x2
; 			return 0;
 80180aa: 2300         	movs	r3, #0x0
 80180ac: e011         	b	0x80180d2 <pinctrl_lookup_state+0x4c> @ imm = #0x22
; 		(*state)++;
 80180ae: 687b         	ldr	r3, [r7, #0x4]
 80180b0: 681b         	ldr	r3, [r3]
 80180b2: f103 0208    	add.w	r2, r3, #0x8
 80180b6: 687b         	ldr	r3, [r7, #0x4]
 80180b8: 601a         	str	r2, [r3]
; 	while (*state < &config->states[config->state_cnt]) {
 80180ba: 687b         	ldr	r3, [r7, #0x4]
 80180bc: 681a         	ldr	r2, [r3]
 80180be: 68fb         	ldr	r3, [r7, #0xc]
 80180c0: 6819         	ldr	r1, [r3]
 80180c2: 68fb         	ldr	r3, [r7, #0xc]
 80180c4: 791b         	ldrb	r3, [r3, #0x4]
 80180c6: 00db         	lsls	r3, r3, #0x3
 80180c8: 440b         	add	r3, r1
 80180ca: 429a         	cmp	r2, r3
 80180cc: d3e7         	blo	0x801809e <pinctrl_lookup_state+0x18> @ imm = #-0x32
; 	return -ENOENT;
 80180ce: f06f 0301    	mvn	r3, #0x1
; }
 80180d2: 4618         	mov	r0, r3
 80180d4: 3714         	adds	r7, #0x14
 80180d6: 46bd         	mov	sp, r7
 80180d8: bc80         	pop	{r7}
 80180da: 4770         	bx	lr

080180dc <device_is_ready>:
; {
 80180dc: b580         	push	{r7, lr}
 80180de: b082         	sub	sp, #0x8
 80180e0: af00         	add	r7, sp, #0x0
 80180e2: 6078         	str	r0, [r7, #0x4]
; 	return z_impl_device_is_ready(dev);
 80180e4: 6878         	ldr	r0, [r7, #0x4]
 80180e6: f003 fd4a    	bl	0x801bb7e <z_impl_device_is_ready> @ imm = #0x3a94
 80180ea: 4603         	mov	r3, r0
; }
 80180ec: 4618         	mov	r0, r3
 80180ee: 3708         	adds	r7, #0x8
 80180f0: 46bd         	mov	sp, r7
 80180f2: bd80         	pop	{r7, pc}

080180f4 <pinctrl_configure_pins>:
; {
 80180f4: b580         	push	{r7, lr}
 80180f6: b08a         	sub	sp, #0x28
 80180f8: af00         	add	r7, sp, #0x0
 80180fa: 60f8         	str	r0, [r7, #0xc]
 80180fc: 460b         	mov	r3, r1
 80180fe: 607a         	str	r2, [r7, #0x4]
 8018100: 72fb         	strb	r3, [r7, #0xb]
; 	uint32_t pin_cgf = 0;
 8018102: 2300         	movs	r3, #0x0
 8018104: 627b         	str	r3, [r7, #0x24]
; 	int ret = 0;
 8018106: 2300         	movs	r3, #0x0
 8018108: 61fb         	str	r3, [r7, #0x1c]
; 	for (uint8_t i = 0U; i < pin_cnt; i++) {
 801810a: 2300         	movs	r3, #0x0
 801810c: f887 3023    	strb.w	r3, [r7, #0x23]
 8018110: e047         	b	0x80181a2 <pinctrl_configure_pins+0xae> @ imm = #0x8e
; 		mux = pins[i].pinmux;
 8018112: f897 3023    	ldrb.w	r3, [r7, #0x23]
 8018116: 00db         	lsls	r3, r3, #0x3
 8018118: 68fa         	ldr	r2, [r7, #0xc]
 801811a: 4413         	add	r3, r2
 801811c: 681b         	ldr	r3, [r3]
 801811e: 61bb         	str	r3, [r7, #0x18]
; 		if (STM32_DT_PINMUX_FUNC(mux) < STM32_ANALOG) {
 8018120: 69bb         	ldr	r3, [r7, #0x18]
 8018122: f003 0310    	and	r3, r3, #0x10
 8018126: 2b00         	cmp	r3, #0x0
 8018128: d109         	bne	0x801813e <pinctrl_configure_pins+0x4a> @ imm = #0x12
; 			pin_cgf = pins[i].pincfg | STM32_MODER_ALT_MODE;
 801812a: f897 3023    	ldrb.w	r3, [r7, #0x23]
 801812e: 00db         	lsls	r3, r3, #0x3
 8018130: 68fa         	ldr	r2, [r7, #0xc]
 8018132: 4413         	add	r3, r2
 8018134: 685b         	ldr	r3, [r3, #0x4]
 8018136: f043 0320    	orr	r3, r3, #0x20
 801813a: 627b         	str	r3, [r7, #0x24]
 801813c: e013         	b	0x8018166 <pinctrl_configure_pins+0x72> @ imm = #0x26
; 		} else if (STM32_DT_PINMUX_FUNC(mux) == STM32_ANALOG) {
 801813e: 69bb         	ldr	r3, [r7, #0x18]
 8018140: f003 031f    	and	r3, r3, #0x1f
 8018144: 2b10         	cmp	r3, #0x10
 8018146: d102         	bne	0x801814e <pinctrl_configure_pins+0x5a> @ imm = #0x4
; 			pin_cgf = STM32_MODER_ANALOG_MODE;
 8018148: 2330         	movs	r3, #0x30
 801814a: 627b         	str	r3, [r7, #0x24]
 801814c: e00b         	b	0x8018166 <pinctrl_configure_pins+0x72> @ imm = #0x16
; 		} else if (STM32_DT_PINMUX_FUNC(mux) == STM32_GPIO) {
 801814e: 69bb         	ldr	r3, [r7, #0x18]
 8018150: f003 031f    	and	r3, r3, #0x1f
 8018154: 2b11         	cmp	r3, #0x11
 8018156: d106         	bne	0x8018166 <pinctrl_configure_pins+0x72> @ imm = #0xc
; 			pin_cgf = pins[i].pincfg;
 8018158: f897 3023    	ldrb.w	r3, [r7, #0x23]
 801815c: 00db         	lsls	r3, r3, #0x3
 801815e: 68fa         	ldr	r2, [r7, #0xc]
 8018160: 4413         	add	r3, r2
 8018162: 685b         	ldr	r3, [r3, #0x4]
 8018164: 627b         	str	r3, [r7, #0x24]
; 		pin = STM32PIN(STM32_DT_PINMUX_PORT(mux),
 8018166: 69bb         	ldr	r3, [r7, #0x18]
 8018168: 0a5b         	lsrs	r3, r3, #0x9
 801816a: 011b         	lsls	r3, r3, #0x4
 801816c: f403 72f8    	and	r2, r3, #0x1f0
 8018170: 69bb         	ldr	r3, [r7, #0x18]
 8018172: 095b         	lsrs	r3, r3, #0x5
 8018174: f003 030f    	and	r3, r3, #0xf
 8018178: 4313         	orrs	r3, r2
 801817a: 617b         	str	r3, [r7, #0x14]
; 		ret = stm32_pin_configure(pin, pin_cgf, STM32_DT_PINMUX_FUNC(mux));
 801817c: 69bb         	ldr	r3, [r7, #0x18]
 801817e: f003 031f    	and	r3, r3, #0x1f
 8018182: 461a         	mov	r2, r3
 8018184: 6a79         	ldr	r1, [r7, #0x24]
 8018186: 6978         	ldr	r0, [r7, #0x14]
 8018188: f7f0 fa46    	bl	0x8008618 <stm32_pin_configure> @ imm = #-0xfb74
 801818c: 61f8         	str	r0, [r7, #0x1c]
; 		if (ret < 0) {
 801818e: 69fb         	ldr	r3, [r7, #0x1c]
 8018190: 2b00         	cmp	r3, #0x0
 8018192: da01         	bge	0x8018198 <pinctrl_configure_pins+0xa4> @ imm = #0x2
; 			return ret;
 8018194: 69fb         	ldr	r3, [r7, #0x1c]
 8018196: e00a         	b	0x80181ae <pinctrl_configure_pins+0xba> @ imm = #0x14
; 	for (uint8_t i = 0U; i < pin_cnt; i++) {
 8018198: f897 3023    	ldrb.w	r3, [r7, #0x23]
 801819c: 3301         	adds	r3, #0x1
 801819e: f887 3023    	strb.w	r3, [r7, #0x23]
 80181a2: f897 2023    	ldrb.w	r2, [r7, #0x23]
 80181a6: 7afb         	ldrb	r3, [r7, #0xb]
 80181a8: 429a         	cmp	r2, r3
 80181aa: d3b2         	blo	0x8018112 <pinctrl_configure_pins+0x1e> @ imm = #-0x9c
; 	return 0;
 80181ac: 2300         	movs	r3, #0x0
; }
 80181ae: 4618         	mov	r0, r3
 80181b0: 3728         	adds	r7, #0x28
 80181b2: 46bd         	mov	sp, r7
 80181b4: bd80         	pop	{r7, pc}

080181b6 <reset_stm32_status>:
; {
 80181b6: b480         	push	{r7}
 80181b8: b089         	sub	sp, #0x24
 80181ba: af00         	add	r7, sp, #0x0
 80181bc: 60f8         	str	r0, [r7, #0xc]
 80181be: 60b9         	str	r1, [r7, #0x8]
 80181c0: 607a         	str	r2, [r7, #0x4]
; 	const struct reset_stm32_config *config = dev->config;
 80181c2: 68fb         	ldr	r3, [r7, #0xc]
 80181c4: 685b         	ldr	r3, [r3, #0x4]
 80181c6: 61fb         	str	r3, [r7, #0x1c]
; 	*status = !!sys_test_bit(config->base + STM32_RESET_SET_OFFSET(id),
 80181c8: 69fb         	ldr	r3, [r7, #0x1c]
 80181ca: 681a         	ldr	r2, [r3]
 80181cc: 68bb         	ldr	r3, [r7, #0x8]
 80181ce: 095b         	lsrs	r3, r3, #0x5
 80181d0: f3c3 030b    	ubfx	r3, r3, #0x0, #0xc
 80181d4: 441a         	add	r2, r3
 80181d6: 68bb         	ldr	r3, [r7, #0x8]
 80181d8: f003 031f    	and	r3, r3, #0x1f
 80181dc: 61ba         	str	r2, [r7, #0x18]
 80181de: 617b         	str	r3, [r7, #0x14]
; 	uint32_t temp = *(volatile uint32_t *)addr;
 80181e0: 69bb         	ldr	r3, [r7, #0x18]
 80181e2: 681b         	ldr	r3, [r3]
 80181e4: 613b         	str	r3, [r7, #0x10]
; 	return temp & (1 << bit);
 80181e6: 2201         	movs	r2, #0x1
 80181e8: 697b         	ldr	r3, [r7, #0x14]
 80181ea: fa02 f303    	lsl.w	r3, r2, r3
 80181ee: 461a         	mov	r2, r3
 80181f0: 693b         	ldr	r3, [r7, #0x10]
 80181f2: 4013         	ands	r3, r2
; 	*status = !!sys_test_bit(config->base + STM32_RESET_SET_OFFSET(id),
 80181f4: 2b00         	cmp	r3, #0x0
 80181f6: bf14         	ite	ne
 80181f8: 2301         	movne	r3, #0x1
 80181fa: 2300         	moveq	r3, #0x0
 80181fc: b2db         	uxtb	r3, r3
 80181fe: 461a         	mov	r2, r3
 8018200: 687b         	ldr	r3, [r7, #0x4]
 8018202: 701a         	strb	r2, [r3]
; 	return 0;
 8018204: 2300         	movs	r3, #0x0
; }
 8018206: 4618         	mov	r0, r3
 8018208: 3724         	adds	r7, #0x24
 801820a: 46bd         	mov	sp, r7
 801820c: bc80         	pop	{r7}
 801820e: 4770         	bx	lr

08018210 <reset_stm32_line_assert>:
; {
 8018210: b480         	push	{r7}
 8018212: b087         	sub	sp, #0x1c
 8018214: af00         	add	r7, sp, #0x0
 8018216: 6078         	str	r0, [r7, #0x4]
 8018218: 6039         	str	r1, [r7]
; 	const struct reset_stm32_config *config = dev->config;
 801821a: 687b         	ldr	r3, [r7, #0x4]
 801821c: 685b         	ldr	r3, [r3, #0x4]
 801821e: 617b         	str	r3, [r7, #0x14]
; 	sys_set_bit(config->base + STM32_RESET_SET_OFFSET(id),
 8018220: 697b         	ldr	r3, [r7, #0x14]
 8018222: 681a         	ldr	r2, [r3]
 8018224: 683b         	ldr	r3, [r7]
 8018226: 095b         	lsrs	r3, r3, #0x5
 8018228: f3c3 030b    	ubfx	r3, r3, #0x0, #0xc
 801822c: 441a         	add	r2, r3
 801822e: 683b         	ldr	r3, [r7]
 8018230: f003 031f    	and	r3, r3, #0x1f
 8018234: 613a         	str	r2, [r7, #0x10]
 8018236: 60fb         	str	r3, [r7, #0xc]
; 	uint32_t temp = *(volatile uint32_t *)addr;
 8018238: 693b         	ldr	r3, [r7, #0x10]
 801823a: 681b         	ldr	r3, [r3]
 801823c: 60bb         	str	r3, [r7, #0x8]
; 	*(volatile uint32_t *)addr = temp | (1 << bit);
 801823e: 2201         	movs	r2, #0x1
 8018240: 68fb         	ldr	r3, [r7, #0xc]
 8018242: fa02 f303    	lsl.w	r3, r2, r3
 8018246: 4619         	mov	r1, r3
 8018248: 693b         	ldr	r3, [r7, #0x10]
 801824a: 68ba         	ldr	r2, [r7, #0x8]
 801824c: 430a         	orrs	r2, r1
 801824e: 601a         	str	r2, [r3]
; }
 8018250: bf00         	nop
; 	return 0;
 8018252: 2300         	movs	r3, #0x0
; }
 8018254: 4618         	mov	r0, r3
 8018256: 371c         	adds	r7, #0x1c
 8018258: 46bd         	mov	sp, r7
 801825a: bc80         	pop	{r7}
 801825c: 4770         	bx	lr

0801825e <reset_stm32_line_deassert>:
; {
 801825e: b480         	push	{r7}
 8018260: b087         	sub	sp, #0x1c
 8018262: af00         	add	r7, sp, #0x0
 8018264: 6078         	str	r0, [r7, #0x4]
 8018266: 6039         	str	r1, [r7]
; 	const struct reset_stm32_config *config = dev->config;
 8018268: 687b         	ldr	r3, [r7, #0x4]
 801826a: 685b         	ldr	r3, [r3, #0x4]
 801826c: 617b         	str	r3, [r7, #0x14]
; 	sys_clear_bit(config->base + STM32_RESET_SET_OFFSET(id),
 801826e: 697b         	ldr	r3, [r7, #0x14]
 8018270: 681a         	ldr	r2, [r3]
 8018272: 683b         	ldr	r3, [r7]
 8018274: 095b         	lsrs	r3, r3, #0x5
 8018276: f3c3 030b    	ubfx	r3, r3, #0x0, #0xc
 801827a: 441a         	add	r2, r3
 801827c: 683b         	ldr	r3, [r7]
 801827e: f003 031f    	and	r3, r3, #0x1f
 8018282: 613a         	str	r2, [r7, #0x10]
 8018284: 60fb         	str	r3, [r7, #0xc]
; 	uint32_t temp = *(volatile uint32_t *)addr;
 8018286: 693b         	ldr	r3, [r7, #0x10]
 8018288: 681b         	ldr	r3, [r3]
 801828a: 60bb         	str	r3, [r7, #0x8]
; 	*(volatile uint32_t *)addr = temp & ~(1 << bit);
 801828c: 2201         	movs	r2, #0x1
 801828e: 68fb         	ldr	r3, [r7, #0xc]
 8018290: fa02 f303    	lsl.w	r3, r2, r3
 8018294: 43db         	mvns	r3, r3
 8018296: 4619         	mov	r1, r3
 8018298: 693b         	ldr	r3, [r7, #0x10]
 801829a: 68ba         	ldr	r2, [r7, #0x8]
 801829c: 400a         	ands	r2, r1
 801829e: 601a         	str	r2, [r3]
; }
 80182a0: bf00         	nop
; 	return 0;
 80182a2: 2300         	movs	r3, #0x0
; }
 80182a4: 4618         	mov	r0, r3
 80182a6: 371c         	adds	r7, #0x1c
 80182a8: 46bd         	mov	sp, r7
 80182aa: bc80         	pop	{r7}
 80182ac: 4770         	bx	lr

080182ae <reset_stm32_line_toggle>:
; {
 80182ae: b580         	push	{r7, lr}
 80182b0: b082         	sub	sp, #0x8
 80182b2: af00         	add	r7, sp, #0x0
 80182b4: 6078         	str	r0, [r7, #0x4]
 80182b6: 6039         	str	r1, [r7]
; 	reset_stm32_line_assert(dev, id);
 80182b8: 6839         	ldr	r1, [r7]
 80182ba: 6878         	ldr	r0, [r7, #0x4]
 80182bc: f7ff ffa8    	bl	0x8018210 <reset_stm32_line_assert> @ imm = #-0xb0
; 	reset_stm32_line_deassert(dev, id);
 80182c0: 6839         	ldr	r1, [r7]
 80182c2: 6878         	ldr	r0, [r7, #0x4]
 80182c4: f7ff ffcb    	bl	0x801825e <reset_stm32_line_deassert> @ imm = #-0x6a
; 	return 0;
 80182c8: 2300         	movs	r3, #0x0
; }
 80182ca: 4618         	mov	r0, r3
 80182cc: 3708         	adds	r7, #0x8
 80182ce: 46bd         	mov	sp, r7
 80182d0: bd80         	pop	{r7, pc}

080182d2 <device_is_ready>:
; {
 80182d2: b580         	push	{r7, lr}
 80182d4: b082         	sub	sp, #0x8
 80182d6: af00         	add	r7, sp, #0x0
 80182d8: 6078         	str	r0, [r7, #0x4]
; 	return z_impl_device_is_ready(dev);
 80182da: 6878         	ldr	r0, [r7, #0x4]
 80182dc: f003 fc4f    	bl	0x801bb7e <z_impl_device_is_ready> @ imm = #0x389e
 80182e0: 4603         	mov	r3, r0
; }
 80182e2: 4618         	mov	r0, r3
 80182e4: 3708         	adds	r7, #0x8
 80182e6: 46bd         	mov	sp, r7
 80182e8: bd80         	pop	{r7, pc}

080182ea <k_msleep>:
; {
 80182ea: e92d 4fb0    	push.w	{r4, r5, r7, r8, r9, r10, r11, lr}
 80182ee: b082         	sub	sp, #0x8
 80182f0: af00         	add	r7, sp, #0x0
 80182f2: 6078         	str	r0, [r7, #0x4]
; 	return k_sleep(Z_TIMEOUT_MS(ms));
 80182f4: 6879         	ldr	r1, [r7, #0x4]
 80182f6: ea21 71e1    	bic.w	r1, r1, r1, asr #31
 80182fa: 17c8         	asrs	r0, r1, #0x1f
 80182fc: 4688         	mov	r8, r1
 80182fe: 4681         	mov	r9, r0
 8018300: 4640         	mov	r0, r8
 8018302: 4649         	mov	r1, r9
 8018304: f04f 0400    	mov.w	r4, #0x0
 8018308: f04f 0500    	mov.w	r5, #0x0
 801830c: 008d         	lsls	r5, r1, #0x2
 801830e: ea45 7590    	orr.w	r5, r5, r0, lsr #30
 8018312: 0084         	lsls	r4, r0, #0x2
 8018314: 4620         	mov	r0, r4
 8018316: 4629         	mov	r1, r5
 8018318: eb10 0208    	adds.w	r2, r0, r8
 801831c: eb41 0309    	adc.w	r3, r1, r9
 8018320: eb12 0a02    	adds.w	r10, r2, r2
 8018324: eb43 0b03    	adc.w	r11, r3, r3
 8018328: 4652         	mov	r2, r10
 801832a: 465b         	mov	r3, r11
 801832c: 4610         	mov	r0, r2
 801832e: 4619         	mov	r1, r3
 8018330: f000 f807    	bl	0x8018342 <k_sleep>     @ imm = #0xe
 8018334: 4601         	mov	r1, r0
 8018336: 460b         	mov	r3, r1
; }
 8018338: 4618         	mov	r0, r3
 801833a: 3708         	adds	r7, #0x8
 801833c: 46bd         	mov	sp, r7
 801833e: e8bd 8fb0    	pop.w	{r4, r5, r7, r8, r9, r10, r11, pc}

08018342 <k_sleep>:
; {
 8018342: b580         	push	{r7, lr}
 8018344: b082         	sub	sp, #0x8
 8018346: af00         	add	r7, sp, #0x0
 8018348: e9c7 0100    	strd	r0, r1, [r7]
; 	return z_impl_k_sleep(timeout);
 801834c: e9d7 0100    	ldrd	r0, r1, [r7]
 8018350: f7f8 f854    	bl	0x80103fc <z_impl_k_sleep> @ imm = #-0x7f58
 8018354: 4603         	mov	r3, r0
; }
 8018356: 4618         	mov	r0, r3
 8018358: 3708         	adds	r7, #0x8
 801835a: 46bd         	mov	sp, r7
 801835c: bd80         	pop	{r7, pc}

0801835e <k_usleep>:
; {
 801835e: b580         	push	{r7, lr}
 8018360: b082         	sub	sp, #0x8
 8018362: af00         	add	r7, sp, #0x0
 8018364: 6078         	str	r0, [r7, #0x4]
; 	return z_impl_k_usleep(us);
 8018366: 6878         	ldr	r0, [r7, #0x4]
 8018368: f005 f813    	bl	0x801d392 <z_impl_k_usleep> @ imm = #0x5026
 801836c: 4603         	mov	r3, r0
; }
 801836e: 4618         	mov	r0, r3
 8018370: 3708         	adds	r7, #0x8
 8018372: 46bd         	mov	sp, r7
 8018374: bd80         	pop	{r7, pc}

08018376 <pm_device_busy_set>:
; {
 8018376: b480         	push	{r7}
 8018378: b083         	sub	sp, #0xc
 801837a: af00         	add	r7, sp, #0x0
 801837c: 6078         	str	r0, [r7, #0x4]
; }
 801837e: bf00         	nop
 8018380: 370c         	adds	r7, #0xc
 8018382: 46bd         	mov	sp, r7
 8018384: bc80         	pop	{r7}
 8018386: 4770         	bx	lr

08018388 <pm_device_busy_clear>:
; {
 8018388: b480         	push	{r7}
 801838a: b083         	sub	sp, #0xc
 801838c: af00         	add	r7, sp, #0x0
 801838e: 6078         	str	r0, [r7, #0x4]
; }
 8018390: bf00         	nop
 8018392: 370c         	adds	r7, #0xc
 8018394: 46bd         	mov	sp, r7
 8018396: bc80         	pop	{r7}
 8018398: 4770         	bx	lr

0801839a <z_log_msg_runtime_create>:
; {
 801839a: b580         	push	{r7, lr}
 801839c: b08a         	sub	sp, #0x28
 801839e: af04         	add	r7, sp, #0x10
 80183a0: 60b9         	str	r1, [r7, #0x8]
 80183a2: 607b         	str	r3, [r7, #0x4]
 80183a4: 4603         	mov	r3, r0
 80183a6: 73fb         	strb	r3, [r7, #0xf]
 80183a8: 4613         	mov	r3, r2
 80183aa: 73bb         	strb	r3, [r7, #0xe]
; 	va_start(ap, fmt);
 80183ac: f107 032c    	add.w	r3, r7, #0x2c
 80183b0: 617b         	str	r3, [r7, #0x14]
; 	z_log_msg_runtime_vcreate(domain_id, source, level,
 80183b2: 7bba         	ldrb	r2, [r7, #0xe]
 80183b4: 7bf8         	ldrb	r0, [r7, #0xf]
 80183b6: 697b         	ldr	r3, [r7, #0x14]
 80183b8: 9303         	str	r3, [sp, #0xc]
 80183ba: 6abb         	ldr	r3, [r7, #0x28]
 80183bc: 9302         	str	r3, [sp, #0x8]
 80183be: 6a7b         	ldr	r3, [r7, #0x24]
 80183c0: 9301         	str	r3, [sp, #0x4]
 80183c2: 6a3b         	ldr	r3, [r7, #0x20]
 80183c4: 9300         	str	r3, [sp]
 80183c6: 687b         	ldr	r3, [r7, #0x4]
 80183c8: 68b9         	ldr	r1, [r7, #0x8]
 80183ca: f7ec f8d1    	bl	0x8004570 <z_log_msg_runtime_vcreate> @ imm = #-0x13e5e
; }
 80183ce: bf00         	nop
 80183d0: 3718         	adds	r7, #0x18
 80183d2: 46bd         	mov	sp, r7
 80183d4: bd80         	pop	{r7, pc}

080183d6 <gpio_is_ready_dt>:
; {
 80183d6: b580         	push	{r7, lr}
 80183d8: b082         	sub	sp, #0x8
 80183da: af00         	add	r7, sp, #0x0
 80183dc: 6078         	str	r0, [r7, #0x4]
; 	return device_is_ready(spec->port);
 80183de: 687b         	ldr	r3, [r7, #0x4]
 80183e0: 681b         	ldr	r3, [r3]
 80183e2: 4618         	mov	r0, r3
 80183e4: f7ff ff75    	bl	0x80182d2 <device_is_ready> @ imm = #-0x116
 80183e8: 4603         	mov	r3, r0
; }
 80183ea: 4618         	mov	r0, r3
 80183ec: 3708         	adds	r7, #0x8
 80183ee: 46bd         	mov	sp, r7
 80183f0: bd80         	pop	{r7, pc}

080183f2 <spi_cs_is_gpio>:
; {
 80183f2: b480         	push	{r7}
 80183f4: b083         	sub	sp, #0xc
 80183f6: af00         	add	r7, sp, #0x0
 80183f8: 6078         	str	r0, [r7, #0x4]
; 	return config->cs.gpio.port != NULL;
 80183fa: 687b         	ldr	r3, [r7, #0x4]
 80183fc: 689b         	ldr	r3, [r3, #0x8]
 80183fe: 2b00         	cmp	r3, #0x0
 8018400: bf14         	ite	ne
 8018402: 2301         	movne	r3, #0x1
 8018404: 2300         	moveq	r3, #0x0
 8018406: b2db         	uxtb	r3, r3
; }
 8018408: 4618         	mov	r0, r3
 801840a: 370c         	adds	r7, #0xc
 801840c: 46bd         	mov	sp, r7
 801840e: bc80         	pop	{r7}
 8018410: 4770         	bx	lr

08018412 <spi_cs_is_gpio_dt>:
; {
 8018412: b580         	push	{r7, lr}
 8018414: b082         	sub	sp, #0x8
 8018416: af00         	add	r7, sp, #0x0
 8018418: 6078         	str	r0, [r7, #0x4]
; 	return spi_cs_is_gpio(&spec->config);
 801841a: 687b         	ldr	r3, [r7, #0x4]
 801841c: 3304         	adds	r3, #0x4
 801841e: 4618         	mov	r0, r3
 8018420: f7ff ffe7    	bl	0x80183f2 <spi_cs_is_gpio> @ imm = #-0x32
 8018424: 4603         	mov	r3, r0
; }
 8018426: 4618         	mov	r0, r3
 8018428: 3708         	adds	r7, #0x8
 801842a: 46bd         	mov	sp, r7
 801842c: bd80         	pop	{r7, pc}

0801842e <spi_is_ready_dt>:
; {
 801842e: b580         	push	{r7, lr}
 8018430: b082         	sub	sp, #0x8
 8018432: af00         	add	r7, sp, #0x0
 8018434: 6078         	str	r0, [r7, #0x4]
; 	if (!device_is_ready(spec->bus)) {
 8018436: 687b         	ldr	r3, [r7, #0x4]
 8018438: 681b         	ldr	r3, [r3]
 801843a: 4618         	mov	r0, r3
 801843c: f7ff ff49    	bl	0x80182d2 <device_is_ready> @ imm = #-0x16e
 8018440: 4603         	mov	r3, r0
 8018442: f083 0301    	eor	r3, r3, #0x1
 8018446: b2db         	uxtb	r3, r3
 8018448: 2b00         	cmp	r3, #0x0
 801844a: d001         	beq	0x8018450 <spi_is_ready_dt+0x22> @ imm = #0x2
; 		return false;
 801844c: 2300         	movs	r3, #0x0
 801844e: e013         	b	0x8018478 <spi_is_ready_dt+0x4a> @ imm = #0x26
; 	if (spi_cs_is_gpio_dt(spec) &&
 8018450: 6878         	ldr	r0, [r7, #0x4]
 8018452: f7ff ffde    	bl	0x8018412 <spi_cs_is_gpio_dt> @ imm = #-0x44
 8018456: 4603         	mov	r3, r0
 8018458: 2b00         	cmp	r3, #0x0
 801845a: d00c         	beq	0x8018476 <spi_is_ready_dt+0x48> @ imm = #0x18
; 	    !gpio_is_ready_dt(&spec->config.cs.gpio)) {
 801845c: 687b         	ldr	r3, [r7, #0x4]
 801845e: 330c         	adds	r3, #0xc
 8018460: 4618         	mov	r0, r3
 8018462: f7ff ffb8    	bl	0x80183d6 <gpio_is_ready_dt> @ imm = #-0x90
 8018466: 4603         	mov	r3, r0
 8018468: f083 0301    	eor	r3, r3, #0x1
 801846c: b2db         	uxtb	r3, r3
; 	if (spi_cs_is_gpio_dt(spec) &&
 801846e: 2b00         	cmp	r3, #0x0
 8018470: d001         	beq	0x8018476 <spi_is_ready_dt+0x48> @ imm = #0x2
; 		return false;
 8018472: 2300         	movs	r3, #0x0
 8018474: e000         	b	0x8018478 <spi_is_ready_dt+0x4a> @ imm = #0x0
; 	return true;
 8018476: 2301         	movs	r3, #0x1
; }
 8018478: 4618         	mov	r0, r3
 801847a: 3708         	adds	r7, #0x8
 801847c: 46bd         	mov	sp, r7
 801847e: bd80         	pop	{r7, pc}

08018480 <z_impl_spi_transceive>:
; {
 8018480: b590         	push	{r4, r7, lr}
 8018482: b087         	sub	sp, #0x1c
 8018484: af00         	add	r7, sp, #0x0
 8018486: 60f8         	str	r0, [r7, #0xc]
 8018488: 60b9         	str	r1, [r7, #0x8]
 801848a: 607a         	str	r2, [r7, #0x4]
 801848c: 603b         	str	r3, [r7]
; 	const struct spi_driver_api *api =
 801848e: 68fb         	ldr	r3, [r7, #0xc]
 8018490: 689b         	ldr	r3, [r3, #0x8]
 8018492: 617b         	str	r3, [r7, #0x14]
; 	ret = api->transceive(dev, config, tx_bufs, rx_bufs);
 8018494: 697b         	ldr	r3, [r7, #0x14]
 8018496: 681c         	ldr	r4, [r3]
 8018498: 683b         	ldr	r3, [r7]
 801849a: 687a         	ldr	r2, [r7, #0x4]
 801849c: 68b9         	ldr	r1, [r7, #0x8]
 801849e: 68f8         	ldr	r0, [r7, #0xc]
 80184a0: 47a0         	blx	r4
 80184a2: 6138         	str	r0, [r7, #0x10]
; 	return ret;
 80184a4: 693b         	ldr	r3, [r7, #0x10]
; }
 80184a6: 4618         	mov	r0, r3
 80184a8: 371c         	adds	r7, #0x1c
 80184aa: 46bd         	mov	sp, r7
 80184ac: bd90         	pop	{r4, r7, pc}

080184ae <spi_transceive_dt>:
; {
 80184ae: b580         	push	{r7, lr}
 80184b0: b084         	sub	sp, #0x10
 80184b2: af00         	add	r7, sp, #0x0
 80184b4: 60f8         	str	r0, [r7, #0xc]
 80184b6: 60b9         	str	r1, [r7, #0x8]
 80184b8: 607a         	str	r2, [r7, #0x4]
; 	return spi_transceive(spec->bus, &spec->config, tx_bufs, rx_bufs);
 80184ba: 68fb         	ldr	r3, [r7, #0xc]
 80184bc: 6818         	ldr	r0, [r3]
 80184be: 68fb         	ldr	r3, [r7, #0xc]
 80184c0: 1d19         	adds	r1, r3, #0x4
 80184c2: 687b         	ldr	r3, [r7, #0x4]
 80184c4: 68ba         	ldr	r2, [r7, #0x8]
 80184c6: f000 f828    	bl	0x801851a <spi_transceive> @ imm = #0x50
 80184ca: 4603         	mov	r3, r0
; }
 80184cc: 4618         	mov	r0, r3
 80184ce: 3710         	adds	r7, #0x10
 80184d0: 46bd         	mov	sp, r7
 80184d2: bd80         	pop	{r7, pc}

080184d4 <spi_write>:
; {
 80184d4: b580         	push	{r7, lr}
 80184d6: b084         	sub	sp, #0x10
 80184d8: af00         	add	r7, sp, #0x0
 80184da: 60f8         	str	r0, [r7, #0xc]
 80184dc: 60b9         	str	r1, [r7, #0x8]
 80184de: 607a         	str	r2, [r7, #0x4]
; 	return spi_transceive(dev, config, tx_bufs, NULL);
 80184e0: 2300         	movs	r3, #0x0
 80184e2: 687a         	ldr	r2, [r7, #0x4]
 80184e4: 68b9         	ldr	r1, [r7, #0x8]
 80184e6: 68f8         	ldr	r0, [r7, #0xc]
 80184e8: f000 f817    	bl	0x801851a <spi_transceive> @ imm = #0x2e
 80184ec: 4603         	mov	r3, r0
; }
 80184ee: 4618         	mov	r0, r3
 80184f0: 3710         	adds	r7, #0x10
 80184f2: 46bd         	mov	sp, r7
 80184f4: bd80         	pop	{r7, pc}

080184f6 <spi_write_dt>:
; {
 80184f6: b580         	push	{r7, lr}
 80184f8: b082         	sub	sp, #0x8
 80184fa: af00         	add	r7, sp, #0x0
 80184fc: 6078         	str	r0, [r7, #0x4]
 80184fe: 6039         	str	r1, [r7]
; 	return spi_write(spec->bus, &spec->config, tx_bufs);
 8018500: 687b         	ldr	r3, [r7, #0x4]
 8018502: 6818         	ldr	r0, [r3]
 8018504: 687b         	ldr	r3, [r7, #0x4]
 8018506: 3304         	adds	r3, #0x4
 8018508: 683a         	ldr	r2, [r7]
 801850a: 4619         	mov	r1, r3
 801850c: f7ff ffe2    	bl	0x80184d4 <spi_write>   @ imm = #-0x3c
 8018510: 4603         	mov	r3, r0
; }
 8018512: 4618         	mov	r0, r3
 8018514: 3708         	adds	r7, #0x8
 8018516: 46bd         	mov	sp, r7
 8018518: bd80         	pop	{r7, pc}

0801851a <spi_transceive>:
; {
 801851a: b580         	push	{r7, lr}
 801851c: b084         	sub	sp, #0x10
 801851e: af00         	add	r7, sp, #0x0
 8018520: 60f8         	str	r0, [r7, #0xc]
 8018522: 60b9         	str	r1, [r7, #0x8]
 8018524: 607a         	str	r2, [r7, #0x4]
 8018526: 603b         	str	r3, [r7]
; 	return z_impl_spi_transceive(dev, config, tx_bufs, rx_bufs);
 8018528: 683b         	ldr	r3, [r7]
 801852a: 687a         	ldr	r2, [r7, #0x4]
 801852c: 68b9         	ldr	r1, [r7, #0x8]
 801852e: 68f8         	ldr	r0, [r7, #0xc]
 8018530: f7ff ffa6    	bl	0x8018480 <z_impl_spi_transceive> @ imm = #-0xb4
 8018534: 4603         	mov	r3, r0
; }
 8018536: 4618         	mov	r0, r3
 8018538: 3710         	adds	r7, #0x10
 801853a: 46bd         	mov	sp, r7
 801853c: bd80         	pop	{r7, pc}

0801853e <bmi08x_accel_transceive_spi>:
; {
 801853e: b580         	push	{r7, lr}
 8018540: b092         	sub	sp, #0x48
 8018542: af00         	add	r7, sp, #0x0
 8018544: 60f8         	str	r0, [r7, #0xc]
 8018546: 607b         	str	r3, [r7, #0x4]
 8018548: 460b         	mov	r3, r1
 801854a: 72fb         	strb	r3, [r7, #0xb]
 801854c: 4613         	mov	r3, r2
 801854e: 72bb         	strb	r3, [r7, #0xa]
; 	const struct bmi08x_accel_config *bmi08x = dev->config;
 8018550: 68fb         	ldr	r3, [r7, #0xc]
 8018552: 685b         	ldr	r3, [r3, #0x4]
 8018554: 647b         	str	r3, [r7, #0x44]
; 	const struct spi_buf tx_buf[2] = {{.buf = &reg, .len = 1}, {.buf = data, .len = length}};
 8018556: f107 030b    	add.w	r3, r7, #0xb
 801855a: 637b         	str	r3, [r7, #0x34]
 801855c: 2301         	movs	r3, #0x1
 801855e: 63bb         	str	r3, [r7, #0x38]
 8018560: 687b         	ldr	r3, [r7, #0x4]
 8018562: 63fb         	str	r3, [r7, #0x3c]
 8018564: 6d3b         	ldr	r3, [r7, #0x50]
 8018566: 643b         	str	r3, [r7, #0x40]
; 	const struct spi_buf_set tx = {.buffers = tx_buf, .count = write ? 2 : 1};
 8018568: f107 0334    	add.w	r3, r7, #0x34
 801856c: 62fb         	str	r3, [r7, #0x2c]
 801856e: 7abb         	ldrb	r3, [r7, #0xa]
 8018570: 2b00         	cmp	r3, #0x0
 8018572: d001         	beq	0x8018578 <bmi08x_accel_transceive_spi+0x3a> @ imm = #0x2
 8018574: 2302         	movs	r3, #0x2
 8018576: e000         	b	0x801857a <bmi08x_accel_transceive_spi+0x3c> @ imm = #0x0
 8018578: 2301         	movs	r3, #0x1
 801857a: 633b         	str	r3, [r7, #0x30]
; 	if (!write) {
 801857c: 7abb         	ldrb	r3, [r7, #0xa]
 801857e: f083 0301    	eor	r3, r3, #0x1
 8018582: b2db         	uxtb	r3, r3
 8018584: 2b00         	cmp	r3, #0x0
 8018586: d017         	beq	0x80185b8 <bmi08x_accel_transceive_spi+0x7a> @ imm = #0x2e
; 		const struct spi_buf rx_buf[2] = {{.buf = &dummy, .len = 2},
 8018588: f107 032a    	add.w	r3, r7, #0x2a
 801858c: 61bb         	str	r3, [r7, #0x18]
 801858e: 2302         	movs	r3, #0x2
 8018590: 61fb         	str	r3, [r7, #0x1c]
 8018592: 687b         	ldr	r3, [r7, #0x4]
 8018594: 623b         	str	r3, [r7, #0x20]
 8018596: 6d3b         	ldr	r3, [r7, #0x50]
 8018598: 627b         	str	r3, [r7, #0x24]
; 		const struct spi_buf_set rx = {.buffers = rx_buf, .count = 2};
 801859a: f107 0318    	add.w	r3, r7, #0x18
 801859e: 613b         	str	r3, [r7, #0x10]
 80185a0: 2302         	movs	r3, #0x2
 80185a2: 617b         	str	r3, [r7, #0x14]
; 		return spi_transceive_dt(&bmi08x->bus.spi, &tx, &rx);
 80185a4: 6c7b         	ldr	r3, [r7, #0x44]
 80185a6: f107 0210    	add.w	r2, r7, #0x10
 80185aa: f107 012c    	add.w	r1, r7, #0x2c
 80185ae: 4618         	mov	r0, r3
 80185b0: f7ff ff7d    	bl	0x80184ae <spi_transceive_dt> @ imm = #-0x106
 80185b4: 4603         	mov	r3, r0
 80185b6: e007         	b	0x80185c8 <bmi08x_accel_transceive_spi+0x8a> @ imm = #0xe
; 	return spi_write_dt(&bmi08x->bus.spi, &tx);
 80185b8: 6c7b         	ldr	r3, [r7, #0x44]
 80185ba: f107 022c    	add.w	r2, r7, #0x2c
 80185be: 4611         	mov	r1, r2
 80185c0: 4618         	mov	r0, r3
 80185c2: f7ff ff98    	bl	0x80184f6 <spi_write_dt> @ imm = #-0xd0
 80185c6: 4603         	mov	r3, r0
; }
 80185c8: 4618         	mov	r0, r3
 80185ca: 3748         	adds	r7, #0x48
 80185cc: 46bd         	mov	sp, r7
 80185ce: bd80         	pop	{r7, pc}

080185d0 <bmi08x_bus_check_spi>:
; {
 80185d0: b580         	push	{r7, lr}
 80185d2: b082         	sub	sp, #0x8
 80185d4: af00         	add	r7, sp, #0x0
 80185d6: 6078         	str	r0, [r7, #0x4]
; 	return spi_is_ready_dt(&bus->spi) ? 0 : -ENODEV;
 80185d8: 687b         	ldr	r3, [r7, #0x4]
 80185da: 4618         	mov	r0, r3
 80185dc: f7ff ff27    	bl	0x801842e <spi_is_ready_dt> @ imm = #-0x1b2
 80185e0: 4603         	mov	r3, r0
 80185e2: 2b00         	cmp	r3, #0x0
 80185e4: d001         	beq	0x80185ea <bmi08x_bus_check_spi+0x1a> @ imm = #0x2
 80185e6: 2300         	movs	r3, #0x0
 80185e8: e001         	b	0x80185ee <bmi08x_bus_check_spi+0x1e> @ imm = #0x2
 80185ea: f06f 0312    	mvn	r3, #0x12
; }
 80185ee: 4618         	mov	r0, r3
 80185f0: 3708         	adds	r7, #0x8
 80185f2: 46bd         	mov	sp, r7
 80185f4: bd80         	pop	{r7, pc}

080185f6 <bmi08x_bus_check>:
; {
 80185f6: b580         	push	{r7, lr}
 80185f8: b084         	sub	sp, #0x10
 80185fa: af00         	add	r7, sp, #0x0
 80185fc: 6078         	str	r0, [r7, #0x4]
; 	const struct bmi08x_accel_config *config = dev->config;
 80185fe: 687b         	ldr	r3, [r7, #0x4]
 8018600: 685b         	ldr	r3, [r3, #0x4]
 8018602: 60fb         	str	r3, [r7, #0xc]
; 	return config->api->check(&config->bus);
 8018604: 68fb         	ldr	r3, [r7, #0xc]
 8018606: 699b         	ldr	r3, [r3, #0x18]
 8018608: 681b         	ldr	r3, [r3]
 801860a: 68fa         	ldr	r2, [r7, #0xc]
 801860c: 4610         	mov	r0, r2
 801860e: 4798         	blx	r3
 8018610: 4603         	mov	r3, r0
; }
 8018612: 4618         	mov	r0, r3
 8018614: 3710         	adds	r7, #0x10
 8018616: 46bd         	mov	sp, r7
 8018618: bd80         	pop	{r7, pc}

0801861a <bmi08x_bus_init>:
; {
 801861a: b580         	push	{r7, lr}
 801861c: b084         	sub	sp, #0x10
 801861e: af00         	add	r7, sp, #0x0
 8018620: 6078         	str	r0, [r7, #0x4]
; 	const struct bmi08x_accel_config *config = dev->config;
 8018622: 687b         	ldr	r3, [r7, #0x4]
 8018624: 685b         	ldr	r3, [r3, #0x4]
 8018626: 60fb         	str	r3, [r7, #0xc]
; 	if (config->api->bus_init) {
 8018628: 68fb         	ldr	r3, [r7, #0xc]
 801862a: 699b         	ldr	r3, [r3, #0x18]
 801862c: 685b         	ldr	r3, [r3, #0x4]
 801862e: 2b00         	cmp	r3, #0x0
 8018630: d006         	beq	0x8018640 <bmi08x_bus_init+0x26> @ imm = #0xc
; 		return config->api->bus_init(dev);
 8018632: 68fb         	ldr	r3, [r7, #0xc]
 8018634: 699b         	ldr	r3, [r3, #0x18]
 8018636: 685b         	ldr	r3, [r3, #0x4]
 8018638: 6878         	ldr	r0, [r7, #0x4]
 801863a: 4798         	blx	r3
 801863c: 4603         	mov	r3, r0
 801863e: e000         	b	0x8018642 <bmi08x_bus_init+0x28> @ imm = #0x0
; 	return 0;
 8018640: 2300         	movs	r3, #0x0
; }
 8018642: 4618         	mov	r0, r3
 8018644: 3710         	adds	r7, #0x10
 8018646: 46bd         	mov	sp, r7
 8018648: bd80         	pop	{r7, pc}

0801864a <bmi08x_accel_transceive>:
; {
 801864a: b590         	push	{r4, r7, lr}
 801864c: b089         	sub	sp, #0x24
 801864e: af02         	add	r7, sp, #0x8
 8018650: 60f8         	str	r0, [r7, #0xc]
 8018652: 607b         	str	r3, [r7, #0x4]
 8018654: 460b         	mov	r3, r1
 8018656: 72fb         	strb	r3, [r7, #0xb]
 8018658: 4613         	mov	r3, r2
 801865a: 72bb         	strb	r3, [r7, #0xa]
; 	const struct bmi08x_accel_config *config = dev->config;
 801865c: 68fb         	ldr	r3, [r7, #0xc]
 801865e: 685b         	ldr	r3, [r3, #0x4]
 8018660: 617b         	str	r3, [r7, #0x14]
; 	return config->api->transceive(dev, reg, write, data, length);
 8018662: 697b         	ldr	r3, [r7, #0x14]
 8018664: 699b         	ldr	r3, [r3, #0x18]
 8018666: 689c         	ldr	r4, [r3, #0x8]
 8018668: 7aba         	ldrb	r2, [r7, #0xa]
 801866a: 7af9         	ldrb	r1, [r7, #0xb]
 801866c: 6abb         	ldr	r3, [r7, #0x28]
 801866e: 9300         	str	r3, [sp]
 8018670: 687b         	ldr	r3, [r7, #0x4]
 8018672: 68f8         	ldr	r0, [r7, #0xc]
 8018674: 47a0         	blx	r4
 8018676: 4603         	mov	r3, r0
; }
 8018678: 4618         	mov	r0, r3
 801867a: 371c         	adds	r7, #0x1c
 801867c: 46bd         	mov	sp, r7
 801867e: bd90         	pop	{r4, r7, pc}

08018680 <bmi08x_accel_read>:
; {
 8018680: b580         	push	{r7, lr}
 8018682: b086         	sub	sp, #0x18
 8018684: af02         	add	r7, sp, #0x8
 8018686: 60f8         	str	r0, [r7, #0xc]
 8018688: 607a         	str	r2, [r7, #0x4]
 801868a: 461a         	mov	r2, r3
 801868c: 460b         	mov	r3, r1
 801868e: 72fb         	strb	r3, [r7, #0xb]
 8018690: 4613         	mov	r3, r2
 8018692: 72bb         	strb	r3, [r7, #0xa]
; 	return bmi08x_accel_transceive(dev, reg_addr | BIT(7), false, data, len);
 8018694: 7afb         	ldrb	r3, [r7, #0xb]
 8018696: f063 037f    	orn	r3, r3, #0x7f
 801869a: b2d9         	uxtb	r1, r3
 801869c: 7abb         	ldrb	r3, [r7, #0xa]
 801869e: 9300         	str	r3, [sp]
 80186a0: 687b         	ldr	r3, [r7, #0x4]
 80186a2: 2200         	movs	r2, #0x0
 80186a4: 68f8         	ldr	r0, [r7, #0xc]
 80186a6: f7ff ffd0    	bl	0x801864a <bmi08x_accel_transceive> @ imm = #-0x60
 80186aa: 4603         	mov	r3, r0
; }
 80186ac: 4618         	mov	r0, r3
 80186ae: 3710         	adds	r7, #0x10
 80186b0: 46bd         	mov	sp, r7
 80186b2: bd80         	pop	{r7, pc}

080186b4 <bmi08x_accel_byte_read>:
; {
 80186b4: b580         	push	{r7, lr}
 80186b6: b086         	sub	sp, #0x18
 80186b8: af02         	add	r7, sp, #0x8
 80186ba: 60f8         	str	r0, [r7, #0xc]
 80186bc: 460b         	mov	r3, r1
 80186be: 607a         	str	r2, [r7, #0x4]
 80186c0: 72fb         	strb	r3, [r7, #0xb]
; 	return bmi08x_accel_transceive(dev, reg_addr | BIT(7), false, byte, 1);
 80186c2: 7afb         	ldrb	r3, [r7, #0xb]
 80186c4: f063 037f    	orn	r3, r3, #0x7f
 80186c8: b2d9         	uxtb	r1, r3
 80186ca: 2301         	movs	r3, #0x1
 80186cc: 9300         	str	r3, [sp]
 80186ce: 687b         	ldr	r3, [r7, #0x4]
 80186d0: 2200         	movs	r2, #0x0
 80186d2: 68f8         	ldr	r0, [r7, #0xc]
 80186d4: f7ff ffb9    	bl	0x801864a <bmi08x_accel_transceive> @ imm = #-0x8e
 80186d8: 4603         	mov	r3, r0
; }
 80186da: 4618         	mov	r0, r3
 80186dc: 3710         	adds	r7, #0x10
 80186de: 46bd         	mov	sp, r7
 80186e0: bd80         	pop	{r7, pc}

080186e2 <bmi08x_accel_word_read>:
; {
 80186e2: b580         	push	{r7, lr}
 80186e4: b088         	sub	sp, #0x20
 80186e6: af02         	add	r7, sp, #0x8
 80186e8: 60f8         	str	r0, [r7, #0xc]
 80186ea: 460b         	mov	r3, r1
 80186ec: 607a         	str	r2, [r7, #0x4]
 80186ee: 72fb         	strb	r3, [r7, #0xb]
; 	ret = bmi08x_accel_transceive(dev, reg_addr | BIT(7), false, word, 2);
 80186f0: 7afb         	ldrb	r3, [r7, #0xb]
 80186f2: f063 037f    	orn	r3, r3, #0x7f
 80186f6: b2d9         	uxtb	r1, r3
 80186f8: 2302         	movs	r3, #0x2
 80186fa: 9300         	str	r3, [sp]
 80186fc: 687b         	ldr	r3, [r7, #0x4]
 80186fe: 2200         	movs	r2, #0x0
 8018700: 68f8         	ldr	r0, [r7, #0xc]
 8018702: f7ff ffa2    	bl	0x801864a <bmi08x_accel_transceive> @ imm = #-0xbc
 8018706: 6178         	str	r0, [r7, #0x14]
; 	if (ret != 0) {
 8018708: 697b         	ldr	r3, [r7, #0x14]
 801870a: 2b00         	cmp	r3, #0x0
 801870c: d001         	beq	0x8018712 <bmi08x_accel_word_read+0x30> @ imm = #0x2
; 		return ret;
 801870e: 697b         	ldr	r3, [r7, #0x14]
 8018710: e004         	b	0x801871c <bmi08x_accel_word_read+0x3a> @ imm = #0x8
; 	*word = sys_le16_to_cpu(*word);
 8018712: 687b         	ldr	r3, [r7, #0x4]
 8018714: 881a         	ldrh	r2, [r3]
 8018716: 687b         	ldr	r3, [r7, #0x4]
 8018718: 801a         	strh	r2, [r3]
; 	return ret;
 801871a: 697b         	ldr	r3, [r7, #0x14]
; }
 801871c: 4618         	mov	r0, r3
 801871e: 3718         	adds	r7, #0x18
 8018720: 46bd         	mov	sp, r7
 8018722: bd80         	pop	{r7, pc}

08018724 <bmi08x_accel_byte_write>:
; {
 8018724: b580         	push	{r7, lr}
 8018726: b084         	sub	sp, #0x10
 8018728: af02         	add	r7, sp, #0x8
 801872a: 6078         	str	r0, [r7, #0x4]
 801872c: 460b         	mov	r3, r1
 801872e: 70fb         	strb	r3, [r7, #0x3]
 8018730: 4613         	mov	r3, r2
 8018732: 70bb         	strb	r3, [r7, #0x2]
; 	return bmi08x_accel_transceive(dev, reg_addr & 0x7F, true, &byte, 1);
 8018734: 78fb         	ldrb	r3, [r7, #0x3]
 8018736: f003 037f    	and	r3, r3, #0x7f
 801873a: b2d9         	uxtb	r1, r3
 801873c: 1cbb         	adds	r3, r7, #0x2
 801873e: 2201         	movs	r2, #0x1
 8018740: 9200         	str	r2, [sp]
 8018742: 2201         	movs	r2, #0x1
 8018744: 6878         	ldr	r0, [r7, #0x4]
 8018746: f7ff ff80    	bl	0x801864a <bmi08x_accel_transceive> @ imm = #-0x100
 801874a: 4603         	mov	r3, r0
; }
 801874c: 4618         	mov	r0, r3
 801874e: 3708         	adds	r7, #0x8
 8018750: 46bd         	mov	sp, r7
 8018752: bd80         	pop	{r7, pc}

08018754 <bmi08x_accel_reg_field_update>:
; {
 8018754: b580         	push	{r7, lr}
 8018756: b084         	sub	sp, #0x10
 8018758: af00         	add	r7, sp, #0x0
 801875a: 6078         	str	r0, [r7, #0x4]
 801875c: 4608         	mov	r0, r1
 801875e: 4611         	mov	r1, r2
 8018760: 461a         	mov	r2, r3
 8018762: 4603         	mov	r3, r0
 8018764: 70fb         	strb	r3, [r7, #0x3]
 8018766: 460b         	mov	r3, r1
 8018768: 70bb         	strb	r3, [r7, #0x2]
 801876a: 4613         	mov	r3, r2
 801876c: 707b         	strb	r3, [r7, #0x1]
; 	ret = bmi08x_accel_byte_read(dev, reg_addr, &old_val);
 801876e: f107 020b    	add.w	r2, r7, #0xb
 8018772: 78fb         	ldrb	r3, [r7, #0x3]
 8018774: 4619         	mov	r1, r3
 8018776: 6878         	ldr	r0, [r7, #0x4]
 8018778: f7ff ff9c    	bl	0x80186b4 <bmi08x_accel_byte_read> @ imm = #-0xc8
 801877c: 60f8         	str	r0, [r7, #0xc]
; 	if (ret < 0) {
 801877e: 68fb         	ldr	r3, [r7, #0xc]
 8018780: 2b00         	cmp	r3, #0x0
 8018782: da01         	bge	0x8018788 <bmi08x_accel_reg_field_update+0x34> @ imm = #0x2
; 		return ret;
 8018784: 68fb         	ldr	r3, [r7, #0xc]
 8018786: e019         	b	0x80187bc <bmi08x_accel_reg_field_update+0x68> @ imm = #0x32
; 	return bmi08x_accel_byte_write(dev, reg_addr, (old_val & ~mask) | ((val << pos) & mask));
 8018788: f997 3001    	ldrsb.w	r3, [r7, #0x1]
 801878c: 43db         	mvns	r3, r3
 801878e: b25a         	sxtb	r2, r3
 8018790: 7afb         	ldrb	r3, [r7, #0xb]
 8018792: b25b         	sxtb	r3, r3
 8018794: 4013         	ands	r3, r2
 8018796: b25a         	sxtb	r2, r3
 8018798: 7e39         	ldrb	r1, [r7, #0x18]
 801879a: 78bb         	ldrb	r3, [r7, #0x2]
 801879c: fa01 f303    	lsl.w	r3, r1, r3
 80187a0: b259         	sxtb	r1, r3
 80187a2: f997 3001    	ldrsb.w	r3, [r7, #0x1]
 80187a6: 400b         	ands	r3, r1
 80187a8: b25b         	sxtb	r3, r3
 80187aa: 4313         	orrs	r3, r2
 80187ac: b25b         	sxtb	r3, r3
 80187ae: b2da         	uxtb	r2, r3
 80187b0: 78fb         	ldrb	r3, [r7, #0x3]
 80187b2: 4619         	mov	r1, r3
 80187b4: 6878         	ldr	r0, [r7, #0x4]
 80187b6: f7ff ffb5    	bl	0x8018724 <bmi08x_accel_byte_write> @ imm = #-0x96
 80187ba: 4603         	mov	r3, r0
; }
 80187bc: 4618         	mov	r0, r3
 80187be: 3710         	adds	r7, #0x10
 80187c0: 46bd         	mov	sp, r7
 80187c2: bd80         	pop	{r7, pc}

080187c4 <bmi08x_acc_odr_set>:
; {
 80187c4: b580         	push	{r7, lr}
 80187c6: b086         	sub	sp, #0x18
 80187c8: af02         	add	r7, sp, #0x8
 80187ca: 6078         	str	r0, [r7, #0x4]
 80187cc: 460b         	mov	r3, r1
 80187ce: 807b         	strh	r3, [r7, #0x2]
 80187d0: 4613         	mov	r3, r2
 80187d2: 803b         	strh	r3, [r7]
; 	int odr = bmi08x_freq_to_odr_val(freq_int, freq_milli);
 80187d4: 883a         	ldrh	r2, [r7]
 80187d6: 887b         	ldrh	r3, [r7, #0x2]
 80187d8: 4611         	mov	r1, r2
 80187da: 4618         	mov	r0, r3
 80187dc: f7f0 ff96    	bl	0x800970c <bmi08x_freq_to_odr_val> @ imm = #-0xf0d4
 80187e0: 60f8         	str	r0, [r7, #0xc]
; 	if (odr < BMI08X_ACCEL_ODR_12_5_HZ) {
 80187e2: 68fb         	ldr	r3, [r7, #0xc]
 80187e4: 2b04         	cmp	r3, #0x4
 80187e6: dc01         	bgt	0x80187ec <bmi08x_acc_odr_set+0x28> @ imm = #0x2
; 		return odr;
 80187e8: 68fb         	ldr	r3, [r7, #0xc]
 80187ea: e009         	b	0x8018800 <bmi08x_acc_odr_set+0x3c> @ imm = #0x12
; 	return bmi08x_accel_reg_field_update(dev, BMI08X_REG_ACCEL_CONF, 0, BMI08X_ACCEL_ODR_MASK,
 80187ec: 68fb         	ldr	r3, [r7, #0xc]
 80187ee: b2db         	uxtb	r3, r3
 80187f0: 9300         	str	r3, [sp]
 80187f2: 230f         	movs	r3, #0xf
 80187f4: 2200         	movs	r2, #0x0
 80187f6: 2140         	movs	r1, #0x40
 80187f8: 6878         	ldr	r0, [r7, #0x4]
 80187fa: f7ff ffab    	bl	0x8018754 <bmi08x_accel_reg_field_update> @ imm = #-0xaa
 80187fe: 4603         	mov	r3, r0
; }
 8018800: 4618         	mov	r0, r3
 8018802: 3710         	adds	r7, #0x10
 8018804: 46bd         	mov	sp, r7
 8018806: bd80         	pop	{r7, pc}

08018808 <bmi08x_channel_convert>:
; {
 8018808: b580         	push	{r7, lr}
 801880a: b086         	sub	sp, #0x18
 801880c: af00         	add	r7, sp, #0x0
 801880e: 60ba         	str	r2, [r7, #0x8]
 8018810: 607b         	str	r3, [r7, #0x4]
 8018812: 4603         	mov	r3, r0
 8018814: 81fb         	strh	r3, [r7, #0xe]
 8018816: 460b         	mov	r3, r1
 8018818: 81bb         	strh	r3, [r7, #0xc]
; 	switch (chan) {
 801881a: 89fb         	ldrh	r3, [r7, #0xe]
 801881c: 2b02         	cmp	r3, #0x2
 801881e: d010         	beq	0x8018842 <bmi08x_channel_convert+0x3a> @ imm = #0x20
 8018820: 2b02         	cmp	r3, #0x2
 8018822: dc13         	bgt	0x801884c <bmi08x_channel_convert+0x44> @ imm = #0x26
 8018824: 2b00         	cmp	r3, #0x0
 8018826: d002         	beq	0x801882e <bmi08x_channel_convert+0x26> @ imm = #0x4
 8018828: 2b01         	cmp	r3, #0x1
 801882a: d005         	beq	0x8018838 <bmi08x_channel_convert+0x30> @ imm = #0xa
 801882c: e00e         	b	0x801884c <bmi08x_channel_convert+0x44> @ imm = #0x1c
; 		ofs_start = ofs_stop = 0U;
 801882e: 2300         	movs	r3, #0x0
 8018830: 74bb         	strb	r3, [r7, #0x12]
 8018832: 7cbb         	ldrb	r3, [r7, #0x12]
 8018834: 74fb         	strb	r3, [r7, #0x13]
; 		break;
 8018836: e00e         	b	0x8018856 <bmi08x_channel_convert+0x4e> @ imm = #0x1c
; 		ofs_start = ofs_stop = 1U;
 8018838: 2301         	movs	r3, #0x1
 801883a: 74bb         	strb	r3, [r7, #0x12]
 801883c: 7cbb         	ldrb	r3, [r7, #0x12]
 801883e: 74fb         	strb	r3, [r7, #0x13]
; 		break;
 8018840: e009         	b	0x8018856 <bmi08x_channel_convert+0x4e> @ imm = #0x12
; 		ofs_start = ofs_stop = 2U;
 8018842: 2302         	movs	r3, #0x2
 8018844: 74bb         	strb	r3, [r7, #0x12]
 8018846: 7cbb         	ldrb	r3, [r7, #0x12]
 8018848: 74fb         	strb	r3, [r7, #0x13]
; 		break;
 801884a: e004         	b	0x8018856 <bmi08x_channel_convert+0x4e> @ imm = #0x8
; 		ofs_start = 0U;
 801884c: 2300         	movs	r3, #0x0
 801884e: 74fb         	strb	r3, [r7, #0x13]
; 		ofs_stop = 2U;
 8018850: 2302         	movs	r3, #0x2
 8018852: 74bb         	strb	r3, [r7, #0x12]
; 		break;
 8018854: bf00         	nop
; 	for (i = ofs_start; i <= ofs_stop; i++, val++) {
 8018856: 7cfb         	ldrb	r3, [r7, #0x13]
 8018858: 617b         	str	r3, [r7, #0x14]
 801885a: e010         	b	0x801887e <bmi08x_channel_convert+0x76> @ imm = #0x20
; 		bmi08x_to_fixed_point(raw_xyz[i], scale, val);
 801885c: 697b         	ldr	r3, [r7, #0x14]
 801885e: 005b         	lsls	r3, r3, #0x1
 8018860: 68ba         	ldr	r2, [r7, #0x8]
 8018862: 4413         	add	r3, r2
 8018864: 881b         	ldrh	r3, [r3]
 8018866: b21b         	sxth	r3, r3
 8018868: 89b9         	ldrh	r1, [r7, #0xc]
 801886a: 687a         	ldr	r2, [r7, #0x4]
 801886c: 4618         	mov	r0, r3
 801886e: f7f0 f8a7    	bl	0x80089c0 <bmi08x_to_fixed_point> @ imm = #-0xfeb2
; 	for (i = ofs_start; i <= ofs_stop; i++, val++) {
 8018872: 697b         	ldr	r3, [r7, #0x14]
 8018874: 3301         	adds	r3, #0x1
 8018876: 617b         	str	r3, [r7, #0x14]
 8018878: 687b         	ldr	r3, [r7, #0x4]
 801887a: 3308         	adds	r3, #0x8
 801887c: 607b         	str	r3, [r7, #0x4]
 801887e: 7cbb         	ldrb	r3, [r7, #0x12]
 8018880: 697a         	ldr	r2, [r7, #0x14]
 8018882: 429a         	cmp	r2, r3
 8018884: ddea         	ble	0x801885c <bmi08x_channel_convert+0x54> @ imm = #-0x2c
; }
 8018886: bf00         	nop
 8018888: bf00         	nop
 801888a: 3718         	adds	r7, #0x18
 801888c: 46bd         	mov	sp, r7
 801888e: bd80         	pop	{r7, pc}

08018890 <bmi08x_acc_channel_get>:
; {
 8018890: b580         	push	{r7, lr}
 8018892: b086         	sub	sp, #0x18
 8018894: af00         	add	r7, sp, #0x0
 8018896: 60f8         	str	r0, [r7, #0xc]
 8018898: 460b         	mov	r3, r1
 801889a: 607a         	str	r2, [r7, #0x4]
 801889c: 817b         	strh	r3, [r7, #0xa]
; 	struct bmi08x_accel_data *data = dev->data;
 801889e: 68fb         	ldr	r3, [r7, #0xc]
 80188a0: 691b         	ldr	r3, [r3, #0x10]
 80188a2: 617b         	str	r3, [r7, #0x14]
; 	bmi08x_channel_convert(chan, data->scale, data->acc_sample, val);
 80188a4: 697b         	ldr	r3, [r7, #0x14]
 80188a6: 8a59         	ldrh	r1, [r3, #0x12]
 80188a8: 697b         	ldr	r3, [r7, #0x14]
 80188aa: f103 020c    	add.w	r2, r3, #0xc
 80188ae: 8978         	ldrh	r0, [r7, #0xa]
 80188b0: 687b         	ldr	r3, [r7, #0x4]
 80188b2: f7ff ffa9    	bl	0x8018808 <bmi08x_channel_convert> @ imm = #-0xae
; }
 80188b6: bf00         	nop
 80188b8: 3718         	adds	r7, #0x18
 80188ba: 46bd         	mov	sp, r7
 80188bc: bd80         	pop	{r7, pc}

080188be <device_is_ready>:
; {
 80188be: b580         	push	{r7, lr}
 80188c0: b082         	sub	sp, #0x8
 80188c2: af00         	add	r7, sp, #0x0
 80188c4: 6078         	str	r0, [r7, #0x4]
; 	return z_impl_device_is_ready(dev);
 80188c6: 6878         	ldr	r0, [r7, #0x4]
 80188c8: f003 f959    	bl	0x801bb7e <z_impl_device_is_ready> @ imm = #0x32b2
 80188cc: 4603         	mov	r3, r0
; }
 80188ce: 4618         	mov	r0, r3
 80188d0: 3708         	adds	r7, #0x8
 80188d2: 46bd         	mov	sp, r7
 80188d4: bd80         	pop	{r7, pc}

080188d6 <k_msleep>:
; {
 80188d6: e92d 4fb0    	push.w	{r4, r5, r7, r8, r9, r10, r11, lr}
 80188da: b082         	sub	sp, #0x8
 80188dc: af00         	add	r7, sp, #0x0
 80188de: 6078         	str	r0, [r7, #0x4]
; 	return k_sleep(Z_TIMEOUT_MS(ms));
 80188e0: 6879         	ldr	r1, [r7, #0x4]
 80188e2: ea21 71e1    	bic.w	r1, r1, r1, asr #31
 80188e6: 17c8         	asrs	r0, r1, #0x1f
 80188e8: 4688         	mov	r8, r1
 80188ea: 4681         	mov	r9, r0
 80188ec: 4640         	mov	r0, r8
 80188ee: 4649         	mov	r1, r9
 80188f0: f04f 0400    	mov.w	r4, #0x0
 80188f4: f04f 0500    	mov.w	r5, #0x0
 80188f8: 008d         	lsls	r5, r1, #0x2
 80188fa: ea45 7590    	orr.w	r5, r5, r0, lsr #30
 80188fe: 0084         	lsls	r4, r0, #0x2
 8018900: 4620         	mov	r0, r4
 8018902: 4629         	mov	r1, r5
 8018904: eb10 0208    	adds.w	r2, r0, r8
 8018908: eb41 0309    	adc.w	r3, r1, r9
 801890c: eb12 0a02    	adds.w	r10, r2, r2
 8018910: eb43 0b03    	adc.w	r11, r3, r3
 8018914: 4652         	mov	r2, r10
 8018916: 465b         	mov	r3, r11
 8018918: 4610         	mov	r0, r2
 801891a: 4619         	mov	r1, r3
 801891c: f000 f807    	bl	0x801892e <k_sleep>     @ imm = #0xe
 8018920: 4601         	mov	r1, r0
 8018922: 460b         	mov	r3, r1
; }
 8018924: 4618         	mov	r0, r3
 8018926: 3708         	adds	r7, #0x8
 8018928: 46bd         	mov	sp, r7
 801892a: e8bd 8fb0    	pop.w	{r4, r5, r7, r8, r9, r10, r11, pc}

0801892e <k_sleep>:
; {
 801892e: b580         	push	{r7, lr}
 8018930: b082         	sub	sp, #0x8
 8018932: af00         	add	r7, sp, #0x0
 8018934: e9c7 0100    	strd	r0, r1, [r7]
; 	return z_impl_k_sleep(timeout);
 8018938: e9d7 0100    	ldrd	r0, r1, [r7]
 801893c: f7f7 fd5e    	bl	0x80103fc <z_impl_k_sleep> @ imm = #-0x8544
 8018940: 4603         	mov	r3, r0
; }
 8018942: 4618         	mov	r0, r3
 8018944: 3708         	adds	r7, #0x8
 8018946: 46bd         	mov	sp, r7
 8018948: bd80         	pop	{r7, pc}

0801894a <z_log_msg_runtime_create>:
; {
 801894a: b580         	push	{r7, lr}
 801894c: b08a         	sub	sp, #0x28
 801894e: af04         	add	r7, sp, #0x10
 8018950: 60b9         	str	r1, [r7, #0x8]
 8018952: 607b         	str	r3, [r7, #0x4]
 8018954: 4603         	mov	r3, r0
 8018956: 73fb         	strb	r3, [r7, #0xf]
 8018958: 4613         	mov	r3, r2
 801895a: 73bb         	strb	r3, [r7, #0xe]
; 	va_start(ap, fmt);
 801895c: f107 032c    	add.w	r3, r7, #0x2c
 8018960: 617b         	str	r3, [r7, #0x14]
; 	z_log_msg_runtime_vcreate(domain_id, source, level,
 8018962: 7bba         	ldrb	r2, [r7, #0xe]
 8018964: 7bf8         	ldrb	r0, [r7, #0xf]
 8018966: 697b         	ldr	r3, [r7, #0x14]
 8018968: 9303         	str	r3, [sp, #0xc]
 801896a: 6abb         	ldr	r3, [r7, #0x28]
 801896c: 9302         	str	r3, [sp, #0x8]
 801896e: 6a7b         	ldr	r3, [r7, #0x24]
 8018970: 9301         	str	r3, [sp, #0x4]
 8018972: 6a3b         	ldr	r3, [r7, #0x20]
 8018974: 9300         	str	r3, [sp]
 8018976: 687b         	ldr	r3, [r7, #0x4]
 8018978: 68b9         	ldr	r1, [r7, #0x8]
 801897a: f7eb fdf9    	bl	0x8004570 <z_log_msg_runtime_vcreate> @ imm = #-0x1440e
; }
 801897e: bf00         	nop
 8018980: 3718         	adds	r7, #0x18
 8018982: 46bd         	mov	sp, r7
 8018984: bd80         	pop	{r7, pc}

08018986 <gpio_is_ready_dt>:
; {
 8018986: b580         	push	{r7, lr}
 8018988: b082         	sub	sp, #0x8
 801898a: af00         	add	r7, sp, #0x0
 801898c: 6078         	str	r0, [r7, #0x4]
; 	return device_is_ready(spec->port);
 801898e: 687b         	ldr	r3, [r7, #0x4]
 8018990: 681b         	ldr	r3, [r3]
 8018992: 4618         	mov	r0, r3
 8018994: f7ff ff93    	bl	0x80188be <device_is_ready> @ imm = #-0xda
 8018998: 4603         	mov	r3, r0
; }
 801899a: 4618         	mov	r0, r3
 801899c: 3708         	adds	r7, #0x8
 801899e: 46bd         	mov	sp, r7
 80189a0: bd80         	pop	{r7, pc}

080189a2 <spi_cs_is_gpio>:
; {
 80189a2: b480         	push	{r7}
 80189a4: b083         	sub	sp, #0xc
 80189a6: af00         	add	r7, sp, #0x0
 80189a8: 6078         	str	r0, [r7, #0x4]
; 	return config->cs.gpio.port != NULL;
 80189aa: 687b         	ldr	r3, [r7, #0x4]
 80189ac: 689b         	ldr	r3, [r3, #0x8]
 80189ae: 2b00         	cmp	r3, #0x0
 80189b0: bf14         	ite	ne
 80189b2: 2301         	movne	r3, #0x1
 80189b4: 2300         	moveq	r3, #0x0
 80189b6: b2db         	uxtb	r3, r3
; }
 80189b8: 4618         	mov	r0, r3
 80189ba: 370c         	adds	r7, #0xc
 80189bc: 46bd         	mov	sp, r7
 80189be: bc80         	pop	{r7}
 80189c0: 4770         	bx	lr

080189c2 <spi_cs_is_gpio_dt>:
; {
 80189c2: b580         	push	{r7, lr}
 80189c4: b082         	sub	sp, #0x8
 80189c6: af00         	add	r7, sp, #0x0
 80189c8: 6078         	str	r0, [r7, #0x4]
; 	return spi_cs_is_gpio(&spec->config);
 80189ca: 687b         	ldr	r3, [r7, #0x4]
 80189cc: 3304         	adds	r3, #0x4
 80189ce: 4618         	mov	r0, r3
 80189d0: f7ff ffe7    	bl	0x80189a2 <spi_cs_is_gpio> @ imm = #-0x32
 80189d4: 4603         	mov	r3, r0
; }
 80189d6: 4618         	mov	r0, r3
 80189d8: 3708         	adds	r7, #0x8
 80189da: 46bd         	mov	sp, r7
 80189dc: bd80         	pop	{r7, pc}

080189de <spi_is_ready_dt>:
; {
 80189de: b580         	push	{r7, lr}
 80189e0: b082         	sub	sp, #0x8
 80189e2: af00         	add	r7, sp, #0x0
 80189e4: 6078         	str	r0, [r7, #0x4]
; 	if (!device_is_ready(spec->bus)) {
 80189e6: 687b         	ldr	r3, [r7, #0x4]
 80189e8: 681b         	ldr	r3, [r3]
 80189ea: 4618         	mov	r0, r3
 80189ec: f7ff ff67    	bl	0x80188be <device_is_ready> @ imm = #-0x132
 80189f0: 4603         	mov	r3, r0
 80189f2: f083 0301    	eor	r3, r3, #0x1
 80189f6: b2db         	uxtb	r3, r3
 80189f8: 2b00         	cmp	r3, #0x0
 80189fa: d001         	beq	0x8018a00 <spi_is_ready_dt+0x22> @ imm = #0x2
; 		return false;
 80189fc: 2300         	movs	r3, #0x0
 80189fe: e013         	b	0x8018a28 <spi_is_ready_dt+0x4a> @ imm = #0x26
; 	if (spi_cs_is_gpio_dt(spec) &&
 8018a00: 6878         	ldr	r0, [r7, #0x4]
 8018a02: f7ff ffde    	bl	0x80189c2 <spi_cs_is_gpio_dt> @ imm = #-0x44
 8018a06: 4603         	mov	r3, r0
 8018a08: 2b00         	cmp	r3, #0x0
 8018a0a: d00c         	beq	0x8018a26 <spi_is_ready_dt+0x48> @ imm = #0x18
; 	    !gpio_is_ready_dt(&spec->config.cs.gpio)) {
 8018a0c: 687b         	ldr	r3, [r7, #0x4]
 8018a0e: 330c         	adds	r3, #0xc
 8018a10: 4618         	mov	r0, r3
 8018a12: f7ff ffb8    	bl	0x8018986 <gpio_is_ready_dt> @ imm = #-0x90
 8018a16: 4603         	mov	r3, r0
 8018a18: f083 0301    	eor	r3, r3, #0x1
 8018a1c: b2db         	uxtb	r3, r3
; 	if (spi_cs_is_gpio_dt(spec) &&
 8018a1e: 2b00         	cmp	r3, #0x0
 8018a20: d001         	beq	0x8018a26 <spi_is_ready_dt+0x48> @ imm = #0x2
; 		return false;
 8018a22: 2300         	movs	r3, #0x0
 8018a24: e000         	b	0x8018a28 <spi_is_ready_dt+0x4a> @ imm = #0x0
; 	return true;
 8018a26: 2301         	movs	r3, #0x1
; }
 8018a28: 4618         	mov	r0, r3
 8018a2a: 3708         	adds	r7, #0x8
 8018a2c: 46bd         	mov	sp, r7
 8018a2e: bd80         	pop	{r7, pc}

08018a30 <z_impl_spi_transceive>:
; {
 8018a30: b590         	push	{r4, r7, lr}
 8018a32: b087         	sub	sp, #0x1c
 8018a34: af00         	add	r7, sp, #0x0
 8018a36: 60f8         	str	r0, [r7, #0xc]
 8018a38: 60b9         	str	r1, [r7, #0x8]
 8018a3a: 607a         	str	r2, [r7, #0x4]
 8018a3c: 603b         	str	r3, [r7]
; 	const struct spi_driver_api *api =
 8018a3e: 68fb         	ldr	r3, [r7, #0xc]
 8018a40: 689b         	ldr	r3, [r3, #0x8]
 8018a42: 617b         	str	r3, [r7, #0x14]
; 	ret = api->transceive(dev, config, tx_bufs, rx_bufs);
 8018a44: 697b         	ldr	r3, [r7, #0x14]
 8018a46: 681c         	ldr	r4, [r3]
 8018a48: 683b         	ldr	r3, [r7]
 8018a4a: 687a         	ldr	r2, [r7, #0x4]
 8018a4c: 68b9         	ldr	r1, [r7, #0x8]
 8018a4e: 68f8         	ldr	r0, [r7, #0xc]
 8018a50: 47a0         	blx	r4
 8018a52: 6138         	str	r0, [r7, #0x10]
; 	return ret;
 8018a54: 693b         	ldr	r3, [r7, #0x10]
; }
 8018a56: 4618         	mov	r0, r3
 8018a58: 371c         	adds	r7, #0x1c
 8018a5a: 46bd         	mov	sp, r7
 8018a5c: bd90         	pop	{r4, r7, pc}

08018a5e <spi_transceive_dt>:
; {
 8018a5e: b580         	push	{r7, lr}
 8018a60: b084         	sub	sp, #0x10
 8018a62: af00         	add	r7, sp, #0x0
 8018a64: 60f8         	str	r0, [r7, #0xc]
 8018a66: 60b9         	str	r1, [r7, #0x8]
 8018a68: 607a         	str	r2, [r7, #0x4]
; 	return spi_transceive(spec->bus, &spec->config, tx_bufs, rx_bufs);
 8018a6a: 68fb         	ldr	r3, [r7, #0xc]
 8018a6c: 6818         	ldr	r0, [r3]
 8018a6e: 68fb         	ldr	r3, [r7, #0xc]
 8018a70: 1d19         	adds	r1, r3, #0x4
 8018a72: 687b         	ldr	r3, [r7, #0x4]
 8018a74: 68ba         	ldr	r2, [r7, #0x8]
 8018a76: f000 f828    	bl	0x8018aca <spi_transceive> @ imm = #0x50
 8018a7a: 4603         	mov	r3, r0
; }
 8018a7c: 4618         	mov	r0, r3
 8018a7e: 3710         	adds	r7, #0x10
 8018a80: 46bd         	mov	sp, r7
 8018a82: bd80         	pop	{r7, pc}

08018a84 <spi_write>:
; {
 8018a84: b580         	push	{r7, lr}
 8018a86: b084         	sub	sp, #0x10
 8018a88: af00         	add	r7, sp, #0x0
 8018a8a: 60f8         	str	r0, [r7, #0xc]
 8018a8c: 60b9         	str	r1, [r7, #0x8]
 8018a8e: 607a         	str	r2, [r7, #0x4]
; 	return spi_transceive(dev, config, tx_bufs, NULL);
 8018a90: 2300         	movs	r3, #0x0
 8018a92: 687a         	ldr	r2, [r7, #0x4]
 8018a94: 68b9         	ldr	r1, [r7, #0x8]
 8018a96: 68f8         	ldr	r0, [r7, #0xc]
 8018a98: f000 f817    	bl	0x8018aca <spi_transceive> @ imm = #0x2e
 8018a9c: 4603         	mov	r3, r0
; }
 8018a9e: 4618         	mov	r0, r3
 8018aa0: 3710         	adds	r7, #0x10
 8018aa2: 46bd         	mov	sp, r7
 8018aa4: bd80         	pop	{r7, pc}

08018aa6 <spi_write_dt>:
; {
 8018aa6: b580         	push	{r7, lr}
 8018aa8: b082         	sub	sp, #0x8
 8018aaa: af00         	add	r7, sp, #0x0
 8018aac: 6078         	str	r0, [r7, #0x4]
 8018aae: 6039         	str	r1, [r7]
; 	return spi_write(spec->bus, &spec->config, tx_bufs);
 8018ab0: 687b         	ldr	r3, [r7, #0x4]
 8018ab2: 6818         	ldr	r0, [r3]
 8018ab4: 687b         	ldr	r3, [r7, #0x4]
 8018ab6: 3304         	adds	r3, #0x4
 8018ab8: 683a         	ldr	r2, [r7]
 8018aba: 4619         	mov	r1, r3
 8018abc: f7ff ffe2    	bl	0x8018a84 <spi_write>   @ imm = #-0x3c
 8018ac0: 4603         	mov	r3, r0
; }
 8018ac2: 4618         	mov	r0, r3
 8018ac4: 3708         	adds	r7, #0x8
 8018ac6: 46bd         	mov	sp, r7
 8018ac8: bd80         	pop	{r7, pc}

08018aca <spi_transceive>:
; {
 8018aca: b580         	push	{r7, lr}
 8018acc: b084         	sub	sp, #0x10
 8018ace: af00         	add	r7, sp, #0x0
 8018ad0: 60f8         	str	r0, [r7, #0xc]
 8018ad2: 60b9         	str	r1, [r7, #0x8]
 8018ad4: 607a         	str	r2, [r7, #0x4]
 8018ad6: 603b         	str	r3, [r7]
; 	return z_impl_spi_transceive(dev, config, tx_bufs, rx_bufs);
 8018ad8: 683b         	ldr	r3, [r7]
 8018ada: 687a         	ldr	r2, [r7, #0x4]
 8018adc: 68b9         	ldr	r1, [r7, #0x8]
 8018ade: 68f8         	ldr	r0, [r7, #0xc]
 8018ae0: f7ff ffa6    	bl	0x8018a30 <z_impl_spi_transceive> @ imm = #-0xb4
 8018ae4: 4603         	mov	r3, r0
; }
 8018ae6: 4618         	mov	r0, r3
 8018ae8: 3710         	adds	r7, #0x10
 8018aea: 46bd         	mov	sp, r7
 8018aec: bd80         	pop	{r7, pc}

08018aee <bmi08x_gyro_transceive_spi>:
; {
 8018aee: b580         	push	{r7, lr}
 8018af0: b092         	sub	sp, #0x48
 8018af2: af00         	add	r7, sp, #0x0
 8018af4: 60f8         	str	r0, [r7, #0xc]
 8018af6: 607b         	str	r3, [r7, #0x4]
 8018af8: 460b         	mov	r3, r1
 8018afa: 72fb         	strb	r3, [r7, #0xb]
 8018afc: 4613         	mov	r3, r2
 8018afe: 72bb         	strb	r3, [r7, #0xa]
; 	const struct bmi08x_gyro_config *bmi08x = dev->config;
 8018b00: 68fb         	ldr	r3, [r7, #0xc]
 8018b02: 685b         	ldr	r3, [r3, #0x4]
 8018b04: 647b         	str	r3, [r7, #0x44]
; 	const struct spi_buf tx_buf[2] = {{.buf = &reg, .len = 1}, {.buf = data, .len = length}};
 8018b06: f107 030b    	add.w	r3, r7, #0xb
 8018b0a: 637b         	str	r3, [r7, #0x34]
 8018b0c: 2301         	movs	r3, #0x1
 8018b0e: 63bb         	str	r3, [r7, #0x38]
 8018b10: 687b         	ldr	r3, [r7, #0x4]
 8018b12: 63fb         	str	r3, [r7, #0x3c]
 8018b14: 6d3b         	ldr	r3, [r7, #0x50]
 8018b16: 643b         	str	r3, [r7, #0x40]
; 	const struct spi_buf_set tx = {.buffers = tx_buf, .count = write ? 2 : 1};
 8018b18: f107 0334    	add.w	r3, r7, #0x34
 8018b1c: 62fb         	str	r3, [r7, #0x2c]
 8018b1e: 7abb         	ldrb	r3, [r7, #0xa]
 8018b20: 2b00         	cmp	r3, #0x0
 8018b22: d001         	beq	0x8018b28 <bmi08x_gyro_transceive_spi+0x3a> @ imm = #0x2
 8018b24: 2302         	movs	r3, #0x2
 8018b26: e000         	b	0x8018b2a <bmi08x_gyro_transceive_spi+0x3c> @ imm = #0x0
 8018b28: 2301         	movs	r3, #0x1
 8018b2a: 633b         	str	r3, [r7, #0x30]
; 	if (!write) {
 8018b2c: 7abb         	ldrb	r3, [r7, #0xa]
 8018b2e: f083 0301    	eor	r3, r3, #0x1
 8018b32: b2db         	uxtb	r3, r3
 8018b34: 2b00         	cmp	r3, #0x0
 8018b36: d017         	beq	0x8018b68 <bmi08x_gyro_transceive_spi+0x7a> @ imm = #0x2e
; 		const struct spi_buf rx_buf[2] = {{.buf = &dummy, .len = 1},
 8018b38: f107 032a    	add.w	r3, r7, #0x2a
 8018b3c: 61bb         	str	r3, [r7, #0x18]
 8018b3e: 2301         	movs	r3, #0x1
 8018b40: 61fb         	str	r3, [r7, #0x1c]
 8018b42: 687b         	ldr	r3, [r7, #0x4]
 8018b44: 623b         	str	r3, [r7, #0x20]
 8018b46: 6d3b         	ldr	r3, [r7, #0x50]
 8018b48: 627b         	str	r3, [r7, #0x24]
; 		const struct spi_buf_set rx = {.buffers = rx_buf, .count = 2};
 8018b4a: f107 0318    	add.w	r3, r7, #0x18
 8018b4e: 613b         	str	r3, [r7, #0x10]
 8018b50: 2302         	movs	r3, #0x2
 8018b52: 617b         	str	r3, [r7, #0x14]
; 		return spi_transceive_dt(&bmi08x->bus.spi, &tx, &rx);
 8018b54: 6c7b         	ldr	r3, [r7, #0x44]
 8018b56: f107 0210    	add.w	r2, r7, #0x10
 8018b5a: f107 012c    	add.w	r1, r7, #0x2c
 8018b5e: 4618         	mov	r0, r3
 8018b60: f7ff ff7d    	bl	0x8018a5e <spi_transceive_dt> @ imm = #-0x106
 8018b64: 4603         	mov	r3, r0
 8018b66: e007         	b	0x8018b78 <bmi08x_gyro_transceive_spi+0x8a> @ imm = #0xe
; 	return spi_write_dt(&bmi08x->bus.spi, &tx);
 8018b68: 6c7b         	ldr	r3, [r7, #0x44]
 8018b6a: f107 022c    	add.w	r2, r7, #0x2c
 8018b6e: 4611         	mov	r1, r2
 8018b70: 4618         	mov	r0, r3
 8018b72: f7ff ff98    	bl	0x8018aa6 <spi_write_dt> @ imm = #-0xd0
 8018b76: 4603         	mov	r3, r0
; }
 8018b78: 4618         	mov	r0, r3
 8018b7a: 3748         	adds	r7, #0x48
 8018b7c: 46bd         	mov	sp, r7
 8018b7e: bd80         	pop	{r7, pc}

08018b80 <bmi08x_bus_check_spi>:
; {
 8018b80: b580         	push	{r7, lr}
 8018b82: b082         	sub	sp, #0x8
 8018b84: af00         	add	r7, sp, #0x0
 8018b86: 6078         	str	r0, [r7, #0x4]
; 	return spi_is_ready_dt(&bus->spi) ? 0 : -ENODEV;
 8018b88: 687b         	ldr	r3, [r7, #0x4]
 8018b8a: 4618         	mov	r0, r3
 8018b8c: f7ff ff27    	bl	0x80189de <spi_is_ready_dt> @ imm = #-0x1b2
 8018b90: 4603         	mov	r3, r0
 8018b92: 2b00         	cmp	r3, #0x0
 8018b94: d001         	beq	0x8018b9a <bmi08x_bus_check_spi+0x1a> @ imm = #0x2
 8018b96: 2300         	movs	r3, #0x0
 8018b98: e001         	b	0x8018b9e <bmi08x_bus_check_spi+0x1e> @ imm = #0x2
 8018b9a: f06f 0312    	mvn	r3, #0x12
; }
 8018b9e: 4618         	mov	r0, r3
 8018ba0: 3708         	adds	r7, #0x8
 8018ba2: 46bd         	mov	sp, r7
 8018ba4: bd80         	pop	{r7, pc}

08018ba6 <bmi08x_bus_check>:
; {
 8018ba6: b580         	push	{r7, lr}
 8018ba8: b084         	sub	sp, #0x10
 8018baa: af00         	add	r7, sp, #0x0
 8018bac: 6078         	str	r0, [r7, #0x4]
; 	const struct bmi08x_gyro_config *config = dev->config;
 8018bae: 687b         	ldr	r3, [r7, #0x4]
 8018bb0: 685b         	ldr	r3, [r3, #0x4]
 8018bb2: 60fb         	str	r3, [r7, #0xc]
; 	return config->api->check(&config->bus);
 8018bb4: 68fb         	ldr	r3, [r7, #0xc]
 8018bb6: 699b         	ldr	r3, [r3, #0x18]
 8018bb8: 681b         	ldr	r3, [r3]
 8018bba: 68fa         	ldr	r2, [r7, #0xc]
 8018bbc: 4610         	mov	r0, r2
 8018bbe: 4798         	blx	r3
 8018bc0: 4603         	mov	r3, r0
; }
 8018bc2: 4618         	mov	r0, r3
 8018bc4: 3710         	adds	r7, #0x10
 8018bc6: 46bd         	mov	sp, r7
 8018bc8: bd80         	pop	{r7, pc}

08018bca <bmi08x_gyro_transceive>:
; {
 8018bca: b590         	push	{r4, r7, lr}
 8018bcc: b089         	sub	sp, #0x24
 8018bce: af02         	add	r7, sp, #0x8
 8018bd0: 60f8         	str	r0, [r7, #0xc]
 8018bd2: 607b         	str	r3, [r7, #0x4]
 8018bd4: 460b         	mov	r3, r1
 8018bd6: 72fb         	strb	r3, [r7, #0xb]
 8018bd8: 4613         	mov	r3, r2
 8018bda: 72bb         	strb	r3, [r7, #0xa]
; 	const struct bmi08x_gyro_config *cfg = dev->config;
 8018bdc: 68fb         	ldr	r3, [r7, #0xc]
 8018bde: 685b         	ldr	r3, [r3, #0x4]
 8018be0: 617b         	str	r3, [r7, #0x14]
; 	return cfg->api->transceive(dev, reg, write, data, length);
 8018be2: 697b         	ldr	r3, [r7, #0x14]
 8018be4: 699b         	ldr	r3, [r3, #0x18]
 8018be6: 685c         	ldr	r4, [r3, #0x4]
 8018be8: 7aba         	ldrb	r2, [r7, #0xa]
 8018bea: 7af9         	ldrb	r1, [r7, #0xb]
 8018bec: 6abb         	ldr	r3, [r7, #0x28]
 8018bee: 9300         	str	r3, [sp]
 8018bf0: 687b         	ldr	r3, [r7, #0x4]
 8018bf2: 68f8         	ldr	r0, [r7, #0xc]
 8018bf4: 47a0         	blx	r4
 8018bf6: 4603         	mov	r3, r0
; }
 8018bf8: 4618         	mov	r0, r3
 8018bfa: 371c         	adds	r7, #0x1c
 8018bfc: 46bd         	mov	sp, r7
 8018bfe: bd90         	pop	{r4, r7, pc}

08018c00 <bmi08x_gyro_read>:
; {
 8018c00: b580         	push	{r7, lr}
 8018c02: b086         	sub	sp, #0x18
 8018c04: af02         	add	r7, sp, #0x8
 8018c06: 60f8         	str	r0, [r7, #0xc]
 8018c08: 607a         	str	r2, [r7, #0x4]
 8018c0a: 461a         	mov	r2, r3
 8018c0c: 460b         	mov	r3, r1
 8018c0e: 72fb         	strb	r3, [r7, #0xb]
 8018c10: 4613         	mov	r3, r2
 8018c12: 72bb         	strb	r3, [r7, #0xa]
; 	return bmi08x_gyro_transceive(dev, reg_addr | BIT(7), false, data, len);
 8018c14: 7afb         	ldrb	r3, [r7, #0xb]
 8018c16: f063 037f    	orn	r3, r3, #0x7f
 8018c1a: b2d9         	uxtb	r1, r3
 8018c1c: 7abb         	ldrb	r3, [r7, #0xa]
 8018c1e: 9300         	str	r3, [sp]
 8018c20: 687b         	ldr	r3, [r7, #0x4]
 8018c22: 2200         	movs	r2, #0x0
 8018c24: 68f8         	ldr	r0, [r7, #0xc]
 8018c26: f7ff ffd0    	bl	0x8018bca <bmi08x_gyro_transceive> @ imm = #-0x60
 8018c2a: 4603         	mov	r3, r0
; }
 8018c2c: 4618         	mov	r0, r3
 8018c2e: 3710         	adds	r7, #0x10
 8018c30: 46bd         	mov	sp, r7
 8018c32: bd80         	pop	{r7, pc}

08018c34 <bmi08x_gyro_byte_read>:
; {
 8018c34: b580         	push	{r7, lr}
 8018c36: b086         	sub	sp, #0x18
 8018c38: af02         	add	r7, sp, #0x8
 8018c3a: 60f8         	str	r0, [r7, #0xc]
 8018c3c: 460b         	mov	r3, r1
 8018c3e: 607a         	str	r2, [r7, #0x4]
 8018c40: 72fb         	strb	r3, [r7, #0xb]
; 	return bmi08x_gyro_transceive(dev, reg_addr | BIT(7), false, byte, 1);
 8018c42: 7afb         	ldrb	r3, [r7, #0xb]
 8018c44: f063 037f    	orn	r3, r3, #0x7f
 8018c48: b2d9         	uxtb	r1, r3
 8018c4a: 2301         	movs	r3, #0x1
 8018c4c: 9300         	str	r3, [sp]
 8018c4e: 687b         	ldr	r3, [r7, #0x4]
 8018c50: 2200         	movs	r2, #0x0
 8018c52: 68f8         	ldr	r0, [r7, #0xc]
 8018c54: f7ff ffb9    	bl	0x8018bca <bmi08x_gyro_transceive> @ imm = #-0x8e
 8018c58: 4603         	mov	r3, r0
; }
 8018c5a: 4618         	mov	r0, r3
 8018c5c: 3710         	adds	r7, #0x10
 8018c5e: 46bd         	mov	sp, r7
 8018c60: bd80         	pop	{r7, pc}

08018c62 <bmi08x_gyro_byte_write>:
; {
 8018c62: b580         	push	{r7, lr}
 8018c64: b084         	sub	sp, #0x10
 8018c66: af02         	add	r7, sp, #0x8
 8018c68: 6078         	str	r0, [r7, #0x4]
 8018c6a: 460b         	mov	r3, r1
 8018c6c: 70fb         	strb	r3, [r7, #0x3]
 8018c6e: 4613         	mov	r3, r2
 8018c70: 70bb         	strb	r3, [r7, #0x2]
; 	return bmi08x_gyro_transceive(dev, reg_addr & 0x7F, true, &byte, 1);
 8018c72: 78fb         	ldrb	r3, [r7, #0x3]
 8018c74: f003 037f    	and	r3, r3, #0x7f
 8018c78: b2d9         	uxtb	r1, r3
 8018c7a: 1cbb         	adds	r3, r7, #0x2
 8018c7c: 2201         	movs	r2, #0x1
 8018c7e: 9200         	str	r2, [sp]
 8018c80: 2201         	movs	r2, #0x1
 8018c82: 6878         	ldr	r0, [r7, #0x4]
 8018c84: f7ff ffa1    	bl	0x8018bca <bmi08x_gyro_transceive> @ imm = #-0xbe
 8018c88: 4603         	mov	r3, r0
; }
 8018c8a: 4618         	mov	r0, r3
 8018c8c: 3708         	adds	r7, #0x8
 8018c8e: 46bd         	mov	sp, r7
 8018c90: bd80         	pop	{r7, pc}

08018c92 <bmi08x_gyr_odr_set>:
; {
 8018c92: b580         	push	{r7, lr}
 8018c94: b084         	sub	sp, #0x10
 8018c96: af00         	add	r7, sp, #0x0
 8018c98: 6078         	str	r0, [r7, #0x4]
 8018c9a: 460b         	mov	r3, r1
 8018c9c: 807b         	strh	r3, [r7, #0x2]
 8018c9e: 4613         	mov	r3, r2
 8018ca0: 803b         	strh	r3, [r7]
; 	int odr = bmi08x_freq_to_odr_val(freq_int, freq_milli);
 8018ca2: 883a         	ldrh	r2, [r7]
 8018ca4: 887b         	ldrh	r3, [r7, #0x2]
 8018ca6: 4611         	mov	r1, r2
 8018ca8: 4618         	mov	r0, r3
 8018caa: f7f0 fd2f    	bl	0x800970c <bmi08x_freq_to_odr_val> @ imm = #-0xf5a2
 8018cae: 60f8         	str	r0, [r7, #0xc]
; 	if (odr < 0) {
 8018cb0: 68fb         	ldr	r3, [r7, #0xc]
 8018cb2: 2b00         	cmp	r3, #0x0
 8018cb4: da01         	bge	0x8018cba <bmi08x_gyr_odr_set+0x28> @ imm = #0x2
; 		return odr;
 8018cb6: 68fb         	ldr	r3, [r7, #0xc]
 8018cb8: e010         	b	0x8018cdc <bmi08x_gyr_odr_set+0x4a> @ imm = #0x20
; 	if (odr < BMI08X_GYRO_BW_532_ODR_2000_HZ || odr > BMI08X_GYRO_BW_32_ODR_100_HZ) {
 8018cba: 68fb         	ldr	r3, [r7, #0xc]
 8018cbc: 2b00         	cmp	r3, #0x0
 8018cbe: db02         	blt	0x8018cc6 <bmi08x_gyr_odr_set+0x34> @ imm = #0x4
 8018cc0: 68fb         	ldr	r3, [r7, #0xc]
 8018cc2: 2b07         	cmp	r3, #0x7
 8018cc4: dd02         	ble	0x8018ccc <bmi08x_gyr_odr_set+0x3a> @ imm = #0x4
; 		return -ENOTSUP;
 8018cc6: f06f 0385    	mvn	r3, #0x85
 8018cca: e007         	b	0x8018cdc <bmi08x_gyr_odr_set+0x4a> @ imm = #0xe
; 	return bmi08x_gyro_byte_write(dev, BMI08X_REG_GYRO_BANDWIDTH, (uint8_t)odr);
 8018ccc: 68fb         	ldr	r3, [r7, #0xc]
 8018cce: b2db         	uxtb	r3, r3
 8018cd0: 461a         	mov	r2, r3
 8018cd2: 2110         	movs	r1, #0x10
 8018cd4: 6878         	ldr	r0, [r7, #0x4]
 8018cd6: f7ff ffc4    	bl	0x8018c62 <bmi08x_gyro_byte_write> @ imm = #-0x78
 8018cda: 4603         	mov	r3, r0
; }
 8018cdc: 4618         	mov	r0, r3
 8018cde: 3710         	adds	r7, #0x10
 8018ce0: 46bd         	mov	sp, r7
 8018ce2: bd80         	pop	{r7, pc}

08018ce4 <bmi08x_channel_convert>:
; {
 8018ce4: b580         	push	{r7, lr}
 8018ce6: b086         	sub	sp, #0x18
 8018ce8: af00         	add	r7, sp, #0x0
 8018cea: 60ba         	str	r2, [r7, #0x8]
 8018cec: 607b         	str	r3, [r7, #0x4]
 8018cee: 4603         	mov	r3, r0
 8018cf0: 81fb         	strh	r3, [r7, #0xe]
 8018cf2: 460b         	mov	r3, r1
 8018cf4: 81bb         	strh	r3, [r7, #0xc]
; 	switch (chan) {
 8018cf6: 89fb         	ldrh	r3, [r7, #0xe]
 8018cf8: 2b06         	cmp	r3, #0x6
 8018cfa: d010         	beq	0x8018d1e <bmi08x_channel_convert+0x3a> @ imm = #0x20
 8018cfc: 2b06         	cmp	r3, #0x6
 8018cfe: dc13         	bgt	0x8018d28 <bmi08x_channel_convert+0x44> @ imm = #0x26
 8018d00: 2b04         	cmp	r3, #0x4
 8018d02: d002         	beq	0x8018d0a <bmi08x_channel_convert+0x26> @ imm = #0x4
 8018d04: 2b05         	cmp	r3, #0x5
 8018d06: d005         	beq	0x8018d14 <bmi08x_channel_convert+0x30> @ imm = #0xa
 8018d08: e00e         	b	0x8018d28 <bmi08x_channel_convert+0x44> @ imm = #0x1c
; 		ofs_start = ofs_stop = 0U;
 8018d0a: 2300         	movs	r3, #0x0
 8018d0c: 74bb         	strb	r3, [r7, #0x12]
 8018d0e: 7cbb         	ldrb	r3, [r7, #0x12]
 8018d10: 74fb         	strb	r3, [r7, #0x13]
; 		break;
 8018d12: e00e         	b	0x8018d32 <bmi08x_channel_convert+0x4e> @ imm = #0x1c
; 		ofs_start = ofs_stop = 1U;
 8018d14: 2301         	movs	r3, #0x1
 8018d16: 74bb         	strb	r3, [r7, #0x12]
 8018d18: 7cbb         	ldrb	r3, [r7, #0x12]
 8018d1a: 74fb         	strb	r3, [r7, #0x13]
; 		break;
 8018d1c: e009         	b	0x8018d32 <bmi08x_channel_convert+0x4e> @ imm = #0x12
; 		ofs_start = ofs_stop = 2U;
 8018d1e: 2302         	movs	r3, #0x2
 8018d20: 74bb         	strb	r3, [r7, #0x12]
 8018d22: 7cbb         	ldrb	r3, [r7, #0x12]
 8018d24: 74fb         	strb	r3, [r7, #0x13]
; 		break;
 8018d26: e004         	b	0x8018d32 <bmi08x_channel_convert+0x4e> @ imm = #0x8
; 		ofs_start = 0U;
 8018d28: 2300         	movs	r3, #0x0
 8018d2a: 74fb         	strb	r3, [r7, #0x13]
; 		ofs_stop = 2U;
 8018d2c: 2302         	movs	r3, #0x2
 8018d2e: 74bb         	strb	r3, [r7, #0x12]
; 		break;
 8018d30: bf00         	nop
; 	for (i = ofs_start; i <= ofs_stop; i++, val++) {
 8018d32: 7cfb         	ldrb	r3, [r7, #0x13]
 8018d34: 617b         	str	r3, [r7, #0x14]
 8018d36: e010         	b	0x8018d5a <bmi08x_channel_convert+0x76> @ imm = #0x20
; 		bmi08x_to_fixed_point(raw_xyz[i], scale, val);
 8018d38: 697b         	ldr	r3, [r7, #0x14]
 8018d3a: 005b         	lsls	r3, r3, #0x1
 8018d3c: 68ba         	ldr	r2, [r7, #0x8]
 8018d3e: 4413         	add	r3, r2
 8018d40: 881b         	ldrh	r3, [r3]
 8018d42: b21b         	sxth	r3, r3
 8018d44: 89b9         	ldrh	r1, [r7, #0xc]
 8018d46: 687a         	ldr	r2, [r7, #0x4]
 8018d48: 4618         	mov	r0, r3
 8018d4a: f7f0 fac3    	bl	0x80092d4 <bmi08x_to_fixed_point> @ imm = #-0xfa7a
; 	for (i = ofs_start; i <= ofs_stop; i++, val++) {
 8018d4e: 697b         	ldr	r3, [r7, #0x14]
 8018d50: 3301         	adds	r3, #0x1
 8018d52: 617b         	str	r3, [r7, #0x14]
 8018d54: 687b         	ldr	r3, [r7, #0x4]
 8018d56: 3308         	adds	r3, #0x8
 8018d58: 607b         	str	r3, [r7, #0x4]
 8018d5a: 7cbb         	ldrb	r3, [r7, #0x12]
 8018d5c: 697a         	ldr	r2, [r7, #0x14]
 8018d5e: 429a         	cmp	r2, r3
 8018d60: ddea         	ble	0x8018d38 <bmi08x_channel_convert+0x54> @ imm = #-0x2c
; }
 8018d62: bf00         	nop
 8018d64: bf00         	nop
 8018d66: 3718         	adds	r7, #0x18
 8018d68: 46bd         	mov	sp, r7
 8018d6a: bd80         	pop	{r7, pc}

08018d6c <bmi08x_gyr_channel_get>:
; {
 8018d6c: b580         	push	{r7, lr}
 8018d6e: b086         	sub	sp, #0x18
 8018d70: af00         	add	r7, sp, #0x0
 8018d72: 60f8         	str	r0, [r7, #0xc]
 8018d74: 460b         	mov	r3, r1
 8018d76: 607a         	str	r2, [r7, #0x4]
 8018d78: 817b         	strh	r3, [r7, #0xa]
; 	struct bmi08x_gyro_data *bmi08x = dev->data;
 8018d7a: 68fb         	ldr	r3, [r7, #0xc]
 8018d7c: 691b         	ldr	r3, [r3, #0x10]
 8018d7e: 617b         	str	r3, [r7, #0x14]
; 	bmi08x_channel_convert(chan, bmi08x->scale, bmi08x->gyr_sample, val);
 8018d80: 697b         	ldr	r3, [r7, #0x14]
 8018d82: 8a59         	ldrh	r1, [r3, #0x12]
 8018d84: 697b         	ldr	r3, [r7, #0x14]
 8018d86: f103 020c    	add.w	r2, r3, #0xc
 8018d8a: 8978         	ldrh	r0, [r7, #0xa]
 8018d8c: 687b         	ldr	r3, [r7, #0x4]
 8018d8e: f7ff ffa9    	bl	0x8018ce4 <bmi08x_channel_convert> @ imm = #-0xae
; }
 8018d92: bf00         	nop
 8018d94: 3718         	adds	r7, #0x18
 8018d96: 46bd         	mov	sp, r7
 8018d98: bd80         	pop	{r7, pc}

08018d9a <bmi08x_range_to_reg_val>:
; {
 8018d9a: b480         	push	{r7}
 8018d9c: b085         	sub	sp, #0x14
 8018d9e: af00         	add	r7, sp, #0x0
 8018da0: 4603         	mov	r3, r0
 8018da2: 6039         	str	r1, [r7]
 8018da4: 80fb         	strh	r3, [r7, #0x6]
 8018da6: 4613         	mov	r3, r2
 8018da8: 80bb         	strh	r3, [r7, #0x4]
; 	for (i = 0; i < range_map_size; i++) {
 8018daa: 2300         	movs	r3, #0x0
 8018dac: 60fb         	str	r3, [r7, #0xc]
 8018dae: e010         	b	0x8018dd2 <bmi08x_range_to_reg_val+0x38> @ imm = #0x20
; 		if (range <= range_map[i].range) {
 8018db0: 68fb         	ldr	r3, [r7, #0xc]
 8018db2: 009b         	lsls	r3, r3, #0x2
 8018db4: 683a         	ldr	r2, [r7]
 8018db6: 4413         	add	r3, r2
 8018db8: 881b         	ldrh	r3, [r3]
 8018dba: 88fa         	ldrh	r2, [r7, #0x6]
 8018dbc: 429a         	cmp	r2, r3
 8018dbe: d805         	bhi	0x8018dcc <bmi08x_range_to_reg_val+0x32> @ imm = #0xa
; 			return range_map[i].reg_val;
 8018dc0: 68fb         	ldr	r3, [r7, #0xc]
 8018dc2: 009b         	lsls	r3, r3, #0x2
 8018dc4: 683a         	ldr	r2, [r7]
 8018dc6: 4413         	add	r3, r2
 8018dc8: 789b         	ldrb	r3, [r3, #0x2]
 8018dca: e008         	b	0x8018dde <bmi08x_range_to_reg_val+0x44> @ imm = #0x10
; 	for (i = 0; i < range_map_size; i++) {
 8018dcc: 68fb         	ldr	r3, [r7, #0xc]
 8018dce: 3301         	adds	r3, #0x1
 8018dd0: 60fb         	str	r3, [r7, #0xc]
 8018dd2: 88bb         	ldrh	r3, [r7, #0x4]
 8018dd4: 68fa         	ldr	r2, [r7, #0xc]
 8018dd6: 429a         	cmp	r2, r3
 8018dd8: dbea         	blt	0x8018db0 <bmi08x_range_to_reg_val+0x16> @ imm = #-0x2c
; 	return -EINVAL;
 8018dda: f06f 0315    	mvn	r3, #0x15
; }
 8018dde: 4618         	mov	r0, r3
 8018de0: 3714         	adds	r7, #0x14
 8018de2: 46bd         	mov	sp, r7
 8018de4: bc80         	pop	{r7}
 8018de6: 4770         	bx	lr

08018de8 <device_is_ready>:
; {
 8018de8: b580         	push	{r7, lr}
 8018dea: b082         	sub	sp, #0x8
 8018dec: af00         	add	r7, sp, #0x0
 8018dee: 6078         	str	r0, [r7, #0x4]
; 	return z_impl_device_is_ready(dev);
 8018df0: 6878         	ldr	r0, [r7, #0x4]
 8018df2: f002 fec4    	bl	0x801bb7e <z_impl_device_is_ready> @ imm = #0x2d88
 8018df6: 4603         	mov	r3, r0
; }
 8018df8: 4618         	mov	r0, r3
 8018dfa: 3708         	adds	r7, #0x8
 8018dfc: 46bd         	mov	sp, r7
 8018dfe: bd80         	pop	{r7, pc}

08018e00 <gpio_is_ready_dt>:
; {
 8018e00: b580         	push	{r7, lr}
 8018e02: b082         	sub	sp, #0x8
 8018e04: af00         	add	r7, sp, #0x0
 8018e06: 6078         	str	r0, [r7, #0x4]
; 	return device_is_ready(spec->port);
 8018e08: 687b         	ldr	r3, [r7, #0x4]
 8018e0a: 681b         	ldr	r3, [r3]
 8018e0c: 4618         	mov	r0, r3
 8018e0e: f7ff ffeb    	bl	0x8018de8 <device_is_ready> @ imm = #-0x2a
 8018e12: 4603         	mov	r3, r0
; }
 8018e14: 4618         	mov	r0, r3
 8018e16: 3708         	adds	r7, #0x8
 8018e18: 46bd         	mov	sp, r7
 8018e1a: bd80         	pop	{r7, pc}

08018e1c <gpio_pin_interrupt_configure_dt>:
; {
 8018e1c: b580         	push	{r7, lr}
 8018e1e: b082         	sub	sp, #0x8
 8018e20: af00         	add	r7, sp, #0x0
 8018e22: 6078         	str	r0, [r7, #0x4]
 8018e24: 6039         	str	r1, [r7]
; 	return gpio_pin_interrupt_configure(spec->port, spec->pin, flags);
 8018e26: 687b         	ldr	r3, [r7, #0x4]
 8018e28: 6818         	ldr	r0, [r3]
 8018e2a: 687b         	ldr	r3, [r7, #0x4]
 8018e2c: 791b         	ldrb	r3, [r3, #0x4]
 8018e2e: 683a         	ldr	r2, [r7]
 8018e30: 4619         	mov	r1, r3
 8018e32: f000 f891    	bl	0x8018f58 <gpio_pin_interrupt_configure> @ imm = #0x122
 8018e36: 4603         	mov	r3, r0
; }
 8018e38: 4618         	mov	r0, r3
 8018e3a: 3708         	adds	r7, #0x8
 8018e3c: 46bd         	mov	sp, r7
 8018e3e: bd80         	pop	{r7, pc}

08018e40 <z_impl_gpio_pin_configure>:
; {
 8018e40: b580         	push	{r7, lr}
 8018e42: b088         	sub	sp, #0x20
 8018e44: af00         	add	r7, sp, #0x0
 8018e46: 60f8         	str	r0, [r7, #0xc]
 8018e48: 460b         	mov	r3, r1
 8018e4a: 607a         	str	r2, [r7, #0x4]
 8018e4c: 72fb         	strb	r3, [r7, #0xb]
; 	const struct gpio_driver_api *api =
 8018e4e: 68fb         	ldr	r3, [r7, #0xc]
 8018e50: 689b         	ldr	r3, [r3, #0x8]
 8018e52: 61fb         	str	r3, [r7, #0x1c]
; 	__unused const struct gpio_driver_config *const cfg =
 8018e54: 68fb         	ldr	r3, [r7, #0xc]
 8018e56: 685b         	ldr	r3, [r3, #0x4]
 8018e58: 61bb         	str	r3, [r7, #0x18]
; 	struct gpio_driver_data *data =
 8018e5a: 68fb         	ldr	r3, [r7, #0xc]
 8018e5c: 691b         	ldr	r3, [r3, #0x10]
 8018e5e: 617b         	str	r3, [r7, #0x14]
; 	if (((flags & GPIO_OUTPUT_INIT_LOGICAL) != 0)
 8018e60: 687b         	ldr	r3, [r7, #0x4]
 8018e62: f403 1380    	and	r3, r3, #0x100000
 8018e66: 2b00         	cmp	r3, #0x0
 8018e68: d00d         	beq	0x8018e86 <z_impl_gpio_pin_configure+0x46> @ imm = #0x1a
; 	    && ((flags & (GPIO_OUTPUT_INIT_LOW | GPIO_OUTPUT_INIT_HIGH)) != 0)
 8018e6a: 687b         	ldr	r3, [r7, #0x4]
 8018e6c: f403 2340    	and	r3, r3, #0xc0000
 8018e70: 2b00         	cmp	r3, #0x0
 8018e72: d008         	beq	0x8018e86 <z_impl_gpio_pin_configure+0x46> @ imm = #0x10
; 	    && ((flags & GPIO_ACTIVE_LOW) != 0)) {
 8018e74: 687b         	ldr	r3, [r7, #0x4]
 8018e76: f003 0301    	and	r3, r3, #0x1
 8018e7a: 2b00         	cmp	r3, #0x0
 8018e7c: d003         	beq	0x8018e86 <z_impl_gpio_pin_configure+0x46> @ imm = #0x6
; 		flags ^= GPIO_OUTPUT_INIT_LOW | GPIO_OUTPUT_INIT_HIGH;
 8018e7e: 687b         	ldr	r3, [r7, #0x4]
 8018e80: f483 2340    	eor	r3, r3, #0xc0000
 8018e84: 607b         	str	r3, [r7, #0x4]
; 	flags &= ~GPIO_OUTPUT_INIT_LOGICAL;
 8018e86: 687b         	ldr	r3, [r7, #0x4]
 8018e88: f423 1380    	bic	r3, r3, #0x100000
 8018e8c: 607b         	str	r3, [r7, #0x4]
; 	if ((flags & GPIO_ACTIVE_LOW) != 0) {
 8018e8e: 687b         	ldr	r3, [r7, #0x4]
 8018e90: f003 0301    	and	r3, r3, #0x1
 8018e94: 2b00         	cmp	r3, #0x0
 8018e96: d009         	beq	0x8018eac <z_impl_gpio_pin_configure+0x6c> @ imm = #0x12
; 		data->invert |= (gpio_port_pins_t)BIT(pin);
 8018e98: 697b         	ldr	r3, [r7, #0x14]
 8018e9a: 681a         	ldr	r2, [r3]
 8018e9c: 7afb         	ldrb	r3, [r7, #0xb]
 8018e9e: 2101         	movs	r1, #0x1
 8018ea0: fa01 f303    	lsl.w	r3, r1, r3
 8018ea4: 431a         	orrs	r2, r3
 8018ea6: 697b         	ldr	r3, [r7, #0x14]
 8018ea8: 601a         	str	r2, [r3]
 8018eaa: e009         	b	0x8018ec0 <z_impl_gpio_pin_configure+0x80> @ imm = #0x12
; 		data->invert &= ~(gpio_port_pins_t)BIT(pin);
 8018eac: 697b         	ldr	r3, [r7, #0x14]
 8018eae: 681a         	ldr	r2, [r3]
 8018eb0: 7afb         	ldrb	r3, [r7, #0xb]
 8018eb2: 2101         	movs	r1, #0x1
 8018eb4: fa01 f303    	lsl.w	r3, r1, r3
 8018eb8: 43db         	mvns	r3, r3
 8018eba: 401a         	ands	r2, r3
 8018ebc: 697b         	ldr	r3, [r7, #0x14]
 8018ebe: 601a         	str	r2, [r3]
; 	return api->pin_configure(port, pin, flags);
 8018ec0: 69fb         	ldr	r3, [r7, #0x1c]
 8018ec2: 681b         	ldr	r3, [r3]
 8018ec4: 7af9         	ldrb	r1, [r7, #0xb]
 8018ec6: 687a         	ldr	r2, [r7, #0x4]
 8018ec8: 68f8         	ldr	r0, [r7, #0xc]
 8018eca: 4798         	blx	r3
 8018ecc: 4603         	mov	r3, r0
; }
 8018ece: 4618         	mov	r0, r3
 8018ed0: 3720         	adds	r7, #0x20
 8018ed2: 46bd         	mov	sp, r7
 8018ed4: bd80         	pop	{r7, pc}

08018ed6 <gpio_pin_configure_dt>:
; {
 8018ed6: b580         	push	{r7, lr}
 8018ed8: b082         	sub	sp, #0x8
 8018eda: af00         	add	r7, sp, #0x0
 8018edc: 6078         	str	r0, [r7, #0x4]
 8018ede: 6039         	str	r1, [r7]
; 	return gpio_pin_configure(spec->port,
 8018ee0: 687b         	ldr	r3, [r7, #0x4]
 8018ee2: 6818         	ldr	r0, [r3]
; 				  spec->pin,
 8018ee4: 687b         	ldr	r3, [r7, #0x4]
 8018ee6: 7919         	ldrb	r1, [r3, #0x4]
; 				  spec->dt_flags | extra_flags);
 8018ee8: 687b         	ldr	r3, [r7, #0x4]
 8018eea: 88db         	ldrh	r3, [r3, #0x6]
 8018eec: 461a         	mov	r2, r3
; 	return gpio_pin_configure(spec->port,
 8018eee: 683b         	ldr	r3, [r7]
 8018ef0: 4313         	orrs	r3, r2
 8018ef2: 461a         	mov	r2, r3
 8018ef4: f000 f842    	bl	0x8018f7c <gpio_pin_configure> @ imm = #0x84
 8018ef8: 4603         	mov	r3, r0
; }
 8018efa: 4618         	mov	r0, r3
 8018efc: 3708         	adds	r7, #0x8
 8018efe: 46bd         	mov	sp, r7
 8018f00: bd80         	pop	{r7, pc}

08018f02 <gpio_init_callback>:
; {
 8018f02: b480         	push	{r7}
 8018f04: b085         	sub	sp, #0x14
 8018f06: af00         	add	r7, sp, #0x0
 8018f08: 60f8         	str	r0, [r7, #0xc]
 8018f0a: 60b9         	str	r1, [r7, #0x8]
 8018f0c: 607a         	str	r2, [r7, #0x4]
; 	callback->handler = handler;
 8018f0e: 68fb         	ldr	r3, [r7, #0xc]
 8018f10: 68ba         	ldr	r2, [r7, #0x8]
 8018f12: 605a         	str	r2, [r3, #0x4]
; 	callback->pin_mask = pin_mask;
 8018f14: 68fb         	ldr	r3, [r7, #0xc]
 8018f16: 687a         	ldr	r2, [r7, #0x4]
 8018f18: 609a         	str	r2, [r3, #0x8]
; }
 8018f1a: bf00         	nop
 8018f1c: 3714         	adds	r7, #0x14
 8018f1e: 46bd         	mov	sp, r7
 8018f20: bc80         	pop	{r7}
 8018f22: 4770         	bx	lr

08018f24 <gpio_add_callback>:
; {
 8018f24: b580         	push	{r7, lr}
 8018f26: b084         	sub	sp, #0x10
 8018f28: af00         	add	r7, sp, #0x0
 8018f2a: 6078         	str	r0, [r7, #0x4]
 8018f2c: 6039         	str	r1, [r7]
; 	const struct gpio_driver_api *api =
 8018f2e: 687b         	ldr	r3, [r7, #0x4]
 8018f30: 689b         	ldr	r3, [r3, #0x8]
 8018f32: 60fb         	str	r3, [r7, #0xc]
; 	if (api->manage_callback == NULL) {
 8018f34: 68fb         	ldr	r3, [r7, #0xc]
 8018f36: 69db         	ldr	r3, [r3, #0x1c]
 8018f38: 2b00         	cmp	r3, #0x0
 8018f3a: d102         	bne	0x8018f42 <gpio_add_callback+0x1e> @ imm = #0x4
; 		return -ENOSYS;
 8018f3c: f06f 0357    	mvn	r3, #0x57
 8018f40: e006         	b	0x8018f50 <gpio_add_callback+0x2c> @ imm = #0xc
; 	return api->manage_callback(port, callback, true);
 8018f42: 68fb         	ldr	r3, [r7, #0xc]
 8018f44: 69db         	ldr	r3, [r3, #0x1c]
 8018f46: 2201         	movs	r2, #0x1
 8018f48: 6839         	ldr	r1, [r7]
 8018f4a: 6878         	ldr	r0, [r7, #0x4]
 8018f4c: 4798         	blx	r3
 8018f4e: 4603         	mov	r3, r0
; }
 8018f50: 4618         	mov	r0, r3
 8018f52: 3710         	adds	r7, #0x10
 8018f54: 46bd         	mov	sp, r7
 8018f56: bd80         	pop	{r7, pc}

08018f58 <gpio_pin_interrupt_configure>:
; {
 8018f58: b580         	push	{r7, lr}
 8018f5a: b084         	sub	sp, #0x10
 8018f5c: af00         	add	r7, sp, #0x0
 8018f5e: 60f8         	str	r0, [r7, #0xc]
 8018f60: 460b         	mov	r3, r1
 8018f62: 607a         	str	r2, [r7, #0x4]
 8018f64: 72fb         	strb	r3, [r7, #0xb]
; 	return z_impl_gpio_pin_interrupt_configure(port, pin, flags);
 8018f66: 7afb         	ldrb	r3, [r7, #0xb]
 8018f68: 687a         	ldr	r2, [r7, #0x4]
 8018f6a: 4619         	mov	r1, r3
 8018f6c: 68f8         	ldr	r0, [r7, #0xc]
 8018f6e: f7f0 fc09    	bl	0x8009784 <z_impl_gpio_pin_interrupt_configure> @ imm = #-0xf7ee
 8018f72: 4603         	mov	r3, r0
; }
 8018f74: 4618         	mov	r0, r3
 8018f76: 3710         	adds	r7, #0x10
 8018f78: 46bd         	mov	sp, r7
 8018f7a: bd80         	pop	{r7, pc}

08018f7c <gpio_pin_configure>:
; {
 8018f7c: b580         	push	{r7, lr}
 8018f7e: b084         	sub	sp, #0x10
 8018f80: af00         	add	r7, sp, #0x0
 8018f82: 60f8         	str	r0, [r7, #0xc]
 8018f84: 460b         	mov	r3, r1
 8018f86: 607a         	str	r2, [r7, #0x4]
 8018f88: 72fb         	strb	r3, [r7, #0xb]
; 	return z_impl_gpio_pin_configure(port, pin, flags);
 8018f8a: 7afb         	ldrb	r3, [r7, #0xb]
 8018f8c: 687a         	ldr	r2, [r7, #0x4]
 8018f8e: 4619         	mov	r1, r3
 8018f90: 68f8         	ldr	r0, [r7, #0xc]
 8018f92: f7ff ff55    	bl	0x8018e40 <z_impl_gpio_pin_configure> @ imm = #-0x156
 8018f96: 4603         	mov	r3, r0
; }
 8018f98: 4618         	mov	r0, r3
 8018f9a: 3710         	adds	r7, #0x10
 8018f9c: 46bd         	mov	sp, r7
 8018f9e: bd80         	pop	{r7, pc}

08018fa0 <k_thread_create>:
; {
 8018fa0: b580         	push	{r7, lr}
 8018fa2: b08c         	sub	sp, #0x30
 8018fa4: af08         	add	r7, sp, #0x20
 8018fa6: 60f8         	str	r0, [r7, #0xc]
 8018fa8: 60b9         	str	r1, [r7, #0x8]
 8018faa: 607a         	str	r2, [r7, #0x4]
 8018fac: 603b         	str	r3, [r7]
; 	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
 8018fae: e9d7 230c    	ldrd	r2, r3, [r7, #48]
 8018fb2: e9cd 2306    	strd	r2, r3, [sp, #24]
 8018fb6: 6abb         	ldr	r3, [r7, #0x28]
 8018fb8: 9304         	str	r3, [sp, #0x10]
 8018fba: 6a7b         	ldr	r3, [r7, #0x24]
 8018fbc: 9303         	str	r3, [sp, #0xc]
 8018fbe: 6a3b         	ldr	r3, [r7, #0x20]
 8018fc0: 9302         	str	r3, [sp, #0x8]
 8018fc2: 69fb         	ldr	r3, [r7, #0x1c]
 8018fc4: 9301         	str	r3, [sp, #0x4]
 8018fc6: 69bb         	ldr	r3, [r7, #0x18]
 8018fc8: 9300         	str	r3, [sp]
 8018fca: 683b         	ldr	r3, [r7]
 8018fcc: 687a         	ldr	r2, [r7, #0x4]
 8018fce: 68b9         	ldr	r1, [r7, #0x8]
 8018fd0: 68f8         	ldr	r0, [r7, #0xc]
 8018fd2: f003 fdb1    	bl	0x801cb38 <z_impl_k_thread_create> @ imm = #0x3b62
 8018fd6: 4603         	mov	r3, r0
; }
 8018fd8: 4618         	mov	r0, r3
 8018fda: 3710         	adds	r7, #0x10
 8018fdc: 46bd         	mov	sp, r7
 8018fde: bd80         	pop	{r7, pc}

08018fe0 <k_thread_name_set>:
; {
 8018fe0: b580         	push	{r7, lr}
 8018fe2: b082         	sub	sp, #0x8
 8018fe4: af00         	add	r7, sp, #0x0
 8018fe6: 6078         	str	r0, [r7, #0x4]
 8018fe8: 6039         	str	r1, [r7]
; 	return z_impl_k_thread_name_set(thread, str);
 8018fea: 6839         	ldr	r1, [r7]
 8018fec: 6878         	ldr	r0, [r7, #0x4]
 8018fee: f7f5 fe5d    	bl	0x800ecac <z_impl_k_thread_name_set> @ imm = #-0xa346
 8018ff2: 4603         	mov	r3, r0
; }
 8018ff4: 4618         	mov	r0, r3
 8018ff6: 3708         	adds	r7, #0x8
 8018ff8: 46bd         	mov	sp, r7
 8018ffa: bd80         	pop	{r7, pc}

08018ffc <k_sem_init>:
; {
 8018ffc: b580         	push	{r7, lr}
 8018ffe: b084         	sub	sp, #0x10
 8019000: af00         	add	r7, sp, #0x0
 8019002: 60f8         	str	r0, [r7, #0xc]
 8019004: 60b9         	str	r1, [r7, #0x8]
 8019006: 607a         	str	r2, [r7, #0x4]
; 	return z_impl_k_sem_init(sem, initial_count, limit);
 8019008: 687a         	ldr	r2, [r7, #0x4]
 801900a: 68b9         	ldr	r1, [r7, #0x8]
 801900c: 68f8         	ldr	r0, [r7, #0xc]
 801900e: f003 f932    	bl	0x801c276 <z_impl_k_sem_init> @ imm = #0x3264
 8019012: 4603         	mov	r3, r0
; }
 8019014: 4618         	mov	r0, r3
 8019016: 3710         	adds	r7, #0x10
 8019018: 46bd         	mov	sp, r7
 801901a: bd80         	pop	{r7, pc}

0801901c <k_sem_take>:
; {
 801901c: b580         	push	{r7, lr}
 801901e: b084         	sub	sp, #0x10
 8019020: af00         	add	r7, sp, #0x0
 8019022: 60f8         	str	r0, [r7, #0xc]
 8019024: e9c7 2300    	strd	r2, r3, [r7]
; 	return z_impl_k_sem_take(sem, timeout);
 8019028: e9d7 2300    	ldrd	r2, r3, [r7]
 801902c: 68f8         	ldr	r0, [r7, #0xc]
 801902e: f7f5 fa79    	bl	0x800e524 <z_impl_k_sem_take> @ imm = #-0xab0e
 8019032: 4603         	mov	r3, r0
; }
 8019034: 4618         	mov	r0, r3
 8019036: 3710         	adds	r7, #0x10
 8019038: 46bd         	mov	sp, r7
 801903a: bd80         	pop	{r7, pc}

0801903c <k_sem_give>:
; {
 801903c: b580         	push	{r7, lr}
 801903e: b082         	sub	sp, #0x8
 8019040: af00         	add	r7, sp, #0x0
 8019042: 6078         	str	r0, [r7, #0x4]
; 	z_impl_k_sem_give(sem);
 8019044: 6878         	ldr	r0, [r7, #0x4]
 8019046: f7f5 f9df    	bl	0x800e408 <z_impl_k_sem_give> @ imm = #-0xac42
; }
 801904a: bf00         	nop
 801904c: 3708         	adds	r7, #0x8
 801904e: 46bd         	mov	sp, r7
 8019050: bd80         	pop	{r7, pc}

08019052 <z_log_msg_runtime_create>:
; {
 8019052: b580         	push	{r7, lr}
 8019054: b08a         	sub	sp, #0x28
 8019056: af04         	add	r7, sp, #0x10
 8019058: 60b9         	str	r1, [r7, #0x8]
 801905a: 607b         	str	r3, [r7, #0x4]
 801905c: 4603         	mov	r3, r0
 801905e: 73fb         	strb	r3, [r7, #0xf]
 8019060: 4613         	mov	r3, r2
 8019062: 73bb         	strb	r3, [r7, #0xe]
; 	va_start(ap, fmt);
 8019064: f107 032c    	add.w	r3, r7, #0x2c
 8019068: 617b         	str	r3, [r7, #0x14]
; 	z_log_msg_runtime_vcreate(domain_id, source, level,
 801906a: 7bba         	ldrb	r2, [r7, #0xe]
 801906c: 7bf8         	ldrb	r0, [r7, #0xf]
 801906e: 697b         	ldr	r3, [r7, #0x14]
 8019070: 9303         	str	r3, [sp, #0xc]
 8019072: 6abb         	ldr	r3, [r7, #0x28]
 8019074: 9302         	str	r3, [sp, #0x8]
 8019076: 6a7b         	ldr	r3, [r7, #0x24]
 8019078: 9301         	str	r3, [sp, #0x4]
 801907a: 6a3b         	ldr	r3, [r7, #0x20]
 801907c: 9300         	str	r3, [sp]
 801907e: 687b         	ldr	r3, [r7, #0x4]
 8019080: 68b9         	ldr	r1, [r7, #0x8]
 8019082: f7eb fa75    	bl	0x8004570 <z_log_msg_runtime_vcreate> @ imm = #-0x14b16
; }
 8019086: bf00         	nop
 8019088: 3718         	adds	r7, #0x18
 801908a: 46bd         	mov	sp, r7
 801908c: bd80         	pop	{r7, pc}

0801908e <bmi08x_handle_drdy_acc>:
; {
 801908e: b580         	push	{r7, lr}
 8019090: b084         	sub	sp, #0x10
 8019092: af00         	add	r7, sp, #0x0
 8019094: 6078         	str	r0, [r7, #0x4]
; 	struct bmi08x_accel_data *data = dev->data;
 8019096: 687b         	ldr	r3, [r7, #0x4]
 8019098: 691b         	ldr	r3, [r3, #0x10]
 801909a: 60fb         	str	r3, [r7, #0xc]
; 	if (data->handler_drdy_acc) {
 801909c: 68fb         	ldr	r3, [r7, #0xc]
 801909e: f8d3 36f8    	ldr.w	r3, [r3, #0x6f8]
 80190a2: 2b00         	cmp	r3, #0x0
 80190a4: d008         	beq	0x80190b8 <bmi08x_handle_drdy_acc+0x2a> @ imm = #0x10
; 		data->handler_drdy_acc(dev, data->drdy_trig_acc);
 80190a6: 68fb         	ldr	r3, [r7, #0xc]
 80190a8: f8d3 36f8    	ldr.w	r3, [r3, #0x6f8]
 80190ac: 68fa         	ldr	r2, [r7, #0xc]
 80190ae: f8d2 26fc    	ldr.w	r2, [r2, #0x6fc]
 80190b2: 4611         	mov	r1, r2
 80190b4: 6878         	ldr	r0, [r7, #0x4]
 80190b6: 4798         	blx	r3
; }
 80190b8: bf00         	nop
 80190ba: 3710         	adds	r7, #0x10
 80190bc: 46bd         	mov	sp, r7
 80190be: bd80         	pop	{r7, pc}

080190c0 <bmi08x_handle_interrupts_acc>:
; {
 80190c0: b580         	push	{r7, lr}
 80190c2: b084         	sub	sp, #0x10
 80190c4: af00         	add	r7, sp, #0x0
 80190c6: 6078         	str	r0, [r7, #0x4]
; 	const struct device *dev = (const struct device *)arg;
 80190c8: 687b         	ldr	r3, [r7, #0x4]
 80190ca: 60fb         	str	r3, [r7, #0xc]
; 	bmi08x_handle_drdy_acc(dev);
 80190cc: 68f8         	ldr	r0, [r7, #0xc]
 80190ce: f7ff ffde    	bl	0x801908e <bmi08x_handle_drdy_acc> @ imm = #-0x44
; }
 80190d2: bf00         	nop
 80190d4: 3710         	adds	r7, #0x10
 80190d6: 46bd         	mov	sp, r7
 80190d8: bd80         	pop	{r7, pc}

080190da <bmi08x_acc_gpio_callback>:
; {
 80190da: b580         	push	{r7, lr}
 80190dc: b086         	sub	sp, #0x18
 80190de: af00         	add	r7, sp, #0x0
 80190e0: 60f8         	str	r0, [r7, #0xc]
 80190e2: 60b9         	str	r1, [r7, #0x8]
 80190e4: 607a         	str	r2, [r7, #0x4]
; 	struct bmi08x_accel_data *data = CONTAINER_OF(cb, struct bmi08x_accel_data, gpio_cb);
 80190e6: 68bb         	ldr	r3, [r7, #0x8]
 80190e8: 617b         	str	r3, [r7, #0x14]
; 	k_sem_give(&data->sem);
 80190ea: 697b         	ldr	r3, [r7, #0x14]
 80190ec: f503 63dd    	add.w	r3, r3, #0x6e8
 80190f0: 4618         	mov	r0, r3
 80190f2: f7ff ffa3    	bl	0x801903c <k_sem_give>  @ imm = #-0xba
; }
 80190f6: bf00         	nop
 80190f8: 3718         	adds	r7, #0x18
 80190fa: 46bd         	mov	sp, r7
 80190fc: bd80         	pop	{r7, pc}

080190fe <bmi08x_trigger_set_acc>:
; {
 80190fe: b480         	push	{r7}
 8019100: b087         	sub	sp, #0x1c
 8019102: af00         	add	r7, sp, #0x0
 8019104: 60f8         	str	r0, [r7, #0xc]
 8019106: 60b9         	str	r1, [r7, #0x8]
 8019108: 607a         	str	r2, [r7, #0x4]
; 	struct bmi08x_accel_data *data = dev->data;
 801910a: 68fb         	ldr	r3, [r7, #0xc]
 801910c: 691b         	ldr	r3, [r3, #0x10]
 801910e: 617b         	str	r3, [r7, #0x14]
; 	if ((trig->chan == SENSOR_CHAN_ACCEL_XYZ) && (trig->type == SENSOR_TRIG_DATA_READY)) {
 8019110: 68bb         	ldr	r3, [r7, #0x8]
 8019112: 885b         	ldrh	r3, [r3, #0x2]
 8019114: 2b03         	cmp	r3, #0x3
 8019116: d10d         	bne	0x8019134 <bmi08x_trigger_set_acc+0x36> @ imm = #0x1a
 8019118: 68bb         	ldr	r3, [r7, #0x8]
 801911a: 881b         	ldrh	r3, [r3]
 801911c: 2b01         	cmp	r3, #0x1
 801911e: d109         	bne	0x8019134 <bmi08x_trigger_set_acc+0x36> @ imm = #0x12
; 		data->drdy_trig_acc = trig;
 8019120: 697b         	ldr	r3, [r7, #0x14]
 8019122: 68ba         	ldr	r2, [r7, #0x8]
 8019124: f8c3 26fc    	str.w	r2, [r3, #0x6fc]
; 		data->handler_drdy_acc = handler;
 8019128: 697b         	ldr	r3, [r7, #0x14]
 801912a: 687a         	ldr	r2, [r7, #0x4]
 801912c: f8c3 26f8    	str.w	r2, [r3, #0x6f8]
; 		return 0;
 8019130: 2300         	movs	r3, #0x0
 8019132: e001         	b	0x8019138 <bmi08x_trigger_set_acc+0x3a> @ imm = #0x2
; 	return -ENOTSUP;
 8019134: f06f 0385    	mvn	r3, #0x85
; }
 8019138: 4618         	mov	r0, r3
 801913a: 371c         	adds	r7, #0x1c
 801913c: 46bd         	mov	sp, r7
 801913e: bc80         	pop	{r7}
 8019140: 4770         	bx	lr

08019142 <device_is_ready>:
; {
 8019142: b580         	push	{r7, lr}
 8019144: b082         	sub	sp, #0x8
 8019146: af00         	add	r7, sp, #0x0
 8019148: 6078         	str	r0, [r7, #0x4]
; 	return z_impl_device_is_ready(dev);
 801914a: 6878         	ldr	r0, [r7, #0x4]
 801914c: f002 fd17    	bl	0x801bb7e <z_impl_device_is_ready> @ imm = #0x2a2e
 8019150: 4603         	mov	r3, r0
; }
 8019152: 4618         	mov	r0, r3
 8019154: 3708         	adds	r7, #0x8
 8019156: 46bd         	mov	sp, r7
 8019158: bd80         	pop	{r7, pc}

0801915a <gpio_is_ready_dt>:
; {
 801915a: b580         	push	{r7, lr}
 801915c: b082         	sub	sp, #0x8
 801915e: af00         	add	r7, sp, #0x0
 8019160: 6078         	str	r0, [r7, #0x4]
; 	return device_is_ready(spec->port);
 8019162: 687b         	ldr	r3, [r7, #0x4]
 8019164: 681b         	ldr	r3, [r3]
 8019166: 4618         	mov	r0, r3
 8019168: f7ff ffeb    	bl	0x8019142 <device_is_ready> @ imm = #-0x2a
 801916c: 4603         	mov	r3, r0
; }
 801916e: 4618         	mov	r0, r3
 8019170: 3708         	adds	r7, #0x8
 8019172: 46bd         	mov	sp, r7
 8019174: bd80         	pop	{r7, pc}

08019176 <gpio_pin_interrupt_configure_dt>:
; {
 8019176: b580         	push	{r7, lr}
 8019178: b082         	sub	sp, #0x8
 801917a: af00         	add	r7, sp, #0x0
 801917c: 6078         	str	r0, [r7, #0x4]
 801917e: 6039         	str	r1, [r7]
; 	return gpio_pin_interrupt_configure(spec->port, spec->pin, flags);
 8019180: 687b         	ldr	r3, [r7, #0x4]
 8019182: 6818         	ldr	r0, [r3]
 8019184: 687b         	ldr	r3, [r7, #0x4]
 8019186: 791b         	ldrb	r3, [r3, #0x4]
 8019188: 683a         	ldr	r2, [r7]
 801918a: 4619         	mov	r1, r3
 801918c: f000 f891    	bl	0x80192b2 <gpio_pin_interrupt_configure> @ imm = #0x122
 8019190: 4603         	mov	r3, r0
; }
 8019192: 4618         	mov	r0, r3
 8019194: 3708         	adds	r7, #0x8
 8019196: 46bd         	mov	sp, r7
 8019198: bd80         	pop	{r7, pc}

0801919a <z_impl_gpio_pin_configure>:
; {
 801919a: b580         	push	{r7, lr}
 801919c: b088         	sub	sp, #0x20
 801919e: af00         	add	r7, sp, #0x0
 80191a0: 60f8         	str	r0, [r7, #0xc]
 80191a2: 460b         	mov	r3, r1
 80191a4: 607a         	str	r2, [r7, #0x4]
 80191a6: 72fb         	strb	r3, [r7, #0xb]
; 	const struct gpio_driver_api *api =
 80191a8: 68fb         	ldr	r3, [r7, #0xc]
 80191aa: 689b         	ldr	r3, [r3, #0x8]
 80191ac: 61fb         	str	r3, [r7, #0x1c]
; 	__unused const struct gpio_driver_config *const cfg =
 80191ae: 68fb         	ldr	r3, [r7, #0xc]
 80191b0: 685b         	ldr	r3, [r3, #0x4]
 80191b2: 61bb         	str	r3, [r7, #0x18]
; 	struct gpio_driver_data *data =
 80191b4: 68fb         	ldr	r3, [r7, #0xc]
 80191b6: 691b         	ldr	r3, [r3, #0x10]
 80191b8: 617b         	str	r3, [r7, #0x14]
; 	if (((flags & GPIO_OUTPUT_INIT_LOGICAL) != 0)
 80191ba: 687b         	ldr	r3, [r7, #0x4]
 80191bc: f403 1380    	and	r3, r3, #0x100000
 80191c0: 2b00         	cmp	r3, #0x0
 80191c2: d00d         	beq	0x80191e0 <z_impl_gpio_pin_configure+0x46> @ imm = #0x1a
; 	    && ((flags & (GPIO_OUTPUT_INIT_LOW | GPIO_OUTPUT_INIT_HIGH)) != 0)
 80191c4: 687b         	ldr	r3, [r7, #0x4]
 80191c6: f403 2340    	and	r3, r3, #0xc0000
 80191ca: 2b00         	cmp	r3, #0x0
 80191cc: d008         	beq	0x80191e0 <z_impl_gpio_pin_configure+0x46> @ imm = #0x10
; 	    && ((flags & GPIO_ACTIVE_LOW) != 0)) {
 80191ce: 687b         	ldr	r3, [r7, #0x4]
 80191d0: f003 0301    	and	r3, r3, #0x1
 80191d4: 2b00         	cmp	r3, #0x0
 80191d6: d003         	beq	0x80191e0 <z_impl_gpio_pin_configure+0x46> @ imm = #0x6
; 		flags ^= GPIO_OUTPUT_INIT_LOW | GPIO_OUTPUT_INIT_HIGH;
 80191d8: 687b         	ldr	r3, [r7, #0x4]
 80191da: f483 2340    	eor	r3, r3, #0xc0000
 80191de: 607b         	str	r3, [r7, #0x4]
; 	flags &= ~GPIO_OUTPUT_INIT_LOGICAL;
 80191e0: 687b         	ldr	r3, [r7, #0x4]
 80191e2: f423 1380    	bic	r3, r3, #0x100000
 80191e6: 607b         	str	r3, [r7, #0x4]
; 	if ((flags & GPIO_ACTIVE_LOW) != 0) {
 80191e8: 687b         	ldr	r3, [r7, #0x4]
 80191ea: f003 0301    	and	r3, r3, #0x1
 80191ee: 2b00         	cmp	r3, #0x0
 80191f0: d009         	beq	0x8019206 <z_impl_gpio_pin_configure+0x6c> @ imm = #0x12
; 		data->invert |= (gpio_port_pins_t)BIT(pin);
 80191f2: 697b         	ldr	r3, [r7, #0x14]
 80191f4: 681a         	ldr	r2, [r3]
 80191f6: 7afb         	ldrb	r3, [r7, #0xb]
 80191f8: 2101         	movs	r1, #0x1
 80191fa: fa01 f303    	lsl.w	r3, r1, r3
 80191fe: 431a         	orrs	r2, r3
 8019200: 697b         	ldr	r3, [r7, #0x14]
 8019202: 601a         	str	r2, [r3]
 8019204: e009         	b	0x801921a <z_impl_gpio_pin_configure+0x80> @ imm = #0x12
; 		data->invert &= ~(gpio_port_pins_t)BIT(pin);
 8019206: 697b         	ldr	r3, [r7, #0x14]
 8019208: 681a         	ldr	r2, [r3]
 801920a: 7afb         	ldrb	r3, [r7, #0xb]
 801920c: 2101         	movs	r1, #0x1
 801920e: fa01 f303    	lsl.w	r3, r1, r3
 8019212: 43db         	mvns	r3, r3
 8019214: 401a         	ands	r2, r3
 8019216: 697b         	ldr	r3, [r7, #0x14]
 8019218: 601a         	str	r2, [r3]
; 	return api->pin_configure(port, pin, flags);
 801921a: 69fb         	ldr	r3, [r7, #0x1c]
 801921c: 681b         	ldr	r3, [r3]
 801921e: 7af9         	ldrb	r1, [r7, #0xb]
 8019220: 687a         	ldr	r2, [r7, #0x4]
 8019222: 68f8         	ldr	r0, [r7, #0xc]
 8019224: 4798         	blx	r3
 8019226: 4603         	mov	r3, r0
; }
 8019228: 4618         	mov	r0, r3
 801922a: 3720         	adds	r7, #0x20
 801922c: 46bd         	mov	sp, r7
 801922e: bd80         	pop	{r7, pc}

08019230 <gpio_pin_configure_dt>:
; {
 8019230: b580         	push	{r7, lr}
 8019232: b082         	sub	sp, #0x8
 8019234: af00         	add	r7, sp, #0x0
 8019236: 6078         	str	r0, [r7, #0x4]
 8019238: 6039         	str	r1, [r7]
; 	return gpio_pin_configure(spec->port,
 801923a: 687b         	ldr	r3, [r7, #0x4]
 801923c: 6818         	ldr	r0, [r3]
; 				  spec->pin,
 801923e: 687b         	ldr	r3, [r7, #0x4]
 8019240: 7919         	ldrb	r1, [r3, #0x4]
; 				  spec->dt_flags | extra_flags);
 8019242: 687b         	ldr	r3, [r7, #0x4]
 8019244: 88db         	ldrh	r3, [r3, #0x6]
 8019246: 461a         	mov	r2, r3
; 	return gpio_pin_configure(spec->port,
 8019248: 683b         	ldr	r3, [r7]
 801924a: 4313         	orrs	r3, r2
 801924c: 461a         	mov	r2, r3
 801924e: f000 f842    	bl	0x80192d6 <gpio_pin_configure> @ imm = #0x84
 8019252: 4603         	mov	r3, r0
; }
 8019254: 4618         	mov	r0, r3
 8019256: 3708         	adds	r7, #0x8
 8019258: 46bd         	mov	sp, r7
 801925a: bd80         	pop	{r7, pc}

0801925c <gpio_init_callback>:
; {
 801925c: b480         	push	{r7}
 801925e: b085         	sub	sp, #0x14
 8019260: af00         	add	r7, sp, #0x0
 8019262: 60f8         	str	r0, [r7, #0xc]
 8019264: 60b9         	str	r1, [r7, #0x8]
 8019266: 607a         	str	r2, [r7, #0x4]
; 	callback->handler = handler;
 8019268: 68fb         	ldr	r3, [r7, #0xc]
 801926a: 68ba         	ldr	r2, [r7, #0x8]
 801926c: 605a         	str	r2, [r3, #0x4]
; 	callback->pin_mask = pin_mask;
 801926e: 68fb         	ldr	r3, [r7, #0xc]
 8019270: 687a         	ldr	r2, [r7, #0x4]
 8019272: 609a         	str	r2, [r3, #0x8]
; }
 8019274: bf00         	nop
 8019276: 3714         	adds	r7, #0x14
 8019278: 46bd         	mov	sp, r7
 801927a: bc80         	pop	{r7}
 801927c: 4770         	bx	lr

0801927e <gpio_add_callback>:
; {
 801927e: b580         	push	{r7, lr}
 8019280: b084         	sub	sp, #0x10
 8019282: af00         	add	r7, sp, #0x0
 8019284: 6078         	str	r0, [r7, #0x4]
 8019286: 6039         	str	r1, [r7]
; 	const struct gpio_driver_api *api =
 8019288: 687b         	ldr	r3, [r7, #0x4]
 801928a: 689b         	ldr	r3, [r3, #0x8]
 801928c: 60fb         	str	r3, [r7, #0xc]
; 	if (api->manage_callback == NULL) {
 801928e: 68fb         	ldr	r3, [r7, #0xc]
 8019290: 69db         	ldr	r3, [r3, #0x1c]
 8019292: 2b00         	cmp	r3, #0x0
 8019294: d102         	bne	0x801929c <gpio_add_callback+0x1e> @ imm = #0x4
; 		return -ENOSYS;
 8019296: f06f 0357    	mvn	r3, #0x57
 801929a: e006         	b	0x80192aa <gpio_add_callback+0x2c> @ imm = #0xc
; 	return api->manage_callback(port, callback, true);
 801929c: 68fb         	ldr	r3, [r7, #0xc]
 801929e: 69db         	ldr	r3, [r3, #0x1c]
 80192a0: 2201         	movs	r2, #0x1
 80192a2: 6839         	ldr	r1, [r7]
 80192a4: 6878         	ldr	r0, [r7, #0x4]
 80192a6: 4798         	blx	r3
 80192a8: 4603         	mov	r3, r0
; }
 80192aa: 4618         	mov	r0, r3
 80192ac: 3710         	adds	r7, #0x10
 80192ae: 46bd         	mov	sp, r7
 80192b0: bd80         	pop	{r7, pc}

080192b2 <gpio_pin_interrupt_configure>:
; {
 80192b2: b580         	push	{r7, lr}
 80192b4: b084         	sub	sp, #0x10
 80192b6: af00         	add	r7, sp, #0x0
 80192b8: 60f8         	str	r0, [r7, #0xc]
 80192ba: 460b         	mov	r3, r1
 80192bc: 607a         	str	r2, [r7, #0x4]
 80192be: 72fb         	strb	r3, [r7, #0xb]
; 	return z_impl_gpio_pin_interrupt_configure(port, pin, flags);
 80192c0: 7afb         	ldrb	r3, [r7, #0xb]
 80192c2: 687a         	ldr	r2, [r7, #0x4]
 80192c4: 4619         	mov	r1, r3
 80192c6: 68f8         	ldr	r0, [r7, #0xc]
 80192c8: f7f0 fbf4    	bl	0x8009ab4 <z_impl_gpio_pin_interrupt_configure> @ imm = #-0xf818
 80192cc: 4603         	mov	r3, r0
; }
 80192ce: 4618         	mov	r0, r3
 80192d0: 3710         	adds	r7, #0x10
 80192d2: 46bd         	mov	sp, r7
 80192d4: bd80         	pop	{r7, pc}

080192d6 <gpio_pin_configure>:
; {
 80192d6: b580         	push	{r7, lr}
 80192d8: b084         	sub	sp, #0x10
 80192da: af00         	add	r7, sp, #0x0
 80192dc: 60f8         	str	r0, [r7, #0xc]
 80192de: 460b         	mov	r3, r1
 80192e0: 607a         	str	r2, [r7, #0x4]
 80192e2: 72fb         	strb	r3, [r7, #0xb]
; 	return z_impl_gpio_pin_configure(port, pin, flags);
 80192e4: 7afb         	ldrb	r3, [r7, #0xb]
 80192e6: 687a         	ldr	r2, [r7, #0x4]
 80192e8: 4619         	mov	r1, r3
 80192ea: 68f8         	ldr	r0, [r7, #0xc]
 80192ec: f7ff ff55    	bl	0x801919a <z_impl_gpio_pin_configure> @ imm = #-0x156
 80192f0: 4603         	mov	r3, r0
; }
 80192f2: 4618         	mov	r0, r3
 80192f4: 3710         	adds	r7, #0x10
 80192f6: 46bd         	mov	sp, r7
 80192f8: bd80         	pop	{r7, pc}

080192fa <k_thread_create>:
; {
 80192fa: b580         	push	{r7, lr}
 80192fc: b08c         	sub	sp, #0x30
 80192fe: af08         	add	r7, sp, #0x20
 8019300: 60f8         	str	r0, [r7, #0xc]
 8019302: 60b9         	str	r1, [r7, #0x8]
 8019304: 607a         	str	r2, [r7, #0x4]
 8019306: 603b         	str	r3, [r7]
; 	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
 8019308: e9d7 230c    	ldrd	r2, r3, [r7, #48]
 801930c: e9cd 2306    	strd	r2, r3, [sp, #24]
 8019310: 6abb         	ldr	r3, [r7, #0x28]
 8019312: 9304         	str	r3, [sp, #0x10]
 8019314: 6a7b         	ldr	r3, [r7, #0x24]
 8019316: 9303         	str	r3, [sp, #0xc]
 8019318: 6a3b         	ldr	r3, [r7, #0x20]
 801931a: 9302         	str	r3, [sp, #0x8]
 801931c: 69fb         	ldr	r3, [r7, #0x1c]
 801931e: 9301         	str	r3, [sp, #0x4]
 8019320: 69bb         	ldr	r3, [r7, #0x18]
 8019322: 9300         	str	r3, [sp]
 8019324: 683b         	ldr	r3, [r7]
 8019326: 687a         	ldr	r2, [r7, #0x4]
 8019328: 68b9         	ldr	r1, [r7, #0x8]
 801932a: 68f8         	ldr	r0, [r7, #0xc]
 801932c: f003 fc04    	bl	0x801cb38 <z_impl_k_thread_create> @ imm = #0x3808
 8019330: 4603         	mov	r3, r0
; }
 8019332: 4618         	mov	r0, r3
 8019334: 3710         	adds	r7, #0x10
 8019336: 46bd         	mov	sp, r7
 8019338: bd80         	pop	{r7, pc}

0801933a <k_thread_name_set>:
; {
 801933a: b580         	push	{r7, lr}
 801933c: b082         	sub	sp, #0x8
 801933e: af00         	add	r7, sp, #0x0
 8019340: 6078         	str	r0, [r7, #0x4]
 8019342: 6039         	str	r1, [r7]
; 	return z_impl_k_thread_name_set(thread, str);
 8019344: 6839         	ldr	r1, [r7]
 8019346: 6878         	ldr	r0, [r7, #0x4]
 8019348: f7f5 fcb0    	bl	0x800ecac <z_impl_k_thread_name_set> @ imm = #-0xa6a0
 801934c: 4603         	mov	r3, r0
; }
 801934e: 4618         	mov	r0, r3
 8019350: 3708         	adds	r7, #0x8
 8019352: 46bd         	mov	sp, r7
 8019354: bd80         	pop	{r7, pc}

08019356 <k_sem_init>:
; {
 8019356: b580         	push	{r7, lr}
 8019358: b084         	sub	sp, #0x10
 801935a: af00         	add	r7, sp, #0x0
 801935c: 60f8         	str	r0, [r7, #0xc]
 801935e: 60b9         	str	r1, [r7, #0x8]
 8019360: 607a         	str	r2, [r7, #0x4]
; 	return z_impl_k_sem_init(sem, initial_count, limit);
 8019362: 687a         	ldr	r2, [r7, #0x4]
 8019364: 68b9         	ldr	r1, [r7, #0x8]
 8019366: 68f8         	ldr	r0, [r7, #0xc]
 8019368: f002 ff85    	bl	0x801c276 <z_impl_k_sem_init> @ imm = #0x2f0a
 801936c: 4603         	mov	r3, r0
; }
 801936e: 4618         	mov	r0, r3
 8019370: 3710         	adds	r7, #0x10
 8019372: 46bd         	mov	sp, r7
 8019374: bd80         	pop	{r7, pc}

08019376 <k_sem_take>:
; {
 8019376: b580         	push	{r7, lr}
 8019378: b084         	sub	sp, #0x10
 801937a: af00         	add	r7, sp, #0x0
 801937c: 60f8         	str	r0, [r7, #0xc]
 801937e: e9c7 2300    	strd	r2, r3, [r7]
; 	return z_impl_k_sem_take(sem, timeout);
 8019382: e9d7 2300    	ldrd	r2, r3, [r7]
 8019386: 68f8         	ldr	r0, [r7, #0xc]
 8019388: f7f5 f8cc    	bl	0x800e524 <z_impl_k_sem_take> @ imm = #-0xae68
 801938c: 4603         	mov	r3, r0
; }
 801938e: 4618         	mov	r0, r3
 8019390: 3710         	adds	r7, #0x10
 8019392: 46bd         	mov	sp, r7
 8019394: bd80         	pop	{r7, pc}

08019396 <k_sem_give>:
; {
 8019396: b580         	push	{r7, lr}
 8019398: b082         	sub	sp, #0x8
 801939a: af00         	add	r7, sp, #0x0
 801939c: 6078         	str	r0, [r7, #0x4]
; 	z_impl_k_sem_give(sem);
 801939e: 6878         	ldr	r0, [r7, #0x4]
 80193a0: f7f5 f832    	bl	0x800e408 <z_impl_k_sem_give> @ imm = #-0xaf9c
; }
 80193a4: bf00         	nop
 80193a6: 3708         	adds	r7, #0x8
 80193a8: 46bd         	mov	sp, r7
 80193aa: bd80         	pop	{r7, pc}

080193ac <z_log_msg_runtime_create>:
; {
 80193ac: b580         	push	{r7, lr}
 80193ae: b08a         	sub	sp, #0x28
 80193b0: af04         	add	r7, sp, #0x10
 80193b2: 60b9         	str	r1, [r7, #0x8]
 80193b4: 607b         	str	r3, [r7, #0x4]
 80193b6: 4603         	mov	r3, r0
 80193b8: 73fb         	strb	r3, [r7, #0xf]
 80193ba: 4613         	mov	r3, r2
 80193bc: 73bb         	strb	r3, [r7, #0xe]
; 	va_start(ap, fmt);
 80193be: f107 032c    	add.w	r3, r7, #0x2c
 80193c2: 617b         	str	r3, [r7, #0x14]
; 	z_log_msg_runtime_vcreate(domain_id, source, level,
 80193c4: 7bba         	ldrb	r2, [r7, #0xe]
 80193c6: 7bf8         	ldrb	r0, [r7, #0xf]
 80193c8: 697b         	ldr	r3, [r7, #0x14]
 80193ca: 9303         	str	r3, [sp, #0xc]
 80193cc: 6abb         	ldr	r3, [r7, #0x28]
 80193ce: 9302         	str	r3, [sp, #0x8]
 80193d0: 6a7b         	ldr	r3, [r7, #0x24]
 80193d2: 9301         	str	r3, [sp, #0x4]
 80193d4: 6a3b         	ldr	r3, [r7, #0x20]
 80193d6: 9300         	str	r3, [sp]
 80193d8: 687b         	ldr	r3, [r7, #0x4]
 80193da: 68b9         	ldr	r1, [r7, #0x8]
 80193dc: f7eb f8c8    	bl	0x8004570 <z_log_msg_runtime_vcreate> @ imm = #-0x14e70
; }
 80193e0: bf00         	nop
 80193e2: 3718         	adds	r7, #0x18
 80193e4: 46bd         	mov	sp, r7
 80193e6: bd80         	pop	{r7, pc}

080193e8 <bmi08x_handle_drdy_gyr>:
; {
 80193e8: b580         	push	{r7, lr}
 80193ea: b084         	sub	sp, #0x10
 80193ec: af00         	add	r7, sp, #0x0
 80193ee: 6078         	str	r0, [r7, #0x4]
; 	struct bmi08x_gyro_data *data = dev->data;
 80193f0: 687b         	ldr	r3, [r7, #0x4]
 80193f2: 691b         	ldr	r3, [r3, #0x10]
 80193f4: 60fb         	str	r3, [r7, #0xc]
; 	if (data->handler_drdy_gyr) {
 80193f6: 68fb         	ldr	r3, [r7, #0xc]
 80193f8: f8d3 36f8    	ldr.w	r3, [r3, #0x6f8]
 80193fc: 2b00         	cmp	r3, #0x0
 80193fe: d008         	beq	0x8019412 <bmi08x_handle_drdy_gyr+0x2a> @ imm = #0x10
; 		data->handler_drdy_gyr(dev, data->drdy_trig_gyr);
 8019400: 68fb         	ldr	r3, [r7, #0xc]
 8019402: f8d3 36f8    	ldr.w	r3, [r3, #0x6f8]
 8019406: 68fa         	ldr	r2, [r7, #0xc]
 8019408: f8d2 26fc    	ldr.w	r2, [r2, #0x6fc]
 801940c: 4611         	mov	r1, r2
 801940e: 6878         	ldr	r0, [r7, #0x4]
 8019410: 4798         	blx	r3
; }
 8019412: bf00         	nop
 8019414: 3710         	adds	r7, #0x10
 8019416: 46bd         	mov	sp, r7
 8019418: bd80         	pop	{r7, pc}

0801941a <bmi08x_handle_interrupts_gyr>:
; {
 801941a: b580         	push	{r7, lr}
 801941c: b084         	sub	sp, #0x10
 801941e: af00         	add	r7, sp, #0x0
 8019420: 6078         	str	r0, [r7, #0x4]
; 	const struct device *dev = (const struct device *)arg;
 8019422: 687b         	ldr	r3, [r7, #0x4]
 8019424: 60fb         	str	r3, [r7, #0xc]
; 	bmi08x_handle_drdy_gyr(dev);
 8019426: 68f8         	ldr	r0, [r7, #0xc]
 8019428: f7ff ffde    	bl	0x80193e8 <bmi08x_handle_drdy_gyr> @ imm = #-0x44
; }
 801942c: bf00         	nop
 801942e: 3710         	adds	r7, #0x10
 8019430: 46bd         	mov	sp, r7
 8019432: bd80         	pop	{r7, pc}

08019434 <bmi08x_gyr_gpio_callback>:
; {
 8019434: b580         	push	{r7, lr}
 8019436: b086         	sub	sp, #0x18
 8019438: af00         	add	r7, sp, #0x0
 801943a: 60f8         	str	r0, [r7, #0xc]
 801943c: 60b9         	str	r1, [r7, #0x8]
 801943e: 607a         	str	r2, [r7, #0x4]
; 	struct bmi08x_gyro_data *data = CONTAINER_OF(cb, struct bmi08x_gyro_data, gpio_cb);
 8019440: 68bb         	ldr	r3, [r7, #0x8]
 8019442: 617b         	str	r3, [r7, #0x14]
; 	k_sem_give(&data->sem);
 8019444: 697b         	ldr	r3, [r7, #0x14]
 8019446: f503 63dd    	add.w	r3, r3, #0x6e8
 801944a: 4618         	mov	r0, r3
 801944c: f7ff ffa3    	bl	0x8019396 <k_sem_give>  @ imm = #-0xba
; }
 8019450: bf00         	nop
 8019452: 3718         	adds	r7, #0x18
 8019454: 46bd         	mov	sp, r7
 8019456: bd80         	pop	{r7, pc}

08019458 <bmi08x_trigger_set_gyr>:
; {
 8019458: b480         	push	{r7}
 801945a: b087         	sub	sp, #0x1c
 801945c: af00         	add	r7, sp, #0x0
 801945e: 60f8         	str	r0, [r7, #0xc]
 8019460: 60b9         	str	r1, [r7, #0x8]
 8019462: 607a         	str	r2, [r7, #0x4]
; 	struct bmi08x_gyro_data *data = dev->data;
 8019464: 68fb         	ldr	r3, [r7, #0xc]
 8019466: 691b         	ldr	r3, [r3, #0x10]
 8019468: 617b         	str	r3, [r7, #0x14]
; 	if ((trig->chan == SENSOR_CHAN_GYRO_XYZ) && (trig->type == SENSOR_TRIG_DATA_READY)) {
 801946a: 68bb         	ldr	r3, [r7, #0x8]
 801946c: 885b         	ldrh	r3, [r3, #0x2]
 801946e: 2b07         	cmp	r3, #0x7
 8019470: d10d         	bne	0x801948e <bmi08x_trigger_set_gyr+0x36> @ imm = #0x1a
 8019472: 68bb         	ldr	r3, [r7, #0x8]
 8019474: 881b         	ldrh	r3, [r3]
 8019476: 2b01         	cmp	r3, #0x1
 8019478: d109         	bne	0x801948e <bmi08x_trigger_set_gyr+0x36> @ imm = #0x12
; 		data->drdy_trig_gyr = trig;
 801947a: 697b         	ldr	r3, [r7, #0x14]
 801947c: 68ba         	ldr	r2, [r7, #0x8]
 801947e: f8c3 26fc    	str.w	r2, [r3, #0x6fc]
; 		data->handler_drdy_gyr = handler;
 8019482: 697b         	ldr	r3, [r7, #0x14]
 8019484: 687a         	ldr	r2, [r7, #0x4]
 8019486: f8c3 26f8    	str.w	r2, [r3, #0x6f8]
; 		return 0;
 801948a: 2300         	movs	r3, #0x0
 801948c: e001         	b	0x8019492 <bmi08x_trigger_set_gyr+0x3a> @ imm = #0x2
; 	return -ENOTSUP;
 801948e: f06f 0385    	mvn	r3, #0x85
; }
 8019492: 4618         	mov	r0, r3
 8019494: 371c         	adds	r7, #0x1c
 8019496: 46bd         	mov	sp, r7
 8019498: bc80         	pop	{r7}
 801949a: 4770         	bx	lr

0801949c <device_is_ready>:
; {
 801949c: b580         	push	{r7, lr}
 801949e: b082         	sub	sp, #0x8
 80194a0: af00         	add	r7, sp, #0x0
 80194a2: 6078         	str	r0, [r7, #0x4]
; 	return z_impl_device_is_ready(dev);
 80194a4: 6878         	ldr	r0, [r7, #0x4]
 80194a6: f002 fb6a    	bl	0x801bb7e <z_impl_device_is_ready> @ imm = #0x26d4
 80194aa: 4603         	mov	r3, r0
; }
 80194ac: 4618         	mov	r0, r3
 80194ae: 3708         	adds	r7, #0x8
 80194b0: 46bd         	mov	sp, r7
 80194b2: bd80         	pop	{r7, pc}

080194b4 <k_work_delayable_from_work>:
; {
 80194b4: b480         	push	{r7}
 80194b6: b083         	sub	sp, #0xc
 80194b8: af00         	add	r7, sp, #0x0
 80194ba: 6078         	str	r0, [r7, #0x4]
; 	return CONTAINER_OF(work, struct k_work_delayable, work);
 80194bc: 687b         	ldr	r3, [r7, #0x4]
; }
 80194be: 4618         	mov	r0, r3
 80194c0: 370c         	adds	r7, #0xc
 80194c2: 46bd         	mov	sp, r7
 80194c4: bc80         	pop	{r7}
 80194c6: 4770         	bx	lr

080194c8 <clock_control_on>:
; {
 80194c8: b580         	push	{r7, lr}
 80194ca: b084         	sub	sp, #0x10
 80194cc: af00         	add	r7, sp, #0x0
 80194ce: 6078         	str	r0, [r7, #0x4]
 80194d0: 6039         	str	r1, [r7]
; 	const struct clock_control_driver_api *api =
 80194d2: 687b         	ldr	r3, [r7, #0x4]
 80194d4: 689b         	ldr	r3, [r3, #0x8]
 80194d6: 60fb         	str	r3, [r7, #0xc]
; 	return api->on(dev, sys);
 80194d8: 68fb         	ldr	r3, [r7, #0xc]
 80194da: 681b         	ldr	r3, [r3]
 80194dc: 6839         	ldr	r1, [r7]
 80194de: 6878         	ldr	r0, [r7, #0x4]
 80194e0: 4798         	blx	r3
 80194e2: 4603         	mov	r3, r0
; }
 80194e4: 4618         	mov	r0, r3
 80194e6: 3710         	adds	r7, #0x10
 80194e8: 46bd         	mov	sp, r7
 80194ea: bd80         	pop	{r7, pc}

080194ec <clock_control_get_rate>:
; {
 80194ec: b580         	push	{r7, lr}
 80194ee: b086         	sub	sp, #0x18
 80194f0: af00         	add	r7, sp, #0x0
 80194f2: 60f8         	str	r0, [r7, #0xc]
 80194f4: 60b9         	str	r1, [r7, #0x8]
 80194f6: 607a         	str	r2, [r7, #0x4]
; 	const struct clock_control_driver_api *api =
 80194f8: 68fb         	ldr	r3, [r7, #0xc]
 80194fa: 689b         	ldr	r3, [r3, #0x8]
 80194fc: 617b         	str	r3, [r7, #0x14]
; 	if (api->get_rate == NULL) {
 80194fe: 697b         	ldr	r3, [r7, #0x14]
 8019500: 68db         	ldr	r3, [r3, #0xc]
 8019502: 2b00         	cmp	r3, #0x0
 8019504: d102         	bne	0x801950c <clock_control_get_rate+0x20> @ imm = #0x4
; 		return -ENOSYS;
 8019506: f06f 0357    	mvn	r3, #0x57
 801950a: e006         	b	0x801951a <clock_control_get_rate+0x2e> @ imm = #0xc
; 	return api->get_rate(dev, sys, rate);
 801950c: 697b         	ldr	r3, [r7, #0x14]
 801950e: 68db         	ldr	r3, [r3, #0xc]
 8019510: 687a         	ldr	r2, [r7, #0x4]
 8019512: 68b9         	ldr	r1, [r7, #0x8]
 8019514: 68f8         	ldr	r0, [r7, #0xc]
 8019516: 4798         	blx	r3
 8019518: 4603         	mov	r3, r0
; }
 801951a: 4618         	mov	r0, r3
 801951c: 3718         	adds	r7, #0x18
 801951e: 46bd         	mov	sp, r7
 8019520: bd80         	pop	{r7, pc}

08019522 <dma_config>:
; {
 8019522: b580         	push	{r7, lr}
 8019524: b086         	sub	sp, #0x18
 8019526: af00         	add	r7, sp, #0x0
 8019528: 60f8         	str	r0, [r7, #0xc]
 801952a: 60b9         	str	r1, [r7, #0x8]
 801952c: 607a         	str	r2, [r7, #0x4]
; 	const struct dma_driver_api *api =
 801952e: 68fb         	ldr	r3, [r7, #0xc]
 8019530: 689b         	ldr	r3, [r3, #0x8]
 8019532: 617b         	str	r3, [r7, #0x14]
; 	return api->config(dev, channel, config);
 8019534: 697b         	ldr	r3, [r7, #0x14]
 8019536: 681b         	ldr	r3, [r3]
 8019538: 687a         	ldr	r2, [r7, #0x4]
 801953a: 68b9         	ldr	r1, [r7, #0x8]
 801953c: 68f8         	ldr	r0, [r7, #0xc]
 801953e: 4798         	blx	r3
 8019540: 4603         	mov	r3, r0
; }
 8019542: 4618         	mov	r0, r3
 8019544: 3718         	adds	r7, #0x18
 8019546: 46bd         	mov	sp, r7
 8019548: bd80         	pop	{r7, pc}

0801954a <dma_reload>:
; {
 801954a: b590         	push	{r4, r7, lr}
 801954c: b089         	sub	sp, #0x24
 801954e: af02         	add	r7, sp, #0x8
 8019550: 60f8         	str	r0, [r7, #0xc]
 8019552: 60b9         	str	r1, [r7, #0x8]
 8019554: 607a         	str	r2, [r7, #0x4]
 8019556: 603b         	str	r3, [r7]
; 	const struct dma_driver_api *api =
 8019558: 68fb         	ldr	r3, [r7, #0xc]
 801955a: 689b         	ldr	r3, [r3, #0x8]
 801955c: 617b         	str	r3, [r7, #0x14]
; 	if (api->reload) {
 801955e: 697b         	ldr	r3, [r7, #0x14]
 8019560: 685b         	ldr	r3, [r3, #0x4]
 8019562: 2b00         	cmp	r3, #0x0
 8019564: d00a         	beq	0x801957c <dma_reload+0x32> @ imm = #0x14
; 		return api->reload(dev, channel, src, dst, size);
 8019566: 697b         	ldr	r3, [r7, #0x14]
 8019568: 685c         	ldr	r4, [r3, #0x4]
 801956a: 6abb         	ldr	r3, [r7, #0x28]
 801956c: 9300         	str	r3, [sp]
 801956e: 683b         	ldr	r3, [r7]
 8019570: 687a         	ldr	r2, [r7, #0x4]
 8019572: 68b9         	ldr	r1, [r7, #0x8]
 8019574: 68f8         	ldr	r0, [r7, #0xc]
 8019576: 47a0         	blx	r4
 8019578: 4603         	mov	r3, r0
 801957a: e001         	b	0x8019580 <dma_reload+0x36> @ imm = #0x2
; 	return -ENOSYS;
 801957c: f06f 0357    	mvn	r3, #0x57
; }
 8019580: 4618         	mov	r0, r3
 8019582: 371c         	adds	r7, #0x1c
 8019584: 46bd         	mov	sp, r7
 8019586: bd90         	pop	{r4, r7, pc}

08019588 <z_impl_dma_start>:
; {
 8019588: b580         	push	{r7, lr}
 801958a: b084         	sub	sp, #0x10
 801958c: af00         	add	r7, sp, #0x0
 801958e: 6078         	str	r0, [r7, #0x4]
 8019590: 6039         	str	r1, [r7]
; 	const struct dma_driver_api *api =
 8019592: 687b         	ldr	r3, [r7, #0x4]
 8019594: 689b         	ldr	r3, [r3, #0x8]
 8019596: 60fb         	str	r3, [r7, #0xc]
; 	return api->start(dev, channel);
 8019598: 68fb         	ldr	r3, [r7, #0xc]
 801959a: 689b         	ldr	r3, [r3, #0x8]
 801959c: 6839         	ldr	r1, [r7]
 801959e: 6878         	ldr	r0, [r7, #0x4]
 80195a0: 4798         	blx	r3
 80195a2: 4603         	mov	r3, r0
; }
 80195a4: 4618         	mov	r0, r3
 80195a6: 3710         	adds	r7, #0x10
 80195a8: 46bd         	mov	sp, r7
 80195aa: bd80         	pop	{r7, pc}

080195ac <z_impl_dma_stop>:
; {
 80195ac: b580         	push	{r7, lr}
 80195ae: b084         	sub	sp, #0x10
 80195b0: af00         	add	r7, sp, #0x0
 80195b2: 6078         	str	r0, [r7, #0x4]
 80195b4: 6039         	str	r1, [r7]
; 	const struct dma_driver_api *api =
 80195b6: 687b         	ldr	r3, [r7, #0x4]
 80195b8: 689b         	ldr	r3, [r3, #0x8]
 80195ba: 60fb         	str	r3, [r7, #0xc]
; 	return api->stop(dev, channel);
 80195bc: 68fb         	ldr	r3, [r7, #0xc]
 80195be: 68db         	ldr	r3, [r3, #0xc]
 80195c0: 6839         	ldr	r1, [r7]
 80195c2: 6878         	ldr	r0, [r7, #0x4]
 80195c4: 4798         	blx	r3
 80195c6: 4603         	mov	r3, r0
; }
 80195c8: 4618         	mov	r0, r3
 80195ca: 3710         	adds	r7, #0x10
 80195cc: 46bd         	mov	sp, r7
 80195ce: bd80         	pop	{r7, pc}

080195d0 <dma_get_status>:
; {
 80195d0: b580         	push	{r7, lr}
 80195d2: b086         	sub	sp, #0x18
 80195d4: af00         	add	r7, sp, #0x0
 80195d6: 60f8         	str	r0, [r7, #0xc]
 80195d8: 60b9         	str	r1, [r7, #0x8]
 80195da: 607a         	str	r2, [r7, #0x4]
; 	const struct dma_driver_api *api =
 80195dc: 68fb         	ldr	r3, [r7, #0xc]
 80195de: 689b         	ldr	r3, [r3, #0x8]
 80195e0: 617b         	str	r3, [r7, #0x14]
; 	if (api->get_status) {
 80195e2: 697b         	ldr	r3, [r7, #0x14]
 80195e4: 699b         	ldr	r3, [r3, #0x18]
 80195e6: 2b00         	cmp	r3, #0x0
 80195e8: d007         	beq	0x80195fa <dma_get_status+0x2a> @ imm = #0xe
; 		return api->get_status(dev, channel, stat);
 80195ea: 697b         	ldr	r3, [r7, #0x14]
 80195ec: 699b         	ldr	r3, [r3, #0x18]
 80195ee: 687a         	ldr	r2, [r7, #0x4]
 80195f0: 68b9         	ldr	r1, [r7, #0x8]
 80195f2: 68f8         	ldr	r0, [r7, #0xc]
 80195f4: 4798         	blx	r3
 80195f6: 4603         	mov	r3, r0
 80195f8: e001         	b	0x80195fe <dma_get_status+0x2e> @ imm = #0x2
; 	return -ENOSYS;
 80195fa: f06f 0357    	mvn	r3, #0x57
; }
 80195fe: 4618         	mov	r0, r3
 8019600: 3718         	adds	r7, #0x18
 8019602: 46bd         	mov	sp, r7
 8019604: bd80         	pop	{r7, pc}

08019606 <dma_start>:
; {
 8019606: b580         	push	{r7, lr}
 8019608: b082         	sub	sp, #0x8
 801960a: af00         	add	r7, sp, #0x0
 801960c: 6078         	str	r0, [r7, #0x4]
 801960e: 6039         	str	r1, [r7]
; 	return z_impl_dma_start(dev, channel);
 8019610: 6839         	ldr	r1, [r7]
 8019612: 6878         	ldr	r0, [r7, #0x4]
 8019614: f7ff ffb8    	bl	0x8019588 <z_impl_dma_start> @ imm = #-0x90
 8019618: 4603         	mov	r3, r0
; }
 801961a: 4618         	mov	r0, r3
 801961c: 3708         	adds	r7, #0x8
 801961e: 46bd         	mov	sp, r7
 8019620: bd80         	pop	{r7, pc}

08019622 <dma_stop>:
; {
 8019622: b580         	push	{r7, lr}
 8019624: b082         	sub	sp, #0x8
 8019626: af00         	add	r7, sp, #0x0
 8019628: 6078         	str	r0, [r7, #0x4]
 801962a: 6039         	str	r1, [r7]
; 	return z_impl_dma_stop(dev, channel);
 801962c: 6839         	ldr	r1, [r7]
 801962e: 6878         	ldr	r0, [r7, #0x4]
 8019630: f7ff ffbc    	bl	0x80195ac <z_impl_dma_stop> @ imm = #-0x88
 8019634: 4603         	mov	r3, r0
; }
 8019636: 4618         	mov	r0, r3
 8019638: 3708         	adds	r7, #0x8
 801963a: 46bd         	mov	sp, r7
 801963c: bd80         	pop	{r7, pc}

0801963e <pinctrl_apply_state_direct>:
; {
 801963e: b580         	push	{r7, lr}
 8019640: b084         	sub	sp, #0x10
 8019642: af00         	add	r7, sp, #0x0
 8019644: 6078         	str	r0, [r7, #0x4]
 8019646: 6039         	str	r1, [r7]
; 	reg = PINCTRL_REG_NONE;
 8019648: 2300         	movs	r3, #0x0
 801964a: 60fb         	str	r3, [r7, #0xc]
; 	return pinctrl_configure_pins(state->pins, state->pin_cnt, reg);
 801964c: 683b         	ldr	r3, [r7]
 801964e: 6818         	ldr	r0, [r3]
 8019650: 683b         	ldr	r3, [r7]
 8019652: 791b         	ldrb	r3, [r3, #0x4]
 8019654: 68fa         	ldr	r2, [r7, #0xc]
 8019656: 4619         	mov	r1, r3
 8019658: f7fe fd4c    	bl	0x80180f4 <pinctrl_configure_pins> @ imm = #-0x1568
 801965c: 4603         	mov	r3, r0
; }
 801965e: 4618         	mov	r0, r3
 8019660: 3710         	adds	r7, #0x10
 8019662: 46bd         	mov	sp, r7
 8019664: bd80         	pop	{r7, pc}

08019666 <pinctrl_apply_state>:
; {
 8019666: b580         	push	{r7, lr}
 8019668: b084         	sub	sp, #0x10
 801966a: af00         	add	r7, sp, #0x0
 801966c: 6078         	str	r0, [r7, #0x4]
 801966e: 460b         	mov	r3, r1
 8019670: 70fb         	strb	r3, [r7, #0x3]
; 	ret = pinctrl_lookup_state(config, id, &state);
 8019672: f107 0208    	add.w	r2, r7, #0x8
 8019676: 78fb         	ldrb	r3, [r7, #0x3]
 8019678: 4619         	mov	r1, r3
 801967a: 6878         	ldr	r0, [r7, #0x4]
 801967c: f7fe fd03    	bl	0x8018086 <pinctrl_lookup_state> @ imm = #-0x15fa
 8019680: 60f8         	str	r0, [r7, #0xc]
; 	if (ret < 0) {
 8019682: 68fb         	ldr	r3, [r7, #0xc]
 8019684: 2b00         	cmp	r3, #0x0
 8019686: da01         	bge	0x801968c <pinctrl_apply_state+0x26> @ imm = #0x2
; 		return ret;
 8019688: 68fb         	ldr	r3, [r7, #0xc]
 801968a: e005         	b	0x8019698 <pinctrl_apply_state+0x32> @ imm = #0xa
; 	return pinctrl_apply_state_direct(config, state);
 801968c: 68bb         	ldr	r3, [r7, #0x8]
 801968e: 4619         	mov	r1, r3
 8019690: 6878         	ldr	r0, [r7, #0x4]
 8019692: f7ff ffd4    	bl	0x801963e <pinctrl_apply_state_direct> @ imm = #-0x58
 8019696: 4603         	mov	r3, r0
; }
 8019698: 4618         	mov	r0, r3
 801969a: 3710         	adds	r7, #0x10
 801969c: 46bd         	mov	sp, r7
 801969e: bd80         	pop	{r7, pc}

080196a0 <z_impl_reset_line_toggle>:
; {
 80196a0: b580         	push	{r7, lr}
 80196a2: b084         	sub	sp, #0x10
 80196a4: af00         	add	r7, sp, #0x0
 80196a6: 6078         	str	r0, [r7, #0x4]
 80196a8: 6039         	str	r1, [r7]
; 	const struct reset_driver_api *api = (const struct reset_driver_api *)dev->api;
 80196aa: 687b         	ldr	r3, [r7, #0x4]
 80196ac: 689b         	ldr	r3, [r3, #0x8]
 80196ae: 60fb         	str	r3, [r7, #0xc]
; 	if (api->line_toggle == NULL) {
 80196b0: 68fb         	ldr	r3, [r7, #0xc]
 80196b2: 68db         	ldr	r3, [r3, #0xc]
 80196b4: 2b00         	cmp	r3, #0x0
 80196b6: d102         	bne	0x80196be <z_impl_reset_line_toggle+0x1e> @ imm = #0x4
; 		return -ENOSYS;
 80196b8: f06f 0357    	mvn	r3, #0x57
 80196bc: e005         	b	0x80196ca <z_impl_reset_line_toggle+0x2a> @ imm = #0xa
; 	return api->line_toggle(dev, id);
 80196be: 68fb         	ldr	r3, [r7, #0xc]
 80196c0: 68db         	ldr	r3, [r3, #0xc]
 80196c2: 6839         	ldr	r1, [r7]
 80196c4: 6878         	ldr	r0, [r7, #0x4]
 80196c6: 4798         	blx	r3
 80196c8: 4603         	mov	r3, r0
; }
 80196ca: 4618         	mov	r0, r3
 80196cc: 3710         	adds	r7, #0x10
 80196ce: 46bd         	mov	sp, r7
 80196d0: bd80         	pop	{r7, pc}

080196d2 <reset_line_toggle_dt>:
; {
 80196d2: b580         	push	{r7, lr}
 80196d4: b082         	sub	sp, #0x8
 80196d6: af00         	add	r7, sp, #0x0
 80196d8: 6078         	str	r0, [r7, #0x4]
; 	return reset_line_toggle(spec->dev, spec->id);
 80196da: 687b         	ldr	r3, [r7, #0x4]
 80196dc: 681a         	ldr	r2, [r3]
 80196de: 687b         	ldr	r3, [r7, #0x4]
 80196e0: 685b         	ldr	r3, [r3, #0x4]
 80196e2: 4619         	mov	r1, r3
 80196e4: 4610         	mov	r0, r2
 80196e6: f000 f805    	bl	0x80196f4 <reset_line_toggle> @ imm = #0xa
 80196ea: 4603         	mov	r3, r0
; }
 80196ec: 4618         	mov	r0, r3
 80196ee: 3708         	adds	r7, #0x8
 80196f0: 46bd         	mov	sp, r7
 80196f2: bd80         	pop	{r7, pc}

080196f4 <reset_line_toggle>:
; {
 80196f4: b580         	push	{r7, lr}
 80196f6: b082         	sub	sp, #0x8
 80196f8: af00         	add	r7, sp, #0x0
 80196fa: 6078         	str	r0, [r7, #0x4]
 80196fc: 6039         	str	r1, [r7]
; 	return z_impl_reset_line_toggle(dev, id);
 80196fe: 6839         	ldr	r1, [r7]
 8019700: 6878         	ldr	r0, [r7, #0x4]
 8019702: f7ff ffcd    	bl	0x80196a0 <z_impl_reset_line_toggle> @ imm = #-0x66
 8019706: 4603         	mov	r3, r0
; }
 8019708: 4618         	mov	r0, r3
 801970a: 3708         	adds	r7, #0x8
 801970c: 46bd         	mov	sp, r7
 801970e: bd80         	pop	{r7, pc}

08019710 <LL_USART_Enable>:
; {
 8019710: b480         	push	{r7}
 8019712: b083         	sub	sp, #0xc
 8019714: af00         	add	r7, sp, #0x0
 8019716: 6078         	str	r0, [r7, #0x4]
;   SET_BIT(USARTx->CR1, USART_CR1_UE);
 8019718: 687b         	ldr	r3, [r7, #0x4]
 801971a: 68db         	ldr	r3, [r3, #0xc]
 801971c: f443 5200    	orr	r2, r3, #0x2000
 8019720: 687b         	ldr	r3, [r7, #0x4]
 8019722: 60da         	str	r2, [r3, #0xc]
; }
 8019724: bf00         	nop
 8019726: 370c         	adds	r7, #0xc
 8019728: 46bd         	mov	sp, r7
 801972a: bc80         	pop	{r7}
 801972c: 4770         	bx	lr

0801972e <LL_USART_Disable>:
; {
 801972e: b480         	push	{r7}
 8019730: b083         	sub	sp, #0xc
 8019732: af00         	add	r7, sp, #0x0
 8019734: 6078         	str	r0, [r7, #0x4]
;   CLEAR_BIT(USARTx->CR1, USART_CR1_UE);
 8019736: 687b         	ldr	r3, [r7, #0x4]
 8019738: 68db         	ldr	r3, [r3, #0xc]
 801973a: f423 5200    	bic	r2, r3, #0x2000
 801973e: 687b         	ldr	r3, [r7, #0x4]
 8019740: 60da         	str	r2, [r3, #0xc]
; }
 8019742: bf00         	nop
 8019744: 370c         	adds	r7, #0xc
 8019746: 46bd         	mov	sp, r7
 8019748: bc80         	pop	{r7}
 801974a: 4770         	bx	lr

0801974c <LL_USART_SetTransferDirection>:
; {
 801974c: b480         	push	{r7}
 801974e: b089         	sub	sp, #0x24
 8019750: af00         	add	r7, sp, #0x0
 8019752: 6078         	str	r0, [r7, #0x4]
 8019754: 6039         	str	r1, [r7]
;   ATOMIC_MODIFY_REG(USARTx->CR1, USART_CR1_RE | USART_CR1_TE, TransferDirection);
 8019756: 687b         	ldr	r3, [r7, #0x4]
 8019758: 330c         	adds	r3, #0xc
 801975a: 60fb         	str	r3, [r7, #0xc]
;    __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 801975c: 68fb         	ldr	r3, [r7, #0xc]
 801975e: e853 3f00    	ldrex	r3, [r3]
 8019762: 60bb         	str	r3, [r7, #0x8]
;    return(result);
 8019764: 68bb         	ldr	r3, [r7, #0x8]
;   ATOMIC_MODIFY_REG(USARTx->CR1, USART_CR1_RE | USART_CR1_TE, TransferDirection);
 8019766: f023 030c    	bic	r3, r3, #0xc
 801976a: 683a         	ldr	r2, [r7]
 801976c: 4313         	orrs	r3, r2
 801976e: 61fb         	str	r3, [r7, #0x1c]
 8019770: 687b         	ldr	r3, [r7, #0x4]
 8019772: 330c         	adds	r3, #0xc
 8019774: 69fa         	ldr	r2, [r7, #0x1c]
 8019776: 61ba         	str	r2, [r7, #0x18]
 8019778: 617b         	str	r3, [r7, #0x14]
;    __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 801977a: 6979         	ldr	r1, [r7, #0x14]
 801977c: 69ba         	ldr	r2, [r7, #0x18]
 801977e: e841 2300    	strex	r3, r2, [r1]
 8019782: 613b         	str	r3, [r7, #0x10]
;    return(result);
 8019784: 693b         	ldr	r3, [r7, #0x10]
;   ATOMIC_MODIFY_REG(USARTx->CR1, USART_CR1_RE | USART_CR1_TE, TransferDirection);
 8019786: 2b00         	cmp	r3, #0x0
 8019788: d1e5         	bne	0x8019756 <LL_USART_SetTransferDirection+0xa> @ imm = #-0x36
; }
 801978a: bf00         	nop
 801978c: bf00         	nop
 801978e: 3724         	adds	r7, #0x24
 8019790: 46bd         	mov	sp, r7
 8019792: bc80         	pop	{r7}
 8019794: 4770         	bx	lr

08019796 <LL_USART_SetParity>:
; {
 8019796: b480         	push	{r7}
 8019798: b083         	sub	sp, #0xc
 801979a: af00         	add	r7, sp, #0x0
 801979c: 6078         	str	r0, [r7, #0x4]
 801979e: 6039         	str	r1, [r7]
;   MODIFY_REG(USARTx->CR1, USART_CR1_PS | USART_CR1_PCE, Parity);
 80197a0: 687b         	ldr	r3, [r7, #0x4]
 80197a2: 68db         	ldr	r3, [r3, #0xc]
 80197a4: f423 62c0    	bic	r2, r3, #0x600
 80197a8: 683b         	ldr	r3, [r7]
 80197aa: 431a         	orrs	r2, r3
 80197ac: 687b         	ldr	r3, [r7, #0x4]
 80197ae: 60da         	str	r2, [r3, #0xc]
; }
 80197b0: bf00         	nop
 80197b2: 370c         	adds	r7, #0xc
 80197b4: 46bd         	mov	sp, r7
 80197b6: bc80         	pop	{r7}
 80197b8: 4770         	bx	lr

080197ba <LL_USART_GetParity>:
; {
 80197ba: b480         	push	{r7}
 80197bc: b083         	sub	sp, #0xc
 80197be: af00         	add	r7, sp, #0x0
 80197c0: 6078         	str	r0, [r7, #0x4]
;   return (uint32_t)(READ_BIT(USARTx->CR1, USART_CR1_PS | USART_CR1_PCE));
 80197c2: 687b         	ldr	r3, [r7, #0x4]
 80197c4: 68db         	ldr	r3, [r3, #0xc]
 80197c6: f403 63c0    	and	r3, r3, #0x600
; }
 80197ca: 4618         	mov	r0, r3
 80197cc: 370c         	adds	r7, #0xc
 80197ce: 46bd         	mov	sp, r7
 80197d0: bc80         	pop	{r7}
 80197d2: 4770         	bx	lr

080197d4 <LL_USART_SetDataWidth>:
; {
 80197d4: b480         	push	{r7}
 80197d6: b083         	sub	sp, #0xc
 80197d8: af00         	add	r7, sp, #0x0
 80197da: 6078         	str	r0, [r7, #0x4]
 80197dc: 6039         	str	r1, [r7]
;   MODIFY_REG(USARTx->CR1, USART_CR1_M, DataWidth);
 80197de: 687b         	ldr	r3, [r7, #0x4]
 80197e0: 68db         	ldr	r3, [r3, #0xc]
 80197e2: f423 5280    	bic	r2, r3, #0x1000
 80197e6: 683b         	ldr	r3, [r7]
 80197e8: 431a         	orrs	r2, r3
 80197ea: 687b         	ldr	r3, [r7, #0x4]
 80197ec: 60da         	str	r2, [r3, #0xc]
; }
 80197ee: bf00         	nop
 80197f0: 370c         	adds	r7, #0xc
 80197f2: 46bd         	mov	sp, r7
 80197f4: bc80         	pop	{r7}
 80197f6: 4770         	bx	lr

080197f8 <LL_USART_GetDataWidth>:
; {
 80197f8: b480         	push	{r7}
 80197fa: b083         	sub	sp, #0xc
 80197fc: af00         	add	r7, sp, #0x0
 80197fe: 6078         	str	r0, [r7, #0x4]
;   return (uint32_t)(READ_BIT(USARTx->CR1, USART_CR1_M));
 8019800: 687b         	ldr	r3, [r7, #0x4]
 8019802: 68db         	ldr	r3, [r3, #0xc]
 8019804: f403 5380    	and	r3, r3, #0x1000
; }
 8019808: 4618         	mov	r0, r3
 801980a: 370c         	adds	r7, #0xc
 801980c: 46bd         	mov	sp, r7
 801980e: bc80         	pop	{r7}
 8019810: 4770         	bx	lr

08019812 <LL_USART_SetOverSampling>:
; {
 8019812: b480         	push	{r7}
 8019814: b083         	sub	sp, #0xc
 8019816: af00         	add	r7, sp, #0x0
 8019818: 6078         	str	r0, [r7, #0x4]
 801981a: 6039         	str	r1, [r7]
;   MODIFY_REG(USARTx->CR1, USART_CR1_OVER8, OverSampling);
 801981c: 687b         	ldr	r3, [r7, #0x4]
 801981e: 68db         	ldr	r3, [r3, #0xc]
 8019820: f423 4200    	bic	r2, r3, #0x8000
 8019824: 683b         	ldr	r3, [r7]
 8019826: 431a         	orrs	r2, r3
 8019828: 687b         	ldr	r3, [r7, #0x4]
 801982a: 60da         	str	r2, [r3, #0xc]
; }
 801982c: bf00         	nop
 801982e: 370c         	adds	r7, #0xc
 8019830: 46bd         	mov	sp, r7
 8019832: bc80         	pop	{r7}
 8019834: 4770         	bx	lr

08019836 <LL_USART_SetStopBitsLength>:
; {
 8019836: b480         	push	{r7}
 8019838: b083         	sub	sp, #0xc
 801983a: af00         	add	r7, sp, #0x0
 801983c: 6078         	str	r0, [r7, #0x4]
 801983e: 6039         	str	r1, [r7]
;   MODIFY_REG(USARTx->CR2, USART_CR2_STOP, StopBits);
 8019840: 687b         	ldr	r3, [r7, #0x4]
 8019842: 691b         	ldr	r3, [r3, #0x10]
 8019844: f423 5240    	bic	r2, r3, #0x3000
 8019848: 683b         	ldr	r3, [r7]
 801984a: 431a         	orrs	r2, r3
 801984c: 687b         	ldr	r3, [r7, #0x4]
 801984e: 611a         	str	r2, [r3, #0x10]
; }
 8019850: bf00         	nop
 8019852: 370c         	adds	r7, #0xc
 8019854: 46bd         	mov	sp, r7
 8019856: bc80         	pop	{r7}
 8019858: 4770         	bx	lr

0801985a <LL_USART_GetStopBitsLength>:
; {
 801985a: b480         	push	{r7}
 801985c: b083         	sub	sp, #0xc
 801985e: af00         	add	r7, sp, #0x0
 8019860: 6078         	str	r0, [r7, #0x4]
;   return (uint32_t)(READ_BIT(USARTx->CR2, USART_CR2_STOP));
 8019862: 687b         	ldr	r3, [r7, #0x4]
 8019864: 691b         	ldr	r3, [r3, #0x10]
 8019866: f403 5340    	and	r3, r3, #0x3000
; }
 801986a: 4618         	mov	r0, r3
 801986c: 370c         	adds	r7, #0xc
 801986e: 46bd         	mov	sp, r7
 8019870: bc80         	pop	{r7}
 8019872: 4770         	bx	lr

08019874 <LL_USART_ConfigCharacter>:
; {
 8019874: b480         	push	{r7}
 8019876: b085         	sub	sp, #0x14
 8019878: af00         	add	r7, sp, #0x0
 801987a: 60f8         	str	r0, [r7, #0xc]
 801987c: 60b9         	str	r1, [r7, #0x8]
 801987e: 607a         	str	r2, [r7, #0x4]
 8019880: 603b         	str	r3, [r7]
;   MODIFY_REG(USARTx->CR1, USART_CR1_PS | USART_CR1_PCE | USART_CR1_M, Parity | DataWidth);
 8019882: 68fb         	ldr	r3, [r7, #0xc]
 8019884: 68db         	ldr	r3, [r3, #0xc]
 8019886: f423 52b0    	bic	r2, r3, #0x1600
 801988a: 6879         	ldr	r1, [r7, #0x4]
 801988c: 68bb         	ldr	r3, [r7, #0x8]
 801988e: 430b         	orrs	r3, r1
 8019890: 431a         	orrs	r2, r3
 8019892: 68fb         	ldr	r3, [r7, #0xc]
 8019894: 60da         	str	r2, [r3, #0xc]
;   MODIFY_REG(USARTx->CR2, USART_CR2_STOP, StopBits);
 8019896: 68fb         	ldr	r3, [r7, #0xc]
 8019898: 691b         	ldr	r3, [r3, #0x10]
 801989a: f423 5240    	bic	r2, r3, #0x3000
 801989e: 683b         	ldr	r3, [r7]
 80198a0: 431a         	orrs	r2, r3
 80198a2: 68fb         	ldr	r3, [r7, #0xc]
 80198a4: 611a         	str	r2, [r3, #0x10]
; }
 80198a6: bf00         	nop
 80198a8: 3714         	adds	r7, #0x14
 80198aa: 46bd         	mov	sp, r7
 80198ac: bc80         	pop	{r7}
 80198ae: 4770         	bx	lr

080198b0 <LL_USART_SetHWFlowCtrl>:
; {
 80198b0: b480         	push	{r7}
 80198b2: b083         	sub	sp, #0xc
 80198b4: af00         	add	r7, sp, #0x0
 80198b6: 6078         	str	r0, [r7, #0x4]
 80198b8: 6039         	str	r1, [r7]
;   MODIFY_REG(USARTx->CR3, USART_CR3_RTSE | USART_CR3_CTSE, HardwareFlowControl);
 80198ba: 687b         	ldr	r3, [r7, #0x4]
 80198bc: 695b         	ldr	r3, [r3, #0x14]
 80198be: f423 7240    	bic	r2, r3, #0x300
 80198c2: 683b         	ldr	r3, [r7]
 80198c4: 431a         	orrs	r2, r3
 80198c6: 687b         	ldr	r3, [r7, #0x4]
 80198c8: 615a         	str	r2, [r3, #0x14]
; }
 80198ca: bf00         	nop
 80198cc: 370c         	adds	r7, #0xc
 80198ce: 46bd         	mov	sp, r7
 80198d0: bc80         	pop	{r7}
 80198d2: 4770         	bx	lr

080198d4 <LL_USART_GetHWFlowCtrl>:
; {
 80198d4: b480         	push	{r7}
 80198d6: b083         	sub	sp, #0xc
 80198d8: af00         	add	r7, sp, #0x0
 80198da: 6078         	str	r0, [r7, #0x4]
;   return (uint32_t)(READ_BIT(USARTx->CR3, USART_CR3_RTSE | USART_CR3_CTSE));
 80198dc: 687b         	ldr	r3, [r7, #0x4]
 80198de: 695b         	ldr	r3, [r3, #0x14]
 80198e0: f403 7340    	and	r3, r3, #0x300
; }
 80198e4: 4618         	mov	r0, r3
 80198e6: 370c         	adds	r7, #0xc
 80198e8: 46bd         	mov	sp, r7
 80198ea: bc80         	pop	{r7}
 80198ec: 4770         	bx	lr

080198ee <LL_USART_EnableHalfDuplex>:
; {
 80198ee: b480         	push	{r7}
 80198f0: b083         	sub	sp, #0xc
 80198f2: af00         	add	r7, sp, #0x0
 80198f4: 6078         	str	r0, [r7, #0x4]
;   SET_BIT(USARTx->CR3, USART_CR3_HDSEL);
 80198f6: 687b         	ldr	r3, [r7, #0x4]
 80198f8: 695b         	ldr	r3, [r3, #0x14]
 80198fa: f043 0208    	orr	r2, r3, #0x8
 80198fe: 687b         	ldr	r3, [r7, #0x4]
 8019900: 615a         	str	r2, [r3, #0x14]
; }
 8019902: bf00         	nop
 8019904: 370c         	adds	r7, #0xc
 8019906: 46bd         	mov	sp, r7
 8019908: bc80         	pop	{r7}
 801990a: 4770         	bx	lr

0801990c <LL_USART_IsActiveFlag_PE>:
; {
 801990c: b480         	push	{r7}
 801990e: b083         	sub	sp, #0xc
 8019910: af00         	add	r7, sp, #0x0
 8019912: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(USARTx->SR, USART_SR_PE) == (USART_SR_PE));
 8019914: 687b         	ldr	r3, [r7, #0x4]
 8019916: 681b         	ldr	r3, [r3]
 8019918: f003 0301    	and	r3, r3, #0x1
 801991c: 2b01         	cmp	r3, #0x1
 801991e: bf0c         	ite	eq
 8019920: 2301         	moveq	r3, #0x1
 8019922: 2300         	movne	r3, #0x0
 8019924: b2db         	uxtb	r3, r3
; }
 8019926: 4618         	mov	r0, r3
 8019928: 370c         	adds	r7, #0xc
 801992a: 46bd         	mov	sp, r7
 801992c: bc80         	pop	{r7}
 801992e: 4770         	bx	lr

08019930 <LL_USART_IsActiveFlag_FE>:
; {
 8019930: b480         	push	{r7}
 8019932: b083         	sub	sp, #0xc
 8019934: af00         	add	r7, sp, #0x0
 8019936: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(USARTx->SR, USART_SR_FE) == (USART_SR_FE));
 8019938: 687b         	ldr	r3, [r7, #0x4]
 801993a: 681b         	ldr	r3, [r3]
 801993c: f003 0302    	and	r3, r3, #0x2
 8019940: 2b02         	cmp	r3, #0x2
 8019942: bf0c         	ite	eq
 8019944: 2301         	moveq	r3, #0x1
 8019946: 2300         	movne	r3, #0x0
 8019948: b2db         	uxtb	r3, r3
; }
 801994a: 4618         	mov	r0, r3
 801994c: 370c         	adds	r7, #0xc
 801994e: 46bd         	mov	sp, r7
 8019950: bc80         	pop	{r7}
 8019952: 4770         	bx	lr

08019954 <LL_USART_IsActiveFlag_NE>:
; {
 8019954: b480         	push	{r7}
 8019956: b083         	sub	sp, #0xc
 8019958: af00         	add	r7, sp, #0x0
 801995a: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(USARTx->SR, USART_SR_NE) == (USART_SR_NE));
 801995c: 687b         	ldr	r3, [r7, #0x4]
 801995e: 681b         	ldr	r3, [r3]
 8019960: f003 0304    	and	r3, r3, #0x4
 8019964: 2b04         	cmp	r3, #0x4
 8019966: bf0c         	ite	eq
 8019968: 2301         	moveq	r3, #0x1
 801996a: 2300         	movne	r3, #0x0
 801996c: b2db         	uxtb	r3, r3
; }
 801996e: 4618         	mov	r0, r3
 8019970: 370c         	adds	r7, #0xc
 8019972: 46bd         	mov	sp, r7
 8019974: bc80         	pop	{r7}
 8019976: 4770         	bx	lr

08019978 <LL_USART_IsActiveFlag_ORE>:
; {
 8019978: b480         	push	{r7}
 801997a: b083         	sub	sp, #0xc
 801997c: af00         	add	r7, sp, #0x0
 801997e: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(USARTx->SR, USART_SR_ORE) == (USART_SR_ORE));
 8019980: 687b         	ldr	r3, [r7, #0x4]
 8019982: 681b         	ldr	r3, [r3]
 8019984: f003 0308    	and	r3, r3, #0x8
 8019988: 2b08         	cmp	r3, #0x8
 801998a: bf0c         	ite	eq
 801998c: 2301         	moveq	r3, #0x1
 801998e: 2300         	movne	r3, #0x0
 8019990: b2db         	uxtb	r3, r3
; }
 8019992: 4618         	mov	r0, r3
 8019994: 370c         	adds	r7, #0xc
 8019996: 46bd         	mov	sp, r7
 8019998: bc80         	pop	{r7}
 801999a: 4770         	bx	lr

0801999c <LL_USART_IsActiveFlag_IDLE>:
; {
 801999c: b480         	push	{r7}
 801999e: b083         	sub	sp, #0xc
 80199a0: af00         	add	r7, sp, #0x0
 80199a2: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(USARTx->SR, USART_SR_IDLE) == (USART_SR_IDLE));
 80199a4: 687b         	ldr	r3, [r7, #0x4]
 80199a6: 681b         	ldr	r3, [r3]
 80199a8: f003 0310    	and	r3, r3, #0x10
 80199ac: 2b10         	cmp	r3, #0x10
 80199ae: bf0c         	ite	eq
 80199b0: 2301         	moveq	r3, #0x1
 80199b2: 2300         	movne	r3, #0x0
 80199b4: b2db         	uxtb	r3, r3
; }
 80199b6: 4618         	mov	r0, r3
 80199b8: 370c         	adds	r7, #0xc
 80199ba: 46bd         	mov	sp, r7
 80199bc: bc80         	pop	{r7}
 80199be: 4770         	bx	lr

080199c0 <LL_USART_IsActiveFlag_RXNE>:
; {
 80199c0: b480         	push	{r7}
 80199c2: b083         	sub	sp, #0xc
 80199c4: af00         	add	r7, sp, #0x0
 80199c6: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(USARTx->SR, USART_SR_RXNE) == (USART_SR_RXNE));
 80199c8: 687b         	ldr	r3, [r7, #0x4]
 80199ca: 681b         	ldr	r3, [r3]
 80199cc: f003 0320    	and	r3, r3, #0x20
 80199d0: 2b20         	cmp	r3, #0x20
 80199d2: bf0c         	ite	eq
 80199d4: 2301         	moveq	r3, #0x1
 80199d6: 2300         	movne	r3, #0x0
 80199d8: b2db         	uxtb	r3, r3
; }
 80199da: 4618         	mov	r0, r3
 80199dc: 370c         	adds	r7, #0xc
 80199de: 46bd         	mov	sp, r7
 80199e0: bc80         	pop	{r7}
 80199e2: 4770         	bx	lr

080199e4 <LL_USART_IsActiveFlag_TC>:
; {
 80199e4: b480         	push	{r7}
 80199e6: b083         	sub	sp, #0xc
 80199e8: af00         	add	r7, sp, #0x0
 80199ea: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(USARTx->SR, USART_SR_TC) == (USART_SR_TC));
 80199ec: 687b         	ldr	r3, [r7, #0x4]
 80199ee: 681b         	ldr	r3, [r3]
 80199f0: f003 0340    	and	r3, r3, #0x40
 80199f4: 2b40         	cmp	r3, #0x40
 80199f6: bf0c         	ite	eq
 80199f8: 2301         	moveq	r3, #0x1
 80199fa: 2300         	movne	r3, #0x0
 80199fc: b2db         	uxtb	r3, r3
; }
 80199fe: 4618         	mov	r0, r3
 8019a00: 370c         	adds	r7, #0xc
 8019a02: 46bd         	mov	sp, r7
 8019a04: bc80         	pop	{r7}
 8019a06: 4770         	bx	lr

08019a08 <LL_USART_IsActiveFlag_TXE>:
; {
 8019a08: b480         	push	{r7}
 8019a0a: b083         	sub	sp, #0xc
 8019a0c: af00         	add	r7, sp, #0x0
 8019a0e: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(USARTx->SR, USART_SR_TXE) == (USART_SR_TXE));
 8019a10: 687b         	ldr	r3, [r7, #0x4]
 8019a12: 681b         	ldr	r3, [r3]
 8019a14: f003 0380    	and	r3, r3, #0x80
 8019a18: 2b80         	cmp	r3, #0x80
 8019a1a: bf0c         	ite	eq
 8019a1c: 2301         	moveq	r3, #0x1
 8019a1e: 2300         	movne	r3, #0x0
 8019a20: b2db         	uxtb	r3, r3
; }
 8019a22: 4618         	mov	r0, r3
 8019a24: 370c         	adds	r7, #0xc
 8019a26: 46bd         	mov	sp, r7
 8019a28: bc80         	pop	{r7}
 8019a2a: 4770         	bx	lr

08019a2c <LL_USART_IsActiveFlag_LBD>:
; {
 8019a2c: b480         	push	{r7}
 8019a2e: b083         	sub	sp, #0xc
 8019a30: af00         	add	r7, sp, #0x0
 8019a32: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(USARTx->SR, USART_SR_LBD) == (USART_SR_LBD));
 8019a34: 687b         	ldr	r3, [r7, #0x4]
 8019a36: 681b         	ldr	r3, [r3]
 8019a38: f403 7380    	and	r3, r3, #0x100
 8019a3c: f5b3 7f80    	cmp.w	r3, #0x100
 8019a40: bf0c         	ite	eq
 8019a42: 2301         	moveq	r3, #0x1
 8019a44: 2300         	movne	r3, #0x0
 8019a46: b2db         	uxtb	r3, r3
; }
 8019a48: 4618         	mov	r0, r3
 8019a4a: 370c         	adds	r7, #0xc
 8019a4c: 46bd         	mov	sp, r7
 8019a4e: bc80         	pop	{r7}
 8019a50: 4770         	bx	lr

08019a52 <LL_USART_ClearFlag_PE>:
; {
 8019a52: b480         	push	{r7}
 8019a54: b085         	sub	sp, #0x14
 8019a56: af00         	add	r7, sp, #0x0
 8019a58: 6078         	str	r0, [r7, #0x4]
;   tmpreg = USARTx->SR;
 8019a5a: 687b         	ldr	r3, [r7, #0x4]
 8019a5c: 681b         	ldr	r3, [r3]
 8019a5e: 60fb         	str	r3, [r7, #0xc]
;   (void) tmpreg;
 8019a60: 68fb         	ldr	r3, [r7, #0xc]
;   tmpreg = USARTx->DR;
 8019a62: 687b         	ldr	r3, [r7, #0x4]
 8019a64: 685b         	ldr	r3, [r3, #0x4]
 8019a66: 60fb         	str	r3, [r7, #0xc]
;   (void) tmpreg;
 8019a68: 68fb         	ldr	r3, [r7, #0xc]
; }
 8019a6a: bf00         	nop
 8019a6c: 3714         	adds	r7, #0x14
 8019a6e: 46bd         	mov	sp, r7
 8019a70: bc80         	pop	{r7}
 8019a72: 4770         	bx	lr

08019a74 <LL_USART_ClearFlag_FE>:
; {
 8019a74: b480         	push	{r7}
 8019a76: b085         	sub	sp, #0x14
 8019a78: af00         	add	r7, sp, #0x0
 8019a7a: 6078         	str	r0, [r7, #0x4]
;   tmpreg = USARTx->SR;
 8019a7c: 687b         	ldr	r3, [r7, #0x4]
 8019a7e: 681b         	ldr	r3, [r3]
 8019a80: 60fb         	str	r3, [r7, #0xc]
;   (void) tmpreg;
 8019a82: 68fb         	ldr	r3, [r7, #0xc]
;   tmpreg = USARTx->DR;
 8019a84: 687b         	ldr	r3, [r7, #0x4]
 8019a86: 685b         	ldr	r3, [r3, #0x4]
 8019a88: 60fb         	str	r3, [r7, #0xc]
;   (void) tmpreg;
 8019a8a: 68fb         	ldr	r3, [r7, #0xc]
; }
 8019a8c: bf00         	nop
 8019a8e: 3714         	adds	r7, #0x14
 8019a90: 46bd         	mov	sp, r7
 8019a92: bc80         	pop	{r7}
 8019a94: 4770         	bx	lr

08019a96 <LL_USART_ClearFlag_NE>:
; {
 8019a96: b480         	push	{r7}
 8019a98: b085         	sub	sp, #0x14
 8019a9a: af00         	add	r7, sp, #0x0
 8019a9c: 6078         	str	r0, [r7, #0x4]
;   tmpreg = USARTx->SR;
 8019a9e: 687b         	ldr	r3, [r7, #0x4]
 8019aa0: 681b         	ldr	r3, [r3]
 8019aa2: 60fb         	str	r3, [r7, #0xc]
;   (void) tmpreg;
 8019aa4: 68fb         	ldr	r3, [r7, #0xc]
;   tmpreg = USARTx->DR;
 8019aa6: 687b         	ldr	r3, [r7, #0x4]
 8019aa8: 685b         	ldr	r3, [r3, #0x4]
 8019aaa: 60fb         	str	r3, [r7, #0xc]
;   (void) tmpreg;
 8019aac: 68fb         	ldr	r3, [r7, #0xc]
; }
 8019aae: bf00         	nop
 8019ab0: 3714         	adds	r7, #0x14
 8019ab2: 46bd         	mov	sp, r7
 8019ab4: bc80         	pop	{r7}
 8019ab6: 4770         	bx	lr

08019ab8 <LL_USART_ClearFlag_ORE>:
; {
 8019ab8: b480         	push	{r7}
 8019aba: b085         	sub	sp, #0x14
 8019abc: af00         	add	r7, sp, #0x0
 8019abe: 6078         	str	r0, [r7, #0x4]
;   tmpreg = USARTx->SR;
 8019ac0: 687b         	ldr	r3, [r7, #0x4]
 8019ac2: 681b         	ldr	r3, [r3]
 8019ac4: 60fb         	str	r3, [r7, #0xc]
;   (void) tmpreg;
 8019ac6: 68fb         	ldr	r3, [r7, #0xc]
;   tmpreg = USARTx->DR;
 8019ac8: 687b         	ldr	r3, [r7, #0x4]
 8019aca: 685b         	ldr	r3, [r3, #0x4]
 8019acc: 60fb         	str	r3, [r7, #0xc]
;   (void) tmpreg;
 8019ace: 68fb         	ldr	r3, [r7, #0xc]
; }
 8019ad0: bf00         	nop
 8019ad2: 3714         	adds	r7, #0x14
 8019ad4: 46bd         	mov	sp, r7
 8019ad6: bc80         	pop	{r7}
 8019ad8: 4770         	bx	lr

08019ada <LL_USART_ClearFlag_IDLE>:
; {
 8019ada: b480         	push	{r7}
 8019adc: b085         	sub	sp, #0x14
 8019ade: af00         	add	r7, sp, #0x0
 8019ae0: 6078         	str	r0, [r7, #0x4]
;   tmpreg = USARTx->SR;
 8019ae2: 687b         	ldr	r3, [r7, #0x4]
 8019ae4: 681b         	ldr	r3, [r3]
 8019ae6: 60fb         	str	r3, [r7, #0xc]
;   (void) tmpreg;
 8019ae8: 68fb         	ldr	r3, [r7, #0xc]
;   tmpreg = USARTx->DR;
 8019aea: 687b         	ldr	r3, [r7, #0x4]
 8019aec: 685b         	ldr	r3, [r3, #0x4]
 8019aee: 60fb         	str	r3, [r7, #0xc]
;   (void) tmpreg;
 8019af0: 68fb         	ldr	r3, [r7, #0xc]
; }
 8019af2: bf00         	nop
 8019af4: 3714         	adds	r7, #0x14
 8019af6: 46bd         	mov	sp, r7
 8019af8: bc80         	pop	{r7}
 8019afa: 4770         	bx	lr

08019afc <LL_USART_ClearFlag_TC>:
; {
 8019afc: b480         	push	{r7}
 8019afe: b083         	sub	sp, #0xc
 8019b00: af00         	add	r7, sp, #0x0
 8019b02: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(USARTx->SR, ~(USART_SR_TC));
 8019b04: 687b         	ldr	r3, [r7, #0x4]
 8019b06: f06f 0240    	mvn	r2, #0x40
 8019b0a: 601a         	str	r2, [r3]
; }
 8019b0c: bf00         	nop
 8019b0e: 370c         	adds	r7, #0xc
 8019b10: 46bd         	mov	sp, r7
 8019b12: bc80         	pop	{r7}
 8019b14: 4770         	bx	lr

08019b16 <LL_USART_ClearFlag_RXNE>:
; {
 8019b16: b480         	push	{r7}
 8019b18: b083         	sub	sp, #0xc
 8019b1a: af00         	add	r7, sp, #0x0
 8019b1c: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(USARTx->SR, ~(USART_SR_RXNE));
 8019b1e: 687b         	ldr	r3, [r7, #0x4]
 8019b20: f06f 0220    	mvn	r2, #0x20
 8019b24: 601a         	str	r2, [r3]
; }
 8019b26: bf00         	nop
 8019b28: 370c         	adds	r7, #0xc
 8019b2a: 46bd         	mov	sp, r7
 8019b2c: bc80         	pop	{r7}
 8019b2e: 4770         	bx	lr

08019b30 <LL_USART_ClearFlag_LBD>:
; {
 8019b30: b480         	push	{r7}
 8019b32: b083         	sub	sp, #0xc
 8019b34: af00         	add	r7, sp, #0x0
 8019b36: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(USARTx->SR, ~(USART_SR_LBD));
 8019b38: 687b         	ldr	r3, [r7, #0x4]
 8019b3a: f46f 7280    	mvn	r2, #0x100
 8019b3e: 601a         	str	r2, [r3]
; }
 8019b40: bf00         	nop
 8019b42: 370c         	adds	r7, #0xc
 8019b44: 46bd         	mov	sp, r7
 8019b46: bc80         	pop	{r7}
 8019b48: 4770         	bx	lr

08019b4a <LL_USART_EnableIT_IDLE>:
; {
 8019b4a: b480         	push	{r7}
 8019b4c: b089         	sub	sp, #0x24
 8019b4e: af00         	add	r7, sp, #0x0
 8019b50: 6078         	str	r0, [r7, #0x4]
;   ATOMIC_SET_BIT(USARTx->CR1, USART_CR1_IDLEIE);
 8019b52: 687b         	ldr	r3, [r7, #0x4]
 8019b54: 330c         	adds	r3, #0xc
 8019b56: 60fb         	str	r3, [r7, #0xc]
;    __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8019b58: 68fb         	ldr	r3, [r7, #0xc]
 8019b5a: e853 3f00    	ldrex	r3, [r3]
 8019b5e: 60bb         	str	r3, [r7, #0x8]
;    return(result);
 8019b60: 68bb         	ldr	r3, [r7, #0x8]
;   ATOMIC_SET_BIT(USARTx->CR1, USART_CR1_IDLEIE);
 8019b62: f043 0310    	orr	r3, r3, #0x10
 8019b66: 61fb         	str	r3, [r7, #0x1c]
 8019b68: 687b         	ldr	r3, [r7, #0x4]
 8019b6a: 330c         	adds	r3, #0xc
 8019b6c: 69fa         	ldr	r2, [r7, #0x1c]
 8019b6e: 61ba         	str	r2, [r7, #0x18]
 8019b70: 617b         	str	r3, [r7, #0x14]
;    __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8019b72: 6979         	ldr	r1, [r7, #0x14]
 8019b74: 69ba         	ldr	r2, [r7, #0x18]
 8019b76: e841 2300    	strex	r3, r2, [r1]
 8019b7a: 613b         	str	r3, [r7, #0x10]
;    return(result);
 8019b7c: 693b         	ldr	r3, [r7, #0x10]
;   ATOMIC_SET_BIT(USARTx->CR1, USART_CR1_IDLEIE);
 8019b7e: 2b00         	cmp	r3, #0x0
 8019b80: d1e7         	bne	0x8019b52 <LL_USART_EnableIT_IDLE+0x8> @ imm = #-0x32
; }
 8019b82: bf00         	nop
 8019b84: bf00         	nop
 8019b86: 3724         	adds	r7, #0x24
 8019b88: 46bd         	mov	sp, r7
 8019b8a: bc80         	pop	{r7}
 8019b8c: 4770         	bx	lr

08019b8e <LL_USART_EnableIT_RXNE>:
; {
 8019b8e: b480         	push	{r7}
 8019b90: b089         	sub	sp, #0x24
 8019b92: af00         	add	r7, sp, #0x0
 8019b94: 6078         	str	r0, [r7, #0x4]
;   ATOMIC_SET_BIT(USARTx->CR1, USART_CR1_RXNEIE);
 8019b96: 687b         	ldr	r3, [r7, #0x4]
 8019b98: 330c         	adds	r3, #0xc
 8019b9a: 60fb         	str	r3, [r7, #0xc]
;    __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8019b9c: 68fb         	ldr	r3, [r7, #0xc]
 8019b9e: e853 3f00    	ldrex	r3, [r3]
 8019ba2: 60bb         	str	r3, [r7, #0x8]
;    return(result);
 8019ba4: 68bb         	ldr	r3, [r7, #0x8]
;   ATOMIC_SET_BIT(USARTx->CR1, USART_CR1_RXNEIE);
 8019ba6: f043 0320    	orr	r3, r3, #0x20
 8019baa: 61fb         	str	r3, [r7, #0x1c]
 8019bac: 687b         	ldr	r3, [r7, #0x4]
 8019bae: 330c         	adds	r3, #0xc
 8019bb0: 69fa         	ldr	r2, [r7, #0x1c]
 8019bb2: 61ba         	str	r2, [r7, #0x18]
 8019bb4: 617b         	str	r3, [r7, #0x14]
;    __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8019bb6: 6979         	ldr	r1, [r7, #0x14]
 8019bb8: 69ba         	ldr	r2, [r7, #0x18]
 8019bba: e841 2300    	strex	r3, r2, [r1]
 8019bbe: 613b         	str	r3, [r7, #0x10]
;    return(result);
 8019bc0: 693b         	ldr	r3, [r7, #0x10]
;   ATOMIC_SET_BIT(USARTx->CR1, USART_CR1_RXNEIE);
 8019bc2: 2b00         	cmp	r3, #0x0
 8019bc4: d1e7         	bne	0x8019b96 <LL_USART_EnableIT_RXNE+0x8> @ imm = #-0x32
; }
 8019bc6: bf00         	nop
 8019bc8: bf00         	nop
 8019bca: 3724         	adds	r7, #0x24
 8019bcc: 46bd         	mov	sp, r7
 8019bce: bc80         	pop	{r7}
 8019bd0: 4770         	bx	lr

08019bd2 <LL_USART_EnableIT_TC>:
; {
 8019bd2: b480         	push	{r7}
 8019bd4: b089         	sub	sp, #0x24
 8019bd6: af00         	add	r7, sp, #0x0
 8019bd8: 6078         	str	r0, [r7, #0x4]
;   ATOMIC_SET_BIT(USARTx->CR1, USART_CR1_TCIE);
 8019bda: 687b         	ldr	r3, [r7, #0x4]
 8019bdc: 330c         	adds	r3, #0xc
 8019bde: 60fb         	str	r3, [r7, #0xc]
;    __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8019be0: 68fb         	ldr	r3, [r7, #0xc]
 8019be2: e853 3f00    	ldrex	r3, [r3]
 8019be6: 60bb         	str	r3, [r7, #0x8]
;    return(result);
 8019be8: 68bb         	ldr	r3, [r7, #0x8]
;   ATOMIC_SET_BIT(USARTx->CR1, USART_CR1_TCIE);
 8019bea: f043 0340    	orr	r3, r3, #0x40
 8019bee: 61fb         	str	r3, [r7, #0x1c]
 8019bf0: 687b         	ldr	r3, [r7, #0x4]
 8019bf2: 330c         	adds	r3, #0xc
 8019bf4: 69fa         	ldr	r2, [r7, #0x1c]
 8019bf6: 61ba         	str	r2, [r7, #0x18]
 8019bf8: 617b         	str	r3, [r7, #0x14]
;    __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8019bfa: 6979         	ldr	r1, [r7, #0x14]
 8019bfc: 69ba         	ldr	r2, [r7, #0x18]
 8019bfe: e841 2300    	strex	r3, r2, [r1]
 8019c02: 613b         	str	r3, [r7, #0x10]
;    return(result);
 8019c04: 693b         	ldr	r3, [r7, #0x10]
;   ATOMIC_SET_BIT(USARTx->CR1, USART_CR1_TCIE);
 8019c06: 2b00         	cmp	r3, #0x0
 8019c08: d1e7         	bne	0x8019bda <LL_USART_EnableIT_TC+0x8> @ imm = #-0x32
; }
 8019c0a: bf00         	nop
 8019c0c: bf00         	nop
 8019c0e: 3724         	adds	r7, #0x24
 8019c10: 46bd         	mov	sp, r7
 8019c12: bc80         	pop	{r7}
 8019c14: 4770         	bx	lr

08019c16 <LL_USART_EnableIT_PE>:
; {
 8019c16: b480         	push	{r7}
 8019c18: b089         	sub	sp, #0x24
 8019c1a: af00         	add	r7, sp, #0x0
 8019c1c: 6078         	str	r0, [r7, #0x4]
;   ATOMIC_SET_BIT(USARTx->CR1, USART_CR1_PEIE);
 8019c1e: 687b         	ldr	r3, [r7, #0x4]
 8019c20: 330c         	adds	r3, #0xc
 8019c22: 60fb         	str	r3, [r7, #0xc]
;    __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8019c24: 68fb         	ldr	r3, [r7, #0xc]
 8019c26: e853 3f00    	ldrex	r3, [r3]
 8019c2a: 60bb         	str	r3, [r7, #0x8]
;    return(result);
 8019c2c: 68bb         	ldr	r3, [r7, #0x8]
;   ATOMIC_SET_BIT(USARTx->CR1, USART_CR1_PEIE);
 8019c2e: f443 7380    	orr	r3, r3, #0x100
 8019c32: 61fb         	str	r3, [r7, #0x1c]
 8019c34: 687b         	ldr	r3, [r7, #0x4]
 8019c36: 330c         	adds	r3, #0xc
 8019c38: 69fa         	ldr	r2, [r7, #0x1c]
 8019c3a: 61ba         	str	r2, [r7, #0x18]
 8019c3c: 617b         	str	r3, [r7, #0x14]
;    __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8019c3e: 6979         	ldr	r1, [r7, #0x14]
 8019c40: 69ba         	ldr	r2, [r7, #0x18]
 8019c42: e841 2300    	strex	r3, r2, [r1]
 8019c46: 613b         	str	r3, [r7, #0x10]
;    return(result);
 8019c48: 693b         	ldr	r3, [r7, #0x10]
;   ATOMIC_SET_BIT(USARTx->CR1, USART_CR1_PEIE);
 8019c4a: 2b00         	cmp	r3, #0x0
 8019c4c: d1e7         	bne	0x8019c1e <LL_USART_EnableIT_PE+0x8> @ imm = #-0x32
; }
 8019c4e: bf00         	nop
 8019c50: bf00         	nop
 8019c52: 3724         	adds	r7, #0x24
 8019c54: 46bd         	mov	sp, r7
 8019c56: bc80         	pop	{r7}
 8019c58: 4770         	bx	lr

08019c5a <LL_USART_EnableIT_LBD>:
; {
 8019c5a: b480         	push	{r7}
 8019c5c: b083         	sub	sp, #0xc
 8019c5e: af00         	add	r7, sp, #0x0
 8019c60: 6078         	str	r0, [r7, #0x4]
;   SET_BIT(USARTx->CR2, USART_CR2_LBDIE);
 8019c62: 687b         	ldr	r3, [r7, #0x4]
 8019c64: 691b         	ldr	r3, [r3, #0x10]
 8019c66: f043 0240    	orr	r2, r3, #0x40
 8019c6a: 687b         	ldr	r3, [r7, #0x4]
 8019c6c: 611a         	str	r2, [r3, #0x10]
; }
 8019c6e: bf00         	nop
 8019c70: 370c         	adds	r7, #0xc
 8019c72: 46bd         	mov	sp, r7
 8019c74: bc80         	pop	{r7}
 8019c76: 4770         	bx	lr

08019c78 <LL_USART_EnableIT_ERROR>:
; {
 8019c78: b480         	push	{r7}
 8019c7a: b089         	sub	sp, #0x24
 8019c7c: af00         	add	r7, sp, #0x0
 8019c7e: 6078         	str	r0, [r7, #0x4]
;   ATOMIC_SET_BIT(USARTx->CR3, USART_CR3_EIE);
 8019c80: 687b         	ldr	r3, [r7, #0x4]
 8019c82: 3314         	adds	r3, #0x14
 8019c84: 60fb         	str	r3, [r7, #0xc]
;    __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8019c86: 68fb         	ldr	r3, [r7, #0xc]
 8019c88: e853 3f00    	ldrex	r3, [r3]
 8019c8c: 60bb         	str	r3, [r7, #0x8]
;    return(result);
 8019c8e: 68bb         	ldr	r3, [r7, #0x8]
;   ATOMIC_SET_BIT(USARTx->CR3, USART_CR3_EIE);
 8019c90: f043 0301    	orr	r3, r3, #0x1
 8019c94: 61fb         	str	r3, [r7, #0x1c]
 8019c96: 687b         	ldr	r3, [r7, #0x4]
 8019c98: 3314         	adds	r3, #0x14
 8019c9a: 69fa         	ldr	r2, [r7, #0x1c]
 8019c9c: 61ba         	str	r2, [r7, #0x18]
 8019c9e: 617b         	str	r3, [r7, #0x14]
;    __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8019ca0: 6979         	ldr	r1, [r7, #0x14]
 8019ca2: 69ba         	ldr	r2, [r7, #0x18]
 8019ca4: e841 2300    	strex	r3, r2, [r1]
 8019ca8: 613b         	str	r3, [r7, #0x10]
;    return(result);
 8019caa: 693b         	ldr	r3, [r7, #0x10]
;   ATOMIC_SET_BIT(USARTx->CR3, USART_CR3_EIE);
 8019cac: 2b00         	cmp	r3, #0x0
 8019cae: d1e7         	bne	0x8019c80 <LL_USART_EnableIT_ERROR+0x8> @ imm = #-0x32
; }
 8019cb0: bf00         	nop
 8019cb2: bf00         	nop
 8019cb4: 3724         	adds	r7, #0x24
 8019cb6: 46bd         	mov	sp, r7
 8019cb8: bc80         	pop	{r7}
 8019cba: 4770         	bx	lr

08019cbc <LL_USART_DisableIT_IDLE>:
; {
 8019cbc: b480         	push	{r7}
 8019cbe: b089         	sub	sp, #0x24
 8019cc0: af00         	add	r7, sp, #0x0
 8019cc2: 6078         	str	r0, [r7, #0x4]
;   ATOMIC_CLEAR_BIT(USARTx->CR1, USART_CR1_IDLEIE);
 8019cc4: 687b         	ldr	r3, [r7, #0x4]
 8019cc6: 330c         	adds	r3, #0xc
 8019cc8: 60fb         	str	r3, [r7, #0xc]
;    __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8019cca: 68fb         	ldr	r3, [r7, #0xc]
 8019ccc: e853 3f00    	ldrex	r3, [r3]
 8019cd0: 60bb         	str	r3, [r7, #0x8]
;    return(result);
 8019cd2: 68bb         	ldr	r3, [r7, #0x8]
;   ATOMIC_CLEAR_BIT(USARTx->CR1, USART_CR1_IDLEIE);
 8019cd4: f023 0310    	bic	r3, r3, #0x10
 8019cd8: 61fb         	str	r3, [r7, #0x1c]
 8019cda: 687b         	ldr	r3, [r7, #0x4]
 8019cdc: 330c         	adds	r3, #0xc
 8019cde: 69fa         	ldr	r2, [r7, #0x1c]
 8019ce0: 61ba         	str	r2, [r7, #0x18]
 8019ce2: 617b         	str	r3, [r7, #0x14]
;    __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8019ce4: 6979         	ldr	r1, [r7, #0x14]
 8019ce6: 69ba         	ldr	r2, [r7, #0x18]
 8019ce8: e841 2300    	strex	r3, r2, [r1]
 8019cec: 613b         	str	r3, [r7, #0x10]
;    return(result);
 8019cee: 693b         	ldr	r3, [r7, #0x10]
;   ATOMIC_CLEAR_BIT(USARTx->CR1, USART_CR1_IDLEIE);
 8019cf0: 2b00         	cmp	r3, #0x0
 8019cf2: d1e7         	bne	0x8019cc4 <LL_USART_DisableIT_IDLE+0x8> @ imm = #-0x32
; }
 8019cf4: bf00         	nop
 8019cf6: bf00         	nop
 8019cf8: 3724         	adds	r7, #0x24
 8019cfa: 46bd         	mov	sp, r7
 8019cfc: bc80         	pop	{r7}
 8019cfe: 4770         	bx	lr

08019d00 <LL_USART_DisableIT_RXNE>:
; {
 8019d00: b480         	push	{r7}
 8019d02: b089         	sub	sp, #0x24
 8019d04: af00         	add	r7, sp, #0x0
 8019d06: 6078         	str	r0, [r7, #0x4]
;   ATOMIC_CLEAR_BIT(USARTx->CR1, USART_CR1_RXNEIE);
 8019d08: 687b         	ldr	r3, [r7, #0x4]
 8019d0a: 330c         	adds	r3, #0xc
 8019d0c: 60fb         	str	r3, [r7, #0xc]
;    __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8019d0e: 68fb         	ldr	r3, [r7, #0xc]
 8019d10: e853 3f00    	ldrex	r3, [r3]
 8019d14: 60bb         	str	r3, [r7, #0x8]
;    return(result);
 8019d16: 68bb         	ldr	r3, [r7, #0x8]
;   ATOMIC_CLEAR_BIT(USARTx->CR1, USART_CR1_RXNEIE);
 8019d18: f023 0320    	bic	r3, r3, #0x20
 8019d1c: 61fb         	str	r3, [r7, #0x1c]
 8019d1e: 687b         	ldr	r3, [r7, #0x4]
 8019d20: 330c         	adds	r3, #0xc
 8019d22: 69fa         	ldr	r2, [r7, #0x1c]
 8019d24: 61ba         	str	r2, [r7, #0x18]
 8019d26: 617b         	str	r3, [r7, #0x14]
;    __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8019d28: 6979         	ldr	r1, [r7, #0x14]
 8019d2a: 69ba         	ldr	r2, [r7, #0x18]
 8019d2c: e841 2300    	strex	r3, r2, [r1]
 8019d30: 613b         	str	r3, [r7, #0x10]
;    return(result);
 8019d32: 693b         	ldr	r3, [r7, #0x10]
;   ATOMIC_CLEAR_BIT(USARTx->CR1, USART_CR1_RXNEIE);
 8019d34: 2b00         	cmp	r3, #0x0
 8019d36: d1e7         	bne	0x8019d08 <LL_USART_DisableIT_RXNE+0x8> @ imm = #-0x32
; }
 8019d38: bf00         	nop
 8019d3a: bf00         	nop
 8019d3c: 3724         	adds	r7, #0x24
 8019d3e: 46bd         	mov	sp, r7
 8019d40: bc80         	pop	{r7}
 8019d42: 4770         	bx	lr

08019d44 <LL_USART_DisableIT_TC>:
; {
 8019d44: b480         	push	{r7}
 8019d46: b089         	sub	sp, #0x24
 8019d48: af00         	add	r7, sp, #0x0
 8019d4a: 6078         	str	r0, [r7, #0x4]
;   ATOMIC_CLEAR_BIT(USARTx->CR1, USART_CR1_TCIE);
 8019d4c: 687b         	ldr	r3, [r7, #0x4]
 8019d4e: 330c         	adds	r3, #0xc
 8019d50: 60fb         	str	r3, [r7, #0xc]
;    __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8019d52: 68fb         	ldr	r3, [r7, #0xc]
 8019d54: e853 3f00    	ldrex	r3, [r3]
 8019d58: 60bb         	str	r3, [r7, #0x8]
;    return(result);
 8019d5a: 68bb         	ldr	r3, [r7, #0x8]
;   ATOMIC_CLEAR_BIT(USARTx->CR1, USART_CR1_TCIE);
 8019d5c: f023 0340    	bic	r3, r3, #0x40
 8019d60: 61fb         	str	r3, [r7, #0x1c]
 8019d62: 687b         	ldr	r3, [r7, #0x4]
 8019d64: 330c         	adds	r3, #0xc
 8019d66: 69fa         	ldr	r2, [r7, #0x1c]
 8019d68: 61ba         	str	r2, [r7, #0x18]
 8019d6a: 617b         	str	r3, [r7, #0x14]
;    __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8019d6c: 6979         	ldr	r1, [r7, #0x14]
 8019d6e: 69ba         	ldr	r2, [r7, #0x18]
 8019d70: e841 2300    	strex	r3, r2, [r1]
 8019d74: 613b         	str	r3, [r7, #0x10]
;    return(result);
 8019d76: 693b         	ldr	r3, [r7, #0x10]
;   ATOMIC_CLEAR_BIT(USARTx->CR1, USART_CR1_TCIE);
 8019d78: 2b00         	cmp	r3, #0x0
 8019d7a: d1e7         	bne	0x8019d4c <LL_USART_DisableIT_TC+0x8> @ imm = #-0x32
; }
 8019d7c: bf00         	nop
 8019d7e: bf00         	nop
 8019d80: 3724         	adds	r7, #0x24
 8019d82: 46bd         	mov	sp, r7
 8019d84: bc80         	pop	{r7}
 8019d86: 4770         	bx	lr

08019d88 <LL_USART_DisableIT_PE>:
; {
 8019d88: b480         	push	{r7}
 8019d8a: b089         	sub	sp, #0x24
 8019d8c: af00         	add	r7, sp, #0x0
 8019d8e: 6078         	str	r0, [r7, #0x4]
;   ATOMIC_CLEAR_BIT(USARTx->CR1, USART_CR1_PEIE);
 8019d90: 687b         	ldr	r3, [r7, #0x4]
 8019d92: 330c         	adds	r3, #0xc
 8019d94: 60fb         	str	r3, [r7, #0xc]
;    __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8019d96: 68fb         	ldr	r3, [r7, #0xc]
 8019d98: e853 3f00    	ldrex	r3, [r3]
 8019d9c: 60bb         	str	r3, [r7, #0x8]
;    return(result);
 8019d9e: 68bb         	ldr	r3, [r7, #0x8]
;   ATOMIC_CLEAR_BIT(USARTx->CR1, USART_CR1_PEIE);
 8019da0: f423 7380    	bic	r3, r3, #0x100
 8019da4: 61fb         	str	r3, [r7, #0x1c]
 8019da6: 687b         	ldr	r3, [r7, #0x4]
 8019da8: 330c         	adds	r3, #0xc
 8019daa: 69fa         	ldr	r2, [r7, #0x1c]
 8019dac: 61ba         	str	r2, [r7, #0x18]
 8019dae: 617b         	str	r3, [r7, #0x14]
;    __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8019db0: 6979         	ldr	r1, [r7, #0x14]
 8019db2: 69ba         	ldr	r2, [r7, #0x18]
 8019db4: e841 2300    	strex	r3, r2, [r1]
 8019db8: 613b         	str	r3, [r7, #0x10]
;    return(result);
 8019dba: 693b         	ldr	r3, [r7, #0x10]
;   ATOMIC_CLEAR_BIT(USARTx->CR1, USART_CR1_PEIE);
 8019dbc: 2b00         	cmp	r3, #0x0
 8019dbe: d1e7         	bne	0x8019d90 <LL_USART_DisableIT_PE+0x8> @ imm = #-0x32
; }
 8019dc0: bf00         	nop
 8019dc2: bf00         	nop
 8019dc4: 3724         	adds	r7, #0x24
 8019dc6: 46bd         	mov	sp, r7
 8019dc8: bc80         	pop	{r7}
 8019dca: 4770         	bx	lr

08019dcc <LL_USART_DisableIT_LBD>:
; {
 8019dcc: b480         	push	{r7}
 8019dce: b083         	sub	sp, #0xc
 8019dd0: af00         	add	r7, sp, #0x0
 8019dd2: 6078         	str	r0, [r7, #0x4]
;   CLEAR_BIT(USARTx->CR2, USART_CR2_LBDIE);
 8019dd4: 687b         	ldr	r3, [r7, #0x4]
 8019dd6: 691b         	ldr	r3, [r3, #0x10]
 8019dd8: f023 0240    	bic	r2, r3, #0x40
 8019ddc: 687b         	ldr	r3, [r7, #0x4]
 8019dde: 611a         	str	r2, [r3, #0x10]
; }
 8019de0: bf00         	nop
 8019de2: 370c         	adds	r7, #0xc
 8019de4: 46bd         	mov	sp, r7
 8019de6: bc80         	pop	{r7}
 8019de8: 4770         	bx	lr

08019dea <LL_USART_DisableIT_ERROR>:
; {
 8019dea: b480         	push	{r7}
 8019dec: b089         	sub	sp, #0x24
 8019dee: af00         	add	r7, sp, #0x0
 8019df0: 6078         	str	r0, [r7, #0x4]
;   ATOMIC_CLEAR_BIT(USARTx->CR3, USART_CR3_EIE);
 8019df2: 687b         	ldr	r3, [r7, #0x4]
 8019df4: 3314         	adds	r3, #0x14
 8019df6: 60fb         	str	r3, [r7, #0xc]
;    __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8019df8: 68fb         	ldr	r3, [r7, #0xc]
 8019dfa: e853 3f00    	ldrex	r3, [r3]
 8019dfe: 60bb         	str	r3, [r7, #0x8]
;    return(result);
 8019e00: 68bb         	ldr	r3, [r7, #0x8]
;   ATOMIC_CLEAR_BIT(USARTx->CR3, USART_CR3_EIE);
 8019e02: f023 0301    	bic	r3, r3, #0x1
 8019e06: 61fb         	str	r3, [r7, #0x1c]
 8019e08: 687b         	ldr	r3, [r7, #0x4]
 8019e0a: 3314         	adds	r3, #0x14
 8019e0c: 69fa         	ldr	r2, [r7, #0x1c]
 8019e0e: 61ba         	str	r2, [r7, #0x18]
 8019e10: 617b         	str	r3, [r7, #0x14]
;    __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8019e12: 6979         	ldr	r1, [r7, #0x14]
 8019e14: 69ba         	ldr	r2, [r7, #0x18]
 8019e16: e841 2300    	strex	r3, r2, [r1]
 8019e1a: 613b         	str	r3, [r7, #0x10]
;    return(result);
 8019e1c: 693b         	ldr	r3, [r7, #0x10]
;   ATOMIC_CLEAR_BIT(USARTx->CR3, USART_CR3_EIE);
 8019e1e: 2b00         	cmp	r3, #0x0
 8019e20: d1e7         	bne	0x8019df2 <LL_USART_DisableIT_ERROR+0x8> @ imm = #-0x32
; }
 8019e22: bf00         	nop
 8019e24: bf00         	nop
 8019e26: 3724         	adds	r7, #0x24
 8019e28: 46bd         	mov	sp, r7
 8019e2a: bc80         	pop	{r7}
 8019e2c: 4770         	bx	lr

08019e2e <LL_USART_IsEnabledIT_IDLE>:
; {
 8019e2e: b480         	push	{r7}
 8019e30: b083         	sub	sp, #0xc
 8019e32: af00         	add	r7, sp, #0x0
 8019e34: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(USARTx->CR1, USART_CR1_IDLEIE) == (USART_CR1_IDLEIE));
 8019e36: 687b         	ldr	r3, [r7, #0x4]
 8019e38: 68db         	ldr	r3, [r3, #0xc]
 8019e3a: f003 0310    	and	r3, r3, #0x10
 8019e3e: 2b10         	cmp	r3, #0x10
 8019e40: bf0c         	ite	eq
 8019e42: 2301         	moveq	r3, #0x1
 8019e44: 2300         	movne	r3, #0x0
 8019e46: b2db         	uxtb	r3, r3
; }
 8019e48: 4618         	mov	r0, r3
 8019e4a: 370c         	adds	r7, #0xc
 8019e4c: 46bd         	mov	sp, r7
 8019e4e: bc80         	pop	{r7}
 8019e50: 4770         	bx	lr

08019e52 <LL_USART_IsEnabledIT_RXNE>:
; {
 8019e52: b480         	push	{r7}
 8019e54: b083         	sub	sp, #0xc
 8019e56: af00         	add	r7, sp, #0x0
 8019e58: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(USARTx->CR1, USART_CR1_RXNEIE) == (USART_CR1_RXNEIE));
 8019e5a: 687b         	ldr	r3, [r7, #0x4]
 8019e5c: 68db         	ldr	r3, [r3, #0xc]
 8019e5e: f003 0320    	and	r3, r3, #0x20
 8019e62: 2b20         	cmp	r3, #0x20
 8019e64: bf0c         	ite	eq
 8019e66: 2301         	moveq	r3, #0x1
 8019e68: 2300         	movne	r3, #0x0
 8019e6a: b2db         	uxtb	r3, r3
; }
 8019e6c: 4618         	mov	r0, r3
 8019e6e: 370c         	adds	r7, #0xc
 8019e70: 46bd         	mov	sp, r7
 8019e72: bc80         	pop	{r7}
 8019e74: 4770         	bx	lr

08019e76 <LL_USART_IsEnabledIT_TC>:
; {
 8019e76: b480         	push	{r7}
 8019e78: b083         	sub	sp, #0xc
 8019e7a: af00         	add	r7, sp, #0x0
 8019e7c: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(USARTx->CR1, USART_CR1_TCIE) == (USART_CR1_TCIE));
 8019e7e: 687b         	ldr	r3, [r7, #0x4]
 8019e80: 68db         	ldr	r3, [r3, #0xc]
 8019e82: f003 0340    	and	r3, r3, #0x40
 8019e86: 2b40         	cmp	r3, #0x40
 8019e88: bf0c         	ite	eq
 8019e8a: 2301         	moveq	r3, #0x1
 8019e8c: 2300         	movne	r3, #0x0
 8019e8e: b2db         	uxtb	r3, r3
; }
 8019e90: 4618         	mov	r0, r3
 8019e92: 370c         	adds	r7, #0xc
 8019e94: 46bd         	mov	sp, r7
 8019e96: bc80         	pop	{r7}
 8019e98: 4770         	bx	lr

08019e9a <LL_USART_EnableDMAReq_RX>:
; {
 8019e9a: b480         	push	{r7}
 8019e9c: b089         	sub	sp, #0x24
 8019e9e: af00         	add	r7, sp, #0x0
 8019ea0: 6078         	str	r0, [r7, #0x4]
;   ATOMIC_SET_BIT(USARTx->CR3, USART_CR3_DMAR);
 8019ea2: 687b         	ldr	r3, [r7, #0x4]
 8019ea4: 3314         	adds	r3, #0x14
 8019ea6: 60fb         	str	r3, [r7, #0xc]
;    __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8019ea8: 68fb         	ldr	r3, [r7, #0xc]
 8019eaa: e853 3f00    	ldrex	r3, [r3]
 8019eae: 60bb         	str	r3, [r7, #0x8]
;    return(result);
 8019eb0: 68bb         	ldr	r3, [r7, #0x8]
;   ATOMIC_SET_BIT(USARTx->CR3, USART_CR3_DMAR);
 8019eb2: f043 0340    	orr	r3, r3, #0x40
 8019eb6: 61fb         	str	r3, [r7, #0x1c]
 8019eb8: 687b         	ldr	r3, [r7, #0x4]
 8019eba: 3314         	adds	r3, #0x14
 8019ebc: 69fa         	ldr	r2, [r7, #0x1c]
 8019ebe: 61ba         	str	r2, [r7, #0x18]
 8019ec0: 617b         	str	r3, [r7, #0x14]
;    __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8019ec2: 6979         	ldr	r1, [r7, #0x14]
 8019ec4: 69ba         	ldr	r2, [r7, #0x18]
 8019ec6: e841 2300    	strex	r3, r2, [r1]
 8019eca: 613b         	str	r3, [r7, #0x10]
;    return(result);
 8019ecc: 693b         	ldr	r3, [r7, #0x10]
;   ATOMIC_SET_BIT(USARTx->CR3, USART_CR3_DMAR);
 8019ece: 2b00         	cmp	r3, #0x0
 8019ed0: d1e7         	bne	0x8019ea2 <LL_USART_EnableDMAReq_RX+0x8> @ imm = #-0x32
; }
 8019ed2: bf00         	nop
 8019ed4: bf00         	nop
 8019ed6: 3724         	adds	r7, #0x24
 8019ed8: 46bd         	mov	sp, r7
 8019eda: bc80         	pop	{r7}
 8019edc: 4770         	bx	lr

08019ede <LL_USART_EnableDMAReq_TX>:
; {
 8019ede: b480         	push	{r7}
 8019ee0: b089         	sub	sp, #0x24
 8019ee2: af00         	add	r7, sp, #0x0
 8019ee4: 6078         	str	r0, [r7, #0x4]
;   ATOMIC_SET_BIT(USARTx->CR3, USART_CR3_DMAT);
 8019ee6: 687b         	ldr	r3, [r7, #0x4]
 8019ee8: 3314         	adds	r3, #0x14
 8019eea: 60fb         	str	r3, [r7, #0xc]
;    __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8019eec: 68fb         	ldr	r3, [r7, #0xc]
 8019eee: e853 3f00    	ldrex	r3, [r3]
 8019ef2: 60bb         	str	r3, [r7, #0x8]
;    return(result);
 8019ef4: 68bb         	ldr	r3, [r7, #0x8]
;   ATOMIC_SET_BIT(USARTx->CR3, USART_CR3_DMAT);
 8019ef6: f043 0380    	orr	r3, r3, #0x80
 8019efa: 61fb         	str	r3, [r7, #0x1c]
 8019efc: 687b         	ldr	r3, [r7, #0x4]
 8019efe: 3314         	adds	r3, #0x14
 8019f00: 69fa         	ldr	r2, [r7, #0x1c]
 8019f02: 61ba         	str	r2, [r7, #0x18]
 8019f04: 617b         	str	r3, [r7, #0x14]
;    __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8019f06: 6979         	ldr	r1, [r7, #0x14]
 8019f08: 69ba         	ldr	r2, [r7, #0x18]
 8019f0a: e841 2300    	strex	r3, r2, [r1]
 8019f0e: 613b         	str	r3, [r7, #0x10]
;    return(result);
 8019f10: 693b         	ldr	r3, [r7, #0x10]
;   ATOMIC_SET_BIT(USARTx->CR3, USART_CR3_DMAT);
 8019f12: 2b00         	cmp	r3, #0x0
 8019f14: d1e7         	bne	0x8019ee6 <LL_USART_EnableDMAReq_TX+0x8> @ imm = #-0x32
; }
 8019f16: bf00         	nop
 8019f18: bf00         	nop
 8019f1a: 3724         	adds	r7, #0x24
 8019f1c: 46bd         	mov	sp, r7
 8019f1e: bc80         	pop	{r7}
 8019f20: 4770         	bx	lr

08019f22 <LL_USART_DisableDMAReq_TX>:
; {
 8019f22: b480         	push	{r7}
 8019f24: b089         	sub	sp, #0x24
 8019f26: af00         	add	r7, sp, #0x0
 8019f28: 6078         	str	r0, [r7, #0x4]
;   ATOMIC_CLEAR_BIT(USARTx->CR3, USART_CR3_DMAT);
 8019f2a: 687b         	ldr	r3, [r7, #0x4]
 8019f2c: 3314         	adds	r3, #0x14
 8019f2e: 60fb         	str	r3, [r7, #0xc]
;    __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8019f30: 68fb         	ldr	r3, [r7, #0xc]
 8019f32: e853 3f00    	ldrex	r3, [r3]
 8019f36: 60bb         	str	r3, [r7, #0x8]
;    return(result);
 8019f38: 68bb         	ldr	r3, [r7, #0x8]
;   ATOMIC_CLEAR_BIT(USARTx->CR3, USART_CR3_DMAT);
 8019f3a: f023 0380    	bic	r3, r3, #0x80
 8019f3e: 61fb         	str	r3, [r7, #0x1c]
 8019f40: 687b         	ldr	r3, [r7, #0x4]
 8019f42: 3314         	adds	r3, #0x14
 8019f44: 69fa         	ldr	r2, [r7, #0x1c]
 8019f46: 61ba         	str	r2, [r7, #0x18]
 8019f48: 617b         	str	r3, [r7, #0x14]
;    __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8019f4a: 6979         	ldr	r1, [r7, #0x14]
 8019f4c: 69ba         	ldr	r2, [r7, #0x18]
 8019f4e: e841 2300    	strex	r3, r2, [r1]
 8019f52: 613b         	str	r3, [r7, #0x10]
;    return(result);
 8019f54: 693b         	ldr	r3, [r7, #0x10]
;   ATOMIC_CLEAR_BIT(USARTx->CR3, USART_CR3_DMAT);
 8019f56: 2b00         	cmp	r3, #0x0
 8019f58: d1e7         	bne	0x8019f2a <LL_USART_DisableDMAReq_TX+0x8> @ imm = #-0x32
; }
 8019f5a: bf00         	nop
 8019f5c: bf00         	nop
 8019f5e: 3724         	adds	r7, #0x24
 8019f60: 46bd         	mov	sp, r7
 8019f62: bc80         	pop	{r7}
 8019f64: 4770         	bx	lr

08019f66 <LL_USART_DMA_GetRegAddr>:
; {
 8019f66: b480         	push	{r7}
 8019f68: b083         	sub	sp, #0xc
 8019f6a: af00         	add	r7, sp, #0x0
 8019f6c: 6078         	str	r0, [r7, #0x4]
;   return ((uint32_t) &(USARTx->DR));
 8019f6e: 687b         	ldr	r3, [r7, #0x4]
 8019f70: 3304         	adds	r3, #0x4
; }
 8019f72: 4618         	mov	r0, r3
 8019f74: 370c         	adds	r7, #0xc
 8019f76: 46bd         	mov	sp, r7
 8019f78: bc80         	pop	{r7}
 8019f7a: 4770         	bx	lr

08019f7c <LL_USART_ReceiveData8>:
; {
 8019f7c: b480         	push	{r7}
 8019f7e: b083         	sub	sp, #0xc
 8019f80: af00         	add	r7, sp, #0x0
 8019f82: 6078         	str	r0, [r7, #0x4]
;   return (uint8_t)(READ_BIT(USARTx->DR, USART_DR_DR));
 8019f84: 687b         	ldr	r3, [r7, #0x4]
 8019f86: 685b         	ldr	r3, [r3, #0x4]
 8019f88: b2db         	uxtb	r3, r3
; }
 8019f8a: 4618         	mov	r0, r3
 8019f8c: 370c         	adds	r7, #0xc
 8019f8e: 46bd         	mov	sp, r7
 8019f90: bc80         	pop	{r7}
 8019f92: 4770         	bx	lr

08019f94 <LL_USART_TransmitData8>:
; {
 8019f94: b480         	push	{r7}
 8019f96: b083         	sub	sp, #0xc
 8019f98: af00         	add	r7, sp, #0x0
 8019f9a: 6078         	str	r0, [r7, #0x4]
 8019f9c: 460b         	mov	r3, r1
 8019f9e: 70fb         	strb	r3, [r7, #0x3]
;   USARTx->DR = Value;
 8019fa0: 78fa         	ldrb	r2, [r7, #0x3]
 8019fa2: 687b         	ldr	r3, [r7, #0x4]
 8019fa4: 605a         	str	r2, [r3, #0x4]
; }
 8019fa6: bf00         	nop
 8019fa8: 370c         	adds	r7, #0xc
 8019faa: 46bd         	mov	sp, r7
 8019fac: bc80         	pop	{r7}
 8019fae: 4770         	bx	lr

08019fb0 <z_log_msg_runtime_create>:
; {
 8019fb0: b580         	push	{r7, lr}
 8019fb2: b08a         	sub	sp, #0x28
 8019fb4: af04         	add	r7, sp, #0x10
 8019fb6: 60b9         	str	r1, [r7, #0x8]
 8019fb8: 607b         	str	r3, [r7, #0x4]
 8019fba: 4603         	mov	r3, r0
 8019fbc: 73fb         	strb	r3, [r7, #0xf]
 8019fbe: 4613         	mov	r3, r2
 8019fc0: 73bb         	strb	r3, [r7, #0xe]
; 	va_start(ap, fmt);
 8019fc2: f107 032c    	add.w	r3, r7, #0x2c
 8019fc6: 617b         	str	r3, [r7, #0x14]
; 	z_log_msg_runtime_vcreate(domain_id, source, level,
 8019fc8: 7bba         	ldrb	r2, [r7, #0xe]
 8019fca: 7bf8         	ldrb	r0, [r7, #0xf]
 8019fcc: 697b         	ldr	r3, [r7, #0x14]
 8019fce: 9303         	str	r3, [sp, #0xc]
 8019fd0: 6abb         	ldr	r3, [r7, #0x28]
 8019fd2: 9302         	str	r3, [sp, #0x8]
 8019fd4: 6a7b         	ldr	r3, [r7, #0x24]
 8019fd6: 9301         	str	r3, [sp, #0x4]
 8019fd8: 6a3b         	ldr	r3, [r7, #0x20]
 8019fda: 9300         	str	r3, [sp]
 8019fdc: 687b         	ldr	r3, [r7, #0x4]
 8019fde: 68b9         	ldr	r1, [r7, #0x8]
 8019fe0: f7ea fac6    	bl	0x8004570 <z_log_msg_runtime_vcreate> @ imm = #-0x15a74
; }
 8019fe4: bf00         	nop
 8019fe6: 3718         	adds	r7, #0x18
 8019fe8: 46bd         	mov	sp, r7
 8019fea: bd80         	pop	{r7, pc}

08019fec <uart_stm32_set_parity>:
; {
 8019fec: b580         	push	{r7, lr}
 8019fee: b084         	sub	sp, #0x10
 8019ff0: af00         	add	r7, sp, #0x0
 8019ff2: 6078         	str	r0, [r7, #0x4]
 8019ff4: 6039         	str	r1, [r7]
; 	const struct uart_stm32_config *config = dev->config;
 8019ff6: 687b         	ldr	r3, [r7, #0x4]
 8019ff8: 685b         	ldr	r3, [r3, #0x4]
 8019ffa: 60fb         	str	r3, [r7, #0xc]
; 	LL_USART_SetParity(config->usart, parity);
 8019ffc: 68fb         	ldr	r3, [r7, #0xc]
 8019ffe: 681b         	ldr	r3, [r3]
 801a000: 6839         	ldr	r1, [r7]
 801a002: 4618         	mov	r0, r3
 801a004: f7ff fbc7    	bl	0x8019796 <LL_USART_SetParity> @ imm = #-0x872
; }
 801a008: bf00         	nop
 801a00a: 3710         	adds	r7, #0x10
 801a00c: 46bd         	mov	sp, r7
 801a00e: bd80         	pop	{r7, pc}

0801a010 <uart_stm32_get_parity>:
; {
 801a010: b580         	push	{r7, lr}
 801a012: b084         	sub	sp, #0x10
 801a014: af00         	add	r7, sp, #0x0
 801a016: 6078         	str	r0, [r7, #0x4]
; 	const struct uart_stm32_config *config = dev->config;
 801a018: 687b         	ldr	r3, [r7, #0x4]
 801a01a: 685b         	ldr	r3, [r3, #0x4]
 801a01c: 60fb         	str	r3, [r7, #0xc]
; 	return LL_USART_GetParity(config->usart);
 801a01e: 68fb         	ldr	r3, [r7, #0xc]
 801a020: 681b         	ldr	r3, [r3]
 801a022: 4618         	mov	r0, r3
 801a024: f7ff fbc9    	bl	0x80197ba <LL_USART_GetParity> @ imm = #-0x86e
 801a028: 4603         	mov	r3, r0
; }
 801a02a: 4618         	mov	r0, r3
 801a02c: 3710         	adds	r7, #0x10
 801a02e: 46bd         	mov	sp, r7
 801a030: bd80         	pop	{r7, pc}

0801a032 <uart_stm32_set_stopbits>:
; {
 801a032: b580         	push	{r7, lr}
 801a034: b084         	sub	sp, #0x10
 801a036: af00         	add	r7, sp, #0x0
 801a038: 6078         	str	r0, [r7, #0x4]
 801a03a: 6039         	str	r1, [r7]
; 	const struct uart_stm32_config *config = dev->config;
 801a03c: 687b         	ldr	r3, [r7, #0x4]
 801a03e: 685b         	ldr	r3, [r3, #0x4]
 801a040: 60fb         	str	r3, [r7, #0xc]
; 	LL_USART_SetStopBitsLength(config->usart, stopbits);
 801a042: 68fb         	ldr	r3, [r7, #0xc]
 801a044: 681b         	ldr	r3, [r3]
 801a046: 6839         	ldr	r1, [r7]
 801a048: 4618         	mov	r0, r3
 801a04a: f7ff fbf4    	bl	0x8019836 <LL_USART_SetStopBitsLength> @ imm = #-0x818
; }
 801a04e: bf00         	nop
 801a050: 3710         	adds	r7, #0x10
 801a052: 46bd         	mov	sp, r7
 801a054: bd80         	pop	{r7, pc}

0801a056 <uart_stm32_get_stopbits>:
; {
 801a056: b580         	push	{r7, lr}
 801a058: b084         	sub	sp, #0x10
 801a05a: af00         	add	r7, sp, #0x0
 801a05c: 6078         	str	r0, [r7, #0x4]
; 	const struct uart_stm32_config *config = dev->config;
 801a05e: 687b         	ldr	r3, [r7, #0x4]
 801a060: 685b         	ldr	r3, [r3, #0x4]
 801a062: 60fb         	str	r3, [r7, #0xc]
; 	return LL_USART_GetStopBitsLength(config->usart);
 801a064: 68fb         	ldr	r3, [r7, #0xc]
 801a066: 681b         	ldr	r3, [r3]
 801a068: 4618         	mov	r0, r3
 801a06a: f7ff fbf6    	bl	0x801985a <LL_USART_GetStopBitsLength> @ imm = #-0x814
 801a06e: 4603         	mov	r3, r0
; }
 801a070: 4618         	mov	r0, r3
 801a072: 3710         	adds	r7, #0x10
 801a074: 46bd         	mov	sp, r7
 801a076: bd80         	pop	{r7, pc}

0801a078 <uart_stm32_set_databits>:
; {
 801a078: b580         	push	{r7, lr}
 801a07a: b084         	sub	sp, #0x10
 801a07c: af00         	add	r7, sp, #0x0
 801a07e: 6078         	str	r0, [r7, #0x4]
 801a080: 6039         	str	r1, [r7]
; 	const struct uart_stm32_config *config = dev->config;
 801a082: 687b         	ldr	r3, [r7, #0x4]
 801a084: 685b         	ldr	r3, [r3, #0x4]
 801a086: 60fb         	str	r3, [r7, #0xc]
; 	LL_USART_SetDataWidth(config->usart, databits);
 801a088: 68fb         	ldr	r3, [r7, #0xc]
 801a08a: 681b         	ldr	r3, [r3]
 801a08c: 6839         	ldr	r1, [r7]
 801a08e: 4618         	mov	r0, r3
 801a090: f7ff fba0    	bl	0x80197d4 <LL_USART_SetDataWidth> @ imm = #-0x8c0
; }
 801a094: bf00         	nop
 801a096: 3710         	adds	r7, #0x10
 801a098: 46bd         	mov	sp, r7
 801a09a: bd80         	pop	{r7, pc}

0801a09c <uart_stm32_get_databits>:
; {
 801a09c: b580         	push	{r7, lr}
 801a09e: b084         	sub	sp, #0x10
 801a0a0: af00         	add	r7, sp, #0x0
 801a0a2: 6078         	str	r0, [r7, #0x4]
; 	const struct uart_stm32_config *config = dev->config;
 801a0a4: 687b         	ldr	r3, [r7, #0x4]
 801a0a6: 685b         	ldr	r3, [r3, #0x4]
 801a0a8: 60fb         	str	r3, [r7, #0xc]
; 	return LL_USART_GetDataWidth(config->usart);
 801a0aa: 68fb         	ldr	r3, [r7, #0xc]
 801a0ac: 681b         	ldr	r3, [r3]
 801a0ae: 4618         	mov	r0, r3
 801a0b0: f7ff fba2    	bl	0x80197f8 <LL_USART_GetDataWidth> @ imm = #-0x8bc
 801a0b4: 4603         	mov	r3, r0
; }
 801a0b6: 4618         	mov	r0, r3
 801a0b8: 3710         	adds	r7, #0x10
 801a0ba: 46bd         	mov	sp, r7
 801a0bc: bd80         	pop	{r7, pc}

0801a0be <uart_stm32_set_hwctrl>:
; {
 801a0be: b580         	push	{r7, lr}
 801a0c0: b084         	sub	sp, #0x10
 801a0c2: af00         	add	r7, sp, #0x0
 801a0c4: 6078         	str	r0, [r7, #0x4]
 801a0c6: 6039         	str	r1, [r7]
; 	const struct uart_stm32_config *config = dev->config;
 801a0c8: 687b         	ldr	r3, [r7, #0x4]
 801a0ca: 685b         	ldr	r3, [r3, #0x4]
 801a0cc: 60fb         	str	r3, [r7, #0xc]
; 	LL_USART_SetHWFlowCtrl(config->usart, hwctrl);
 801a0ce: 68fb         	ldr	r3, [r7, #0xc]
 801a0d0: 681b         	ldr	r3, [r3]
 801a0d2: 6839         	ldr	r1, [r7]
 801a0d4: 4618         	mov	r0, r3
 801a0d6: f7ff fbeb    	bl	0x80198b0 <LL_USART_SetHWFlowCtrl> @ imm = #-0x82a
; }
 801a0da: bf00         	nop
 801a0dc: 3710         	adds	r7, #0x10
 801a0de: 46bd         	mov	sp, r7
 801a0e0: bd80         	pop	{r7, pc}

0801a0e2 <uart_stm32_get_hwctrl>:
; {
 801a0e2: b580         	push	{r7, lr}
 801a0e4: b084         	sub	sp, #0x10
 801a0e6: af00         	add	r7, sp, #0x0
 801a0e8: 6078         	str	r0, [r7, #0x4]
; 	const struct uart_stm32_config *config = dev->config;
 801a0ea: 687b         	ldr	r3, [r7, #0x4]
 801a0ec: 685b         	ldr	r3, [r3, #0x4]
 801a0ee: 60fb         	str	r3, [r7, #0xc]
; 	return LL_USART_GetHWFlowCtrl(config->usart);
 801a0f0: 68fb         	ldr	r3, [r7, #0xc]
 801a0f2: 681b         	ldr	r3, [r3]
 801a0f4: 4618         	mov	r0, r3
 801a0f6: f7ff fbed    	bl	0x80198d4 <LL_USART_GetHWFlowCtrl> @ imm = #-0x826
 801a0fa: 4603         	mov	r3, r0
; }
 801a0fc: 4618         	mov	r0, r3
 801a0fe: 3710         	adds	r7, #0x10
 801a100: 46bd         	mov	sp, r7
 801a102: bd80         	pop	{r7, pc}

0801a104 <uart_stm32_cfg2ll_parity>:
; {
 801a104: b480         	push	{r7}
 801a106: b083         	sub	sp, #0xc
 801a108: af00         	add	r7, sp, #0x0
 801a10a: 4603         	mov	r3, r0
 801a10c: 71fb         	strb	r3, [r7, #0x7]
; 	switch (parity) {
 801a10e: 79fb         	ldrb	r3, [r7, #0x7]
 801a110: 2b01         	cmp	r3, #0x1
 801a112: d002         	beq	0x801a11a <uart_stm32_cfg2ll_parity+0x16> @ imm = #0x4
 801a114: 2b02         	cmp	r3, #0x2
 801a116: d003         	beq	0x801a120 <uart_stm32_cfg2ll_parity+0x1c> @ imm = #0x6
 801a118: e005         	b	0x801a126 <uart_stm32_cfg2ll_parity+0x22> @ imm = #0xa
; 		return LL_USART_PARITY_ODD;
 801a11a: f44f 63c0    	mov.w	r3, #0x600
 801a11e: e003         	b	0x801a128 <uart_stm32_cfg2ll_parity+0x24> @ imm = #0x6
; 		return LL_USART_PARITY_EVEN;
 801a120: f44f 6380    	mov.w	r3, #0x400
 801a124: e000         	b	0x801a128 <uart_stm32_cfg2ll_parity+0x24> @ imm = #0x0
; 		return LL_USART_PARITY_NONE;
 801a126: 2300         	movs	r3, #0x0
; }
 801a128: 4618         	mov	r0, r3
 801a12a: 370c         	adds	r7, #0xc
 801a12c: 46bd         	mov	sp, r7
 801a12e: bc80         	pop	{r7}
 801a130: 4770         	bx	lr

0801a132 <uart_stm32_ll2cfg_parity>:
; {
 801a132: b480         	push	{r7}
 801a134: b083         	sub	sp, #0xc
 801a136: af00         	add	r7, sp, #0x0
 801a138: 6078         	str	r0, [r7, #0x4]
; 	switch (parity) {
 801a13a: 687b         	ldr	r3, [r7, #0x4]
 801a13c: f5b3 6f80    	cmp.w	r3, #0x400
 801a140: d005         	beq	0x801a14e <uart_stm32_ll2cfg_parity+0x1c> @ imm = #0xa
 801a142: 687b         	ldr	r3, [r7, #0x4]
 801a144: f5b3 6fc0    	cmp.w	r3, #0x600
 801a148: d103         	bne	0x801a152 <uart_stm32_ll2cfg_parity+0x20> @ imm = #0x6
; 		return UART_CFG_PARITY_ODD;
 801a14a: 2301         	movs	r3, #0x1
 801a14c: e002         	b	0x801a154 <uart_stm32_ll2cfg_parity+0x22> @ imm = #0x4
; 		return UART_CFG_PARITY_EVEN;
 801a14e: 2302         	movs	r3, #0x2
 801a150: e000         	b	0x801a154 <uart_stm32_ll2cfg_parity+0x22> @ imm = #0x0
; 		return UART_CFG_PARITY_NONE;
 801a152: 2300         	movs	r3, #0x0
; }
 801a154: 4618         	mov	r0, r3
 801a156: 370c         	adds	r7, #0xc
 801a158: 46bd         	mov	sp, r7
 801a15a: bc80         	pop	{r7}
 801a15c: 4770         	bx	lr

0801a15e <uart_stm32_cfg2ll_stopbits>:
; {
 801a15e: b480         	push	{r7}
 801a160: b083         	sub	sp, #0xc
 801a162: af00         	add	r7, sp, #0x0
 801a164: 6078         	str	r0, [r7, #0x4]
 801a166: 460b         	mov	r3, r1
 801a168: 70fb         	strb	r3, [r7, #0x3]
; 	switch (sb) {
 801a16a: 78fb         	ldrb	r3, [r7, #0x3]
 801a16c: 2b02         	cmp	r3, #0x2
 801a16e: d00b         	beq	0x801a188 <uart_stm32_cfg2ll_stopbits+0x2a> @ imm = #0x16
 801a170: 2b02         	cmp	r3, #0x2
 801a172: dc0c         	bgt	0x801a18e <uart_stm32_cfg2ll_stopbits+0x30> @ imm = #0x18
 801a174: 2b00         	cmp	r3, #0x0
 801a176: d002         	beq	0x801a17e <uart_stm32_cfg2ll_stopbits+0x20> @ imm = #0x4
 801a178: 2b01         	cmp	r3, #0x1
 801a17a: d003         	beq	0x801a184 <uart_stm32_cfg2ll_stopbits+0x26> @ imm = #0x6
 801a17c: e007         	b	0x801a18e <uart_stm32_cfg2ll_stopbits+0x30> @ imm = #0xe
; 		return LL_USART_STOPBITS_0_5;
 801a17e: f44f 5380    	mov.w	r3, #0x1000
 801a182: e006         	b	0x801a192 <uart_stm32_cfg2ll_stopbits+0x34> @ imm = #0xc
; 		return LL_USART_STOPBITS_1;
 801a184: 2300         	movs	r3, #0x0
 801a186: e004         	b	0x801a192 <uart_stm32_cfg2ll_stopbits+0x34> @ imm = #0x8
; 		return LL_USART_STOPBITS_1_5;
 801a188: f44f 5340    	mov.w	r3, #0x3000
 801a18c: e001         	b	0x801a192 <uart_stm32_cfg2ll_stopbits+0x34> @ imm = #0x2
; 		return LL_USART_STOPBITS_2;
 801a18e: f44f 5300    	mov.w	r3, #0x2000
; }
 801a192: 4618         	mov	r0, r3
 801a194: 370c         	adds	r7, #0xc
 801a196: 46bd         	mov	sp, r7
 801a198: bc80         	pop	{r7}
 801a19a: 4770         	bx	lr

0801a19c <uart_stm32_ll2cfg_stopbits>:
; {
 801a19c: b480         	push	{r7}
 801a19e: b083         	sub	sp, #0xc
 801a1a0: af00         	add	r7, sp, #0x0
 801a1a2: 6078         	str	r0, [r7, #0x4]
; 	switch (sb) {
 801a1a4: 687b         	ldr	r3, [r7, #0x4]
 801a1a6: f5b3 5f40    	cmp.w	r3, #0x3000
 801a1aa: d00e         	beq	0x801a1ca <uart_stm32_ll2cfg_stopbits+0x2e> @ imm = #0x1c
 801a1ac: 687b         	ldr	r3, [r7, #0x4]
 801a1ae: f5b3 5f40    	cmp.w	r3, #0x3000
 801a1b2: d80c         	bhi	0x801a1ce <uart_stm32_ll2cfg_stopbits+0x32> @ imm = #0x18
 801a1b4: 687b         	ldr	r3, [r7, #0x4]
 801a1b6: 2b00         	cmp	r3, #0x0
 801a1b8: d005         	beq	0x801a1c6 <uart_stm32_ll2cfg_stopbits+0x2a> @ imm = #0xa
 801a1ba: 687b         	ldr	r3, [r7, #0x4]
 801a1bc: f5b3 5f80    	cmp.w	r3, #0x1000
 801a1c0: d105         	bne	0x801a1ce <uart_stm32_ll2cfg_stopbits+0x32> @ imm = #0xa
; 		return UART_CFG_STOP_BITS_0_5;
 801a1c2: 2300         	movs	r3, #0x0
 801a1c4: e004         	b	0x801a1d0 <uart_stm32_ll2cfg_stopbits+0x34> @ imm = #0x8
; 		return UART_CFG_STOP_BITS_1;
 801a1c6: 2301         	movs	r3, #0x1
 801a1c8: e002         	b	0x801a1d0 <uart_stm32_ll2cfg_stopbits+0x34> @ imm = #0x4
; 		return UART_CFG_STOP_BITS_1_5;
 801a1ca: 2302         	movs	r3, #0x2
 801a1cc: e000         	b	0x801a1d0 <uart_stm32_ll2cfg_stopbits+0x34> @ imm = #0x0
; 		return UART_CFG_STOP_BITS_2;
 801a1ce: 2303         	movs	r3, #0x3
; }
 801a1d0: 4618         	mov	r0, r3
 801a1d2: 370c         	adds	r7, #0xc
 801a1d4: 46bd         	mov	sp, r7
 801a1d6: bc80         	pop	{r7}
 801a1d8: 4770         	bx	lr

0801a1da <uart_stm32_cfg2ll_databits>:
; {
 801a1da: b480         	push	{r7}
 801a1dc: b083         	sub	sp, #0xc
 801a1de: af00         	add	r7, sp, #0x0
 801a1e0: 4603         	mov	r3, r0
 801a1e2: 460a         	mov	r2, r1
 801a1e4: 71fb         	strb	r3, [r7, #0x7]
 801a1e6: 4613         	mov	r3, r2
 801a1e8: 71bb         	strb	r3, [r7, #0x6]
; 	switch (db) {
 801a1ea: 79fb         	ldrb	r3, [r7, #0x7]
 801a1ec: 2b04         	cmp	r3, #0x4
 801a1ee: d102         	bne	0x801a1f6 <uart_stm32_cfg2ll_databits+0x1c> @ imm = #0x4
; 		return LL_USART_DATAWIDTH_9B;
 801a1f0: f44f 5380    	mov.w	r3, #0x1000
 801a1f4: e006         	b	0x801a204 <uart_stm32_cfg2ll_databits+0x2a> @ imm = #0xc
; 		if (p == UART_CFG_PARITY_NONE) {
 801a1f6: 79bb         	ldrb	r3, [r7, #0x6]
 801a1f8: 2b00         	cmp	r3, #0x0
 801a1fa: d101         	bne	0x801a200 <uart_stm32_cfg2ll_databits+0x26> @ imm = #0x2
; 			return LL_USART_DATAWIDTH_8B;
 801a1fc: 2300         	movs	r3, #0x0
 801a1fe: e001         	b	0x801a204 <uart_stm32_cfg2ll_databits+0x2a> @ imm = #0x2
; 			return LL_USART_DATAWIDTH_9B;
 801a200: f44f 5380    	mov.w	r3, #0x1000
; }
 801a204: 4618         	mov	r0, r3
 801a206: 370c         	adds	r7, #0xc
 801a208: 46bd         	mov	sp, r7
 801a20a: bc80         	pop	{r7}
 801a20c: 4770         	bx	lr

0801a20e <uart_stm32_ll2cfg_databits>:
; {
 801a20e: b480         	push	{r7}
 801a210: b083         	sub	sp, #0xc
 801a212: af00         	add	r7, sp, #0x0
 801a214: 6078         	str	r0, [r7, #0x4]
 801a216: 6039         	str	r1, [r7]
; 	switch (db) {
 801a218: 687b         	ldr	r3, [r7, #0x4]
 801a21a: f5b3 5f80    	cmp.w	r3, #0x1000
 801a21e: d106         	bne	0x801a22e <uart_stm32_ll2cfg_databits+0x20> @ imm = #0xc
; 		if (p == LL_USART_PARITY_NONE) {
 801a220: 683b         	ldr	r3, [r7]
 801a222: 2b00         	cmp	r3, #0x0
 801a224: d101         	bne	0x801a22a <uart_stm32_ll2cfg_databits+0x1c> @ imm = #0x2
; 			return UART_CFG_DATA_BITS_9;
 801a226: 2304         	movs	r3, #0x4
 801a228: e007         	b	0x801a23a <uart_stm32_ll2cfg_databits+0x2c> @ imm = #0xe
; 			return UART_CFG_DATA_BITS_8;
 801a22a: 2303         	movs	r3, #0x3
 801a22c: e005         	b	0x801a23a <uart_stm32_ll2cfg_databits+0x2c> @ imm = #0xa
; 		if (p == LL_USART_PARITY_NONE) {
 801a22e: 683b         	ldr	r3, [r7]
 801a230: 2b00         	cmp	r3, #0x0
 801a232: d101         	bne	0x801a238 <uart_stm32_ll2cfg_databits+0x2a> @ imm = #0x2
; 			return UART_CFG_DATA_BITS_8;
 801a234: 2303         	movs	r3, #0x3
 801a236: e000         	b	0x801a23a <uart_stm32_ll2cfg_databits+0x2c> @ imm = #0x0
; 			return UART_CFG_DATA_BITS_7;
 801a238: 2302         	movs	r3, #0x2
; }
 801a23a: 4618         	mov	r0, r3
 801a23c: 370c         	adds	r7, #0xc
 801a23e: 46bd         	mov	sp, r7
 801a240: bc80         	pop	{r7}
 801a242: 4770         	bx	lr

0801a244 <uart_stm32_cfg2ll_hwctrl>:
; {
 801a244: b480         	push	{r7}
 801a246: b083         	sub	sp, #0xc
 801a248: af00         	add	r7, sp, #0x0
 801a24a: 4603         	mov	r3, r0
 801a24c: 71fb         	strb	r3, [r7, #0x7]
; 	if (fc == UART_CFG_FLOW_CTRL_RTS_CTS) {
 801a24e: 79fb         	ldrb	r3, [r7, #0x7]
 801a250: 2b01         	cmp	r3, #0x1
 801a252: d102         	bne	0x801a25a <uart_stm32_cfg2ll_hwctrl+0x16> @ imm = #0x4
; 		return LL_USART_HWCONTROL_RTS_CTS;
 801a254: f44f 7340    	mov.w	r3, #0x300
 801a258: e005         	b	0x801a266 <uart_stm32_cfg2ll_hwctrl+0x22> @ imm = #0xa
; 	} else if (fc == UART_CFG_FLOW_CTRL_RS485) {
 801a25a: 79fb         	ldrb	r3, [r7, #0x7]
 801a25c: 2b03         	cmp	r3, #0x3
 801a25e: d101         	bne	0x801a264 <uart_stm32_cfg2ll_hwctrl+0x20> @ imm = #0x2
; 		return LL_USART_HWCONTROL_NONE;
 801a260: 2300         	movs	r3, #0x0
 801a262: e000         	b	0x801a266 <uart_stm32_cfg2ll_hwctrl+0x22> @ imm = #0x0
; 	return LL_USART_HWCONTROL_NONE;
 801a264: 2300         	movs	r3, #0x0
; }
 801a266: 4618         	mov	r0, r3
 801a268: 370c         	adds	r7, #0xc
 801a26a: 46bd         	mov	sp, r7
 801a26c: bc80         	pop	{r7}
 801a26e: 4770         	bx	lr

0801a270 <uart_stm32_ll2cfg_hwctrl>:
; {
 801a270: b480         	push	{r7}
 801a272: b083         	sub	sp, #0xc
 801a274: af00         	add	r7, sp, #0x0
 801a276: 6078         	str	r0, [r7, #0x4]
; 	if (fc == LL_USART_HWCONTROL_RTS_CTS) {
 801a278: 687b         	ldr	r3, [r7, #0x4]
 801a27a: f5b3 7f40    	cmp.w	r3, #0x300
 801a27e: d101         	bne	0x801a284 <uart_stm32_ll2cfg_hwctrl+0x14> @ imm = #0x2
; 		return UART_CFG_FLOW_CTRL_RTS_CTS;
 801a280: 2301         	movs	r3, #0x1
 801a282: e000         	b	0x801a286 <uart_stm32_ll2cfg_hwctrl+0x16> @ imm = #0x0
; 	return UART_CFG_FLOW_CTRL_NONE;
 801a284: 2300         	movs	r3, #0x0
; }
 801a286: 4618         	mov	r0, r3
 801a288: 370c         	adds	r7, #0xc
 801a28a: 46bd         	mov	sp, r7
 801a28c: bc80         	pop	{r7}
 801a28e: 4770         	bx	lr

0801a290 <uart_stm32_parameters_set>:
; {
 801a290: b580         	push	{r7, lr}
 801a292: b08a         	sub	sp, #0x28
 801a294: af00         	add	r7, sp, #0x0
 801a296: 6078         	str	r0, [r7, #0x4]
 801a298: 6039         	str	r1, [r7]
; 	const struct uart_stm32_config *config = dev->config;
 801a29a: 687b         	ldr	r3, [r7, #0x4]
 801a29c: 685b         	ldr	r3, [r3, #0x4]
 801a29e: 627b         	str	r3, [r7, #0x24]
; 	struct uart_stm32_data *data = dev->data;
 801a2a0: 687b         	ldr	r3, [r7, #0x4]
 801a2a2: 691b         	ldr	r3, [r3, #0x10]
 801a2a4: 623b         	str	r3, [r7, #0x20]
; 	struct uart_config *uart_cfg = data->uart_cfg;
 801a2a6: 6a3b         	ldr	r3, [r7, #0x20]
 801a2a8: 685b         	ldr	r3, [r3, #0x4]
 801a2aa: 61fb         	str	r3, [r7, #0x1c]
; 	const uint32_t parity = uart_stm32_cfg2ll_parity(cfg->parity);
 801a2ac: 683b         	ldr	r3, [r7]
 801a2ae: 791b         	ldrb	r3, [r3, #0x4]
 801a2b0: 4618         	mov	r0, r3
 801a2b2: f7ff ff27    	bl	0x801a104 <uart_stm32_cfg2ll_parity> @ imm = #-0x1b2
 801a2b6: 61b8         	str	r0, [r7, #0x18]
; 	const uint32_t stopbits = uart_stm32_cfg2ll_stopbits(config, cfg->stop_bits);
 801a2b8: 683b         	ldr	r3, [r7]
 801a2ba: 795b         	ldrb	r3, [r3, #0x5]
 801a2bc: 4619         	mov	r1, r3
 801a2be: 6a78         	ldr	r0, [r7, #0x24]
 801a2c0: f7ff ff4d    	bl	0x801a15e <uart_stm32_cfg2ll_stopbits> @ imm = #-0x166
 801a2c4: 6178         	str	r0, [r7, #0x14]
; 	const uint32_t databits = uart_stm32_cfg2ll_databits(cfg->data_bits,
 801a2c6: 683b         	ldr	r3, [r7]
 801a2c8: 799a         	ldrb	r2, [r3, #0x6]
; 							     cfg->parity);
 801a2ca: 683b         	ldr	r3, [r7]
 801a2cc: 791b         	ldrb	r3, [r3, #0x4]
; 	const uint32_t databits = uart_stm32_cfg2ll_databits(cfg->data_bits,
 801a2ce: 4619         	mov	r1, r3
 801a2d0: 4610         	mov	r0, r2
 801a2d2: f7ff ff82    	bl	0x801a1da <uart_stm32_cfg2ll_databits> @ imm = #-0xfc
 801a2d6: 6138         	str	r0, [r7, #0x10]
; 	const uint32_t flowctrl = uart_stm32_cfg2ll_hwctrl(cfg->flow_ctrl);
 801a2d8: 683b         	ldr	r3, [r7]
 801a2da: 79db         	ldrb	r3, [r3, #0x7]
 801a2dc: 4618         	mov	r0, r3
 801a2de: f7ff ffb1    	bl	0x801a244 <uart_stm32_cfg2ll_hwctrl> @ imm = #-0x9e
 801a2e2: 60f8         	str	r0, [r7, #0xc]
; 	if (cfg == uart_cfg) {
 801a2e4: 683a         	ldr	r2, [r7]
 801a2e6: 69fb         	ldr	r3, [r7, #0x1c]
 801a2e8: 429a         	cmp	r2, r3
 801a2ea: d111         	bne	0x801a310 <uart_stm32_parameters_set+0x80> @ imm = #0x22
; 		LL_USART_ConfigCharacter(config->usart,
 801a2ec: 6a7b         	ldr	r3, [r7, #0x24]
 801a2ee: 6818         	ldr	r0, [r3]
 801a2f0: 697b         	ldr	r3, [r7, #0x14]
 801a2f2: 69ba         	ldr	r2, [r7, #0x18]
 801a2f4: 6939         	ldr	r1, [r7, #0x10]
 801a2f6: f7ff fabd    	bl	0x8019874 <LL_USART_ConfigCharacter> @ imm = #-0xa86
; 		uart_stm32_set_hwctrl(dev, flowctrl);
 801a2fa: 68f9         	ldr	r1, [r7, #0xc]
 801a2fc: 6878         	ldr	r0, [r7, #0x4]
 801a2fe: f7ff fede    	bl	0x801a0be <uart_stm32_set_hwctrl> @ imm = #-0x244
; 		uart_stm32_set_baudrate(dev, cfg->baudrate);
 801a302: 683b         	ldr	r3, [r7]
 801a304: 681b         	ldr	r3, [r3]
 801a306: 4619         	mov	r1, r3
 801a308: 6878         	ldr	r0, [r7, #0x4]
 801a30a: f7ef ff0f    	bl	0x800a12c <uart_stm32_set_baudrate> @ imm = #-0x101e2
; }
 801a30e: e03b         	b	0x801a388 <uart_stm32_parameters_set+0xf8> @ imm = #0x76
; 		if (parity != uart_stm32_get_parity(dev)) {
 801a310: 6878         	ldr	r0, [r7, #0x4]
 801a312: f7ff fe7d    	bl	0x801a010 <uart_stm32_get_parity> @ imm = #-0x306
 801a316: 4602         	mov	r2, r0
 801a318: 69bb         	ldr	r3, [r7, #0x18]
 801a31a: 4293         	cmp	r3, r2
 801a31c: d003         	beq	0x801a326 <uart_stm32_parameters_set+0x96> @ imm = #0x6
; 			uart_stm32_set_parity(dev, parity);
 801a31e: 69b9         	ldr	r1, [r7, #0x18]
 801a320: 6878         	ldr	r0, [r7, #0x4]
 801a322: f7ff fe63    	bl	0x8019fec <uart_stm32_set_parity> @ imm = #-0x33a
; 		if (stopbits != uart_stm32_get_stopbits(dev)) {
 801a326: 6878         	ldr	r0, [r7, #0x4]
 801a328: f7ff fe95    	bl	0x801a056 <uart_stm32_get_stopbits> @ imm = #-0x2d6
 801a32c: 4602         	mov	r2, r0
 801a32e: 697b         	ldr	r3, [r7, #0x14]
 801a330: 4293         	cmp	r3, r2
 801a332: d003         	beq	0x801a33c <uart_stm32_parameters_set+0xac> @ imm = #0x6
; 			uart_stm32_set_stopbits(dev, stopbits);
 801a334: 6979         	ldr	r1, [r7, #0x14]
 801a336: 6878         	ldr	r0, [r7, #0x4]
 801a338: f7ff fe7b    	bl	0x801a032 <uart_stm32_set_stopbits> @ imm = #-0x30a
; 		if (databits != uart_stm32_get_databits(dev)) {
 801a33c: 6878         	ldr	r0, [r7, #0x4]
 801a33e: f7ff fead    	bl	0x801a09c <uart_stm32_get_databits> @ imm = #-0x2a6
 801a342: 4602         	mov	r2, r0
 801a344: 693b         	ldr	r3, [r7, #0x10]
 801a346: 4293         	cmp	r3, r2
 801a348: d003         	beq	0x801a352 <uart_stm32_parameters_set+0xc2> @ imm = #0x6
; 			uart_stm32_set_databits(dev, databits);
 801a34a: 6939         	ldr	r1, [r7, #0x10]
 801a34c: 6878         	ldr	r0, [r7, #0x4]
 801a34e: f7ff fe93    	bl	0x801a078 <uart_stm32_set_databits> @ imm = #-0x2da
; 		if (flowctrl != uart_stm32_get_hwctrl(dev)) {
 801a352: 6878         	ldr	r0, [r7, #0x4]
 801a354: f7ff fec5    	bl	0x801a0e2 <uart_stm32_get_hwctrl> @ imm = #-0x276
 801a358: 4602         	mov	r2, r0
 801a35a: 68fb         	ldr	r3, [r7, #0xc]
 801a35c: 4293         	cmp	r3, r2
 801a35e: d003         	beq	0x801a368 <uart_stm32_parameters_set+0xd8> @ imm = #0x6
; 			uart_stm32_set_hwctrl(dev, flowctrl);
 801a360: 68f9         	ldr	r1, [r7, #0xc]
 801a362: 6878         	ldr	r0, [r7, #0x4]
 801a364: f7ff feab    	bl	0x801a0be <uart_stm32_set_hwctrl> @ imm = #-0x2aa
; 		if (cfg->baudrate != uart_cfg->baudrate) {
 801a368: 683b         	ldr	r3, [r7]
 801a36a: 681a         	ldr	r2, [r3]
 801a36c: 69fb         	ldr	r3, [r7, #0x1c]
 801a36e: 681b         	ldr	r3, [r3]
 801a370: 429a         	cmp	r2, r3
 801a372: d009         	beq	0x801a388 <uart_stm32_parameters_set+0xf8> @ imm = #0x12
; 			uart_stm32_set_baudrate(dev, cfg->baudrate);
 801a374: 683b         	ldr	r3, [r7]
 801a376: 681b         	ldr	r3, [r3]
 801a378: 4619         	mov	r1, r3
 801a37a: 6878         	ldr	r0, [r7, #0x4]
 801a37c: f7ef fed6    	bl	0x800a12c <uart_stm32_set_baudrate> @ imm = #-0x10254
; 			uart_cfg->baudrate = cfg->baudrate;
 801a380: 683b         	ldr	r3, [r7]
 801a382: 681a         	ldr	r2, [r3]
 801a384: 69fb         	ldr	r3, [r7, #0x1c]
 801a386: 601a         	str	r2, [r3]
; }
 801a388: bf00         	nop
 801a38a: 3728         	adds	r7, #0x28
 801a38c: 46bd         	mov	sp, r7
 801a38e: bd80         	pop	{r7, pc}

0801a390 <uart_stm32_config_get>:
; {
 801a390: b590         	push	{r4, r7, lr}
 801a392: b085         	sub	sp, #0x14
 801a394: af00         	add	r7, sp, #0x0
 801a396: 6078         	str	r0, [r7, #0x4]
 801a398: 6039         	str	r1, [r7]
; 	struct uart_stm32_data *data = dev->data;
 801a39a: 687b         	ldr	r3, [r7, #0x4]
 801a39c: 691b         	ldr	r3, [r3, #0x10]
 801a39e: 60fb         	str	r3, [r7, #0xc]
; 	struct uart_config *uart_cfg = data->uart_cfg;
 801a3a0: 68fb         	ldr	r3, [r7, #0xc]
 801a3a2: 685b         	ldr	r3, [r3, #0x4]
 801a3a4: 60bb         	str	r3, [r7, #0x8]
; 	cfg->baudrate = uart_cfg->baudrate;
 801a3a6: 68bb         	ldr	r3, [r7, #0x8]
 801a3a8: 681a         	ldr	r2, [r3]
 801a3aa: 683b         	ldr	r3, [r7]
 801a3ac: 601a         	str	r2, [r3]
; 	cfg->parity = uart_stm32_ll2cfg_parity(uart_stm32_get_parity(dev));
 801a3ae: 6878         	ldr	r0, [r7, #0x4]
 801a3b0: f7ff fe2e    	bl	0x801a010 <uart_stm32_get_parity> @ imm = #-0x3a4
 801a3b4: 4603         	mov	r3, r0
 801a3b6: 4618         	mov	r0, r3
 801a3b8: f7ff febb    	bl	0x801a132 <uart_stm32_ll2cfg_parity> @ imm = #-0x28a
 801a3bc: 4603         	mov	r3, r0
 801a3be: 461a         	mov	r2, r3
 801a3c0: 683b         	ldr	r3, [r7]
 801a3c2: 711a         	strb	r2, [r3, #0x4]
; 	cfg->stop_bits = uart_stm32_ll2cfg_stopbits(
 801a3c4: 6878         	ldr	r0, [r7, #0x4]
 801a3c6: f7ff fe46    	bl	0x801a056 <uart_stm32_get_stopbits> @ imm = #-0x374
 801a3ca: 4603         	mov	r3, r0
 801a3cc: 4618         	mov	r0, r3
 801a3ce: f7ff fee5    	bl	0x801a19c <uart_stm32_ll2cfg_stopbits> @ imm = #-0x236
 801a3d2: 4603         	mov	r3, r0
 801a3d4: 461a         	mov	r2, r3
 801a3d6: 683b         	ldr	r3, [r7]
 801a3d8: 715a         	strb	r2, [r3, #0x5]
; 	cfg->data_bits = uart_stm32_ll2cfg_databits(
 801a3da: 6878         	ldr	r0, [r7, #0x4]
 801a3dc: f7ff fe5e    	bl	0x801a09c <uart_stm32_get_databits> @ imm = #-0x344
 801a3e0: 4604         	mov	r4, r0
 801a3e2: 6878         	ldr	r0, [r7, #0x4]
 801a3e4: f7ff fe14    	bl	0x801a010 <uart_stm32_get_parity> @ imm = #-0x3d8
 801a3e8: 4603         	mov	r3, r0
 801a3ea: 4619         	mov	r1, r3
 801a3ec: 4620         	mov	r0, r4
 801a3ee: f7ff ff0e    	bl	0x801a20e <uart_stm32_ll2cfg_databits> @ imm = #-0x1e4
 801a3f2: 4603         	mov	r3, r0
 801a3f4: 461a         	mov	r2, r3
 801a3f6: 683b         	ldr	r3, [r7]
 801a3f8: 719a         	strb	r2, [r3, #0x6]
; 	cfg->flow_ctrl = uart_stm32_ll2cfg_hwctrl(
 801a3fa: 6878         	ldr	r0, [r7, #0x4]
 801a3fc: f7ff fe71    	bl	0x801a0e2 <uart_stm32_get_hwctrl> @ imm = #-0x31e
 801a400: 4603         	mov	r3, r0
 801a402: 4618         	mov	r0, r3
 801a404: f7ff ff34    	bl	0x801a270 <uart_stm32_ll2cfg_hwctrl> @ imm = #-0x198
 801a408: 4603         	mov	r3, r0
 801a40a: 461a         	mov	r2, r3
 801a40c: 683b         	ldr	r3, [r7]
 801a40e: 71da         	strb	r2, [r3, #0x7]
; 	return 0;
 801a410: 2300         	movs	r3, #0x0
; }
 801a412: 4618         	mov	r0, r3
 801a414: 3714         	adds	r7, #0x14
 801a416: 46bd         	mov	sp, r7
 801a418: bd90         	pop	{r4, r7, pc}

0801a41a <uart_stm32_poll_in_visitor>:
; {
 801a41a: b580         	push	{r7, lr}
 801a41c: b086         	sub	sp, #0x18
 801a41e: af00         	add	r7, sp, #0x0
 801a420: 60f8         	str	r0, [r7, #0xc]
 801a422: 60b9         	str	r1, [r7, #0x8]
 801a424: 607a         	str	r2, [r7, #0x4]
; 	const struct uart_stm32_config *config = dev->config;
 801a426: 68fb         	ldr	r3, [r7, #0xc]
 801a428: 685b         	ldr	r3, [r3, #0x4]
 801a42a: 617b         	str	r3, [r7, #0x14]
; 	USART_TypeDef *usart = config->usart;
 801a42c: 697b         	ldr	r3, [r7, #0x14]
 801a42e: 681b         	ldr	r3, [r3]
 801a430: 613b         	str	r3, [r7, #0x10]
; 	if (LL_USART_IsActiveFlag_ORE(usart)) {
 801a432: 6938         	ldr	r0, [r7, #0x10]
 801a434: f7ff faa0    	bl	0x8019978 <LL_USART_IsActiveFlag_ORE> @ imm = #-0xac0
 801a438: 4603         	mov	r3, r0
 801a43a: 2b00         	cmp	r3, #0x0
 801a43c: d002         	beq	0x801a444 <uart_stm32_poll_in_visitor+0x2a> @ imm = #0x4
; 		LL_USART_ClearFlag_ORE(usart);
 801a43e: 6938         	ldr	r0, [r7, #0x10]
 801a440: f7ff fb3a    	bl	0x8019ab8 <LL_USART_ClearFlag_ORE> @ imm = #-0x98c
; 	if (!LL_USART_IsActiveFlag_RXNE(usart)) {
 801a444: 6938         	ldr	r0, [r7, #0x10]
 801a446: f7ff fabb    	bl	0x80199c0 <LL_USART_IsActiveFlag_RXNE> @ imm = #-0xa8a
 801a44a: 4603         	mov	r3, r0
 801a44c: 2b00         	cmp	r3, #0x0
 801a44e: d102         	bne	0x801a456 <uart_stm32_poll_in_visitor+0x3c> @ imm = #0x4
; 		return -1;
 801a450: f04f 33ff    	mov.w	r3, #0xffffffff
 801a454: e004         	b	0x801a460 <uart_stm32_poll_in_visitor+0x46> @ imm = #0x8
; 	get_fn(usart, in);
 801a456: 687b         	ldr	r3, [r7, #0x4]
 801a458: 68b9         	ldr	r1, [r7, #0x8]
 801a45a: 6938         	ldr	r0, [r7, #0x10]
 801a45c: 4798         	blx	r3
; 	return 0;
 801a45e: 2300         	movs	r3, #0x0
; }
 801a460: 4618         	mov	r0, r3
 801a462: 3718         	adds	r7, #0x18
 801a464: 46bd         	mov	sp, r7
 801a466: bd80         	pop	{r7, pc}

0801a468 <uart_stm32_poll_out_visitor>:
; {
 801a468: b580         	push	{r7, lr}
 801a46a: b08e         	sub	sp, #0x38
 801a46c: af00         	add	r7, sp, #0x0
 801a46e: 60f8         	str	r0, [r7, #0xc]
 801a470: 460b         	mov	r3, r1
 801a472: 607a         	str	r2, [r7, #0x4]
 801a474: 817b         	strh	r3, [r7, #0xa]
; 	const struct uart_stm32_config *config = dev->config;
 801a476: 68fb         	ldr	r3, [r7, #0xc]
 801a478: 685b         	ldr	r3, [r3, #0x4]
 801a47a: 637b         	str	r3, [r7, #0x34]
; 	USART_TypeDef *usart = config->usart;
 801a47c: 6b7b         	ldr	r3, [r7, #0x34]
 801a47e: 681b         	ldr	r3, [r3]
 801a480: 633b         	str	r3, [r7, #0x30]
; 		if (LL_USART_IsActiveFlag_TXE(usart)) {
 801a482: 6b38         	ldr	r0, [r7, #0x30]
 801a484: f7ff fac0    	bl	0x8019a08 <LL_USART_IsActiveFlag_TXE> @ imm = #-0xa80
 801a488: 4603         	mov	r3, r0
 801a48a: 2b00         	cmp	r3, #0x0
 801a48c: d0f9         	beq	0x801a482 <uart_stm32_poll_out_visitor+0x1a> @ imm = #-0xe
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 801a48e: f3ef 8311    	mrs	r3, basepri
 801a492: 62bb         	str	r3, [r7, #0x28]
;   return(result);
 801a494: 6abb         	ldr	r3, [r7, #0x28]
; 	key = __get_BASEPRI();
 801a496: 627b         	str	r3, [r7, #0x24]
 801a498: 2310         	movs	r3, #0x10
 801a49a: 623b         	str	r3, [r7, #0x20]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 801a49c: 6a3b         	ldr	r3, [r7, #0x20]
 801a49e: f383 8812    	msr	basepri_max, r3
; }
 801a4a2: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 801a4a4: f3bf 8f6f    	isb	sy
; }
 801a4a8: bf00         	nop
; 	return key;
 801a4aa: 6a7b         	ldr	r3, [r7, #0x24]
; 			key = irq_lock();
 801a4ac: 62fb         	str	r3, [r7, #0x2c]
; 			if (LL_USART_IsActiveFlag_TXE(usart)) {
 801a4ae: 6b38         	ldr	r0, [r7, #0x30]
 801a4b0: f7ff faaa    	bl	0x8019a08 <LL_USART_IsActiveFlag_TXE> @ imm = #-0xaac
 801a4b4: 4603         	mov	r3, r0
 801a4b6: 2b00         	cmp	r3, #0x0
 801a4b8: d10c         	bne	0x801a4d4 <uart_stm32_poll_out_visitor+0x6c> @ imm = #0x18
 801a4ba: 6afb         	ldr	r3, [r7, #0x2c]
 801a4bc: 61fb         	str	r3, [r7, #0x1c]
 801a4be: 69fb         	ldr	r3, [r7, #0x1c]
 801a4c0: 61bb         	str	r3, [r7, #0x18]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 801a4c2: 69bb         	ldr	r3, [r7, #0x18]
 801a4c4: f383 8811    	msr	basepri, r3
; }
 801a4c8: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 801a4ca: f3bf 8f6f    	isb	sy
; }
 801a4ce: bf00         	nop
; }
 801a4d0: bf00         	nop
; 		if (LL_USART_IsActiveFlag_TXE(usart)) {
 801a4d2: e7d6         	b	0x801a482 <uart_stm32_poll_out_visitor+0x1a> @ imm = #-0x54
; 				break;
 801a4d4: bf00         	nop
; 	set_fn(usart, out);
 801a4d6: 897a         	ldrh	r2, [r7, #0xa]
 801a4d8: 687b         	ldr	r3, [r7, #0x4]
 801a4da: 4611         	mov	r1, r2
 801a4dc: 6b38         	ldr	r0, [r7, #0x30]
 801a4de: 4798         	blx	r3
 801a4e0: 6afb         	ldr	r3, [r7, #0x2c]
 801a4e2: 617b         	str	r3, [r7, #0x14]
 801a4e4: 697b         	ldr	r3, [r7, #0x14]
 801a4e6: 613b         	str	r3, [r7, #0x10]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 801a4e8: 693b         	ldr	r3, [r7, #0x10]
 801a4ea: f383 8811    	msr	basepri, r3
; }
 801a4ee: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 801a4f0: f3bf 8f6f    	isb	sy
; }
 801a4f4: bf00         	nop
; }
 801a4f6: bf00         	nop
; }
 801a4f8: bf00         	nop
 801a4fa: 3738         	adds	r7, #0x38
 801a4fc: 46bd         	mov	sp, r7
 801a4fe: bd80         	pop	{r7, pc}

0801a500 <poll_in_u8>:
; {
 801a500: b580         	push	{r7, lr}
 801a502: b082         	sub	sp, #0x8
 801a504: af00         	add	r7, sp, #0x0
 801a506: 6078         	str	r0, [r7, #0x4]
 801a508: 6039         	str	r1, [r7]
; 	*((unsigned char *)in) = (unsigned char)LL_USART_ReceiveData8(usart);
 801a50a: 6878         	ldr	r0, [r7, #0x4]
 801a50c: f7ff fd36    	bl	0x8019f7c <LL_USART_ReceiveData8> @ imm = #-0x594
 801a510: 4603         	mov	r3, r0
 801a512: 461a         	mov	r2, r3
 801a514: 683b         	ldr	r3, [r7]
 801a516: 701a         	strb	r2, [r3]
; }
 801a518: bf00         	nop
 801a51a: 3708         	adds	r7, #0x8
 801a51c: 46bd         	mov	sp, r7
 801a51e: bd80         	pop	{r7, pc}

0801a520 <poll_out_u8>:
; {
 801a520: b580         	push	{r7, lr}
 801a522: b082         	sub	sp, #0x8
 801a524: af00         	add	r7, sp, #0x0
 801a526: 6078         	str	r0, [r7, #0x4]
 801a528: 460b         	mov	r3, r1
 801a52a: 807b         	strh	r3, [r7, #0x2]
; 	LL_USART_TransmitData8(usart, (uint8_t)out);
 801a52c: 887b         	ldrh	r3, [r7, #0x2]
 801a52e: b2db         	uxtb	r3, r3
 801a530: 4619         	mov	r1, r3
 801a532: 6878         	ldr	r0, [r7, #0x4]
 801a534: f7ff fd2e    	bl	0x8019f94 <LL_USART_TransmitData8> @ imm = #-0x5a4
; }
 801a538: bf00         	nop
 801a53a: 3708         	adds	r7, #0x8
 801a53c: 46bd         	mov	sp, r7
 801a53e: bd80         	pop	{r7, pc}

0801a540 <uart_stm32_err_check>:
; {
 801a540: b580         	push	{r7, lr}
 801a542: b086         	sub	sp, #0x18
 801a544: af00         	add	r7, sp, #0x0
 801a546: 6078         	str	r0, [r7, #0x4]
; 	const struct uart_stm32_config *config = dev->config;
 801a548: 687b         	ldr	r3, [r7, #0x4]
 801a54a: 685b         	ldr	r3, [r3, #0x4]
 801a54c: 613b         	str	r3, [r7, #0x10]
; 	USART_TypeDef *usart = config->usart;
 801a54e: 693b         	ldr	r3, [r7, #0x10]
 801a550: 681b         	ldr	r3, [r3]
 801a552: 60fb         	str	r3, [r7, #0xc]
; 	uint32_t err = 0U;
 801a554: 2300         	movs	r3, #0x0
 801a556: 617b         	str	r3, [r7, #0x14]
; 	if (LL_USART_IsActiveFlag_ORE(usart)) {
 801a558: 68f8         	ldr	r0, [r7, #0xc]
 801a55a: f7ff fa0d    	bl	0x8019978 <LL_USART_IsActiveFlag_ORE> @ imm = #-0xbe6
 801a55e: 4603         	mov	r3, r0
 801a560: 2b00         	cmp	r3, #0x0
 801a562: d003         	beq	0x801a56c <uart_stm32_err_check+0x2c> @ imm = #0x6
; 		err |= UART_ERROR_OVERRUN;
 801a564: 697b         	ldr	r3, [r7, #0x14]
 801a566: f043 0301    	orr	r3, r3, #0x1
 801a56a: 617b         	str	r3, [r7, #0x14]
; 	if (LL_USART_IsActiveFlag_PE(usart)) {
 801a56c: 68f8         	ldr	r0, [r7, #0xc]
 801a56e: f7ff f9cd    	bl	0x801990c <LL_USART_IsActiveFlag_PE> @ imm = #-0xc66
 801a572: 4603         	mov	r3, r0
 801a574: 2b00         	cmp	r3, #0x0
 801a576: d003         	beq	0x801a580 <uart_stm32_err_check+0x40> @ imm = #0x6
; 		err |= UART_ERROR_PARITY;
 801a578: 697b         	ldr	r3, [r7, #0x14]
 801a57a: f043 0302    	orr	r3, r3, #0x2
 801a57e: 617b         	str	r3, [r7, #0x14]
; 	if (LL_USART_IsActiveFlag_FE(usart)) {
 801a580: 68f8         	ldr	r0, [r7, #0xc]
 801a582: f7ff f9d5    	bl	0x8019930 <LL_USART_IsActiveFlag_FE> @ imm = #-0xc56
 801a586: 4603         	mov	r3, r0
 801a588: 2b00         	cmp	r3, #0x0
 801a58a: d003         	beq	0x801a594 <uart_stm32_err_check+0x54> @ imm = #0x6
; 		err |= UART_ERROR_FRAMING;
 801a58c: 697b         	ldr	r3, [r7, #0x14]
 801a58e: f043 0304    	orr	r3, r3, #0x4
 801a592: 617b         	str	r3, [r7, #0x14]
; 	if (LL_USART_IsActiveFlag_NE(usart)) {
 801a594: 68f8         	ldr	r0, [r7, #0xc]
 801a596: f7ff f9dd    	bl	0x8019954 <LL_USART_IsActiveFlag_NE> @ imm = #-0xc46
 801a59a: 4603         	mov	r3, r0
 801a59c: 2b00         	cmp	r3, #0x0
 801a59e: d003         	beq	0x801a5a8 <uart_stm32_err_check+0x68> @ imm = #0x6
; 		err |= UART_ERROR_NOISE;
 801a5a0: 697b         	ldr	r3, [r7, #0x14]
 801a5a2: f043 0320    	orr	r3, r3, #0x20
 801a5a6: 617b         	str	r3, [r7, #0x14]
; 	if (LL_USART_IsActiveFlag_LBD(usart)) {
 801a5a8: 68f8         	ldr	r0, [r7, #0xc]
 801a5aa: f7ff fa3f    	bl	0x8019a2c <LL_USART_IsActiveFlag_LBD> @ imm = #-0xb82
 801a5ae: 4603         	mov	r3, r0
 801a5b0: 2b00         	cmp	r3, #0x0
 801a5b2: d003         	beq	0x801a5bc <uart_stm32_err_check+0x7c> @ imm = #0x6
; 		err |= UART_BREAK;
 801a5b4: 697b         	ldr	r3, [r7, #0x14]
 801a5b6: f043 0308    	orr	r3, r3, #0x8
 801a5ba: 617b         	str	r3, [r7, #0x14]
; 	if (err & UART_BREAK) {
 801a5bc: 697b         	ldr	r3, [r7, #0x14]
 801a5be: f003 0308    	and	r3, r3, #0x8
 801a5c2: 2b00         	cmp	r3, #0x0
 801a5c4: d002         	beq	0x801a5cc <uart_stm32_err_check+0x8c> @ imm = #0x4
; 		LL_USART_ClearFlag_LBD(usart);
 801a5c6: 68f8         	ldr	r0, [r7, #0xc]
 801a5c8: f7ff fab2    	bl	0x8019b30 <LL_USART_ClearFlag_LBD> @ imm = #-0xa9c
; 	if (err & UART_ERROR_OVERRUN) {
 801a5cc: 697b         	ldr	r3, [r7, #0x14]
 801a5ce: f003 0301    	and	r3, r3, #0x1
 801a5d2: 2b00         	cmp	r3, #0x0
 801a5d4: d002         	beq	0x801a5dc <uart_stm32_err_check+0x9c> @ imm = #0x4
; 		LL_USART_ClearFlag_ORE(usart);
 801a5d6: 68f8         	ldr	r0, [r7, #0xc]
 801a5d8: f7ff fa6e    	bl	0x8019ab8 <LL_USART_ClearFlag_ORE> @ imm = #-0xb24
; 	if (err & UART_ERROR_PARITY) {
 801a5dc: 697b         	ldr	r3, [r7, #0x14]
 801a5de: f003 0302    	and	r3, r3, #0x2
 801a5e2: 2b00         	cmp	r3, #0x0
 801a5e4: d002         	beq	0x801a5ec <uart_stm32_err_check+0xac> @ imm = #0x4
; 		LL_USART_ClearFlag_PE(usart);
 801a5e6: 68f8         	ldr	r0, [r7, #0xc]
 801a5e8: f7ff fa33    	bl	0x8019a52 <LL_USART_ClearFlag_PE> @ imm = #-0xb9a
; 	if (err & UART_ERROR_FRAMING) {
 801a5ec: 697b         	ldr	r3, [r7, #0x14]
 801a5ee: f003 0304    	and	r3, r3, #0x4
 801a5f2: 2b00         	cmp	r3, #0x0
 801a5f4: d002         	beq	0x801a5fc <uart_stm32_err_check+0xbc> @ imm = #0x4
; 		LL_USART_ClearFlag_FE(usart);
 801a5f6: 68f8         	ldr	r0, [r7, #0xc]
 801a5f8: f7ff fa3c    	bl	0x8019a74 <LL_USART_ClearFlag_FE> @ imm = #-0xb88
; 	if (err & UART_ERROR_NOISE) {
 801a5fc: 697b         	ldr	r3, [r7, #0x14]
 801a5fe: f003 0320    	and	r3, r3, #0x20
 801a602: 2b00         	cmp	r3, #0x0
 801a604: d002         	beq	0x801a60c <uart_stm32_err_check+0xcc> @ imm = #0x4
; 		LL_USART_ClearFlag_NE(usart);
 801a606: 68f8         	ldr	r0, [r7, #0xc]
 801a608: f7ff fa45    	bl	0x8019a96 <LL_USART_ClearFlag_NE> @ imm = #-0xb76
; 	return err;
 801a60c: 697b         	ldr	r3, [r7, #0x14]
; }
 801a60e: 4618         	mov	r0, r3
 801a610: 3718         	adds	r7, #0x18
 801a612: 46bd         	mov	sp, r7
 801a614: bd80         	pop	{r7, pc}

0801a616 <uart_stm32_fifo_fill_visitor>:
; {
 801a616: b580         	push	{r7, lr}
 801a618: b08e         	sub	sp, #0x38
 801a61a: af00         	add	r7, sp, #0x0
 801a61c: 60f8         	str	r0, [r7, #0xc]
 801a61e: 60b9         	str	r1, [r7, #0x8]
 801a620: 607a         	str	r2, [r7, #0x4]
 801a622: 603b         	str	r3, [r7]
; 	const struct uart_stm32_config *config = dev->config;
 801a624: 68fb         	ldr	r3, [r7, #0xc]
 801a626: 685b         	ldr	r3, [r3, #0x4]
 801a628: 633b         	str	r3, [r7, #0x30]
; 	USART_TypeDef *usart = config->usart;
 801a62a: 6b3b         	ldr	r3, [r7, #0x30]
 801a62c: 681b         	ldr	r3, [r3]
 801a62e: 62fb         	str	r3, [r7, #0x2c]
; 	int num_tx = 0U;
 801a630: 2300         	movs	r3, #0x0
 801a632: 637b         	str	r3, [r7, #0x34]
; 	if (!LL_USART_IsActiveFlag_TXE(usart)) {
 801a634: 6af8         	ldr	r0, [r7, #0x2c]
 801a636: f7ff f9e7    	bl	0x8019a08 <LL_USART_IsActiveFlag_TXE> @ imm = #-0xc32
 801a63a: 4603         	mov	r3, r0
 801a63c: 2b00         	cmp	r3, #0x0
 801a63e: d101         	bne	0x801a644 <uart_stm32_fifo_fill_visitor+0x2e> @ imm = #0x2
; 		return num_tx;
 801a640: 6b7b         	ldr	r3, [r7, #0x34]
 801a642: e030         	b	0x801a6a6 <uart_stm32_fifo_fill_visitor+0x90> @ imm = #0x60
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 801a644: f3ef 8311    	mrs	r3, basepri
 801a648: 627b         	str	r3, [r7, #0x24]
;   return(result);
 801a64a: 6a7b         	ldr	r3, [r7, #0x24]
; 	key = __get_BASEPRI();
 801a64c: 623b         	str	r3, [r7, #0x20]
 801a64e: 2310         	movs	r3, #0x10
 801a650: 61fb         	str	r3, [r7, #0x1c]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 801a652: 69fb         	ldr	r3, [r7, #0x1c]
 801a654: f383 8812    	msr	basepri_max, r3
; }
 801a658: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 801a65a: f3bf 8f6f    	isb	sy
; }
 801a65e: bf00         	nop
; 	return key;
 801a660: 6a3b         	ldr	r3, [r7, #0x20]
; 	key = irq_lock();
 801a662: 62bb         	str	r3, [r7, #0x28]
; 	while ((size - num_tx > 0) && LL_USART_IsActiveFlag_TXE(usart)) {
 801a664: e007         	b	0x801a676 <uart_stm32_fifo_fill_visitor+0x60> @ imm = #0xe
; 		fill_fn(usart, tx_data, num_tx);
 801a666: 683b         	ldr	r3, [r7]
 801a668: 6b7a         	ldr	r2, [r7, #0x34]
 801a66a: 68b9         	ldr	r1, [r7, #0x8]
 801a66c: 6af8         	ldr	r0, [r7, #0x2c]
 801a66e: 4798         	blx	r3
; 		num_tx++;
 801a670: 6b7b         	ldr	r3, [r7, #0x34]
 801a672: 3301         	adds	r3, #0x1
 801a674: 637b         	str	r3, [r7, #0x34]
; 	while ((size - num_tx > 0) && LL_USART_IsActiveFlag_TXE(usart)) {
 801a676: 687a         	ldr	r2, [r7, #0x4]
 801a678: 6b7b         	ldr	r3, [r7, #0x34]
 801a67a: 1ad3         	subs	r3, r2, r3
 801a67c: 2b00         	cmp	r3, #0x0
 801a67e: dd05         	ble	0x801a68c <uart_stm32_fifo_fill_visitor+0x76> @ imm = #0xa
 801a680: 6af8         	ldr	r0, [r7, #0x2c]
 801a682: f7ff f9c1    	bl	0x8019a08 <LL_USART_IsActiveFlag_TXE> @ imm = #-0xc7e
 801a686: 4603         	mov	r3, r0
 801a688: 2b00         	cmp	r3, #0x0
 801a68a: d1ec         	bne	0x801a666 <uart_stm32_fifo_fill_visitor+0x50> @ imm = #-0x28
 801a68c: 6abb         	ldr	r3, [r7, #0x28]
 801a68e: 61bb         	str	r3, [r7, #0x18]
 801a690: 69bb         	ldr	r3, [r7, #0x18]
 801a692: 617b         	str	r3, [r7, #0x14]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 801a694: 697b         	ldr	r3, [r7, #0x14]
 801a696: f383 8811    	msr	basepri, r3
; }
 801a69a: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 801a69c: f3bf 8f6f    	isb	sy
; }
 801a6a0: bf00         	nop
; }
 801a6a2: bf00         	nop
; 	return num_tx;
 801a6a4: 6b7b         	ldr	r3, [r7, #0x34]
; }
 801a6a6: 4618         	mov	r0, r3
 801a6a8: 3738         	adds	r7, #0x38
 801a6aa: 46bd         	mov	sp, r7
 801a6ac: bd80         	pop	{r7, pc}

0801a6ae <fifo_fill_with_u8>:
; {
 801a6ae: b580         	push	{r7, lr}
 801a6b0: b086         	sub	sp, #0x18
 801a6b2: af00         	add	r7, sp, #0x0
 801a6b4: 60f8         	str	r0, [r7, #0xc]
 801a6b6: 60b9         	str	r1, [r7, #0x8]
 801a6b8: 607a         	str	r2, [r7, #0x4]
; 	const uint8_t *data = (const uint8_t *)tx_data;
 801a6ba: 68bb         	ldr	r3, [r7, #0x8]
 801a6bc: 617b         	str	r3, [r7, #0x14]
; 	LL_USART_TransmitData8(usart, data[offset]);
 801a6be: 687b         	ldr	r3, [r7, #0x4]
 801a6c0: 697a         	ldr	r2, [r7, #0x14]
 801a6c2: 4413         	add	r3, r2
 801a6c4: 781b         	ldrb	r3, [r3]
 801a6c6: 4619         	mov	r1, r3
 801a6c8: 68f8         	ldr	r0, [r7, #0xc]
 801a6ca: f7ff fc63    	bl	0x8019f94 <LL_USART_TransmitData8> @ imm = #-0x73a
; }
 801a6ce: bf00         	nop
 801a6d0: 3718         	adds	r7, #0x18
 801a6d2: 46bd         	mov	sp, r7
 801a6d4: bd80         	pop	{r7, pc}

0801a6d6 <uart_stm32_fifo_read_visitor>:
; {
 801a6d6: b580         	push	{r7, lr}
 801a6d8: b088         	sub	sp, #0x20
 801a6da: af00         	add	r7, sp, #0x0
 801a6dc: 60f8         	str	r0, [r7, #0xc]
 801a6de: 60b9         	str	r1, [r7, #0x8]
 801a6e0: 607a         	str	r2, [r7, #0x4]
 801a6e2: 603b         	str	r3, [r7]
; 	const struct uart_stm32_config *config = dev->config;
 801a6e4: 68fb         	ldr	r3, [r7, #0xc]
 801a6e6: 685b         	ldr	r3, [r3, #0x4]
 801a6e8: 61bb         	str	r3, [r7, #0x18]
; 	USART_TypeDef *usart = config->usart;
 801a6ea: 69bb         	ldr	r3, [r7, #0x18]
 801a6ec: 681b         	ldr	r3, [r3]
 801a6ee: 617b         	str	r3, [r7, #0x14]
; 	int num_rx = 0U;
 801a6f0: 2300         	movs	r3, #0x0
 801a6f2: 61fb         	str	r3, [r7, #0x1c]
; 	while ((size - num_rx > 0) && LL_USART_IsActiveFlag_RXNE(usart)) {
 801a6f4: e010         	b	0x801a718 <uart_stm32_fifo_read_visitor+0x42> @ imm = #0x20
; 		read_fn(usart, rx_data, num_rx);
 801a6f6: 683b         	ldr	r3, [r7]
 801a6f8: 69fa         	ldr	r2, [r7, #0x1c]
 801a6fa: 68b9         	ldr	r1, [r7, #0x8]
 801a6fc: 6978         	ldr	r0, [r7, #0x14]
 801a6fe: 4798         	blx	r3
; 		num_rx++;
 801a700: 69fb         	ldr	r3, [r7, #0x1c]
 801a702: 3301         	adds	r3, #0x1
 801a704: 61fb         	str	r3, [r7, #0x1c]
; 		if (LL_USART_IsActiveFlag_ORE(usart)) {
 801a706: 6978         	ldr	r0, [r7, #0x14]
 801a708: f7ff f936    	bl	0x8019978 <LL_USART_IsActiveFlag_ORE> @ imm = #-0xd94
 801a70c: 4603         	mov	r3, r0
 801a70e: 2b00         	cmp	r3, #0x0
 801a710: d002         	beq	0x801a718 <uart_stm32_fifo_read_visitor+0x42> @ imm = #0x4
; 			LL_USART_ClearFlag_ORE(usart);
 801a712: 6978         	ldr	r0, [r7, #0x14]
 801a714: f7ff f9d0    	bl	0x8019ab8 <LL_USART_ClearFlag_ORE> @ imm = #-0xc60
; 	while ((size - num_rx > 0) && LL_USART_IsActiveFlag_RXNE(usart)) {
 801a718: 687a         	ldr	r2, [r7, #0x4]
 801a71a: 69fb         	ldr	r3, [r7, #0x1c]
 801a71c: 1ad3         	subs	r3, r2, r3
 801a71e: 2b00         	cmp	r3, #0x0
 801a720: dd05         	ble	0x801a72e <uart_stm32_fifo_read_visitor+0x58> @ imm = #0xa
 801a722: 6978         	ldr	r0, [r7, #0x14]
 801a724: f7ff f94c    	bl	0x80199c0 <LL_USART_IsActiveFlag_RXNE> @ imm = #-0xd68
 801a728: 4603         	mov	r3, r0
 801a72a: 2b00         	cmp	r3, #0x0
 801a72c: d1e3         	bne	0x801a6f6 <uart_stm32_fifo_read_visitor+0x20> @ imm = #-0x3a
; 	return num_rx;
 801a72e: 69fb         	ldr	r3, [r7, #0x1c]
; }
 801a730: 4618         	mov	r0, r3
 801a732: 3720         	adds	r7, #0x20
 801a734: 46bd         	mov	sp, r7
 801a736: bd80         	pop	{r7, pc}

0801a738 <fifo_read_with_u8>:
; {
 801a738: b590         	push	{r4, r7, lr}
 801a73a: b087         	sub	sp, #0x1c
 801a73c: af00         	add	r7, sp, #0x0
 801a73e: 60f8         	str	r0, [r7, #0xc]
 801a740: 60b9         	str	r1, [r7, #0x8]
 801a742: 607a         	str	r2, [r7, #0x4]
; 	uint8_t *data = (uint8_t *)rx_data;
 801a744: 68bb         	ldr	r3, [r7, #0x8]
 801a746: 617b         	str	r3, [r7, #0x14]
; 	data[offset] = LL_USART_ReceiveData8(usart);
 801a748: 687b         	ldr	r3, [r7, #0x4]
 801a74a: 697a         	ldr	r2, [r7, #0x14]
 801a74c: 18d4         	adds	r4, r2, r3
 801a74e: 68f8         	ldr	r0, [r7, #0xc]
 801a750: f7ff fc14    	bl	0x8019f7c <LL_USART_ReceiveData8> @ imm = #-0x7d8
 801a754: 4603         	mov	r3, r0
 801a756: 7023         	strb	r3, [r4]
; }
 801a758: bf00         	nop
 801a75a: 371c         	adds	r7, #0x1c
 801a75c: 46bd         	mov	sp, r7
 801a75e: bd90         	pop	{r4, r7, pc}

0801a760 <uart_stm32_irq_tx_enable>:
; {
 801a760: b580         	push	{r7, lr}
 801a762: b084         	sub	sp, #0x10
 801a764: af00         	add	r7, sp, #0x0
 801a766: 6078         	str	r0, [r7, #0x4]
; 	const struct uart_stm32_config *config = dev->config;
 801a768: 687b         	ldr	r3, [r7, #0x4]
 801a76a: 685b         	ldr	r3, [r3, #0x4]
 801a76c: 60fb         	str	r3, [r7, #0xc]
; 	LL_USART_EnableIT_TC(config->usart);
 801a76e: 68fb         	ldr	r3, [r7, #0xc]
 801a770: 681b         	ldr	r3, [r3]
 801a772: 4618         	mov	r0, r3
 801a774: f7ff fa2d    	bl	0x8019bd2 <LL_USART_EnableIT_TC> @ imm = #-0xba6
; }
 801a778: bf00         	nop
 801a77a: 3710         	adds	r7, #0x10
 801a77c: 46bd         	mov	sp, r7
 801a77e: bd80         	pop	{r7, pc}

0801a780 <uart_stm32_irq_tx_disable>:
; {
 801a780: b580         	push	{r7, lr}
 801a782: b084         	sub	sp, #0x10
 801a784: af00         	add	r7, sp, #0x0
 801a786: 6078         	str	r0, [r7, #0x4]
; 	const struct uart_stm32_config *config = dev->config;
 801a788: 687b         	ldr	r3, [r7, #0x4]
 801a78a: 685b         	ldr	r3, [r3, #0x4]
 801a78c: 60fb         	str	r3, [r7, #0xc]
; 	LL_USART_DisableIT_TC(config->usart);
 801a78e: 68fb         	ldr	r3, [r7, #0xc]
 801a790: 681b         	ldr	r3, [r3]
 801a792: 4618         	mov	r0, r3
 801a794: f7ff fad6    	bl	0x8019d44 <LL_USART_DisableIT_TC> @ imm = #-0xa54
; }
 801a798: bf00         	nop
 801a79a: 3710         	adds	r7, #0x10
 801a79c: 46bd         	mov	sp, r7
 801a79e: bd80         	pop	{r7, pc}

0801a7a0 <uart_stm32_irq_tx_ready>:
; {
 801a7a0: b580         	push	{r7, lr}
 801a7a2: b084         	sub	sp, #0x10
 801a7a4: af00         	add	r7, sp, #0x0
 801a7a6: 6078         	str	r0, [r7, #0x4]
; 	const struct uart_stm32_config *config = dev->config;
 801a7a8: 687b         	ldr	r3, [r7, #0x4]
 801a7aa: 685b         	ldr	r3, [r3, #0x4]
 801a7ac: 60fb         	str	r3, [r7, #0xc]
; 	return LL_USART_IsActiveFlag_TXE(config->usart) &&
 801a7ae: 68fb         	ldr	r3, [r7, #0xc]
 801a7b0: 681b         	ldr	r3, [r3]
 801a7b2: 4618         	mov	r0, r3
 801a7b4: f7ff f928    	bl	0x8019a08 <LL_USART_IsActiveFlag_TXE> @ imm = #-0xdb0
 801a7b8: 4603         	mov	r3, r0
 801a7ba: 2b00         	cmp	r3, #0x0
 801a7bc: d009         	beq	0x801a7d2 <uart_stm32_irq_tx_ready+0x32> @ imm = #0x12
; 		LL_USART_IsEnabledIT_TC(config->usart);
 801a7be: 68fb         	ldr	r3, [r7, #0xc]
 801a7c0: 681b         	ldr	r3, [r3]
 801a7c2: 4618         	mov	r0, r3
 801a7c4: f7ff fb57    	bl	0x8019e76 <LL_USART_IsEnabledIT_TC> @ imm = #-0x952
 801a7c8: 4603         	mov	r3, r0
; 	return LL_USART_IsActiveFlag_TXE(config->usart) &&
 801a7ca: 2b00         	cmp	r3, #0x0
 801a7cc: d001         	beq	0x801a7d2 <uart_stm32_irq_tx_ready+0x32> @ imm = #0x2
 801a7ce: 2301         	movs	r3, #0x1
 801a7d0: e000         	b	0x801a7d4 <uart_stm32_irq_tx_ready+0x34> @ imm = #0x0
 801a7d2: 2300         	movs	r3, #0x0
; }
 801a7d4: 4618         	mov	r0, r3
 801a7d6: 3710         	adds	r7, #0x10
 801a7d8: 46bd         	mov	sp, r7
 801a7da: bd80         	pop	{r7, pc}

0801a7dc <uart_stm32_irq_tx_complete>:
; {
 801a7dc: b580         	push	{r7, lr}
 801a7de: b084         	sub	sp, #0x10
 801a7e0: af00         	add	r7, sp, #0x0
 801a7e2: 6078         	str	r0, [r7, #0x4]
; 	const struct uart_stm32_config *config = dev->config;
 801a7e4: 687b         	ldr	r3, [r7, #0x4]
 801a7e6: 685b         	ldr	r3, [r3, #0x4]
 801a7e8: 60fb         	str	r3, [r7, #0xc]
; 	return LL_USART_IsActiveFlag_TC(config->usart);
 801a7ea: 68fb         	ldr	r3, [r7, #0xc]
 801a7ec: 681b         	ldr	r3, [r3]
 801a7ee: 4618         	mov	r0, r3
 801a7f0: f7ff f8f8    	bl	0x80199e4 <LL_USART_IsActiveFlag_TC> @ imm = #-0xe10
 801a7f4: 4603         	mov	r3, r0
; }
 801a7f6: 4618         	mov	r0, r3
 801a7f8: 3710         	adds	r7, #0x10
 801a7fa: 46bd         	mov	sp, r7
 801a7fc: bd80         	pop	{r7, pc}

0801a7fe <uart_stm32_irq_rx_enable>:
; {
 801a7fe: b580         	push	{r7, lr}
 801a800: b084         	sub	sp, #0x10
 801a802: af00         	add	r7, sp, #0x0
 801a804: 6078         	str	r0, [r7, #0x4]
; 	const struct uart_stm32_config *config = dev->config;
 801a806: 687b         	ldr	r3, [r7, #0x4]
 801a808: 685b         	ldr	r3, [r3, #0x4]
 801a80a: 60fb         	str	r3, [r7, #0xc]
; 	LL_USART_EnableIT_RXNE(config->usart);
 801a80c: 68fb         	ldr	r3, [r7, #0xc]
 801a80e: 681b         	ldr	r3, [r3]
 801a810: 4618         	mov	r0, r3
 801a812: f7ff f9bc    	bl	0x8019b8e <LL_USART_EnableIT_RXNE> @ imm = #-0xc88
; }
 801a816: bf00         	nop
 801a818: 3710         	adds	r7, #0x10
 801a81a: 46bd         	mov	sp, r7
 801a81c: bd80         	pop	{r7, pc}

0801a81e <uart_stm32_irq_rx_disable>:
; {
 801a81e: b580         	push	{r7, lr}
 801a820: b084         	sub	sp, #0x10
 801a822: af00         	add	r7, sp, #0x0
 801a824: 6078         	str	r0, [r7, #0x4]
; 	const struct uart_stm32_config *config = dev->config;
 801a826: 687b         	ldr	r3, [r7, #0x4]
 801a828: 685b         	ldr	r3, [r3, #0x4]
 801a82a: 60fb         	str	r3, [r7, #0xc]
; 	LL_USART_DisableIT_RXNE(config->usart);
 801a82c: 68fb         	ldr	r3, [r7, #0xc]
 801a82e: 681b         	ldr	r3, [r3]
 801a830: 4618         	mov	r0, r3
 801a832: f7ff fa65    	bl	0x8019d00 <LL_USART_DisableIT_RXNE> @ imm = #-0xb36
; }
 801a836: bf00         	nop
 801a838: 3710         	adds	r7, #0x10
 801a83a: 46bd         	mov	sp, r7
 801a83c: bd80         	pop	{r7, pc}

0801a83e <uart_stm32_irq_rx_ready>:
; {
 801a83e: b580         	push	{r7, lr}
 801a840: b084         	sub	sp, #0x10
 801a842: af00         	add	r7, sp, #0x0
 801a844: 6078         	str	r0, [r7, #0x4]
; 	const struct uart_stm32_config *config = dev->config;
 801a846: 687b         	ldr	r3, [r7, #0x4]
 801a848: 685b         	ldr	r3, [r3, #0x4]
 801a84a: 60fb         	str	r3, [r7, #0xc]
; 	return LL_USART_IsActiveFlag_RXNE(config->usart);
 801a84c: 68fb         	ldr	r3, [r7, #0xc]
 801a84e: 681b         	ldr	r3, [r3]
 801a850: 4618         	mov	r0, r3
 801a852: f7ff f8b5    	bl	0x80199c0 <LL_USART_IsActiveFlag_RXNE> @ imm = #-0xe96
 801a856: 4603         	mov	r3, r0
; }
 801a858: 4618         	mov	r0, r3
 801a85a: 3710         	adds	r7, #0x10
 801a85c: 46bd         	mov	sp, r7
 801a85e: bd80         	pop	{r7, pc}

0801a860 <uart_stm32_irq_is_pending>:
; {
 801a860: b580         	push	{r7, lr}
 801a862: b084         	sub	sp, #0x10
 801a864: af00         	add	r7, sp, #0x0
 801a866: 6078         	str	r0, [r7, #0x4]
; 	const struct uart_stm32_config *config = dev->config;
 801a868: 687b         	ldr	r3, [r7, #0x4]
 801a86a: 685b         	ldr	r3, [r3, #0x4]
 801a86c: 60fb         	str	r3, [r7, #0xc]
; 	USART_TypeDef *usart = config->usart;
 801a86e: 68fb         	ldr	r3, [r7, #0xc]
 801a870: 681b         	ldr	r3, [r3]
 801a872: 60bb         	str	r3, [r7, #0x8]
; 	return ((LL_USART_IsActiveFlag_RXNE(usart) &&
 801a874: 68b8         	ldr	r0, [r7, #0x8]
 801a876: f7ff f8a3    	bl	0x80199c0 <LL_USART_IsActiveFlag_RXNE> @ imm = #-0xeba
 801a87a: 4603         	mov	r3, r0
; 		 LL_USART_IsEnabledIT_RXNE(usart)) ||
 801a87c: 2b00         	cmp	r3, #0x0
 801a87e: d005         	beq	0x801a88c <uart_stm32_irq_is_pending+0x2c> @ imm = #0xa
 801a880: 68b8         	ldr	r0, [r7, #0x8]
 801a882: f7ff fae6    	bl	0x8019e52 <LL_USART_IsEnabledIT_RXNE> @ imm = #-0xa34
 801a886: 4603         	mov	r3, r0
; 	return ((LL_USART_IsActiveFlag_RXNE(usart) &&
 801a888: 2b00         	cmp	r3, #0x0
 801a88a: d10b         	bne	0x801a8a4 <uart_stm32_irq_is_pending+0x44> @ imm = #0x16
; 		(LL_USART_IsActiveFlag_TC(usart) &&
 801a88c: 68b8         	ldr	r0, [r7, #0x8]
 801a88e: f7ff f8a9    	bl	0x80199e4 <LL_USART_IsActiveFlag_TC> @ imm = #-0xeae
 801a892: 4603         	mov	r3, r0
; 		 LL_USART_IsEnabledIT_RXNE(usart)) ||
 801a894: 2b00         	cmp	r3, #0x0
 801a896: d007         	beq	0x801a8a8 <uart_stm32_irq_is_pending+0x48> @ imm = #0xe
; 		 LL_USART_IsEnabledIT_TC(usart)));
 801a898: 68b8         	ldr	r0, [r7, #0x8]
 801a89a: f7ff faec    	bl	0x8019e76 <LL_USART_IsEnabledIT_TC> @ imm = #-0xa28
 801a89e: 4603         	mov	r3, r0
; 		(LL_USART_IsActiveFlag_TC(usart) &&
 801a8a0: 2b00         	cmp	r3, #0x0
 801a8a2: d001         	beq	0x801a8a8 <uart_stm32_irq_is_pending+0x48> @ imm = #0x2
; 		 LL_USART_IsEnabledIT_RXNE(usart)) ||
 801a8a4: 2301         	movs	r3, #0x1
 801a8a6: e000         	b	0x801a8aa <uart_stm32_irq_is_pending+0x4a> @ imm = #0x0
 801a8a8: 2300         	movs	r3, #0x0
; }
 801a8aa: 4618         	mov	r0, r3
 801a8ac: 3710         	adds	r7, #0x10
 801a8ae: 46bd         	mov	sp, r7
 801a8b0: bd80         	pop	{r7, pc}

0801a8b2 <uart_stm32_irq_update>:
; {
 801a8b2: b480         	push	{r7}
 801a8b4: b083         	sub	sp, #0xc
 801a8b6: af00         	add	r7, sp, #0x0
 801a8b8: 6078         	str	r0, [r7, #0x4]
; 	return 1;
 801a8ba: 2301         	movs	r3, #0x1
; }
 801a8bc: 4618         	mov	r0, r3
 801a8be: 370c         	adds	r7, #0xc
 801a8c0: 46bd         	mov	sp, r7
 801a8c2: bc80         	pop	{r7}
 801a8c4: 4770         	bx	lr

0801a8c6 <uart_stm32_irq_callback_set>:
; {
 801a8c6: b480         	push	{r7}
 801a8c8: b087         	sub	sp, #0x1c
 801a8ca: af00         	add	r7, sp, #0x0
 801a8cc: 60f8         	str	r0, [r7, #0xc]
 801a8ce: 60b9         	str	r1, [r7, #0x8]
 801a8d0: 607a         	str	r2, [r7, #0x4]
; 	struct uart_stm32_data *data = dev->data;
 801a8d2: 68fb         	ldr	r3, [r7, #0xc]
 801a8d4: 691b         	ldr	r3, [r3, #0x10]
 801a8d6: 617b         	str	r3, [r7, #0x14]
; 	data->user_cb = cb;
 801a8d8: 697b         	ldr	r3, [r7, #0x14]
 801a8da: 68ba         	ldr	r2, [r7, #0x8]
 801a8dc: 609a         	str	r2, [r3, #0x8]
; 	data->user_data = cb_data;
 801a8de: 697b         	ldr	r3, [r7, #0x14]
 801a8e0: 687a         	ldr	r2, [r7, #0x4]
 801a8e2: 60da         	str	r2, [r3, #0xc]
; 	data->async_cb = NULL;
 801a8e4: 697b         	ldr	r3, [r7, #0x14]
 801a8e6: 2200         	movs	r2, #0x0
 801a8e8: 615a         	str	r2, [r3, #0x14]
; 	data->async_user_data = NULL;
 801a8ea: 697b         	ldr	r3, [r7, #0x14]
 801a8ec: 2200         	movs	r2, #0x0
 801a8ee: 619a         	str	r2, [r3, #0x18]
; }
 801a8f0: bf00         	nop
 801a8f2: 371c         	adds	r7, #0x1c
 801a8f4: 46bd         	mov	sp, r7
 801a8f6: bc80         	pop	{r7}
 801a8f8: 4770         	bx	lr

0801a8fa <async_user_callback>:
; {
 801a8fa: b580         	push	{r7, lr}
 801a8fc: b082         	sub	sp, #0x8
 801a8fe: af00         	add	r7, sp, #0x0
 801a900: 6078         	str	r0, [r7, #0x4]
 801a902: 6039         	str	r1, [r7]
; 	if (data->async_cb) {
 801a904: 687b         	ldr	r3, [r7, #0x4]
 801a906: 695b         	ldr	r3, [r3, #0x14]
 801a908: 2b00         	cmp	r3, #0x0
 801a90a: d007         	beq	0x801a91c <async_user_callback+0x22> @ imm = #0xe
; 		data->async_cb(data->uart_dev, event, data->async_user_data);
 801a90c: 687b         	ldr	r3, [r7, #0x4]
 801a90e: 695b         	ldr	r3, [r3, #0x14]
 801a910: 687a         	ldr	r2, [r7, #0x4]
 801a912: 6910         	ldr	r0, [r2, #0x10]
 801a914: 687a         	ldr	r2, [r7, #0x4]
 801a916: 6992         	ldr	r2, [r2, #0x18]
 801a918: 6839         	ldr	r1, [r7]
 801a91a: 4798         	blx	r3
; }
 801a91c: bf00         	nop
 801a91e: 3708         	adds	r7, #0x8
 801a920: 46bd         	mov	sp, r7
 801a922: bd80         	pop	{r7, pc}

0801a924 <async_evt_rx_buf_request>:
; {
 801a924: b580         	push	{r7, lr}
 801a926: b088         	sub	sp, #0x20
 801a928: af00         	add	r7, sp, #0x0
 801a92a: 6078         	str	r0, [r7, #0x4]
; 	struct uart_event evt = {
 801a92c: f107 030c    	add.w	r3, r7, #0xc
 801a930: 2200         	movs	r2, #0x0
 801a932: 601a         	str	r2, [r3]
 801a934: 605a         	str	r2, [r3, #0x4]
 801a936: 609a         	str	r2, [r3, #0x8]
 801a938: 60da         	str	r2, [r3, #0xc]
 801a93a: 611a         	str	r2, [r3, #0x10]
 801a93c: 2303         	movs	r3, #0x3
 801a93e: 733b         	strb	r3, [r7, #0xc]
; 	async_user_callback(data, &evt);
 801a940: f107 030c    	add.w	r3, r7, #0xc
 801a944: 4619         	mov	r1, r3
 801a946: 6878         	ldr	r0, [r7, #0x4]
 801a948: f7ff ffd7    	bl	0x801a8fa <async_user_callback> @ imm = #-0x52
; }
 801a94c: bf00         	nop
 801a94e: 3720         	adds	r7, #0x20
 801a950: 46bd         	mov	sp, r7
 801a952: bd80         	pop	{r7, pc}

0801a954 <async_evt_rx_buf_release>:
; {
 801a954: b580         	push	{r7, lr}
 801a956: b088         	sub	sp, #0x20
 801a958: af00         	add	r7, sp, #0x0
 801a95a: 6078         	str	r0, [r7, #0x4]
; 	struct uart_event evt = {
 801a95c: f107 030c    	add.w	r3, r7, #0xc
 801a960: 2200         	movs	r2, #0x0
 801a962: 601a         	str	r2, [r3]
 801a964: 605a         	str	r2, [r3, #0x4]
 801a966: 609a         	str	r2, [r3, #0x8]
 801a968: 60da         	str	r2, [r3, #0xc]
 801a96a: 611a         	str	r2, [r3, #0x10]
 801a96c: 2304         	movs	r3, #0x4
 801a96e: 733b         	strb	r3, [r7, #0xc]
; 		.data.rx_buf.buf = data->dma_rx.buffer,
 801a970: 687b         	ldr	r3, [r7, #0x4]
 801a972: 6edb         	ldr	r3, [r3, #0x6c]
; 	struct uart_event evt = {
 801a974: 613b         	str	r3, [r7, #0x10]
; 	async_user_callback(data, &evt);
 801a976: f107 030c    	add.w	r3, r7, #0xc
 801a97a: 4619         	mov	r1, r3
 801a97c: 6878         	ldr	r0, [r7, #0x4]
 801a97e: f7ff ffbc    	bl	0x801a8fa <async_user_callback> @ imm = #-0x88
; }
 801a982: bf00         	nop
 801a984: 3720         	adds	r7, #0x20
 801a986: 46bd         	mov	sp, r7
 801a988: bd80         	pop	{r7, pc}

0801a98a <uart_stm32_dma_rx_flush>:
; {
 801a98a: b580         	push	{r7, lr}
 801a98c: b08c         	sub	sp, #0x30
 801a98e: af00         	add	r7, sp, #0x0
 801a990: 6078         	str	r0, [r7, #0x4]
; 	struct uart_stm32_data *data = dev->data;
 801a992: 687b         	ldr	r3, [r7, #0x4]
 801a994: 691b         	ldr	r3, [r3, #0x10]
 801a996: 62fb         	str	r3, [r7, #0x2c]
; 	if (dma_get_status(data->dma_rx.dma_dev,
 801a998: 6afb         	ldr	r3, [r7, #0x2c]
 801a99a: 6a18         	ldr	r0, [r3, #0x20]
 801a99c: 6afb         	ldr	r3, [r7, #0x2c]
 801a99e: 6a5b         	ldr	r3, [r3, #0x24]
 801a9a0: f107 0208    	add.w	r2, r7, #0x8
 801a9a4: 4619         	mov	r1, r3
 801a9a6: f7fe fe13    	bl	0x80195d0 <dma_get_status> @ imm = #-0x13da
 801a9aa: 4603         	mov	r3, r0
 801a9ac: 2b00         	cmp	r3, #0x0
 801a9ae: d10f         	bne	0x801a9d0 <uart_stm32_dma_rx_flush+0x46> @ imm = #0x1e
; 		size_t rx_rcv_len = data->dma_rx.buffer_length -
 801a9b0: 6afb         	ldr	r3, [r7, #0x2c]
 801a9b2: 6f1a         	ldr	r2, [r3, #0x70]
; 					stat.pending_length;
 801a9b4: 68fb         	ldr	r3, [r7, #0xc]
; 		size_t rx_rcv_len = data->dma_rx.buffer_length -
 801a9b6: 1ad3         	subs	r3, r2, r3
 801a9b8: 62bb         	str	r3, [r7, #0x28]
; 		if (rx_rcv_len > data->dma_rx.offset) {
 801a9ba: 6afb         	ldr	r3, [r7, #0x2c]
 801a9bc: 6f5b         	ldr	r3, [r3, #0x74]
 801a9be: 6aba         	ldr	r2, [r7, #0x28]
 801a9c0: 429a         	cmp	r2, r3
 801a9c2: d905         	bls	0x801a9d0 <uart_stm32_dma_rx_flush+0x46> @ imm = #0xa
; 			data->dma_rx.counter = rx_rcv_len;
 801a9c4: 6afb         	ldr	r3, [r7, #0x2c]
 801a9c6: 6aba         	ldr	r2, [r7, #0x28]
 801a9c8: 679a         	str	r2, [r3, #0x78]
; 			async_evt_rx_rdy(data);
 801a9ca: 6af8         	ldr	r0, [r7, #0x2c]
 801a9cc: f7ef fd80    	bl	0x800a4d0 <async_evt_rx_rdy> @ imm = #-0x10500
; }
 801a9d0: bf00         	nop
 801a9d2: 3730         	adds	r7, #0x30
 801a9d4: 46bd         	mov	sp, r7
 801a9d6: bd80         	pop	{r7, pc}

0801a9d8 <uart_stm32_async_callback_set>:
; {
 801a9d8: b480         	push	{r7}
 801a9da: b087         	sub	sp, #0x1c
 801a9dc: af00         	add	r7, sp, #0x0
 801a9de: 60f8         	str	r0, [r7, #0xc]
 801a9e0: 60b9         	str	r1, [r7, #0x8]
 801a9e2: 607a         	str	r2, [r7, #0x4]
; 	struct uart_stm32_data *data = dev->data;
 801a9e4: 68fb         	ldr	r3, [r7, #0xc]
 801a9e6: 691b         	ldr	r3, [r3, #0x10]
 801a9e8: 617b         	str	r3, [r7, #0x14]
; 	data->async_cb = callback;
 801a9ea: 697b         	ldr	r3, [r7, #0x14]
 801a9ec: 68ba         	ldr	r2, [r7, #0x8]
 801a9ee: 615a         	str	r2, [r3, #0x14]
; 	data->async_user_data = user_data;
 801a9f0: 697b         	ldr	r3, [r7, #0x14]
 801a9f2: 687a         	ldr	r2, [r7, #0x4]
 801a9f4: 619a         	str	r2, [r3, #0x18]
; 	data->user_cb = NULL;
 801a9f6: 697b         	ldr	r3, [r7, #0x14]
 801a9f8: 2200         	movs	r2, #0x0
 801a9fa: 609a         	str	r2, [r3, #0x8]
; 	data->user_data = NULL;
 801a9fc: 697b         	ldr	r3, [r7, #0x14]
 801a9fe: 2200         	movs	r2, #0x0
 801aa00: 60da         	str	r2, [r3, #0xc]
; 	return 0;
 801aa02: 2300         	movs	r3, #0x0
; }
 801aa04: 4618         	mov	r0, r3
 801aa06: 371c         	adds	r7, #0x1c
 801aa08: 46bd         	mov	sp, r7
 801aa0a: bc80         	pop	{r7}
 801aa0c: 4770         	bx	lr

0801aa0e <uart_stm32_dma_tx_enable>:
; {
 801aa0e: b580         	push	{r7, lr}
 801aa10: b084         	sub	sp, #0x10
 801aa12: af00         	add	r7, sp, #0x0
 801aa14: 6078         	str	r0, [r7, #0x4]
; 	const struct uart_stm32_config *config = dev->config;
 801aa16: 687b         	ldr	r3, [r7, #0x4]
 801aa18: 685b         	ldr	r3, [r3, #0x4]
 801aa1a: 60fb         	str	r3, [r7, #0xc]
; 	LL_USART_EnableDMAReq_TX(config->usart);
 801aa1c: 68fb         	ldr	r3, [r7, #0xc]
 801aa1e: 681b         	ldr	r3, [r3]
 801aa20: 4618         	mov	r0, r3
 801aa22: f7ff fa5c    	bl	0x8019ede <LL_USART_EnableDMAReq_TX> @ imm = #-0xb48
; }
 801aa26: bf00         	nop
 801aa28: 3710         	adds	r7, #0x10
 801aa2a: 46bd         	mov	sp, r7
 801aa2c: bd80         	pop	{r7, pc}

0801aa2e <uart_stm32_dma_tx_disable>:
; {
 801aa2e: b580         	push	{r7, lr}
 801aa30: b084         	sub	sp, #0x10
 801aa32: af00         	add	r7, sp, #0x0
 801aa34: 6078         	str	r0, [r7, #0x4]
; 	const struct uart_stm32_config *config = dev->config;
 801aa36: 687b         	ldr	r3, [r7, #0x4]
 801aa38: 685b         	ldr	r3, [r3, #0x4]
 801aa3a: 60fb         	str	r3, [r7, #0xc]
; 	LL_USART_DisableDMAReq_TX(config->usart);
 801aa3c: 68fb         	ldr	r3, [r7, #0xc]
 801aa3e: 681b         	ldr	r3, [r3]
 801aa40: 4618         	mov	r0, r3
 801aa42: f7ff fa6e    	bl	0x8019f22 <LL_USART_DisableDMAReq_TX> @ imm = #-0xb24
; }
 801aa46: bf00         	nop
 801aa48: 3710         	adds	r7, #0x10
 801aa4a: 46bd         	mov	sp, r7
 801aa4c: bd80         	pop	{r7, pc}

0801aa4e <uart_stm32_dma_rx_enable>:
; {
 801aa4e: b580         	push	{r7, lr}
 801aa50: b084         	sub	sp, #0x10
 801aa52: af00         	add	r7, sp, #0x0
 801aa54: 6078         	str	r0, [r7, #0x4]
; 	const struct uart_stm32_config *config = dev->config;
 801aa56: 687b         	ldr	r3, [r7, #0x4]
 801aa58: 685b         	ldr	r3, [r3, #0x4]
 801aa5a: 60fb         	str	r3, [r7, #0xc]
; 	struct uart_stm32_data *data = dev->data;
 801aa5c: 687b         	ldr	r3, [r7, #0x4]
 801aa5e: 691b         	ldr	r3, [r3, #0x10]
 801aa60: 60bb         	str	r3, [r7, #0x8]
; 	LL_USART_EnableDMAReq_RX(config->usart);
 801aa62: 68fb         	ldr	r3, [r7, #0xc]
 801aa64: 681b         	ldr	r3, [r3]
 801aa66: 4618         	mov	r0, r3
 801aa68: f7ff fa17    	bl	0x8019e9a <LL_USART_EnableDMAReq_RX> @ imm = #-0xbd2
; 	data->dma_rx.enabled = true;
 801aa6c: 68bb         	ldr	r3, [r7, #0x8]
 801aa6e: 2201         	movs	r2, #0x1
 801aa70: f883 20b0    	strb.w	r2, [r3, #0xb0]
; }
 801aa74: bf00         	nop
 801aa76: 3710         	adds	r7, #0x10
 801aa78: 46bd         	mov	sp, r7
 801aa7a: bd80         	pop	{r7, pc}

0801aa7c <uart_stm32_dma_rx_disable>:
; {
 801aa7c: b480         	push	{r7}
 801aa7e: b085         	sub	sp, #0x14
 801aa80: af00         	add	r7, sp, #0x0
 801aa82: 6078         	str	r0, [r7, #0x4]
; 	struct uart_stm32_data *data = dev->data;
 801aa84: 687b         	ldr	r3, [r7, #0x4]
 801aa86: 691b         	ldr	r3, [r3, #0x10]
 801aa88: 60fb         	str	r3, [r7, #0xc]
; 	data->dma_rx.enabled = false;
 801aa8a: 68fb         	ldr	r3, [r7, #0xc]
 801aa8c: 2200         	movs	r2, #0x0
 801aa8e: f883 20b0    	strb.w	r2, [r3, #0xb0]
; }
 801aa92: bf00         	nop
 801aa94: 3714         	adds	r7, #0x14
 801aa96: 46bd         	mov	sp, r7
 801aa98: bc80         	pop	{r7}
 801aa9a: 4770         	bx	lr

0801aa9c <uart_stm32_dma_tx_cb>:
; {
 801aa9c: b580         	push	{r7, lr}
 801aa9e: b094         	sub	sp, #0x50
 801aaa0: af00         	add	r7, sp, #0x0
 801aaa2: 60f8         	str	r0, [r7, #0xc]
 801aaa4: 60b9         	str	r1, [r7, #0x8]
 801aaa6: 607a         	str	r2, [r7, #0x4]
 801aaa8: 603b         	str	r3, [r7]
; 	const struct device *uart_dev = user_data;
 801aaaa: 68bb         	ldr	r3, [r7, #0x8]
 801aaac: 64fb         	str	r3, [r7, #0x4c]
; 	struct uart_stm32_data *data = uart_dev->data;
 801aaae: 6cfb         	ldr	r3, [r7, #0x4c]
 801aab0: 691b         	ldr	r3, [r3, #0x10]
 801aab2: 64bb         	str	r3, [r7, #0x48]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 801aab4: f3ef 8311    	mrs	r3, basepri
 801aab8: 643b         	str	r3, [r7, #0x40]
;   return(result);
 801aaba: 6c3b         	ldr	r3, [r7, #0x40]
; 	key = __get_BASEPRI();
 801aabc: 63fb         	str	r3, [r7, #0x3c]
 801aabe: 2310         	movs	r3, #0x10
 801aac0: 63bb         	str	r3, [r7, #0x38]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 801aac2: 6bbb         	ldr	r3, [r7, #0x38]
 801aac4: f383 8812    	msr	basepri_max, r3
; }
 801aac8: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 801aaca: f3bf 8f6f    	isb	sy
; }
 801aace: bf00         	nop
; 	return key;
 801aad0: 6bfb         	ldr	r3, [r7, #0x3c]
; 	unsigned int key = irq_lock();
 801aad2: 647b         	str	r3, [r7, #0x44]
; 	uart_stm32_dma_tx_disable(uart_dev);
 801aad4: 6cf8         	ldr	r0, [r7, #0x4c]
 801aad6: f7ff ffaa    	bl	0x801aa2e <uart_stm32_dma_tx_disable> @ imm = #-0xac
; 	(void)k_work_cancel_delayable(&data->dma_tx.timeout_work);
 801aada: 6cbb         	ldr	r3, [r7, #0x48]
 801aadc: f503 738c    	add.w	r3, r3, #0x118
 801aae0: 4618         	mov	r0, r3
 801aae2: f7f4 f895    	bl	0x800ec10 <k_work_cancel_delayable> @ imm = #-0xbed6
; 	if (!dma_get_status(data->dma_tx.dma_dev,
 801aae6: 6cbb         	ldr	r3, [r7, #0x48]
 801aae8: f8d3 00b8    	ldr.w	r0, [r3, #0xb8]
 801aaec: 6cbb         	ldr	r3, [r7, #0x48]
 801aaee: f8d3 30bc    	ldr.w	r3, [r3, #0xbc]
 801aaf2: f107 0210    	add.w	r2, r7, #0x10
 801aaf6: 4619         	mov	r1, r3
 801aaf8: f7fe fd6a    	bl	0x80195d0 <dma_get_status> @ imm = #-0x152c
 801aafc: 4603         	mov	r3, r0
 801aafe: 2b00         	cmp	r3, #0x0
 801ab00: d107         	bne	0x801ab12 <uart_stm32_dma_tx_cb+0x76> @ imm = #0xe
; 		data->dma_tx.counter = data->dma_tx.buffer_length -
 801ab02: 6cbb         	ldr	r3, [r7, #0x48]
 801ab04: f8d3 2108    	ldr.w	r2, [r3, #0x108]
; 					stat.pending_length;
 801ab08: 697b         	ldr	r3, [r7, #0x14]
; 		data->dma_tx.counter = data->dma_tx.buffer_length -
 801ab0a: 1ad2         	subs	r2, r2, r3
 801ab0c: 6cbb         	ldr	r3, [r7, #0x48]
 801ab0e: f8c3 2110    	str.w	r2, [r3, #0x110]
; 	data->dma_tx.buffer_length = 0;
 801ab12: 6cbb         	ldr	r3, [r7, #0x48]
 801ab14: 2200         	movs	r2, #0x0
 801ab16: f8c3 2108    	str.w	r2, [r3, #0x108]
 801ab1a: 6c7b         	ldr	r3, [r7, #0x44]
 801ab1c: 637b         	str	r3, [r7, #0x34]
 801ab1e: 6b7b         	ldr	r3, [r7, #0x34]
 801ab20: 633b         	str	r3, [r7, #0x30]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 801ab22: 6b3b         	ldr	r3, [r7, #0x30]
 801ab24: f383 8811    	msr	basepri, r3
; }
 801ab28: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 801ab2a: f3bf 8f6f    	isb	sy
; }
 801ab2e: bf00         	nop
; }
 801ab30: bf00         	nop
; }
 801ab32: bf00         	nop
 801ab34: 3750         	adds	r7, #0x50
 801ab36: 46bd         	mov	sp, r7
 801ab38: bd80         	pop	{r7, pc}

0801ab3a <uart_stm32_dma_rx_cb>:
; {
 801ab3a: b580         	push	{r7, lr}
 801ab3c: b086         	sub	sp, #0x18
 801ab3e: af00         	add	r7, sp, #0x0
 801ab40: 60f8         	str	r0, [r7, #0xc]
 801ab42: 60b9         	str	r1, [r7, #0x8]
 801ab44: 607a         	str	r2, [r7, #0x4]
 801ab46: 603b         	str	r3, [r7]
; 	const struct device *uart_dev = user_data;
 801ab48: 68bb         	ldr	r3, [r7, #0x8]
 801ab4a: 617b         	str	r3, [r7, #0x14]
; 	struct uart_stm32_data *data = uart_dev->data;
 801ab4c: 697b         	ldr	r3, [r7, #0x14]
 801ab4e: 691b         	ldr	r3, [r3, #0x10]
 801ab50: 613b         	str	r3, [r7, #0x10]
; 	if (status < 0) {
 801ab52: 683b         	ldr	r3, [r7]
 801ab54: 2b00         	cmp	r3, #0x0
 801ab56: da04         	bge	0x801ab62 <uart_stm32_dma_rx_cb+0x28> @ imm = #0x8
; 		async_evt_rx_err(data, status);
 801ab58: 6839         	ldr	r1, [r7]
 801ab5a: 6938         	ldr	r0, [r7, #0x10]
 801ab5c: f7ef fd0e    	bl	0x800a57c <async_evt_rx_err> @ imm = #-0x105e4
; 		return;
 801ab60: e021         	b	0x801aba6 <uart_stm32_dma_rx_cb+0x6c> @ imm = #0x42
; 	(void)k_work_cancel_delayable(&data->dma_rx.timeout_work);
 801ab62: 693b         	ldr	r3, [r7, #0x10]
 801ab64: 3380         	adds	r3, #0x80
 801ab66: 4618         	mov	r0, r3
 801ab68: f7f4 f852    	bl	0x800ec10 <k_work_cancel_delayable> @ imm = #-0xbf5c
; 	data->dma_rx.counter = data->dma_rx.buffer_length;
 801ab6c: 693b         	ldr	r3, [r7, #0x10]
 801ab6e: 6f1a         	ldr	r2, [r3, #0x70]
 801ab70: 693b         	ldr	r3, [r7, #0x10]
 801ab72: 679a         	str	r2, [r3, #0x78]
; 	async_evt_rx_rdy(data);
 801ab74: 6938         	ldr	r0, [r7, #0x10]
 801ab76: f7ef fcab    	bl	0x800a4d0 <async_evt_rx_rdy> @ imm = #-0x106aa
; 	if (data->rx_next_buffer != NULL) {
 801ab7a: 693b         	ldr	r3, [r7, #0x10]
 801ab7c: f8d3 3150    	ldr.w	r3, [r3, #0x150]
 801ab80: 2b00         	cmp	r3, #0x0
 801ab82: d006         	beq	0x801ab92 <uart_stm32_dma_rx_cb+0x58> @ imm = #0xc
; 		async_evt_rx_buf_release(data);
 801ab84: 6938         	ldr	r0, [r7, #0x10]
 801ab86: f7ff fee5    	bl	0x801a954 <async_evt_rx_buf_release> @ imm = #-0x236
; 		uart_stm32_dma_replace_buffer(uart_dev);
 801ab8a: 6978         	ldr	r0, [r7, #0x14]
 801ab8c: f7ef ff3e    	bl	0x800aa0c <uart_stm32_dma_replace_buffer> @ imm = #-0x10184
 801ab90: e009         	b	0x801aba6 <uart_stm32_dma_rx_cb+0x6c> @ imm = #0x12
; 		k_work_reschedule(&data->dma_rx.timeout_work, K_TICKS(1));
 801ab92: 693b         	ldr	r3, [r7, #0x10]
 801ab94: f103 0180    	add.w	r1, r3, #0x80
 801ab98: f04f 0201    	mov.w	r2, #0x1
 801ab9c: f04f 0300    	mov.w	r3, #0x0
 801aba0: 4608         	mov	r0, r1
 801aba2: f7f4 f821    	bl	0x800ebe8 <k_work_reschedule> @ imm = #-0xbfbe
; }
 801aba6: 3718         	adds	r7, #0x18
 801aba8: 46bd         	mov	sp, r7
 801abaa: bd80         	pop	{r7, pc}

0801abac <uart_stm32_async_tx_abort>:
; {
 801abac: b580         	push	{r7, lr}
 801abae: b08c         	sub	sp, #0x30
 801abb0: af00         	add	r7, sp, #0x0
 801abb2: 6078         	str	r0, [r7, #0x4]
; 	struct uart_stm32_data *data = dev->data;
 801abb4: 687b         	ldr	r3, [r7, #0x4]
 801abb6: 691b         	ldr	r3, [r3, #0x10]
 801abb8: 62fb         	str	r3, [r7, #0x2c]
; 	size_t tx_buffer_length = data->dma_tx.buffer_length;
 801abba: 6afb         	ldr	r3, [r7, #0x2c]
 801abbc: f8d3 3108    	ldr.w	r3, [r3, #0x108]
 801abc0: 62bb         	str	r3, [r7, #0x28]
; 	if (tx_buffer_length == 0) {
 801abc2: 6abb         	ldr	r3, [r7, #0x28]
 801abc4: 2b00         	cmp	r3, #0x0
 801abc6: d102         	bne	0x801abce <uart_stm32_async_tx_abort+0x22> @ imm = #0x4
; 		return -EFAULT;
 801abc8: f06f 030d    	mvn	r3, #0xd
 801abcc: e027         	b	0x801ac1e <uart_stm32_async_tx_abort+0x72> @ imm = #0x4e
; 	(void)k_work_cancel_delayable(&data->dma_tx.timeout_work);
 801abce: 6afb         	ldr	r3, [r7, #0x2c]
 801abd0: f503 738c    	add.w	r3, r3, #0x118
 801abd4: 4618         	mov	r0, r3
 801abd6: f7f4 f81b    	bl	0x800ec10 <k_work_cancel_delayable> @ imm = #-0xbfca
; 	if (!dma_get_status(data->dma_tx.dma_dev,
 801abda: 6afb         	ldr	r3, [r7, #0x2c]
 801abdc: f8d3 00b8    	ldr.w	r0, [r3, #0xb8]
 801abe0: 6afb         	ldr	r3, [r7, #0x2c]
 801abe2: f8d3 30bc    	ldr.w	r3, [r3, #0xbc]
 801abe6: f107 0208    	add.w	r2, r7, #0x8
 801abea: 4619         	mov	r1, r3
 801abec: f7fe fcf0    	bl	0x80195d0 <dma_get_status> @ imm = #-0x1620
 801abf0: 4603         	mov	r3, r0
 801abf2: 2b00         	cmp	r3, #0x0
 801abf4: d105         	bne	0x801ac02 <uart_stm32_async_tx_abort+0x56> @ imm = #0xa
; 		data->dma_tx.counter = tx_buffer_length - stat.pending_length;
 801abf6: 68fb         	ldr	r3, [r7, #0xc]
 801abf8: 6aba         	ldr	r2, [r7, #0x28]
 801abfa: 1ad2         	subs	r2, r2, r3
 801abfc: 6afb         	ldr	r3, [r7, #0x2c]
 801abfe: f8c3 2110    	str.w	r2, [r3, #0x110]
; 	dma_stop(data->dma_tx.dma_dev, data->dma_tx.dma_channel);
 801ac02: 6afb         	ldr	r3, [r7, #0x2c]
 801ac04: f8d3 20b8    	ldr.w	r2, [r3, #0xb8]
 801ac08: 6afb         	ldr	r3, [r7, #0x2c]
 801ac0a: f8d3 30bc    	ldr.w	r3, [r3, #0xbc]
 801ac0e: 4619         	mov	r1, r3
 801ac10: 4610         	mov	r0, r2
 801ac12: f7fe fd06    	bl	0x8019622 <dma_stop>    @ imm = #-0x15f4
; 	async_evt_tx_abort(data);
 801ac16: 6af8         	ldr	r0, [r7, #0x2c]
 801ac18: f7ef fd40    	bl	0x800a69c <async_evt_tx_abort> @ imm = #-0x10580
; 	return 0;
 801ac1c: 2300         	movs	r3, #0x0
; }
 801ac1e: 4618         	mov	r0, r3
 801ac20: 3730         	adds	r7, #0x30
 801ac22: 46bd         	mov	sp, r7
 801ac24: bd80         	pop	{r7, pc}

0801ac26 <uart_stm32_init>:
; {
 801ac26: b580         	push	{r7, lr}
 801ac28: b084         	sub	sp, #0x10
 801ac2a: af00         	add	r7, sp, #0x0
 801ac2c: 6078         	str	r0, [r7, #0x4]
; 	const struct uart_stm32_config *config = dev->config;
 801ac2e: 687b         	ldr	r3, [r7, #0x4]
 801ac30: 685b         	ldr	r3, [r3, #0x4]
 801ac32: 60fb         	str	r3, [r7, #0xc]
; 	err = uart_stm32_clocks_enable(dev);
 801ac34: 6878         	ldr	r0, [r7, #0x4]
 801ac36: f7f0 fb13    	bl	0x800b260 <uart_stm32_clocks_enable> @ imm = #-0xf9da
 801ac3a: 60b8         	str	r0, [r7, #0x8]
; 	if (err < 0) {
 801ac3c: 68bb         	ldr	r3, [r7, #0x8]
 801ac3e: 2b00         	cmp	r3, #0x0
 801ac40: da01         	bge	0x801ac46 <uart_stm32_init+0x20> @ imm = #0x2
; 		return err;
 801ac42: 68bb         	ldr	r3, [r7, #0x8]
 801ac44: e01c         	b	0x801ac80 <uart_stm32_init+0x5a> @ imm = #0x38
; 	err = pinctrl_apply_state(config->pcfg, PINCTRL_STATE_DEFAULT);
 801ac46: 68fb         	ldr	r3, [r7, #0xc]
 801ac48: 6a1b         	ldr	r3, [r3, #0x20]
 801ac4a: 2100         	movs	r1, #0x0
 801ac4c: 4618         	mov	r0, r3
 801ac4e: f7fe fd0a    	bl	0x8019666 <pinctrl_apply_state> @ imm = #-0x15ec
 801ac52: 60b8         	str	r0, [r7, #0x8]
; 	if (err < 0) {
 801ac54: 68bb         	ldr	r3, [r7, #0x8]
 801ac56: 2b00         	cmp	r3, #0x0
 801ac58: da01         	bge	0x801ac5e <uart_stm32_init+0x38> @ imm = #0x2
; 		return err;
 801ac5a: 68bb         	ldr	r3, [r7, #0x8]
 801ac5c: e010         	b	0x801ac80 <uart_stm32_init+0x5a> @ imm = #0x20
; 	err = uart_stm32_registers_configure(dev);
 801ac5e: 6878         	ldr	r0, [r7, #0x4]
 801ac60: f7f0 fb66    	bl	0x800b330 <uart_stm32_registers_configure> @ imm = #-0xf934
 801ac64: 60b8         	str	r0, [r7, #0x8]
; 	if (err < 0) {
 801ac66: 68bb         	ldr	r3, [r7, #0x8]
 801ac68: 2b00         	cmp	r3, #0x0
 801ac6a: da01         	bge	0x801ac70 <uart_stm32_init+0x4a> @ imm = #0x2
; 		return err;
 801ac6c: 68bb         	ldr	r3, [r7, #0x8]
 801ac6e: e007         	b	0x801ac80 <uart_stm32_init+0x5a> @ imm = #0xe
; 	config->irq_config_func(dev);
 801ac70: 68fb         	ldr	r3, [r7, #0xc]
 801ac72: 6a5b         	ldr	r3, [r3, #0x24]
 801ac74: 6878         	ldr	r0, [r7, #0x4]
 801ac76: 4798         	blx	r3
; 	return uart_stm32_async_init(dev);
 801ac78: 6878         	ldr	r0, [r7, #0x4]
 801ac7a: f7f0 f9e7    	bl	0x800b04c <uart_stm32_async_init> @ imm = #-0xfc32
 801ac7e: 4603         	mov	r3, r0
; }
 801ac80: 4618         	mov	r0, r3
 801ac82: 3710         	adds	r7, #0x10
 801ac84: 46bd         	mov	sp, r7
 801ac86: bd80         	pop	{r7, pc}

0801ac88 <uart_stm32_irq_config_func_0>:
; DT_INST_FOREACH_STATUS_OKAY(STM32_UART_INIT)
 801ac88: b580         	push	{r7, lr}
 801ac8a: b082         	sub	sp, #0x8
 801ac8c: af00         	add	r7, sp, #0x0
 801ac8e: 6078         	str	r0, [r7, #0x4]
 801ac90: 2200         	movs	r2, #0x0
 801ac92: 2100         	movs	r1, #0x0
 801ac94: 2025         	movs	r0, #0x25
 801ac96: f7fa ff6e    	bl	0x8015b76 <z_arm_irq_priority_set> @ imm = #-0x5124
 801ac9a: 2025         	movs	r0, #0x25
 801ac9c: f7fa ff5e    	bl	0x8015b5c <arch_irq_enable> @ imm = #-0x5144
 801aca0: 3708         	adds	r7, #0x8
 801aca2: 46bd         	mov	sp, r7
 801aca4: bd80         	pop	{r7, pc}

0801aca6 <uart_stm32_irq_config_func_1>:
 801aca6: b580         	push	{r7, lr}
 801aca8: b082         	sub	sp, #0x8
 801acaa: af00         	add	r7, sp, #0x0
 801acac: 6078         	str	r0, [r7, #0x4]
 801acae: 2200         	movs	r2, #0x0
 801acb0: 2100         	movs	r1, #0x0
 801acb2: 2047         	movs	r0, #0x47
 801acb4: f7fa ff5f    	bl	0x8015b76 <z_arm_irq_priority_set> @ imm = #-0x5142
 801acb8: 2047         	movs	r0, #0x47
 801acba: f7fa ff4f    	bl	0x8015b5c <arch_irq_enable> @ imm = #-0x5162
 801acbe: 3708         	adds	r7, #0x8
 801acc0: 46bd         	mov	sp, r7
 801acc2: bd80         	pop	{r7, pc}

0801acc4 <uart_stm32_irq_config_func_2>:
 801acc4: b580         	push	{r7, lr}
 801acc6: b082         	sub	sp, #0x8
 801acc8: af00         	add	r7, sp, #0x0
 801acca: 6078         	str	r0, [r7, #0x4]
 801accc: 2200         	movs	r2, #0x0
 801acce: 2100         	movs	r1, #0x0
 801acd0: 2027         	movs	r0, #0x27
 801acd2: f7fa ff50    	bl	0x8015b76 <z_arm_irq_priority_set> @ imm = #-0x5160
 801acd6: 2027         	movs	r0, #0x27
 801acd8: f7fa ff40    	bl	0x8015b5c <arch_irq_enable> @ imm = #-0x5180
 801acdc: 3708         	adds	r7, #0x8
 801acde: 46bd         	mov	sp, r7
 801ace0: bd80         	pop	{r7, pc}

0801ace2 <device_is_ready>:
; {
 801ace2: b580         	push	{r7, lr}
 801ace4: b082         	sub	sp, #0x8
 801ace6: af00         	add	r7, sp, #0x0
 801ace8: 6078         	str	r0, [r7, #0x4]
; 	return z_impl_device_is_ready(dev);
 801acea: 6878         	ldr	r0, [r7, #0x4]
 801acec: f000 ff47    	bl	0x801bb7e <z_impl_device_is_ready> @ imm = #0xe8e
 801acf0: 4603         	mov	r3, r0
; }
 801acf2: 4618         	mov	r0, r3
 801acf4: 3708         	adds	r7, #0x8
 801acf6: 46bd         	mov	sp, r7
 801acf8: bd80         	pop	{r7, pc}

0801acfa <z_log_msg_runtime_create>:
; {
 801acfa: b580         	push	{r7, lr}
 801acfc: b08a         	sub	sp, #0x28
 801acfe: af04         	add	r7, sp, #0x10
 801ad00: 60b9         	str	r1, [r7, #0x8]
 801ad02: 607b         	str	r3, [r7, #0x4]
 801ad04: 4603         	mov	r3, r0
 801ad06: 73fb         	strb	r3, [r7, #0xf]
 801ad08: 4613         	mov	r3, r2
 801ad0a: 73bb         	strb	r3, [r7, #0xe]
; 	va_start(ap, fmt);
 801ad0c: f107 032c    	add.w	r3, r7, #0x2c
 801ad10: 617b         	str	r3, [r7, #0x14]
; 	z_log_msg_runtime_vcreate(domain_id, source, level,
 801ad12: 7bba         	ldrb	r2, [r7, #0xe]
 801ad14: 7bf8         	ldrb	r0, [r7, #0xf]
 801ad16: 697b         	ldr	r3, [r7, #0x14]
 801ad18: 9303         	str	r3, [sp, #0xc]
 801ad1a: 6abb         	ldr	r3, [r7, #0x28]
 801ad1c: 9302         	str	r3, [sp, #0x8]
 801ad1e: 6a7b         	ldr	r3, [r7, #0x24]
 801ad20: 9301         	str	r3, [sp, #0x4]
 801ad22: 6a3b         	ldr	r3, [r7, #0x20]
 801ad24: 9300         	str	r3, [sp]
 801ad26: 687b         	ldr	r3, [r7, #0x4]
 801ad28: 68b9         	ldr	r1, [r7, #0x8]
 801ad2a: f7e9 fc21    	bl	0x8004570 <z_log_msg_runtime_vcreate> @ imm = #-0x167be
; }
 801ad2e: bf00         	nop
 801ad30: 3718         	adds	r7, #0x18
 801ad32: 46bd         	mov	sp, r7
 801ad34: bd80         	pop	{r7, pc}

0801ad36 <z_impl_k_sem_count_get>:
; {
 801ad36: b480         	push	{r7}
 801ad38: b083         	sub	sp, #0xc
 801ad3a: af00         	add	r7, sp, #0x0
 801ad3c: 6078         	str	r0, [r7, #0x4]
; 	return sem->count;
 801ad3e: 687b         	ldr	r3, [r7, #0x4]
 801ad40: 689b         	ldr	r3, [r3, #0x8]
; }
 801ad42: 4618         	mov	r0, r3
 801ad44: 370c         	adds	r7, #0xc
 801ad46: 46bd         	mov	sp, r7
 801ad48: bc80         	pop	{r7}
 801ad4a: 4770         	bx	lr

0801ad4c <k_busy_wait>:
; {
 801ad4c: b580         	push	{r7, lr}
 801ad4e: b082         	sub	sp, #0x8
 801ad50: af00         	add	r7, sp, #0x0
 801ad52: 6078         	str	r0, [r7, #0x4]
; 	z_impl_k_busy_wait(usec_to_wait);
 801ad54: 6878         	ldr	r0, [r7, #0x4]
 801ad56: f000 feea    	bl	0x801bb2e <z_impl_k_busy_wait> @ imm = #0xdd4
; }
 801ad5a: bf00         	nop
 801ad5c: 3708         	adds	r7, #0x8
 801ad5e: 46bd         	mov	sp, r7
 801ad60: bd80         	pop	{r7, pc}

0801ad62 <k_sem_take>:
; {
 801ad62: b580         	push	{r7, lr}
 801ad64: b084         	sub	sp, #0x10
 801ad66: af00         	add	r7, sp, #0x0
 801ad68: 60f8         	str	r0, [r7, #0xc]
 801ad6a: e9c7 2300    	strd	r2, r3, [r7]
; 	return z_impl_k_sem_take(sem, timeout);
 801ad6e: e9d7 2300    	ldrd	r2, r3, [r7]
 801ad72: 68f8         	ldr	r0, [r7, #0xc]
 801ad74: f7f3 fbd6    	bl	0x800e524 <z_impl_k_sem_take> @ imm = #-0xc854
 801ad78: 4603         	mov	r3, r0
; }
 801ad7a: 4618         	mov	r0, r3
 801ad7c: 3710         	adds	r7, #0x10
 801ad7e: 46bd         	mov	sp, r7
 801ad80: bd80         	pop	{r7, pc}

0801ad82 <k_sem_give>:
; {
 801ad82: b580         	push	{r7, lr}
 801ad84: b082         	sub	sp, #0x8
 801ad86: af00         	add	r7, sp, #0x0
 801ad88: 6078         	str	r0, [r7, #0x4]
; 	z_impl_k_sem_give(sem);
 801ad8a: 6878         	ldr	r0, [r7, #0x4]
 801ad8c: f7f3 fb3c    	bl	0x800e408 <z_impl_k_sem_give> @ imm = #-0xc988
; }
 801ad90: bf00         	nop
 801ad92: 3708         	adds	r7, #0x8
 801ad94: 46bd         	mov	sp, r7
 801ad96: bd80         	pop	{r7, pc}

0801ad98 <k_sem_count_get>:
; {
 801ad98: b580         	push	{r7, lr}
 801ad9a: b082         	sub	sp, #0x8
 801ad9c: af00         	add	r7, sp, #0x0
 801ad9e: 6078         	str	r0, [r7, #0x4]
; 	return z_impl_k_sem_count_get(sem);
 801ada0: 6878         	ldr	r0, [r7, #0x4]
 801ada2: f7ff ffc8    	bl	0x801ad36 <z_impl_k_sem_count_get> @ imm = #-0x70
 801ada6: 4603         	mov	r3, r0
; }
 801ada8: 4618         	mov	r0, r3
 801adaa: 3708         	adds	r7, #0x8
 801adac: 46bd         	mov	sp, r7
 801adae: bd80         	pop	{r7, pc}

0801adb0 <LL_SPI_Enable>:
; {
 801adb0: b480         	push	{r7}
 801adb2: b083         	sub	sp, #0xc
 801adb4: af00         	add	r7, sp, #0x0
 801adb6: 6078         	str	r0, [r7, #0x4]
;   SET_BIT(SPIx->CR1, SPI_CR1_SPE);
 801adb8: 687b         	ldr	r3, [r7, #0x4]
 801adba: 681b         	ldr	r3, [r3]
 801adbc: f043 0240    	orr	r2, r3, #0x40
 801adc0: 687b         	ldr	r3, [r7, #0x4]
 801adc2: 601a         	str	r2, [r3]
; }
 801adc4: bf00         	nop
 801adc6: 370c         	adds	r7, #0xc
 801adc8: 46bd         	mov	sp, r7
 801adca: bc80         	pop	{r7}
 801adcc: 4770         	bx	lr

0801adce <LL_SPI_Disable>:
; {
 801adce: b480         	push	{r7}
 801add0: b083         	sub	sp, #0xc
 801add2: af00         	add	r7, sp, #0x0
 801add4: 6078         	str	r0, [r7, #0x4]
;   CLEAR_BIT(SPIx->CR1, SPI_CR1_SPE);
 801add6: 687b         	ldr	r3, [r7, #0x4]
 801add8: 681b         	ldr	r3, [r3]
 801adda: f023 0240    	bic	r2, r3, #0x40
 801adde: 687b         	ldr	r3, [r7, #0x4]
 801ade0: 601a         	str	r2, [r3]
; }
 801ade2: bf00         	nop
 801ade4: 370c         	adds	r7, #0xc
 801ade6: 46bd         	mov	sp, r7
 801ade8: bc80         	pop	{r7}
 801adea: 4770         	bx	lr

0801adec <LL_SPI_IsEnabled>:
; {
 801adec: b480         	push	{r7}
 801adee: b083         	sub	sp, #0xc
 801adf0: af00         	add	r7, sp, #0x0
 801adf2: 6078         	str	r0, [r7, #0x4]
;   return ((READ_BIT(SPIx->CR1, SPI_CR1_SPE) == (SPI_CR1_SPE)) ? 1UL : 0UL);
 801adf4: 687b         	ldr	r3, [r7, #0x4]
 801adf6: 681b         	ldr	r3, [r3]
 801adf8: f003 0340    	and	r3, r3, #0x40
 801adfc: 2b40         	cmp	r3, #0x40
 801adfe: d101         	bne	0x801ae04 <LL_SPI_IsEnabled+0x18> @ imm = #0x2
 801ae00: 2301         	movs	r3, #0x1
 801ae02: e000         	b	0x801ae06 <LL_SPI_IsEnabled+0x1a> @ imm = #0x0
 801ae04: 2300         	movs	r3, #0x0
; }
 801ae06: 4618         	mov	r0, r3
 801ae08: 370c         	adds	r7, #0xc
 801ae0a: 46bd         	mov	sp, r7
 801ae0c: bc80         	pop	{r7}
 801ae0e: 4770         	bx	lr

0801ae10 <LL_SPI_SetMode>:
; {
 801ae10: b480         	push	{r7}
 801ae12: b083         	sub	sp, #0xc
 801ae14: af00         	add	r7, sp, #0x0
 801ae16: 6078         	str	r0, [r7, #0x4]
 801ae18: 6039         	str	r1, [r7]
;   MODIFY_REG(SPIx->CR1, SPI_CR1_MSTR | SPI_CR1_SSI, Mode);
 801ae1a: 687b         	ldr	r3, [r7, #0x4]
 801ae1c: 681b         	ldr	r3, [r3]
 801ae1e: f423 7282    	bic	r2, r3, #0x104
 801ae22: 683b         	ldr	r3, [r7]
 801ae24: 431a         	orrs	r2, r3
 801ae26: 687b         	ldr	r3, [r7, #0x4]
 801ae28: 601a         	str	r2, [r3]
; }
 801ae2a: bf00         	nop
 801ae2c: 370c         	adds	r7, #0xc
 801ae2e: 46bd         	mov	sp, r7
 801ae30: bc80         	pop	{r7}
 801ae32: 4770         	bx	lr

0801ae34 <LL_SPI_GetMode>:
; {
 801ae34: b480         	push	{r7}
 801ae36: b083         	sub	sp, #0xc
 801ae38: af00         	add	r7, sp, #0x0
 801ae3a: 6078         	str	r0, [r7, #0x4]
;   return (uint32_t)(READ_BIT(SPIx->CR1, SPI_CR1_MSTR | SPI_CR1_SSI));
 801ae3c: 687b         	ldr	r3, [r7, #0x4]
 801ae3e: 681b         	ldr	r3, [r3]
 801ae40: f403 7382    	and	r3, r3, #0x104
; }
 801ae44: 4618         	mov	r0, r3
 801ae46: 370c         	adds	r7, #0xc
 801ae48: 46bd         	mov	sp, r7
 801ae4a: bc80         	pop	{r7}
 801ae4c: 4770         	bx	lr

0801ae4e <LL_SPI_SetStandard>:
; {
 801ae4e: b480         	push	{r7}
 801ae50: b083         	sub	sp, #0xc
 801ae52: af00         	add	r7, sp, #0x0
 801ae54: 6078         	str	r0, [r7, #0x4]
 801ae56: 6039         	str	r1, [r7]
;   MODIFY_REG(SPIx->CR2, SPI_CR2_FRF, Standard);
 801ae58: 687b         	ldr	r3, [r7, #0x4]
 801ae5a: 685b         	ldr	r3, [r3, #0x4]
 801ae5c: f023 0210    	bic	r2, r3, #0x10
 801ae60: 683b         	ldr	r3, [r7]
 801ae62: 431a         	orrs	r2, r3
 801ae64: 687b         	ldr	r3, [r7, #0x4]
 801ae66: 605a         	str	r2, [r3, #0x4]
; }
 801ae68: bf00         	nop
 801ae6a: 370c         	adds	r7, #0xc
 801ae6c: 46bd         	mov	sp, r7
 801ae6e: bc80         	pop	{r7}
 801ae70: 4770         	bx	lr

0801ae72 <LL_SPI_SetClockPhase>:
; {
 801ae72: b480         	push	{r7}
 801ae74: b083         	sub	sp, #0xc
 801ae76: af00         	add	r7, sp, #0x0
 801ae78: 6078         	str	r0, [r7, #0x4]
 801ae7a: 6039         	str	r1, [r7]
;   MODIFY_REG(SPIx->CR1, SPI_CR1_CPHA, ClockPhase);
 801ae7c: 687b         	ldr	r3, [r7, #0x4]
 801ae7e: 681b         	ldr	r3, [r3]
 801ae80: f023 0201    	bic	r2, r3, #0x1
 801ae84: 683b         	ldr	r3, [r7]
 801ae86: 431a         	orrs	r2, r3
 801ae88: 687b         	ldr	r3, [r7, #0x4]
 801ae8a: 601a         	str	r2, [r3]
; }
 801ae8c: bf00         	nop
 801ae8e: 370c         	adds	r7, #0xc
 801ae90: 46bd         	mov	sp, r7
 801ae92: bc80         	pop	{r7}
 801ae94: 4770         	bx	lr

0801ae96 <LL_SPI_SetClockPolarity>:
; {
 801ae96: b480         	push	{r7}
 801ae98: b083         	sub	sp, #0xc
 801ae9a: af00         	add	r7, sp, #0x0
 801ae9c: 6078         	str	r0, [r7, #0x4]
 801ae9e: 6039         	str	r1, [r7]
;   MODIFY_REG(SPIx->CR1, SPI_CR1_CPOL, ClockPolarity);
 801aea0: 687b         	ldr	r3, [r7, #0x4]
 801aea2: 681b         	ldr	r3, [r3]
 801aea4: f023 0202    	bic	r2, r3, #0x2
 801aea8: 683b         	ldr	r3, [r7]
 801aeaa: 431a         	orrs	r2, r3
 801aeac: 687b         	ldr	r3, [r7, #0x4]
 801aeae: 601a         	str	r2, [r3]
; }
 801aeb0: bf00         	nop
 801aeb2: 370c         	adds	r7, #0xc
 801aeb4: 46bd         	mov	sp, r7
 801aeb6: bc80         	pop	{r7}
 801aeb8: 4770         	bx	lr

0801aeba <LL_SPI_SetBaudRatePrescaler>:
; {
 801aeba: b480         	push	{r7}
 801aebc: b083         	sub	sp, #0xc
 801aebe: af00         	add	r7, sp, #0x0
 801aec0: 6078         	str	r0, [r7, #0x4]
 801aec2: 6039         	str	r1, [r7]
;   MODIFY_REG(SPIx->CR1, SPI_CR1_BR, BaudRate);
 801aec4: 687b         	ldr	r3, [r7, #0x4]
 801aec6: 681b         	ldr	r3, [r3]
 801aec8: f023 0238    	bic	r2, r3, #0x38
 801aecc: 683b         	ldr	r3, [r7]
 801aece: 431a         	orrs	r2, r3
 801aed0: 687b         	ldr	r3, [r7, #0x4]
 801aed2: 601a         	str	r2, [r3]
; }
 801aed4: bf00         	nop
 801aed6: 370c         	adds	r7, #0xc
 801aed8: 46bd         	mov	sp, r7
 801aeda: bc80         	pop	{r7}
 801aedc: 4770         	bx	lr

0801aede <LL_SPI_SetTransferBitOrder>:
; {
 801aede: b480         	push	{r7}
 801aee0: b083         	sub	sp, #0xc
 801aee2: af00         	add	r7, sp, #0x0
 801aee4: 6078         	str	r0, [r7, #0x4]
 801aee6: 6039         	str	r1, [r7]
;   MODIFY_REG(SPIx->CR1, SPI_CR1_LSBFIRST, BitOrder);
 801aee8: 687b         	ldr	r3, [r7, #0x4]
 801aeea: 681b         	ldr	r3, [r3]
 801aeec: f023 0280    	bic	r2, r3, #0x80
 801aef0: 683b         	ldr	r3, [r7]
 801aef2: 431a         	orrs	r2, r3
 801aef4: 687b         	ldr	r3, [r7, #0x4]
 801aef6: 601a         	str	r2, [r3]
; }
 801aef8: bf00         	nop
 801aefa: 370c         	adds	r7, #0xc
 801aefc: 46bd         	mov	sp, r7
 801aefe: bc80         	pop	{r7}
 801af00: 4770         	bx	lr

0801af02 <LL_SPI_SetTransferDirection>:
; {
 801af02: b480         	push	{r7}
 801af04: b083         	sub	sp, #0xc
 801af06: af00         	add	r7, sp, #0x0
 801af08: 6078         	str	r0, [r7, #0x4]
 801af0a: 6039         	str	r1, [r7]
;   MODIFY_REG(SPIx->CR1, SPI_CR1_RXONLY | SPI_CR1_BIDIMODE | SPI_CR1_BIDIOE, TransferDirection);
 801af0c: 687b         	ldr	r3, [r7, #0x4]
 801af0e: 681b         	ldr	r3, [r3]
 801af10: f423 4244    	bic	r2, r3, #0xc400
 801af14: 683b         	ldr	r3, [r7]
 801af16: 431a         	orrs	r2, r3
 801af18: 687b         	ldr	r3, [r7, #0x4]
 801af1a: 601a         	str	r2, [r3]
; }
 801af1c: bf00         	nop
 801af1e: 370c         	adds	r7, #0xc
 801af20: 46bd         	mov	sp, r7
 801af22: bc80         	pop	{r7}
 801af24: 4770         	bx	lr

0801af26 <LL_SPI_SetDataWidth>:
; {
 801af26: b480         	push	{r7}
 801af28: b083         	sub	sp, #0xc
 801af2a: af00         	add	r7, sp, #0x0
 801af2c: 6078         	str	r0, [r7, #0x4]
 801af2e: 6039         	str	r1, [r7]
;   MODIFY_REG(SPIx->CR1, SPI_CR1_DFF, DataWidth);
 801af30: 687b         	ldr	r3, [r7, #0x4]
 801af32: 681b         	ldr	r3, [r3]
 801af34: f423 6200    	bic	r2, r3, #0x800
 801af38: 683b         	ldr	r3, [r7]
 801af3a: 431a         	orrs	r2, r3
 801af3c: 687b         	ldr	r3, [r7, #0x4]
 801af3e: 601a         	str	r2, [r3]
; }
 801af40: bf00         	nop
 801af42: 370c         	adds	r7, #0xc
 801af44: 46bd         	mov	sp, r7
 801af46: bc80         	pop	{r7}
 801af48: 4770         	bx	lr

0801af4a <LL_SPI_DisableCRC>:
; {
 801af4a: b480         	push	{r7}
 801af4c: b083         	sub	sp, #0xc
 801af4e: af00         	add	r7, sp, #0x0
 801af50: 6078         	str	r0, [r7, #0x4]
;   CLEAR_BIT(SPIx->CR1, SPI_CR1_CRCEN);
 801af52: 687b         	ldr	r3, [r7, #0x4]
 801af54: 681b         	ldr	r3, [r3]
 801af56: f423 5200    	bic	r2, r3, #0x2000
 801af5a: 687b         	ldr	r3, [r7, #0x4]
 801af5c: 601a         	str	r2, [r3]
; }
 801af5e: bf00         	nop
 801af60: 370c         	adds	r7, #0xc
 801af62: 46bd         	mov	sp, r7
 801af64: bc80         	pop	{r7}
 801af66: 4770         	bx	lr

0801af68 <LL_SPI_SetNSSMode>:
; {
 801af68: b480         	push	{r7}
 801af6a: b083         	sub	sp, #0xc
 801af6c: af00         	add	r7, sp, #0x0
 801af6e: 6078         	str	r0, [r7, #0x4]
 801af70: 6039         	str	r1, [r7]
;   MODIFY_REG(SPIx->CR1, SPI_CR1_SSM,  NSS);
 801af72: 687b         	ldr	r3, [r7, #0x4]
 801af74: 681b         	ldr	r3, [r3]
 801af76: f423 7200    	bic	r2, r3, #0x200
 801af7a: 683b         	ldr	r3, [r7]
 801af7c: 431a         	orrs	r2, r3
 801af7e: 687b         	ldr	r3, [r7, #0x4]
 801af80: 601a         	str	r2, [r3]
;   MODIFY_REG(SPIx->CR2, SPI_CR2_SSOE, ((uint32_t)(NSS >> 16U)));
 801af82: 687b         	ldr	r3, [r7, #0x4]
 801af84: 685b         	ldr	r3, [r3, #0x4]
 801af86: f023 0204    	bic	r2, r3, #0x4
 801af8a: 683b         	ldr	r3, [r7]
 801af8c: 0c1b         	lsrs	r3, r3, #0x10
 801af8e: 431a         	orrs	r2, r3
 801af90: 687b         	ldr	r3, [r7, #0x4]
 801af92: 605a         	str	r2, [r3, #0x4]
; }
 801af94: bf00         	nop
 801af96: 370c         	adds	r7, #0xc
 801af98: 46bd         	mov	sp, r7
 801af9a: bc80         	pop	{r7}
 801af9c: 4770         	bx	lr

0801af9e <LL_SPI_IsActiveFlag_RXNE>:
; {
 801af9e: b480         	push	{r7}
 801afa0: b083         	sub	sp, #0xc
 801afa2: af00         	add	r7, sp, #0x0
 801afa4: 6078         	str	r0, [r7, #0x4]
;   return ((READ_BIT(SPIx->SR, SPI_SR_RXNE) == (SPI_SR_RXNE)) ? 1UL : 0UL);
 801afa6: 687b         	ldr	r3, [r7, #0x4]
 801afa8: 689b         	ldr	r3, [r3, #0x8]
 801afaa: f003 0301    	and	r3, r3, #0x1
 801afae: 2b01         	cmp	r3, #0x1
 801afb0: d101         	bne	0x801afb6 <LL_SPI_IsActiveFlag_RXNE+0x18> @ imm = #0x2
 801afb2: 2301         	movs	r3, #0x1
 801afb4: e000         	b	0x801afb8 <LL_SPI_IsActiveFlag_RXNE+0x1a> @ imm = #0x0
 801afb6: 2300         	movs	r3, #0x0
; }
 801afb8: 4618         	mov	r0, r3
 801afba: 370c         	adds	r7, #0xc
 801afbc: 46bd         	mov	sp, r7
 801afbe: bc80         	pop	{r7}
 801afc0: 4770         	bx	lr

0801afc2 <LL_SPI_IsActiveFlag_TXE>:
; {
 801afc2: b480         	push	{r7}
 801afc4: b083         	sub	sp, #0xc
 801afc6: af00         	add	r7, sp, #0x0
 801afc8: 6078         	str	r0, [r7, #0x4]
;   return ((READ_BIT(SPIx->SR, SPI_SR_TXE) == (SPI_SR_TXE)) ? 1UL : 0UL);
 801afca: 687b         	ldr	r3, [r7, #0x4]
 801afcc: 689b         	ldr	r3, [r3, #0x8]
 801afce: f003 0302    	and	r3, r3, #0x2
 801afd2: 2b02         	cmp	r3, #0x2
 801afd4: d101         	bne	0x801afda <LL_SPI_IsActiveFlag_TXE+0x18> @ imm = #0x2
 801afd6: 2301         	movs	r3, #0x1
 801afd8: e000         	b	0x801afdc <LL_SPI_IsActiveFlag_TXE+0x1a> @ imm = #0x0
 801afda: 2300         	movs	r3, #0x0
; }
 801afdc: 4618         	mov	r0, r3
 801afde: 370c         	adds	r7, #0xc
 801afe0: 46bd         	mov	sp, r7
 801afe2: bc80         	pop	{r7}
 801afe4: 4770         	bx	lr

0801afe6 <LL_SPI_IsActiveFlag_MODF>:
; {
 801afe6: b480         	push	{r7}
 801afe8: b083         	sub	sp, #0xc
 801afea: af00         	add	r7, sp, #0x0
 801afec: 6078         	str	r0, [r7, #0x4]
;   return ((READ_BIT(SPIx->SR, SPI_SR_MODF) == (SPI_SR_MODF)) ? 1UL : 0UL);
 801afee: 687b         	ldr	r3, [r7, #0x4]
 801aff0: 689b         	ldr	r3, [r3, #0x8]
 801aff2: f003 0320    	and	r3, r3, #0x20
 801aff6: 2b20         	cmp	r3, #0x20
 801aff8: d101         	bne	0x801affe <LL_SPI_IsActiveFlag_MODF+0x18> @ imm = #0x2
 801affa: 2301         	movs	r3, #0x1
 801affc: e000         	b	0x801b000 <LL_SPI_IsActiveFlag_MODF+0x1a> @ imm = #0x0
 801affe: 2300         	movs	r3, #0x0
; }
 801b000: 4618         	mov	r0, r3
 801b002: 370c         	adds	r7, #0xc
 801b004: 46bd         	mov	sp, r7
 801b006: bc80         	pop	{r7}
 801b008: 4770         	bx	lr

0801b00a <LL_SPI_IsActiveFlag_OVR>:
; {
 801b00a: b480         	push	{r7}
 801b00c: b083         	sub	sp, #0xc
 801b00e: af00         	add	r7, sp, #0x0
 801b010: 6078         	str	r0, [r7, #0x4]
;   return ((READ_BIT(SPIx->SR, SPI_SR_OVR) == (SPI_SR_OVR)) ? 1UL : 0UL);
 801b012: 687b         	ldr	r3, [r7, #0x4]
 801b014: 689b         	ldr	r3, [r3, #0x8]
 801b016: f003 0340    	and	r3, r3, #0x40
 801b01a: 2b40         	cmp	r3, #0x40
 801b01c: d101         	bne	0x801b022 <LL_SPI_IsActiveFlag_OVR+0x18> @ imm = #0x2
 801b01e: 2301         	movs	r3, #0x1
 801b020: e000         	b	0x801b024 <LL_SPI_IsActiveFlag_OVR+0x1a> @ imm = #0x0
 801b022: 2300         	movs	r3, #0x0
; }
 801b024: 4618         	mov	r0, r3
 801b026: 370c         	adds	r7, #0xc
 801b028: 46bd         	mov	sp, r7
 801b02a: bc80         	pop	{r7}
 801b02c: 4770         	bx	lr

0801b02e <LL_SPI_IsActiveFlag_BSY>:
; {
 801b02e: b480         	push	{r7}
 801b030: b083         	sub	sp, #0xc
 801b032: af00         	add	r7, sp, #0x0
 801b034: 6078         	str	r0, [r7, #0x4]
;   return ((READ_BIT(SPIx->SR, SPI_SR_BSY) == (SPI_SR_BSY)) ? 1UL : 0UL);
 801b036: 687b         	ldr	r3, [r7, #0x4]
 801b038: 689b         	ldr	r3, [r3, #0x8]
 801b03a: f003 0380    	and	r3, r3, #0x80
 801b03e: 2b80         	cmp	r3, #0x80
 801b040: d101         	bne	0x801b046 <LL_SPI_IsActiveFlag_BSY+0x18> @ imm = #0x2
 801b042: 2301         	movs	r3, #0x1
 801b044: e000         	b	0x801b048 <LL_SPI_IsActiveFlag_BSY+0x1a> @ imm = #0x0
 801b046: 2300         	movs	r3, #0x0
; }
 801b048: 4618         	mov	r0, r3
 801b04a: 370c         	adds	r7, #0xc
 801b04c: 46bd         	mov	sp, r7
 801b04e: bc80         	pop	{r7}
 801b050: 4770         	bx	lr

0801b052 <LL_SPI_ClearFlag_MODF>:
; {
 801b052: b480         	push	{r7}
 801b054: b085         	sub	sp, #0x14
 801b056: af00         	add	r7, sp, #0x0
 801b058: 6078         	str	r0, [r7, #0x4]
;   tmpreg_sr = SPIx->SR;
 801b05a: 687b         	ldr	r3, [r7, #0x4]
 801b05c: 689b         	ldr	r3, [r3, #0x8]
 801b05e: 60fb         	str	r3, [r7, #0xc]
;   (void) tmpreg_sr;
 801b060: 68fb         	ldr	r3, [r7, #0xc]
;   CLEAR_BIT(SPIx->CR1, SPI_CR1_SPE);
 801b062: 687b         	ldr	r3, [r7, #0x4]
 801b064: 681b         	ldr	r3, [r3]
 801b066: f023 0240    	bic	r2, r3, #0x40
 801b06a: 687b         	ldr	r3, [r7, #0x4]
 801b06c: 601a         	str	r2, [r3]
; }
 801b06e: bf00         	nop
 801b070: 3714         	adds	r7, #0x14
 801b072: 46bd         	mov	sp, r7
 801b074: bc80         	pop	{r7}
 801b076: 4770         	bx	lr

0801b078 <LL_SPI_ClearFlag_OVR>:
; {
 801b078: b480         	push	{r7}
 801b07a: b085         	sub	sp, #0x14
 801b07c: af00         	add	r7, sp, #0x0
 801b07e: 6078         	str	r0, [r7, #0x4]
;   tmpreg = SPIx->DR;
 801b080: 687b         	ldr	r3, [r7, #0x4]
 801b082: 68db         	ldr	r3, [r3, #0xc]
 801b084: 60fb         	str	r3, [r7, #0xc]
;   (void) tmpreg;
 801b086: 68fb         	ldr	r3, [r7, #0xc]
;   tmpreg = SPIx->SR;
 801b088: 687b         	ldr	r3, [r7, #0x4]
 801b08a: 689b         	ldr	r3, [r3, #0x8]
 801b08c: 60fb         	str	r3, [r7, #0xc]
;   (void) tmpreg;
 801b08e: 68fb         	ldr	r3, [r7, #0xc]
; }
 801b090: bf00         	nop
 801b092: 3714         	adds	r7, #0x14
 801b094: 46bd         	mov	sp, r7
 801b096: bc80         	pop	{r7}
 801b098: 4770         	bx	lr

0801b09a <LL_SPI_DisableIT_TXE>:
; {
 801b09a: b480         	push	{r7}
 801b09c: b083         	sub	sp, #0xc
 801b09e: af00         	add	r7, sp, #0x0
 801b0a0: 6078         	str	r0, [r7, #0x4]
;   CLEAR_BIT(SPIx->CR2, SPI_CR2_TXEIE);
 801b0a2: 687b         	ldr	r3, [r7, #0x4]
 801b0a4: 685b         	ldr	r3, [r3, #0x4]
 801b0a6: f023 0280    	bic	r2, r3, #0x80
 801b0aa: 687b         	ldr	r3, [r7, #0x4]
 801b0ac: 605a         	str	r2, [r3, #0x4]
; }
 801b0ae: bf00         	nop
 801b0b0: 370c         	adds	r7, #0xc
 801b0b2: 46bd         	mov	sp, r7
 801b0b4: bc80         	pop	{r7}
 801b0b6: 4770         	bx	lr

0801b0b8 <LL_SPI_ReceiveData8>:
; {
 801b0b8: b480         	push	{r7}
 801b0ba: b083         	sub	sp, #0xc
 801b0bc: af00         	add	r7, sp, #0x0
 801b0be: 6078         	str	r0, [r7, #0x4]
;   return (*((__IO uint8_t *)&SPIx->DR));
 801b0c0: 687b         	ldr	r3, [r7, #0x4]
 801b0c2: 330c         	adds	r3, #0xc
 801b0c4: 781b         	ldrb	r3, [r3]
 801b0c6: b2db         	uxtb	r3, r3
; }
 801b0c8: 4618         	mov	r0, r3
 801b0ca: 370c         	adds	r7, #0xc
 801b0cc: 46bd         	mov	sp, r7
 801b0ce: bc80         	pop	{r7}
 801b0d0: 4770         	bx	lr

0801b0d2 <LL_SPI_ReceiveData16>:
; {
 801b0d2: b480         	push	{r7}
 801b0d4: b083         	sub	sp, #0xc
 801b0d6: af00         	add	r7, sp, #0x0
 801b0d8: 6078         	str	r0, [r7, #0x4]
;   return (uint16_t)(READ_REG(SPIx->DR));
 801b0da: 687b         	ldr	r3, [r7, #0x4]
 801b0dc: 68db         	ldr	r3, [r3, #0xc]
 801b0de: b29b         	uxth	r3, r3
; }
 801b0e0: 4618         	mov	r0, r3
 801b0e2: 370c         	adds	r7, #0xc
 801b0e4: 46bd         	mov	sp, r7
 801b0e6: bc80         	pop	{r7}
 801b0e8: 4770         	bx	lr

0801b0ea <LL_SPI_TransmitData8>:
; {
 801b0ea: b480         	push	{r7}
 801b0ec: b085         	sub	sp, #0x14
 801b0ee: af00         	add	r7, sp, #0x0
 801b0f0: 6078         	str	r0, [r7, #0x4]
 801b0f2: 460b         	mov	r3, r1
 801b0f4: 70fb         	strb	r3, [r7, #0x3]
;   __IO uint8_t *spidr = ((__IO uint8_t *)&SPIx->DR);
 801b0f6: 687b         	ldr	r3, [r7, #0x4]
 801b0f8: 330c         	adds	r3, #0xc
 801b0fa: 60fb         	str	r3, [r7, #0xc]
;   *spidr = TxData;
 801b0fc: 68fb         	ldr	r3, [r7, #0xc]
 801b0fe: 78fa         	ldrb	r2, [r7, #0x3]
 801b100: 701a         	strb	r2, [r3]
; }
 801b102: bf00         	nop
 801b104: 3714         	adds	r7, #0x14
 801b106: 46bd         	mov	sp, r7
 801b108: bc80         	pop	{r7}
 801b10a: 4770         	bx	lr

0801b10c <LL_SPI_TransmitData16>:
; {
 801b10c: b480         	push	{r7}
 801b10e: b085         	sub	sp, #0x14
 801b110: af00         	add	r7, sp, #0x0
 801b112: 6078         	str	r0, [r7, #0x4]
 801b114: 460b         	mov	r3, r1
 801b116: 807b         	strh	r3, [r7, #0x2]
;   __IO uint16_t *spidr = ((__IO uint16_t *)&SPIx->DR);
 801b118: 687b         	ldr	r3, [r7, #0x4]
 801b11a: 330c         	adds	r3, #0xc
 801b11c: 60fb         	str	r3, [r7, #0xc]
;   *spidr = TxData;
 801b11e: 68fb         	ldr	r3, [r7, #0xc]
 801b120: 887a         	ldrh	r2, [r7, #0x2]
 801b122: 801a         	strh	r2, [r3]
; }
 801b124: bf00         	nop
 801b126: 3714         	adds	r7, #0x14
 801b128: 46bd         	mov	sp, r7
 801b12a: bc80         	pop	{r7}
 801b12c: 4770         	bx	lr

0801b12e <z_impl_gpio_pin_configure>:
; {
 801b12e: b580         	push	{r7, lr}
 801b130: b088         	sub	sp, #0x20
 801b132: af00         	add	r7, sp, #0x0
 801b134: 60f8         	str	r0, [r7, #0xc]
 801b136: 460b         	mov	r3, r1
 801b138: 607a         	str	r2, [r7, #0x4]
 801b13a: 72fb         	strb	r3, [r7, #0xb]
; 	const struct gpio_driver_api *api =
 801b13c: 68fb         	ldr	r3, [r7, #0xc]
 801b13e: 689b         	ldr	r3, [r3, #0x8]
 801b140: 61fb         	str	r3, [r7, #0x1c]
; 	__unused const struct gpio_driver_config *const cfg =
 801b142: 68fb         	ldr	r3, [r7, #0xc]
 801b144: 685b         	ldr	r3, [r3, #0x4]
 801b146: 61bb         	str	r3, [r7, #0x18]
; 	struct gpio_driver_data *data =
 801b148: 68fb         	ldr	r3, [r7, #0xc]
 801b14a: 691b         	ldr	r3, [r3, #0x10]
 801b14c: 617b         	str	r3, [r7, #0x14]
; 	if (((flags & GPIO_OUTPUT_INIT_LOGICAL) != 0)
 801b14e: 687b         	ldr	r3, [r7, #0x4]
 801b150: f403 1380    	and	r3, r3, #0x100000
 801b154: 2b00         	cmp	r3, #0x0
 801b156: d00d         	beq	0x801b174 <z_impl_gpio_pin_configure+0x46> @ imm = #0x1a
; 	    && ((flags & (GPIO_OUTPUT_INIT_LOW | GPIO_OUTPUT_INIT_HIGH)) != 0)
 801b158: 687b         	ldr	r3, [r7, #0x4]
 801b15a: f403 2340    	and	r3, r3, #0xc0000
 801b15e: 2b00         	cmp	r3, #0x0
 801b160: d008         	beq	0x801b174 <z_impl_gpio_pin_configure+0x46> @ imm = #0x10
; 	    && ((flags & GPIO_ACTIVE_LOW) != 0)) {
 801b162: 687b         	ldr	r3, [r7, #0x4]
 801b164: f003 0301    	and	r3, r3, #0x1
 801b168: 2b00         	cmp	r3, #0x0
 801b16a: d003         	beq	0x801b174 <z_impl_gpio_pin_configure+0x46> @ imm = #0x6
; 		flags ^= GPIO_OUTPUT_INIT_LOW | GPIO_OUTPUT_INIT_HIGH;
 801b16c: 687b         	ldr	r3, [r7, #0x4]
 801b16e: f483 2340    	eor	r3, r3, #0xc0000
 801b172: 607b         	str	r3, [r7, #0x4]
; 	flags &= ~GPIO_OUTPUT_INIT_LOGICAL;
 801b174: 687b         	ldr	r3, [r7, #0x4]
 801b176: f423 1380    	bic	r3, r3, #0x100000
 801b17a: 607b         	str	r3, [r7, #0x4]
; 	if ((flags & GPIO_ACTIVE_LOW) != 0) {
 801b17c: 687b         	ldr	r3, [r7, #0x4]
 801b17e: f003 0301    	and	r3, r3, #0x1
 801b182: 2b00         	cmp	r3, #0x0
 801b184: d009         	beq	0x801b19a <z_impl_gpio_pin_configure+0x6c> @ imm = #0x12
; 		data->invert |= (gpio_port_pins_t)BIT(pin);
 801b186: 697b         	ldr	r3, [r7, #0x14]
 801b188: 681a         	ldr	r2, [r3]
 801b18a: 7afb         	ldrb	r3, [r7, #0xb]
 801b18c: 2101         	movs	r1, #0x1
 801b18e: fa01 f303    	lsl.w	r3, r1, r3
 801b192: 431a         	orrs	r2, r3
 801b194: 697b         	ldr	r3, [r7, #0x14]
 801b196: 601a         	str	r2, [r3]
 801b198: e009         	b	0x801b1ae <z_impl_gpio_pin_configure+0x80> @ imm = #0x12
; 		data->invert &= ~(gpio_port_pins_t)BIT(pin);
 801b19a: 697b         	ldr	r3, [r7, #0x14]
 801b19c: 681a         	ldr	r2, [r3]
 801b19e: 7afb         	ldrb	r3, [r7, #0xb]
 801b1a0: 2101         	movs	r1, #0x1
 801b1a2: fa01 f303    	lsl.w	r3, r1, r3
 801b1a6: 43db         	mvns	r3, r3
 801b1a8: 401a         	ands	r2, r3
 801b1aa: 697b         	ldr	r3, [r7, #0x14]
 801b1ac: 601a         	str	r2, [r3]
; 	return api->pin_configure(port, pin, flags);
 801b1ae: 69fb         	ldr	r3, [r7, #0x1c]
 801b1b0: 681b         	ldr	r3, [r3]
 801b1b2: 7af9         	ldrb	r1, [r7, #0xb]
 801b1b4: 687a         	ldr	r2, [r7, #0x4]
 801b1b6: 68f8         	ldr	r0, [r7, #0xc]
 801b1b8: 4798         	blx	r3
 801b1ba: 4603         	mov	r3, r0
; }
 801b1bc: 4618         	mov	r0, r3
 801b1be: 3720         	adds	r7, #0x20
 801b1c0: 46bd         	mov	sp, r7
 801b1c2: bd80         	pop	{r7, pc}

0801b1c4 <gpio_pin_configure_dt>:
; {
 801b1c4: b580         	push	{r7, lr}
 801b1c6: b082         	sub	sp, #0x8
 801b1c8: af00         	add	r7, sp, #0x0
 801b1ca: 6078         	str	r0, [r7, #0x4]
 801b1cc: 6039         	str	r1, [r7]
; 	return gpio_pin_configure(spec->port,
 801b1ce: 687b         	ldr	r3, [r7, #0x4]
 801b1d0: 6818         	ldr	r0, [r3]
; 				  spec->pin,
 801b1d2: 687b         	ldr	r3, [r7, #0x4]
 801b1d4: 7919         	ldrb	r1, [r3, #0x4]
; 				  spec->dt_flags | extra_flags);
 801b1d6: 687b         	ldr	r3, [r7, #0x4]
 801b1d8: 88db         	ldrh	r3, [r3, #0x6]
 801b1da: 461a         	mov	r2, r3
; 	return gpio_pin_configure(spec->port,
 801b1dc: 683b         	ldr	r3, [r7]
 801b1de: 4313         	orrs	r3, r2
 801b1e0: 461a         	mov	r2, r3
 801b1e2: f000 f888    	bl	0x801b2f6 <gpio_pin_configure> @ imm = #0x110
 801b1e6: 4603         	mov	r3, r0
; }
 801b1e8: 4618         	mov	r0, r3
 801b1ea: 3708         	adds	r7, #0x8
 801b1ec: 46bd         	mov	sp, r7
 801b1ee: bd80         	pop	{r7, pc}

0801b1f0 <z_impl_gpio_port_set_bits_raw>:
; {
 801b1f0: b580         	push	{r7, lr}
 801b1f2: b084         	sub	sp, #0x10
 801b1f4: af00         	add	r7, sp, #0x0
 801b1f6: 6078         	str	r0, [r7, #0x4]
 801b1f8: 6039         	str	r1, [r7]
; 	const struct gpio_driver_api *api =
 801b1fa: 687b         	ldr	r3, [r7, #0x4]
 801b1fc: 689b         	ldr	r3, [r3, #0x8]
 801b1fe: 60fb         	str	r3, [r7, #0xc]
; 	return api->port_set_bits_raw(port, pins);
 801b200: 68fb         	ldr	r3, [r7, #0xc]
 801b202: 68db         	ldr	r3, [r3, #0xc]
 801b204: 6839         	ldr	r1, [r7]
 801b206: 6878         	ldr	r0, [r7, #0x4]
 801b208: 4798         	blx	r3
 801b20a: 4603         	mov	r3, r0
; }
 801b20c: 4618         	mov	r0, r3
 801b20e: 3710         	adds	r7, #0x10
 801b210: 46bd         	mov	sp, r7
 801b212: bd80         	pop	{r7, pc}

0801b214 <z_impl_gpio_port_clear_bits_raw>:
; {
 801b214: b580         	push	{r7, lr}
 801b216: b084         	sub	sp, #0x10
 801b218: af00         	add	r7, sp, #0x0
 801b21a: 6078         	str	r0, [r7, #0x4]
 801b21c: 6039         	str	r1, [r7]
; 	const struct gpio_driver_api *api =
 801b21e: 687b         	ldr	r3, [r7, #0x4]
 801b220: 689b         	ldr	r3, [r3, #0x8]
 801b222: 60fb         	str	r3, [r7, #0xc]
; 	return api->port_clear_bits_raw(port, pins);
 801b224: 68fb         	ldr	r3, [r7, #0xc]
 801b226: 691b         	ldr	r3, [r3, #0x10]
 801b228: 6839         	ldr	r1, [r7]
 801b22a: 6878         	ldr	r0, [r7, #0x4]
 801b22c: 4798         	blx	r3
 801b22e: 4603         	mov	r3, r0
; }
 801b230: 4618         	mov	r0, r3
 801b232: 3710         	adds	r7, #0x10
 801b234: 46bd         	mov	sp, r7
 801b236: bd80         	pop	{r7, pc}

0801b238 <gpio_pin_set_raw>:
; {
 801b238: b580         	push	{r7, lr}
 801b23a: b086         	sub	sp, #0x18
 801b23c: af00         	add	r7, sp, #0x0
 801b23e: 60f8         	str	r0, [r7, #0xc]
 801b240: 460b         	mov	r3, r1
 801b242: 607a         	str	r2, [r7, #0x4]
 801b244: 72fb         	strb	r3, [r7, #0xb]
; 	__unused const struct gpio_driver_config *const cfg =
 801b246: 68fb         	ldr	r3, [r7, #0xc]
 801b248: 685b         	ldr	r3, [r3, #0x4]
 801b24a: 613b         	str	r3, [r7, #0x10]
; 	if (value != 0)	{
 801b24c: 687b         	ldr	r3, [r7, #0x4]
 801b24e: 2b00         	cmp	r3, #0x0
 801b250: d009         	beq	0x801b266 <gpio_pin_set_raw+0x2e> @ imm = #0x12
; 		ret = gpio_port_set_bits_raw(port, (gpio_port_pins_t)BIT(pin));
 801b252: 7afb         	ldrb	r3, [r7, #0xb]
 801b254: 2201         	movs	r2, #0x1
 801b256: fa02 f303    	lsl.w	r3, r2, r3
 801b25a: 4619         	mov	r1, r3
 801b25c: 68f8         	ldr	r0, [r7, #0xc]
 801b25e: f000 f85c    	bl	0x801b31a <gpio_port_set_bits_raw> @ imm = #0xb8
 801b262: 6178         	str	r0, [r7, #0x14]
 801b264: e008         	b	0x801b278 <gpio_pin_set_raw+0x40> @ imm = #0x10
; 		ret = gpio_port_clear_bits_raw(port, (gpio_port_pins_t)BIT(pin));
 801b266: 7afb         	ldrb	r3, [r7, #0xb]
 801b268: 2201         	movs	r2, #0x1
 801b26a: fa02 f303    	lsl.w	r3, r2, r3
 801b26e: 4619         	mov	r1, r3
 801b270: 68f8         	ldr	r0, [r7, #0xc]
 801b272: f000 f860    	bl	0x801b336 <gpio_port_clear_bits_raw> @ imm = #0xc0
 801b276: 6178         	str	r0, [r7, #0x14]
; 	return ret;
 801b278: 697b         	ldr	r3, [r7, #0x14]
; }
 801b27a: 4618         	mov	r0, r3
 801b27c: 3718         	adds	r7, #0x18
 801b27e: 46bd         	mov	sp, r7
 801b280: bd80         	pop	{r7, pc}

0801b282 <gpio_pin_set>:
; {
 801b282: b580         	push	{r7, lr}
 801b284: b086         	sub	sp, #0x18
 801b286: af00         	add	r7, sp, #0x0
 801b288: 60f8         	str	r0, [r7, #0xc]
 801b28a: 460b         	mov	r3, r1
 801b28c: 607a         	str	r2, [r7, #0x4]
 801b28e: 72fb         	strb	r3, [r7, #0xb]
; 	__unused const struct gpio_driver_config *const cfg =
 801b290: 68fb         	ldr	r3, [r7, #0xc]
 801b292: 685b         	ldr	r3, [r3, #0x4]
 801b294: 617b         	str	r3, [r7, #0x14]
; 	const struct gpio_driver_data *const data =
 801b296: 68fb         	ldr	r3, [r7, #0xc]
 801b298: 691b         	ldr	r3, [r3, #0x10]
 801b29a: 613b         	str	r3, [r7, #0x10]
; 	if (data->invert & (gpio_port_pins_t)BIT(pin)) {
 801b29c: 693b         	ldr	r3, [r7, #0x10]
 801b29e: 681a         	ldr	r2, [r3]
 801b2a0: 7afb         	ldrb	r3, [r7, #0xb]
 801b2a2: 2101         	movs	r1, #0x1
 801b2a4: fa01 f303    	lsl.w	r3, r1, r3
 801b2a8: 4013         	ands	r3, r2
 801b2aa: 2b00         	cmp	r3, #0x0
 801b2ac: d006         	beq	0x801b2bc <gpio_pin_set+0x3a> @ imm = #0xc
; 		value = (value != 0) ? 0 : 1;
 801b2ae: 687b         	ldr	r3, [r7, #0x4]
 801b2b0: 2b00         	cmp	r3, #0x0
 801b2b2: bf0c         	ite	eq
 801b2b4: 2301         	moveq	r3, #0x1
 801b2b6: 2300         	movne	r3, #0x0
 801b2b8: b2db         	uxtb	r3, r3
 801b2ba: 607b         	str	r3, [r7, #0x4]
; 	return gpio_pin_set_raw(port, pin, value);
 801b2bc: 7afb         	ldrb	r3, [r7, #0xb]
 801b2be: 687a         	ldr	r2, [r7, #0x4]
 801b2c0: 4619         	mov	r1, r3
 801b2c2: 68f8         	ldr	r0, [r7, #0xc]
 801b2c4: f7ff ffb8    	bl	0x801b238 <gpio_pin_set_raw> @ imm = #-0x90
 801b2c8: 4603         	mov	r3, r0
; }
 801b2ca: 4618         	mov	r0, r3
 801b2cc: 3718         	adds	r7, #0x18
 801b2ce: 46bd         	mov	sp, r7
 801b2d0: bd80         	pop	{r7, pc}

0801b2d2 <gpio_pin_set_dt>:
; {
 801b2d2: b580         	push	{r7, lr}
 801b2d4: b082         	sub	sp, #0x8
 801b2d6: af00         	add	r7, sp, #0x0
 801b2d8: 6078         	str	r0, [r7, #0x4]
 801b2da: 6039         	str	r1, [r7]
; 	return gpio_pin_set(spec->port, spec->pin, value);
 801b2dc: 687b         	ldr	r3, [r7, #0x4]
 801b2de: 6818         	ldr	r0, [r3]
 801b2e0: 687b         	ldr	r3, [r7, #0x4]
 801b2e2: 791b         	ldrb	r3, [r3, #0x4]
 801b2e4: 683a         	ldr	r2, [r7]
 801b2e6: 4619         	mov	r1, r3
 801b2e8: f7ff ffcb    	bl	0x801b282 <gpio_pin_set> @ imm = #-0x6a
 801b2ec: 4603         	mov	r3, r0
; }
 801b2ee: 4618         	mov	r0, r3
 801b2f0: 3708         	adds	r7, #0x8
 801b2f2: 46bd         	mov	sp, r7
 801b2f4: bd80         	pop	{r7, pc}

0801b2f6 <gpio_pin_configure>:
; {
 801b2f6: b580         	push	{r7, lr}
 801b2f8: b084         	sub	sp, #0x10
 801b2fa: af00         	add	r7, sp, #0x0
 801b2fc: 60f8         	str	r0, [r7, #0xc]
 801b2fe: 460b         	mov	r3, r1
 801b300: 607a         	str	r2, [r7, #0x4]
 801b302: 72fb         	strb	r3, [r7, #0xb]
; 	return z_impl_gpio_pin_configure(port, pin, flags);
 801b304: 7afb         	ldrb	r3, [r7, #0xb]
 801b306: 687a         	ldr	r2, [r7, #0x4]
 801b308: 4619         	mov	r1, r3
 801b30a: 68f8         	ldr	r0, [r7, #0xc]
 801b30c: f7ff ff0f    	bl	0x801b12e <z_impl_gpio_pin_configure> @ imm = #-0x1e2
 801b310: 4603         	mov	r3, r0
; }
 801b312: 4618         	mov	r0, r3
 801b314: 3710         	adds	r7, #0x10
 801b316: 46bd         	mov	sp, r7
 801b318: bd80         	pop	{r7, pc}

0801b31a <gpio_port_set_bits_raw>:
; {
 801b31a: b580         	push	{r7, lr}
 801b31c: b082         	sub	sp, #0x8
 801b31e: af00         	add	r7, sp, #0x0
 801b320: 6078         	str	r0, [r7, #0x4]
 801b322: 6039         	str	r1, [r7]
; 	return z_impl_gpio_port_set_bits_raw(port, pins);
 801b324: 6839         	ldr	r1, [r7]
 801b326: 6878         	ldr	r0, [r7, #0x4]
 801b328: f7ff ff62    	bl	0x801b1f0 <z_impl_gpio_port_set_bits_raw> @ imm = #-0x13c
 801b32c: 4603         	mov	r3, r0
; }
 801b32e: 4618         	mov	r0, r3
 801b330: 3708         	adds	r7, #0x8
 801b332: 46bd         	mov	sp, r7
 801b334: bd80         	pop	{r7, pc}

0801b336 <gpio_port_clear_bits_raw>:
; {
 801b336: b580         	push	{r7, lr}
 801b338: b082         	sub	sp, #0x8
 801b33a: af00         	add	r7, sp, #0x0
 801b33c: 6078         	str	r0, [r7, #0x4]
 801b33e: 6039         	str	r1, [r7]
; 	return z_impl_gpio_port_clear_bits_raw(port, pins);
 801b340: 6839         	ldr	r1, [r7]
 801b342: 6878         	ldr	r0, [r7, #0x4]
 801b344: f7ff ff66    	bl	0x801b214 <z_impl_gpio_port_clear_bits_raw> @ imm = #-0x134
 801b348: 4603         	mov	r3, r0
; }
 801b34a: 4618         	mov	r0, r3
 801b34c: 3708         	adds	r7, #0x8
 801b34e: 46bd         	mov	sp, r7
 801b350: bd80         	pop	{r7, pc}

0801b352 <spi_cs_is_gpio>:
; {
 801b352: b480         	push	{r7}
 801b354: b083         	sub	sp, #0xc
 801b356: af00         	add	r7, sp, #0x0
 801b358: 6078         	str	r0, [r7, #0x4]
; 	return config->cs.gpio.port != NULL;
 801b35a: 687b         	ldr	r3, [r7, #0x4]
 801b35c: 689b         	ldr	r3, [r3, #0x8]
 801b35e: 2b00         	cmp	r3, #0x0
 801b360: bf14         	ite	ne
 801b362: 2301         	movne	r3, #0x1
 801b364: 2300         	moveq	r3, #0x0
 801b366: b2db         	uxtb	r3, r3
; }
 801b368: 4618         	mov	r0, r3
 801b36a: 370c         	adds	r7, #0xc
 801b36c: 46bd         	mov	sp, r7
 801b36e: bc80         	pop	{r7}
 801b370: 4770         	bx	lr

0801b372 <pinctrl_apply_state_direct>:
; {
 801b372: b580         	push	{r7, lr}
 801b374: b084         	sub	sp, #0x10
 801b376: af00         	add	r7, sp, #0x0
 801b378: 6078         	str	r0, [r7, #0x4]
 801b37a: 6039         	str	r1, [r7]
; 	reg = PINCTRL_REG_NONE;
 801b37c: 2300         	movs	r3, #0x0
 801b37e: 60fb         	str	r3, [r7, #0xc]
; 	return pinctrl_configure_pins(state->pins, state->pin_cnt, reg);
 801b380: 683b         	ldr	r3, [r7]
 801b382: 6818         	ldr	r0, [r3]
 801b384: 683b         	ldr	r3, [r7]
 801b386: 791b         	ldrb	r3, [r3, #0x4]
 801b388: 68fa         	ldr	r2, [r7, #0xc]
 801b38a: 4619         	mov	r1, r3
 801b38c: f7fc feb2    	bl	0x80180f4 <pinctrl_configure_pins> @ imm = #-0x329c
 801b390: 4603         	mov	r3, r0
; }
 801b392: 4618         	mov	r0, r3
 801b394: 3710         	adds	r7, #0x10
 801b396: 46bd         	mov	sp, r7
 801b398: bd80         	pop	{r7, pc}

0801b39a <pinctrl_apply_state>:
; {
 801b39a: b580         	push	{r7, lr}
 801b39c: b084         	sub	sp, #0x10
 801b39e: af00         	add	r7, sp, #0x0
 801b3a0: 6078         	str	r0, [r7, #0x4]
 801b3a2: 460b         	mov	r3, r1
 801b3a4: 70fb         	strb	r3, [r7, #0x3]
; 	ret = pinctrl_lookup_state(config, id, &state);
 801b3a6: f107 0208    	add.w	r2, r7, #0x8
 801b3aa: 78fb         	ldrb	r3, [r7, #0x3]
 801b3ac: 4619         	mov	r1, r3
 801b3ae: 6878         	ldr	r0, [r7, #0x4]
 801b3b0: f7fc fe69    	bl	0x8018086 <pinctrl_lookup_state> @ imm = #-0x332e
 801b3b4: 60f8         	str	r0, [r7, #0xc]
; 	if (ret < 0) {
 801b3b6: 68fb         	ldr	r3, [r7, #0xc]
 801b3b8: 2b00         	cmp	r3, #0x0
 801b3ba: da01         	bge	0x801b3c0 <pinctrl_apply_state+0x26> @ imm = #0x2
; 		return ret;
 801b3bc: 68fb         	ldr	r3, [r7, #0xc]
 801b3be: e005         	b	0x801b3cc <pinctrl_apply_state+0x32> @ imm = #0xa
; 	return pinctrl_apply_state_direct(config, state);
 801b3c0: 68bb         	ldr	r3, [r7, #0x8]
 801b3c2: 4619         	mov	r1, r3
 801b3c4: 6878         	ldr	r0, [r7, #0x4]
 801b3c6: f7ff ffd4    	bl	0x801b372 <pinctrl_apply_state_direct> @ imm = #-0x58
 801b3ca: 4603         	mov	r3, r0
; }
 801b3cc: 4618         	mov	r0, r3
 801b3ce: 3710         	adds	r7, #0x10
 801b3d0: 46bd         	mov	sp, r7
 801b3d2: bd80         	pop	{r7, pc}

0801b3d4 <pm_device_runtime_enable>:
; {
 801b3d4: b480         	push	{r7}
 801b3d6: b083         	sub	sp, #0xc
 801b3d8: af00         	add	r7, sp, #0x0
 801b3da: 6078         	str	r0, [r7, #0x4]
; 	return 0;
 801b3dc: 2300         	movs	r3, #0x0
; }
 801b3de: 4618         	mov	r0, r3
 801b3e0: 370c         	adds	r7, #0xc
 801b3e2: 46bd         	mov	sp, r7
 801b3e4: bc80         	pop	{r7}
 801b3e6: 4770         	bx	lr

0801b3e8 <clock_control_on>:
; {
 801b3e8: b580         	push	{r7, lr}
 801b3ea: b084         	sub	sp, #0x10
 801b3ec: af00         	add	r7, sp, #0x0
 801b3ee: 6078         	str	r0, [r7, #0x4]
 801b3f0: 6039         	str	r1, [r7]
; 	const struct clock_control_driver_api *api =
 801b3f2: 687b         	ldr	r3, [r7, #0x4]
 801b3f4: 689b         	ldr	r3, [r3, #0x8]
 801b3f6: 60fb         	str	r3, [r7, #0xc]
; 	return api->on(dev, sys);
 801b3f8: 68fb         	ldr	r3, [r7, #0xc]
 801b3fa: 681b         	ldr	r3, [r3]
 801b3fc: 6839         	ldr	r1, [r7]
 801b3fe: 6878         	ldr	r0, [r7, #0x4]
 801b400: 4798         	blx	r3
 801b402: 4603         	mov	r3, r0
; }
 801b404: 4618         	mov	r0, r3
 801b406: 3710         	adds	r7, #0x10
 801b408: 46bd         	mov	sp, r7
 801b40a: bd80         	pop	{r7, pc}

0801b40c <clock_control_get_rate>:
; {
 801b40c: b580         	push	{r7, lr}
 801b40e: b086         	sub	sp, #0x18
 801b410: af00         	add	r7, sp, #0x0
 801b412: 60f8         	str	r0, [r7, #0xc]
 801b414: 60b9         	str	r1, [r7, #0x8]
 801b416: 607a         	str	r2, [r7, #0x4]
; 	const struct clock_control_driver_api *api =
 801b418: 68fb         	ldr	r3, [r7, #0xc]
 801b41a: 689b         	ldr	r3, [r3, #0x8]
 801b41c: 617b         	str	r3, [r7, #0x14]
; 	if (api->get_rate == NULL) {
 801b41e: 697b         	ldr	r3, [r7, #0x14]
 801b420: 68db         	ldr	r3, [r3, #0xc]
 801b422: 2b00         	cmp	r3, #0x0
 801b424: d102         	bne	0x801b42c <clock_control_get_rate+0x20> @ imm = #0x4
; 		return -ENOSYS;
 801b426: f06f 0357    	mvn	r3, #0x57
 801b42a: e006         	b	0x801b43a <clock_control_get_rate+0x2e> @ imm = #0xc
; 	return api->get_rate(dev, sys, rate);
 801b42c: 697b         	ldr	r3, [r7, #0x14]
 801b42e: 68db         	ldr	r3, [r3, #0xc]
 801b430: 687a         	ldr	r2, [r7, #0x4]
 801b432: 68b9         	ldr	r1, [r7, #0x8]
 801b434: 68f8         	ldr	r0, [r7, #0xc]
 801b436: 4798         	blx	r3
 801b438: 4603         	mov	r3, r0
; }
 801b43a: 4618         	mov	r0, r3
 801b43c: 3718         	adds	r7, #0x18
 801b43e: 46bd         	mov	sp, r7
 801b440: bd80         	pop	{r7, pc}

0801b442 <spi_context_configured>:
; {
 801b442: b480         	push	{r7}
 801b444: b083         	sub	sp, #0xc
 801b446: af00         	add	r7, sp, #0x0
 801b448: 6078         	str	r0, [r7, #0x4]
 801b44a: 6039         	str	r1, [r7]
; 	return !!(ctx->config == config);
 801b44c: 687b         	ldr	r3, [r7, #0x4]
 801b44e: 681b         	ldr	r3, [r3]
 801b450: 683a         	ldr	r2, [r7]
 801b452: 429a         	cmp	r2, r3
 801b454: bf0c         	ite	eq
 801b456: 2301         	moveq	r3, #0x1
 801b458: 2300         	movne	r3, #0x0
 801b45a: b2db         	uxtb	r3, r3
; }
 801b45c: 4618         	mov	r0, r3
 801b45e: 370c         	adds	r7, #0xc
 801b460: 46bd         	mov	sp, r7
 801b462: bc80         	pop	{r7}
 801b464: 4770         	bx	lr

0801b466 <spi_context_lock>:
; {
 801b466: b580         	push	{r7, lr}
 801b468: b084         	sub	sp, #0x10
 801b46a: af00         	add	r7, sp, #0x0
 801b46c: 60f8         	str	r0, [r7, #0xc]
 801b46e: 607a         	str	r2, [r7, #0x4]
 801b470: 603b         	str	r3, [r7]
 801b472: 460b         	mov	r3, r1
 801b474: 72fb         	strb	r3, [r7, #0xb]
; 	if ((spi_cfg->operation & SPI_LOCK_ON) &&
 801b476: 69bb         	ldr	r3, [r7, #0x18]
 801b478: 889b         	ldrh	r3, [r3, #0x4]
 801b47a: f403 5300    	and	r3, r3, #0x2000
 801b47e: 2b00         	cmp	r3, #0x0
 801b480: d00d         	beq	0x801b49e <spi_context_lock+0x38> @ imm = #0x1a
; 		(k_sem_count_get(&ctx->lock) == 0) &&
 801b482: 68fb         	ldr	r3, [r7, #0xc]
 801b484: 3310         	adds	r3, #0x10
 801b486: 4618         	mov	r0, r3
 801b488: f7ff fc86    	bl	0x801ad98 <k_sem_count_get> @ imm = #-0x6f4
 801b48c: 4603         	mov	r3, r0
; 	if ((spi_cfg->operation & SPI_LOCK_ON) &&
 801b48e: 2b00         	cmp	r3, #0x0
 801b490: d105         	bne	0x801b49e <spi_context_lock+0x38> @ imm = #0xa
; 		(ctx->owner == spi_cfg)) {
 801b492: 68fb         	ldr	r3, [r7, #0xc]
 801b494: 685b         	ldr	r3, [r3, #0x4]
; 		(k_sem_count_get(&ctx->lock) == 0) &&
 801b496: 69ba         	ldr	r2, [r7, #0x18]
 801b498: 429a         	cmp	r2, r3
 801b49a: d100         	bne	0x801b49e <spi_context_lock+0x38> @ imm = #0x0
 801b49c: e00c         	b	0x801b4b8 <spi_context_lock+0x52> @ imm = #0x18
; 	k_sem_take(&ctx->lock, K_FOREVER);
 801b49e: 68fb         	ldr	r3, [r7, #0xc]
 801b4a0: f103 0110    	add.w	r1, r3, #0x10
 801b4a4: f04f 32ff    	mov.w	r2, #0xffffffff
 801b4a8: f04f 33ff    	mov.w	r3, #0xffffffff
 801b4ac: 4608         	mov	r0, r1
 801b4ae: f7ff fc58    	bl	0x801ad62 <k_sem_take>  @ imm = #-0x750
; 	ctx->owner = spi_cfg;
 801b4b2: 68fb         	ldr	r3, [r7, #0xc]
 801b4b4: 69ba         	ldr	r2, [r7, #0x18]
 801b4b6: 605a         	str	r2, [r3, #0x4]
; }
 801b4b8: 3710         	adds	r7, #0x10
 801b4ba: 46bd         	mov	sp, r7
 801b4bc: bd80         	pop	{r7, pc}

0801b4be <spi_context_release>:
; {
 801b4be: b580         	push	{r7, lr}
 801b4c0: b082         	sub	sp, #0x8
 801b4c2: af00         	add	r7, sp, #0x0
 801b4c4: 6078         	str	r0, [r7, #0x4]
 801b4c6: 6039         	str	r1, [r7]
; 	if (!(ctx->config->operation & SPI_LOCK_ON)) {
 801b4c8: 687b         	ldr	r3, [r7, #0x4]
 801b4ca: 681b         	ldr	r3, [r3]
 801b4cc: 889b         	ldrh	r3, [r3, #0x4]
 801b4ce: f403 5300    	and	r3, r3, #0x2000
 801b4d2: 2b00         	cmp	r3, #0x0
 801b4d4: d107         	bne	0x801b4e6 <spi_context_release+0x28> @ imm = #0xe
; 		ctx->owner = NULL;
 801b4d6: 687b         	ldr	r3, [r7, #0x4]
 801b4d8: 2200         	movs	r2, #0x0
 801b4da: 605a         	str	r2, [r3, #0x4]
; 		k_sem_give(&ctx->lock);
 801b4dc: 687b         	ldr	r3, [r7, #0x4]
 801b4de: 3310         	adds	r3, #0x10
 801b4e0: 4618         	mov	r0, r3
 801b4e2: f7ff fc4e    	bl	0x801ad82 <k_sem_give>  @ imm = #-0x764
; }
 801b4e6: bf00         	nop
 801b4e8: 3708         	adds	r7, #0x8
 801b4ea: 46bd         	mov	sp, r7
 801b4ec: bd80         	pop	{r7, pc}

0801b4ee <_spi_context_cs_control>:
; {
 801b4ee: b580         	push	{r7, lr}
 801b4f0: b082         	sub	sp, #0x8
 801b4f2: af00         	add	r7, sp, #0x0
 801b4f4: 6078         	str	r0, [r7, #0x4]
 801b4f6: 460b         	mov	r3, r1
 801b4f8: 70fb         	strb	r3, [r7, #0x3]
 801b4fa: 4613         	mov	r3, r2
 801b4fc: 70bb         	strb	r3, [r7, #0x2]
; 	if (ctx->config && spi_cs_is_gpio(ctx->config)) {
 801b4fe: 687b         	ldr	r3, [r7, #0x4]
 801b500: 681b         	ldr	r3, [r3]
 801b502: 2b00         	cmp	r3, #0x0
 801b504: d034         	beq	0x801b570 <_spi_context_cs_control+0x82> @ imm = #0x68
 801b506: 687b         	ldr	r3, [r7, #0x4]
 801b508: 681b         	ldr	r3, [r3]
 801b50a: 4618         	mov	r0, r3
 801b50c: f7ff ff21    	bl	0x801b352 <spi_cs_is_gpio> @ imm = #-0x1be
 801b510: 4603         	mov	r3, r0
 801b512: 2b00         	cmp	r3, #0x0
 801b514: d02c         	beq	0x801b570 <_spi_context_cs_control+0x82> @ imm = #0x58
; 		if (on) {
 801b516: 78fb         	ldrb	r3, [r7, #0x3]
 801b518: 2b00         	cmp	r3, #0x0
 801b51a: d00d         	beq	0x801b538 <_spi_context_cs_control+0x4a> @ imm = #0x1a
; 			gpio_pin_set_dt(&ctx->config->cs.gpio, 1);
 801b51c: 687b         	ldr	r3, [r7, #0x4]
 801b51e: 681b         	ldr	r3, [r3]
 801b520: 3308         	adds	r3, #0x8
 801b522: 2101         	movs	r1, #0x1
 801b524: 4618         	mov	r0, r3
 801b526: f7ff fed4    	bl	0x801b2d2 <gpio_pin_set_dt> @ imm = #-0x258
; 			k_busy_wait(ctx->config->cs.delay);
 801b52a: 687b         	ldr	r3, [r7, #0x4]
 801b52c: 681b         	ldr	r3, [r3]
 801b52e: 691b         	ldr	r3, [r3, #0x10]
 801b530: 4618         	mov	r0, r3
 801b532: f7ff fc0b    	bl	0x801ad4c <k_busy_wait> @ imm = #-0x7ea
 801b536: e01b         	b	0x801b570 <_spi_context_cs_control+0x82> @ imm = #0x36
; 			if (!force_off &&
 801b538: 78bb         	ldrb	r3, [r7, #0x2]
 801b53a: f083 0301    	eor	r3, r3, #0x1
 801b53e: b2db         	uxtb	r3, r3
 801b540: 2b00         	cmp	r3, #0x0
 801b542: d006         	beq	0x801b552 <_spi_context_cs_control+0x64> @ imm = #0xc
; 			    ctx->config->operation & SPI_HOLD_ON_CS) {
 801b544: 687b         	ldr	r3, [r7, #0x4]
 801b546: 681b         	ldr	r3, [r3]
 801b548: 889b         	ldrh	r3, [r3, #0x4]
 801b54a: f403 5380    	and	r3, r3, #0x1000
; 			if (!force_off &&
 801b54e: 2b00         	cmp	r3, #0x0
 801b550: d10d         	bne	0x801b56e <_spi_context_cs_control+0x80> @ imm = #0x1a
; 			k_busy_wait(ctx->config->cs.delay);
 801b552: 687b         	ldr	r3, [r7, #0x4]
 801b554: 681b         	ldr	r3, [r3]
 801b556: 691b         	ldr	r3, [r3, #0x10]
 801b558: 4618         	mov	r0, r3
 801b55a: f7ff fbf7    	bl	0x801ad4c <k_busy_wait> @ imm = #-0x812
; 			gpio_pin_set_dt(&ctx->config->cs.gpio, 0);
 801b55e: 687b         	ldr	r3, [r7, #0x4]
 801b560: 681b         	ldr	r3, [r3]
 801b562: 3308         	adds	r3, #0x8
 801b564: 2100         	movs	r1, #0x0
 801b566: 4618         	mov	r0, r3
 801b568: f7ff feb3    	bl	0x801b2d2 <gpio_pin_set_dt> @ imm = #-0x29a
 801b56c: e000         	b	0x801b570 <_spi_context_cs_control+0x82> @ imm = #0x0
; 				return;
 801b56e: bf00         	nop
; }
 801b570: 3708         	adds	r7, #0x8
 801b572: 46bd         	mov	sp, r7
 801b574: bd80         	pop	{r7, pc}

0801b576 <spi_context_cs_control>:
; {
 801b576: b580         	push	{r7, lr}
 801b578: b082         	sub	sp, #0x8
 801b57a: af00         	add	r7, sp, #0x0
 801b57c: 6078         	str	r0, [r7, #0x4]
 801b57e: 460b         	mov	r3, r1
 801b580: 70fb         	strb	r3, [r7, #0x3]
; 	_spi_context_cs_control(ctx, on, false);
 801b582: 78fb         	ldrb	r3, [r7, #0x3]
 801b584: 2200         	movs	r2, #0x0
 801b586: 4619         	mov	r1, r3
 801b588: 6878         	ldr	r0, [r7, #0x4]
 801b58a: f7ff ffb0    	bl	0x801b4ee <_spi_context_cs_control> @ imm = #-0xa0
; }
 801b58e: bf00         	nop
 801b590: 3708         	adds	r7, #0x8
 801b592: 46bd         	mov	sp, r7
 801b594: bd80         	pop	{r7, pc}

0801b596 <spi_context_unlock_unconditionally>:
; {
 801b596: b580         	push	{r7, lr}
 801b598: b082         	sub	sp, #0x8
 801b59a: af00         	add	r7, sp, #0x0
 801b59c: 6078         	str	r0, [r7, #0x4]
; 	_spi_context_cs_control(ctx, false, true);
 801b59e: 2201         	movs	r2, #0x1
 801b5a0: 2100         	movs	r1, #0x0
 801b5a2: 6878         	ldr	r0, [r7, #0x4]
 801b5a4: f7ff ffa3    	bl	0x801b4ee <_spi_context_cs_control> @ imm = #-0xba
; 	if (!k_sem_count_get(&ctx->lock)) {
 801b5a8: 687b         	ldr	r3, [r7, #0x4]
 801b5aa: 3310         	adds	r3, #0x10
 801b5ac: 4618         	mov	r0, r3
 801b5ae: f7ff fbf3    	bl	0x801ad98 <k_sem_count_get> @ imm = #-0x81a
 801b5b2: 4603         	mov	r3, r0
 801b5b4: 2b00         	cmp	r3, #0x0
 801b5b6: d107         	bne	0x801b5c8 <spi_context_unlock_unconditionally+0x32> @ imm = #0xe
; 		ctx->owner = NULL;
 801b5b8: 687b         	ldr	r3, [r7, #0x4]
 801b5ba: 2200         	movs	r2, #0x0
 801b5bc: 605a         	str	r2, [r3, #0x4]
; 		k_sem_give(&ctx->lock);
 801b5be: 687b         	ldr	r3, [r7, #0x4]
 801b5c0: 3310         	adds	r3, #0x10
 801b5c2: 4618         	mov	r0, r3
 801b5c4: f7ff fbdd    	bl	0x801ad82 <k_sem_give>  @ imm = #-0x846
; }
 801b5c8: bf00         	nop
 801b5ca: 3708         	adds	r7, #0x8
 801b5cc: 46bd         	mov	sp, r7
 801b5ce: bd80         	pop	{r7, pc}

0801b5d0 <spi_context_get_next_buf>:
; {
 801b5d0: b480         	push	{r7}
 801b5d2: b085         	sub	sp, #0x14
 801b5d4: af00         	add	r7, sp, #0x0
 801b5d6: 60f8         	str	r0, [r7, #0xc]
 801b5d8: 60b9         	str	r1, [r7, #0x8]
 801b5da: 607a         	str	r2, [r7, #0x4]
 801b5dc: 70fb         	strb	r3, [r7, #0x3]
; 	while (*count) {
 801b5de: e01c         	b	0x801b61a <spi_context_get_next_buf+0x4a> @ imm = #0x38
; 		if (((*current)->len / dfs) != 0) {
 801b5e0: 68fb         	ldr	r3, [r7, #0xc]
 801b5e2: 681b         	ldr	r3, [r3]
 801b5e4: 685a         	ldr	r2, [r3, #0x4]
 801b5e6: 78fb         	ldrb	r3, [r7, #0x3]
 801b5e8: 429a         	cmp	r2, r3
 801b5ea: d30b         	blo	0x801b604 <spi_context_get_next_buf+0x34> @ imm = #0x16
; 			*buf_len = (*current)->len / dfs;
 801b5ec: 68fb         	ldr	r3, [r7, #0xc]
 801b5ee: 681b         	ldr	r3, [r3]
 801b5f0: 685a         	ldr	r2, [r3, #0x4]
 801b5f2: 78fb         	ldrb	r3, [r7, #0x3]
 801b5f4: fbb2 f2f3    	udiv	r2, r2, r3
 801b5f8: 687b         	ldr	r3, [r7, #0x4]
 801b5fa: 601a         	str	r2, [r3]
; 			return (*current)->buf;
 801b5fc: 68fb         	ldr	r3, [r7, #0xc]
 801b5fe: 681b         	ldr	r3, [r3]
 801b600: 681b         	ldr	r3, [r3]
 801b602: e012         	b	0x801b62a <spi_context_get_next_buf+0x5a> @ imm = #0x24
; 		++(*current);
 801b604: 68fb         	ldr	r3, [r7, #0xc]
 801b606: 681b         	ldr	r3, [r3]
 801b608: f103 0208    	add.w	r2, r3, #0x8
 801b60c: 68fb         	ldr	r3, [r7, #0xc]
 801b60e: 601a         	str	r2, [r3]
; 		--(*count);
 801b610: 68bb         	ldr	r3, [r7, #0x8]
 801b612: 681b         	ldr	r3, [r3]
 801b614: 1e5a         	subs	r2, r3, #0x1
 801b616: 68bb         	ldr	r3, [r7, #0x8]
 801b618: 601a         	str	r2, [r3]
; 	while (*count) {
 801b61a: 68bb         	ldr	r3, [r7, #0x8]
 801b61c: 681b         	ldr	r3, [r3]
 801b61e: 2b00         	cmp	r3, #0x0
 801b620: d1de         	bne	0x801b5e0 <spi_context_get_next_buf+0x10> @ imm = #-0x44
; 	*buf_len = 0;
 801b622: 687b         	ldr	r3, [r7, #0x4]
 801b624: 2200         	movs	r2, #0x0
 801b626: 601a         	str	r2, [r3]
; 	return NULL;
 801b628: 2300         	movs	r3, #0x0
; }
 801b62a: 4618         	mov	r0, r3
 801b62c: 3714         	adds	r7, #0x14
 801b62e: 46bd         	mov	sp, r7
 801b630: bc80         	pop	{r7}
 801b632: 4770         	bx	lr

0801b634 <ll_func_tx_is_not_full>:
; {
 801b634: b580         	push	{r7, lr}
 801b636: b082         	sub	sp, #0x8
 801b638: af00         	add	r7, sp, #0x0
 801b63a: 6078         	str	r0, [r7, #0x4]
; 	return LL_SPI_IsActiveFlag_TXE(spi);
 801b63c: 6878         	ldr	r0, [r7, #0x4]
 801b63e: f7ff fcc0    	bl	0x801afc2 <LL_SPI_IsActiveFlag_TXE> @ imm = #-0x680
 801b642: 4603         	mov	r3, r0
; }
 801b644: 4618         	mov	r0, r3
 801b646: 3708         	adds	r7, #0x8
 801b648: 46bd         	mov	sp, r7
 801b64a: bd80         	pop	{r7, pc}

0801b64c <ll_func_rx_is_not_empty>:
; {
 801b64c: b580         	push	{r7, lr}
 801b64e: b082         	sub	sp, #0x8
 801b650: af00         	add	r7, sp, #0x0
 801b652: 6078         	str	r0, [r7, #0x4]
; 	return LL_SPI_IsActiveFlag_RXNE(spi);
 801b654: 6878         	ldr	r0, [r7, #0x4]
 801b656: f7ff fca2    	bl	0x801af9e <LL_SPI_IsActiveFlag_RXNE> @ imm = #-0x6bc
 801b65a: 4603         	mov	r3, r0
; }
 801b65c: 4618         	mov	r0, r3
 801b65e: 3708         	adds	r7, #0x8
 801b660: 46bd         	mov	sp, r7
 801b662: bd80         	pop	{r7, pc}

0801b664 <ll_func_disable_int_tx_empty>:
; {
 801b664: b580         	push	{r7, lr}
 801b666: b082         	sub	sp, #0x8
 801b668: af00         	add	r7, sp, #0x0
 801b66a: 6078         	str	r0, [r7, #0x4]
; 	LL_SPI_DisableIT_TXE(spi);
 801b66c: 6878         	ldr	r0, [r7, #0x4]
 801b66e: f7ff fd14    	bl	0x801b09a <LL_SPI_DisableIT_TXE> @ imm = #-0x5d8
; }
 801b672: bf00         	nop
 801b674: 3708         	adds	r7, #0x8
 801b676: 46bd         	mov	sp, r7
 801b678: bd80         	pop	{r7, pc}

0801b67a <ll_func_spi_is_busy>:
; {
 801b67a: b580         	push	{r7, lr}
 801b67c: b082         	sub	sp, #0x8
 801b67e: af00         	add	r7, sp, #0x0
 801b680: 6078         	str	r0, [r7, #0x4]
; 	return LL_SPI_IsActiveFlag_BSY(spi);
 801b682: 6878         	ldr	r0, [r7, #0x4]
 801b684: f7ff fcd3    	bl	0x801b02e <LL_SPI_IsActiveFlag_BSY> @ imm = #-0x65a
 801b688: 4603         	mov	r3, r0
; }
 801b68a: 4618         	mov	r0, r3
 801b68c: 3708         	adds	r7, #0x8
 801b68e: 46bd         	mov	sp, r7
 801b690: bd80         	pop	{r7, pc}

0801b692 <ll_func_disable_spi>:
; {
 801b692: b580         	push	{r7, lr}
 801b694: b082         	sub	sp, #0x8
 801b696: af00         	add	r7, sp, #0x0
 801b698: 6078         	str	r0, [r7, #0x4]
; 	LL_SPI_Disable(spi);
 801b69a: 6878         	ldr	r0, [r7, #0x4]
 801b69c: f7ff fb97    	bl	0x801adce <LL_SPI_Disable> @ imm = #-0x8d2
; 	while (LL_SPI_IsEnabled(spi)) {
 801b6a0: bf00         	nop
 801b6a2: 6878         	ldr	r0, [r7, #0x4]
 801b6a4: f7ff fba2    	bl	0x801adec <LL_SPI_IsEnabled> @ imm = #-0x8bc
 801b6a8: 4603         	mov	r3, r0
 801b6aa: 2b00         	cmp	r3, #0x0
 801b6ac: d1f9         	bne	0x801b6a2 <ll_func_disable_spi+0x10> @ imm = #-0xe
; }
 801b6ae: bf00         	nop
 801b6b0: bf00         	nop
 801b6b2: 3708         	adds	r7, #0x8
 801b6b4: 46bd         	mov	sp, r7
 801b6b6: bd80         	pop	{r7, pc}

0801b6b8 <spi_stm32_pm_policy_state_lock_get>:
; {
 801b6b8: b480         	push	{r7}
 801b6ba: b083         	sub	sp, #0xc
 801b6bc: af00         	add	r7, sp, #0x0
 801b6be: 6078         	str	r0, [r7, #0x4]
; }
 801b6c0: bf00         	nop
 801b6c2: 370c         	adds	r7, #0xc
 801b6c4: 46bd         	mov	sp, r7
 801b6c6: bc80         	pop	{r7}
 801b6c8: 4770         	bx	lr

0801b6ca <spi_stm32_pm_policy_state_lock_put>:
; {
 801b6ca: b480         	push	{r7}
 801b6cc: b083         	sub	sp, #0xc
 801b6ce: af00         	add	r7, sp, #0x0
 801b6d0: 6078         	str	r0, [r7, #0x4]
; }
 801b6d2: bf00         	nop
 801b6d4: 370c         	adds	r7, #0xc
 801b6d6: 46bd         	mov	sp, r7
 801b6d8: bc80         	pop	{r7}
 801b6da: 4770         	bx	lr

0801b6dc <spi_stm32_transfer_ongoing>:
; {
 801b6dc: b480         	push	{r7}
 801b6de: b085         	sub	sp, #0x14
 801b6e0: af00         	add	r7, sp, #0x0
 801b6e2: 6078         	str	r0, [r7, #0x4]
; 	return spi_context_tx_on(&data->ctx) || spi_context_rx_on(&data->ctx);
 801b6e4: 687b         	ldr	r3, [r7, #0x4]
 801b6e6: 60fb         	str	r3, [r7, #0xc]
; 	return !!(ctx->tx_len);
 801b6e8: 68fb         	ldr	r3, [r7, #0xc]
 801b6ea: 6c9b         	ldr	r3, [r3, #0x48]
 801b6ec: 2b00         	cmp	r3, #0x0
 801b6ee: bf14         	ite	ne
 801b6f0: 2301         	movne	r3, #0x1
 801b6f2: 2300         	moveq	r3, #0x0
 801b6f4: b2db         	uxtb	r3, r3
; 	return spi_context_tx_on(&data->ctx) || spi_context_rx_on(&data->ctx);
 801b6f6: 2b00         	cmp	r3, #0x0
 801b6f8: d10a         	bne	0x801b710 <spi_stm32_transfer_ongoing+0x34> @ imm = #0x14
 801b6fa: 687b         	ldr	r3, [r7, #0x4]
 801b6fc: 60bb         	str	r3, [r7, #0x8]
; 	return !!(ctx->rx_len);
 801b6fe: 68bb         	ldr	r3, [r7, #0x8]
 801b700: 6d1b         	ldr	r3, [r3, #0x50]
 801b702: 2b00         	cmp	r3, #0x0
 801b704: bf14         	ite	ne
 801b706: 2301         	movne	r3, #0x1
 801b708: 2300         	moveq	r3, #0x0
 801b70a: b2db         	uxtb	r3, r3
; 	return spi_context_tx_on(&data->ctx) || spi_context_rx_on(&data->ctx);
 801b70c: 2b00         	cmp	r3, #0x0
 801b70e: d001         	beq	0x801b714 <spi_stm32_transfer_ongoing+0x38> @ imm = #0x2
 801b710: 2301         	movs	r3, #0x1
 801b712: e000         	b	0x801b716 <spi_stm32_transfer_ongoing+0x3a> @ imm = #0x0
 801b714: 2300         	movs	r3, #0x0
 801b716: f003 0301    	and	r3, r3, #0x1
 801b71a: b2db         	uxtb	r3, r3
; }
 801b71c: 4618         	mov	r0, r3
 801b71e: 3714         	adds	r7, #0x14
 801b720: 46bd         	mov	sp, r7
 801b722: bc80         	pop	{r7}
 801b724: 4770         	bx	lr

0801b726 <spi_stm32_shift_fifo>:
; {
 801b726: b580         	push	{r7, lr}
 801b728: b082         	sub	sp, #0x8
 801b72a: af00         	add	r7, sp, #0x0
 801b72c: 6078         	str	r0, [r7, #0x4]
 801b72e: 6039         	str	r1, [r7]
; 	if (ll_func_rx_is_not_empty(spi)) {
 801b730: 6878         	ldr	r0, [r7, #0x4]
 801b732: f7ff ff8b    	bl	0x801b64c <ll_func_rx_is_not_empty> @ imm = #-0xea
 801b736: 4603         	mov	r3, r0
 801b738: 2b00         	cmp	r3, #0x0
 801b73a: d003         	beq	0x801b744 <spi_stm32_shift_fifo+0x1e> @ imm = #0x6
; 		spi_stm32_read_next_frame(spi, data);
 801b73c: 6839         	ldr	r1, [r7]
 801b73e: 6878         	ldr	r0, [r7, #0x4]
 801b740: f7f0 f8d0    	bl	0x800b8e4 <spi_stm32_read_next_frame> @ imm = #-0xfe60
; 	if (ll_func_tx_is_not_full(spi)) {
 801b744: 6878         	ldr	r0, [r7, #0x4]
 801b746: f7ff ff75    	bl	0x801b634 <ll_func_tx_is_not_full> @ imm = #-0x116
 801b74a: 4603         	mov	r3, r0
 801b74c: 2b00         	cmp	r3, #0x0
 801b74e: d003         	beq	0x801b758 <spi_stm32_shift_fifo+0x32> @ imm = #0x6
; 		spi_stm32_send_next_frame(spi, data);
 801b750: 6839         	ldr	r1, [r7]
 801b752: 6878         	ldr	r0, [r7, #0x4]
 801b754: f7ef ff5a    	bl	0x800b60c <spi_stm32_send_next_frame> @ imm = #-0x1014c
; }
 801b758: bf00         	nop
 801b75a: 3708         	adds	r7, #0x8
 801b75c: 46bd         	mov	sp, r7
 801b75e: bd80         	pop	{r7, pc}

0801b760 <spi_stm32_shift_m>:
; {
 801b760: b580         	push	{r7, lr}
 801b762: b082         	sub	sp, #0x8
 801b764: af00         	add	r7, sp, #0x0
 801b766: 6078         	str	r0, [r7, #0x4]
 801b768: 6039         	str	r1, [r7]
; 	if (cfg->fifo_enabled) {
 801b76a: 687b         	ldr	r3, [r7, #0x4]
 801b76c: 7c1b         	ldrb	r3, [r3, #0x10]
 801b76e: 2b00         	cmp	r3, #0x0
 801b770: d006         	beq	0x801b780 <spi_stm32_shift_m+0x20> @ imm = #0xc
; 		spi_stm32_shift_fifo(cfg->spi, data);
 801b772: 687b         	ldr	r3, [r7, #0x4]
 801b774: 681b         	ldr	r3, [r3]
 801b776: 6839         	ldr	r1, [r7]
 801b778: 4618         	mov	r0, r3
 801b77a: f7ff ffd4    	bl	0x801b726 <spi_stm32_shift_fifo> @ imm = #-0x58
; }
 801b77e: e01d         	b	0x801b7bc <spi_stm32_shift_m+0x5c> @ imm = #0x3a
; 		while (!ll_func_tx_is_not_full(cfg->spi)) {
 801b780: bf00         	nop
 801b782: 687b         	ldr	r3, [r7, #0x4]
 801b784: 681b         	ldr	r3, [r3]
 801b786: 4618         	mov	r0, r3
 801b788: f7ff ff54    	bl	0x801b634 <ll_func_tx_is_not_full> @ imm = #-0x158
 801b78c: 4603         	mov	r3, r0
 801b78e: 2b00         	cmp	r3, #0x0
 801b790: d0f7         	beq	0x801b782 <spi_stm32_shift_m+0x22> @ imm = #-0x12
; 		spi_stm32_send_next_frame(cfg->spi, data);
 801b792: 687b         	ldr	r3, [r7, #0x4]
 801b794: 681b         	ldr	r3, [r3]
 801b796: 6839         	ldr	r1, [r7]
 801b798: 4618         	mov	r0, r3
 801b79a: f7ef ff37    	bl	0x800b60c <spi_stm32_send_next_frame> @ imm = #-0x10192
; 		while (!ll_func_rx_is_not_empty(cfg->spi)) {
 801b79e: bf00         	nop
 801b7a0: 687b         	ldr	r3, [r7, #0x4]
 801b7a2: 681b         	ldr	r3, [r3]
 801b7a4: 4618         	mov	r0, r3
 801b7a6: f7ff ff51    	bl	0x801b64c <ll_func_rx_is_not_empty> @ imm = #-0x15e
 801b7aa: 4603         	mov	r3, r0
 801b7ac: 2b00         	cmp	r3, #0x0
 801b7ae: d0f7         	beq	0x801b7a0 <spi_stm32_shift_m+0x40> @ imm = #-0x12
; 		spi_stm32_read_next_frame(cfg->spi, data);
 801b7b0: 687b         	ldr	r3, [r7, #0x4]
 801b7b2: 681b         	ldr	r3, [r3]
 801b7b4: 6839         	ldr	r1, [r7]
 801b7b6: 4618         	mov	r0, r3
 801b7b8: f7f0 f894    	bl	0x800b8e4 <spi_stm32_read_next_frame> @ imm = #-0xfed8
; }
 801b7bc: bf00         	nop
 801b7be: 3708         	adds	r7, #0x8
 801b7c0: 46bd         	mov	sp, r7
 801b7c2: bd80         	pop	{r7, pc}

0801b7c4 <spi_stm32_shift_frames>:
; {
 801b7c4: b580         	push	{r7, lr}
 801b7c6: b084         	sub	sp, #0x10
 801b7c8: af00         	add	r7, sp, #0x0
 801b7ca: 6078         	str	r0, [r7, #0x4]
 801b7cc: 6039         	str	r1, [r7]
; 	uint16_t operation = data->ctx.config->operation;
 801b7ce: 683b         	ldr	r3, [r7]
 801b7d0: 681b         	ldr	r3, [r3]
 801b7d2: 889b         	ldrh	r3, [r3, #0x4]
 801b7d4: 81fb         	strh	r3, [r7, #0xe]
; 	if (SPI_OP_MODE_GET(operation) == SPI_OP_MODE_MASTER) {
 801b7d6: 89fb         	ldrh	r3, [r7, #0xe]
 801b7d8: f003 0301    	and	r3, r3, #0x1
 801b7dc: 2b00         	cmp	r3, #0x0
 801b7de: d104         	bne	0x801b7ea <spi_stm32_shift_frames+0x26> @ imm = #0x8
; 		spi_stm32_shift_m(cfg, data);
 801b7e0: 6839         	ldr	r1, [r7]
 801b7e2: 6878         	ldr	r0, [r7, #0x4]
 801b7e4: f7ff ffbc    	bl	0x801b760 <spi_stm32_shift_m> @ imm = #-0x88
 801b7e8: e005         	b	0x801b7f6 <spi_stm32_shift_frames+0x32> @ imm = #0xa
; 		spi_stm32_shift_s(cfg->spi, data);
 801b7ea: 687b         	ldr	r3, [r7, #0x4]
 801b7ec: 681b         	ldr	r3, [r3]
 801b7ee: 6839         	ldr	r1, [r7]
 801b7f0: 4618         	mov	r0, r3
 801b7f2: f7f0 fa25    	bl	0x800bc40 <spi_stm32_shift_s> @ imm = #-0xfbb6
; 	return spi_stm32_get_err(cfg->spi);
 801b7f6: 687b         	ldr	r3, [r7, #0x4]
 801b7f8: 681b         	ldr	r3, [r3]
 801b7fa: 4618         	mov	r0, r3
 801b7fc: f7f0 f9dc    	bl	0x800bbb8 <spi_stm32_get_err> @ imm = #-0xfc48
 801b800: 4603         	mov	r3, r0
; }
 801b802: 4618         	mov	r0, r3
 801b804: 3710         	adds	r7, #0x10
 801b806: 46bd         	mov	sp, r7
 801b808: bd80         	pop	{r7, pc}

0801b80a <spi_stm32_cs_control>:
; {
 801b80a: b580         	push	{r7, lr}
 801b80c: b084         	sub	sp, #0x10
 801b80e: af00         	add	r7, sp, #0x0
 801b810: 6078         	str	r0, [r7, #0x4]
 801b812: 460b         	mov	r3, r1
 801b814: 70fb         	strb	r3, [r7, #0x3]
; 	struct spi_stm32_data *data = dev->data;
 801b816: 687b         	ldr	r3, [r7, #0x4]
 801b818: 691b         	ldr	r3, [r3, #0x10]
 801b81a: 60fb         	str	r3, [r7, #0xc]
; 	spi_context_cs_control(&data->ctx, on);
 801b81c: 68fb         	ldr	r3, [r7, #0xc]
 801b81e: 78fa         	ldrb	r2, [r7, #0x3]
 801b820: 4611         	mov	r1, r2
 801b822: 4618         	mov	r0, r3
 801b824: f7ff fea7    	bl	0x801b576 <spi_context_cs_control> @ imm = #-0x2b2
; }
 801b828: bf00         	nop
 801b82a: 3710         	adds	r7, #0x10
 801b82c: 46bd         	mov	sp, r7
 801b82e: bd80         	pop	{r7, pc}

0801b830 <spi_stm32_complete>:
; {
 801b830: b580         	push	{r7, lr}
 801b832: b086         	sub	sp, #0x18
 801b834: af00         	add	r7, sp, #0x0
 801b836: 6078         	str	r0, [r7, #0x4]
 801b838: 6039         	str	r1, [r7]
; 	const struct spi_stm32_config *cfg = dev->config;
 801b83a: 687b         	ldr	r3, [r7, #0x4]
 801b83c: 685b         	ldr	r3, [r3, #0x4]
 801b83e: 617b         	str	r3, [r7, #0x14]
; 	SPI_TypeDef *spi = cfg->spi;
 801b840: 697b         	ldr	r3, [r7, #0x14]
 801b842: 681b         	ldr	r3, [r3]
 801b844: 613b         	str	r3, [r7, #0x10]
; 	struct spi_stm32_data *data = dev->data;
 801b846: 687b         	ldr	r3, [r7, #0x4]
 801b848: 691b         	ldr	r3, [r3, #0x10]
 801b84a: 60fb         	str	r3, [r7, #0xc]
; 	if (LL_SPI_GetMode(spi) == LL_SPI_MODE_MASTER) {
 801b84c: 6938         	ldr	r0, [r7, #0x10]
 801b84e: f7ff faf1    	bl	0x801ae34 <LL_SPI_GetMode> @ imm = #-0xa1e
 801b852: 4603         	mov	r3, r0
 801b854: f5b3 7f82    	cmp.w	r3, #0x104
 801b858: d10a         	bne	0x801b870 <spi_stm32_complete+0x40> @ imm = #0x14
; 		while (ll_func_spi_is_busy(spi)) {
 801b85a: bf00         	nop
 801b85c: 6938         	ldr	r0, [r7, #0x10]
 801b85e: f7ff ff0c    	bl	0x801b67a <ll_func_spi_is_busy> @ imm = #-0x1e8
 801b862: 4603         	mov	r3, r0
 801b864: 2b00         	cmp	r3, #0x0
 801b866: d1f9         	bne	0x801b85c <spi_stm32_complete+0x2c> @ imm = #-0xe
; 		spi_stm32_cs_control(dev, false);
 801b868: 2100         	movs	r1, #0x0
 801b86a: 6878         	ldr	r0, [r7, #0x4]
 801b86c: f7ff ffcd    	bl	0x801b80a <spi_stm32_cs_control> @ imm = #-0x66
; 	if (LL_SPI_IsActiveFlag_MODF(spi)) {
 801b870: 6938         	ldr	r0, [r7, #0x10]
 801b872: f7ff fbb8    	bl	0x801afe6 <LL_SPI_IsActiveFlag_MODF> @ imm = #-0x890
 801b876: 4603         	mov	r3, r0
 801b878: 2b00         	cmp	r3, #0x0
 801b87a: d002         	beq	0x801b882 <spi_stm32_complete+0x52> @ imm = #0x4
; 		LL_SPI_ClearFlag_MODF(spi);
 801b87c: 6938         	ldr	r0, [r7, #0x10]
 801b87e: f7ff fbe8    	bl	0x801b052 <LL_SPI_ClearFlag_MODF> @ imm = #-0x830
; 	if (!(data->ctx.config->operation & SPI_HOLD_ON_CS)) {
 801b882: 68fb         	ldr	r3, [r7, #0xc]
 801b884: 681b         	ldr	r3, [r3]
 801b886: 889b         	ldrh	r3, [r3, #0x4]
 801b888: f403 5380    	and	r3, r3, #0x1000
 801b88c: 2b00         	cmp	r3, #0x0
 801b88e: d102         	bne	0x801b896 <spi_stm32_complete+0x66> @ imm = #0x4
; 		ll_func_disable_spi(spi);
 801b890: 6938         	ldr	r0, [r7, #0x10]
 801b892: f7ff fefe    	bl	0x801b692 <ll_func_disable_spi> @ imm = #-0x204
; 	spi_stm32_pm_policy_state_lock_put(dev);
 801b896: 6878         	ldr	r0, [r7, #0x4]
 801b898: f7ff ff17    	bl	0x801b6ca <spi_stm32_pm_policy_state_lock_put> @ imm = #-0x1d2
; }
 801b89c: bf00         	nop
 801b89e: 3718         	adds	r7, #0x18
 801b8a0: 46bd         	mov	sp, r7
 801b8a2: bd80         	pop	{r7, pc}

0801b8a4 <spi_stm32_release>:
; {
 801b8a4: b580         	push	{r7, lr}
 801b8a6: b084         	sub	sp, #0x10
 801b8a8: af00         	add	r7, sp, #0x0
 801b8aa: 6078         	str	r0, [r7, #0x4]
 801b8ac: 6039         	str	r1, [r7]
; 	struct spi_stm32_data *data = dev->data;
 801b8ae: 687b         	ldr	r3, [r7, #0x4]
 801b8b0: 691b         	ldr	r3, [r3, #0x10]
 801b8b2: 60fb         	str	r3, [r7, #0xc]
; 	const struct spi_stm32_config *cfg = dev->config;
 801b8b4: 687b         	ldr	r3, [r7, #0x4]
 801b8b6: 685b         	ldr	r3, [r3, #0x4]
 801b8b8: 60bb         	str	r3, [r7, #0x8]
; 	spi_context_unlock_unconditionally(&data->ctx);
 801b8ba: 68fb         	ldr	r3, [r7, #0xc]
 801b8bc: 4618         	mov	r0, r3
 801b8be: f7ff fe6a    	bl	0x801b596 <spi_context_unlock_unconditionally> @ imm = #-0x32c
; 	ll_func_disable_spi(cfg->spi);
 801b8c2: 68bb         	ldr	r3, [r7, #0x8]
 801b8c4: 681b         	ldr	r3, [r3]
 801b8c6: 4618         	mov	r0, r3
 801b8c8: f7ff fee3    	bl	0x801b692 <ll_func_disable_spi> @ imm = #-0x23a
; 	return 0;
 801b8cc: 2300         	movs	r3, #0x0
; }
 801b8ce: 4618         	mov	r0, r3
 801b8d0: 3710         	adds	r7, #0x10
 801b8d2: 46bd         	mov	sp, r7
 801b8d4: bd80         	pop	{r7, pc}

0801b8d6 <transceive>:
; {
 801b8d6: b580         	push	{r7, lr}
 801b8d8: b08a         	sub	sp, #0x28
 801b8da: af02         	add	r7, sp, #0x8
 801b8dc: 60f8         	str	r0, [r7, #0xc]
 801b8de: 60b9         	str	r1, [r7, #0x8]
 801b8e0: 607a         	str	r2, [r7, #0x4]
 801b8e2: 603b         	str	r3, [r7]
; 	const struct spi_stm32_config *cfg = dev->config;
 801b8e4: 68fb         	ldr	r3, [r7, #0xc]
 801b8e6: 685b         	ldr	r3, [r3, #0x4]
 801b8e8: 61bb         	str	r3, [r7, #0x18]
; 	struct spi_stm32_data *data = dev->data;
 801b8ea: 68fb         	ldr	r3, [r7, #0xc]
 801b8ec: 691b         	ldr	r3, [r3, #0x10]
 801b8ee: 617b         	str	r3, [r7, #0x14]
; 	SPI_TypeDef *spi = cfg->spi;
 801b8f0: 69bb         	ldr	r3, [r7, #0x18]
 801b8f2: 681b         	ldr	r3, [r3]
 801b8f4: 613b         	str	r3, [r7, #0x10]
; 	if (!tx_bufs && !rx_bufs) {
 801b8f6: 687b         	ldr	r3, [r7, #0x4]
 801b8f8: 2b00         	cmp	r3, #0x0
 801b8fa: d104         	bne	0x801b906 <transceive+0x30> @ imm = #0x8
 801b8fc: 683b         	ldr	r3, [r7]
 801b8fe: 2b00         	cmp	r3, #0x0
 801b900: d101         	bne	0x801b906 <transceive+0x30> @ imm = #0x2
; 		return 0;
 801b902: 2300         	movs	r3, #0x0
 801b904: e04f         	b	0x801b9a6 <transceive+0xd0> @ imm = #0x9e
; 	if (asynchronous) {
 801b906: f897 3028    	ldrb.w	r3, [r7, #0x28]
 801b90a: 2b00         	cmp	r3, #0x0
 801b90c: d002         	beq	0x801b914 <transceive+0x3e> @ imm = #0x4
; 		return -ENOTSUP;
 801b90e: f06f 0385    	mvn	r3, #0x85
 801b912: e048         	b	0x801b9a6 <transceive+0xd0> @ imm = #0x90
; 	spi_context_lock(&data->ctx, asynchronous, cb, userdata, config);
 801b914: 6978         	ldr	r0, [r7, #0x14]
 801b916: f897 1028    	ldrb.w	r1, [r7, #0x28]
 801b91a: 68bb         	ldr	r3, [r7, #0x8]
 801b91c: 9300         	str	r3, [sp]
 801b91e: 6b3b         	ldr	r3, [r7, #0x30]
 801b920: 6afa         	ldr	r2, [r7, #0x2c]
 801b922: f7ff fda0    	bl	0x801b466 <spi_context_lock> @ imm = #-0x4c0
; 	spi_stm32_pm_policy_state_lock_get(dev);
 801b926: 68f8         	ldr	r0, [r7, #0xc]
 801b928: f7ff fec6    	bl	0x801b6b8 <spi_stm32_pm_policy_state_lock_get> @ imm = #-0x274
; 	ret = spi_stm32_configure(dev, config);
 801b92c: 68b9         	ldr	r1, [r7, #0x8]
 801b92e: 68f8         	ldr	r0, [r7, #0xc]
 801b930: f7f0 fc42    	bl	0x800c1b8 <spi_stm32_configure> @ imm = #-0xf77c
 801b934: 61f8         	str	r0, [r7, #0x1c]
; 	if (ret) {
 801b936: 69fb         	ldr	r3, [r7, #0x1c]
 801b938: 2b00         	cmp	r3, #0x0
 801b93a: d12d         	bne	0x801b998 <transceive+0xc2> @ imm = #0x5a
; 	if (SPI_WORD_SIZE_GET(config->operation) == 8) {
 801b93c: 68bb         	ldr	r3, [r7, #0x8]
 801b93e: 889b         	ldrh	r3, [r3, #0x4]
 801b940: 095b         	lsrs	r3, r3, #0x5
 801b942: f003 033f    	and	r3, r3, #0x3f
 801b946: 2b08         	cmp	r3, #0x8
 801b948: d106         	bne	0x801b958 <transceive+0x82> @ imm = #0xc
; 		spi_context_buffers_setup(&data->ctx, tx_bufs, rx_bufs, 1);
 801b94a: 6978         	ldr	r0, [r7, #0x14]
 801b94c: 2301         	movs	r3, #0x1
 801b94e: 683a         	ldr	r2, [r7]
 801b950: 6879         	ldr	r1, [r7, #0x4]
 801b952: f7ef fda1    	bl	0x800b498 <spi_context_buffers_setup> @ imm = #-0x104be
 801b956: e005         	b	0x801b964 <transceive+0x8e> @ imm = #0xa
; 		spi_context_buffers_setup(&data->ctx, tx_bufs, rx_bufs, 2);
 801b958: 6978         	ldr	r0, [r7, #0x14]
 801b95a: 2302         	movs	r3, #0x2
 801b95c: 683a         	ldr	r2, [r7]
 801b95e: 6879         	ldr	r1, [r7, #0x4]
 801b960: f7ef fd9a    	bl	0x800b498 <spi_context_buffers_setup> @ imm = #-0x104cc
; 	LL_SPI_Enable(spi);
 801b964: 6938         	ldr	r0, [r7, #0x10]
 801b966: f7ff fa23    	bl	0x801adb0 <LL_SPI_Enable> @ imm = #-0xbba
; 	spi_stm32_cs_control(dev, true);
 801b96a: 2101         	movs	r1, #0x1
 801b96c: 68f8         	ldr	r0, [r7, #0xc]
 801b96e: f7ff ff4c    	bl	0x801b80a <spi_stm32_cs_control> @ imm = #-0x168
; 		ret = spi_stm32_shift_frames(cfg, data);
 801b972: 6979         	ldr	r1, [r7, #0x14]
 801b974: 69b8         	ldr	r0, [r7, #0x18]
 801b976: f7ff ff25    	bl	0x801b7c4 <spi_stm32_shift_frames> @ imm = #-0x1b6
 801b97a: 61f8         	str	r0, [r7, #0x1c]
; 	} while (!ret && spi_stm32_transfer_ongoing(data));
 801b97c: 69fb         	ldr	r3, [r7, #0x1c]
 801b97e: 2b00         	cmp	r3, #0x0
 801b980: d105         	bne	0x801b98e <transceive+0xb8> @ imm = #0xa
 801b982: 6978         	ldr	r0, [r7, #0x14]
 801b984: f7ff feaa    	bl	0x801b6dc <spi_stm32_transfer_ongoing> @ imm = #-0x2ac
 801b988: 4603         	mov	r3, r0
 801b98a: 2b00         	cmp	r3, #0x0
 801b98c: d1f1         	bne	0x801b972 <transceive+0x9c> @ imm = #-0x1e
; 	spi_stm32_complete(dev, ret);
 801b98e: 69f9         	ldr	r1, [r7, #0x1c]
 801b990: 68f8         	ldr	r0, [r7, #0xc]
 801b992: f7ff ff4d    	bl	0x801b830 <spi_stm32_complete> @ imm = #-0x166
 801b996: e000         	b	0x801b99a <transceive+0xc4> @ imm = #0x0
; 		goto end;
 801b998: bf00         	nop
; 	spi_context_release(&data->ctx, ret);
 801b99a: 697b         	ldr	r3, [r7, #0x14]
 801b99c: 69f9         	ldr	r1, [r7, #0x1c]
 801b99e: 4618         	mov	r0, r3
 801b9a0: f7ff fd8d    	bl	0x801b4be <spi_context_release> @ imm = #-0x4e6
; 	return ret;
 801b9a4: 69fb         	ldr	r3, [r7, #0x1c]
; }
 801b9a6: 4618         	mov	r0, r3
 801b9a8: 3720         	adds	r7, #0x20
 801b9aa: 46bd         	mov	sp, r7
 801b9ac: bd80         	pop	{r7, pc}

0801b9ae <spi_stm32_transceive>:
; {
 801b9ae: b580         	push	{r7, lr}
 801b9b0: b088         	sub	sp, #0x20
 801b9b2: af04         	add	r7, sp, #0x10
 801b9b4: 60f8         	str	r0, [r7, #0xc]
 801b9b6: 60b9         	str	r1, [r7, #0x8]
 801b9b8: 607a         	str	r2, [r7, #0x4]
 801b9ba: 603b         	str	r3, [r7]
; 	return transceive(dev, config, tx_bufs, rx_bufs, false, NULL, NULL);
 801b9bc: 2300         	movs	r3, #0x0
 801b9be: 9302         	str	r3, [sp, #0x8]
 801b9c0: 2300         	movs	r3, #0x0
 801b9c2: 9301         	str	r3, [sp, #0x4]
 801b9c4: 2300         	movs	r3, #0x0
 801b9c6: 9300         	str	r3, [sp]
 801b9c8: 683b         	ldr	r3, [r7]
 801b9ca: 687a         	ldr	r2, [r7, #0x4]
 801b9cc: 68b9         	ldr	r1, [r7, #0x8]
 801b9ce: 68f8         	ldr	r0, [r7, #0xc]
 801b9d0: f7ff ff81    	bl	0x801b8d6 <transceive>  @ imm = #-0xfe
 801b9d4: 4603         	mov	r3, r0
; }
 801b9d6: 4618         	mov	r0, r3
 801b9d8: 3710         	adds	r7, #0x10
 801b9da: 46bd         	mov	sp, r7
 801b9dc: bd80         	pop	{r7, pc}

0801b9de <spi_stm32_is_subghzspi>:
; {
 801b9de: b480         	push	{r7}
 801b9e0: b083         	sub	sp, #0xc
 801b9e2: af00         	add	r7, sp, #0x0
 801b9e4: 6078         	str	r0, [r7, #0x4]
; 	return false;
 801b9e6: 2300         	movs	r3, #0x0
; }
 801b9e8: 4618         	mov	r0, r3
 801b9ea: 370c         	adds	r7, #0xc
 801b9ec: 46bd         	mov	sp, r7
 801b9ee: bc80         	pop	{r7}
 801b9f0: 4770         	bx	lr

0801b9f2 <LL_DMA_Init>:
; {
 801b9f2: b580         	push	{r7, lr}
 801b9f4: b084         	sub	sp, #0x10
 801b9f6: af00         	add	r7, sp, #0x0
 801b9f8: 60f8         	str	r0, [r7, #0xc]
 801b9fa: 60b9         	str	r1, [r7, #0x8]
 801b9fc: 607a         	str	r2, [r7, #0x4]
;   LL_DMA_ConfigTransfer(DMAx, Stream, DMA_InitStruct->Direction | \
 801b9fe: 687b         	ldr	r3, [r7, #0x4]
 801ba00: 689a         	ldr	r2, [r3, #0x8]
;                         DMA_InitStruct->Mode                    | \
 801ba02: 687b         	ldr	r3, [r7, #0x4]
 801ba04: 68db         	ldr	r3, [r3, #0xc]
;   LL_DMA_ConfigTransfer(DMAx, Stream, DMA_InitStruct->Direction | \
 801ba06: 431a         	orrs	r2, r3
;                         DMA_InitStruct->PeriphOrM2MSrcIncMode   | \
 801ba08: 687b         	ldr	r3, [r7, #0x4]
 801ba0a: 691b         	ldr	r3, [r3, #0x10]
;                         DMA_InitStruct->Mode                    | \
 801ba0c: 431a         	orrs	r2, r3
;                         DMA_InitStruct->MemoryOrM2MDstIncMode   | \
 801ba0e: 687b         	ldr	r3, [r7, #0x4]
 801ba10: 695b         	ldr	r3, [r3, #0x14]
;                         DMA_InitStruct->PeriphOrM2MSrcIncMode   | \
 801ba12: 431a         	orrs	r2, r3
;                         DMA_InitStruct->PeriphOrM2MSrcDataSize  | \
 801ba14: 687b         	ldr	r3, [r7, #0x4]
 801ba16: 699b         	ldr	r3, [r3, #0x18]
;                         DMA_InitStruct->MemoryOrM2MDstIncMode   | \
 801ba18: 431a         	orrs	r2, r3
;                         DMA_InitStruct->MemoryOrM2MDstDataSize  | \
 801ba1a: 687b         	ldr	r3, [r7, #0x4]
 801ba1c: 69db         	ldr	r3, [r3, #0x1c]
;                         DMA_InitStruct->PeriphOrM2MSrcDataSize  | \
 801ba1e: 431a         	orrs	r2, r3
;                         DMA_InitStruct->Priority
 801ba20: 687b         	ldr	r3, [r7, #0x4]
 801ba22: 6a9b         	ldr	r3, [r3, #0x28]
;   LL_DMA_ConfigTransfer(DMAx, Stream, DMA_InitStruct->Direction | \
 801ba24: 4313         	orrs	r3, r2
 801ba26: 461a         	mov	r2, r3
 801ba28: 68b9         	ldr	r1, [r7, #0x8]
 801ba2a: 68f8         	ldr	r0, [r7, #0xc]
 801ba2c: f7f1 fbce    	bl	0x800d1cc <LL_DMA_ConfigTransfer> @ imm = #-0xe864
;   if(DMA_InitStruct->FIFOMode != LL_DMA_FIFOMODE_DISABLE)
 801ba30: 687b         	ldr	r3, [r7, #0x4]
 801ba32: 6adb         	ldr	r3, [r3, #0x2c]
 801ba34: 2b00         	cmp	r3, #0x0
 801ba36: d015         	beq	0x801ba64 <LL_DMA_Init+0x72> @ imm = #0x2a
;     LL_DMA_ConfigFifo(DMAx, Stream, DMA_InitStruct->FIFOMode, DMA_InitStruct->FIFOThreshold);
 801ba38: 687b         	ldr	r3, [r7, #0x4]
 801ba3a: 6ada         	ldr	r2, [r3, #0x2c]
 801ba3c: 687b         	ldr	r3, [r7, #0x4]
 801ba3e: 6b1b         	ldr	r3, [r3, #0x30]
 801ba40: 68b9         	ldr	r1, [r7, #0x8]
 801ba42: 68f8         	ldr	r0, [r7, #0xc]
 801ba44: f7f1 fc6e    	bl	0x800d324 <LL_DMA_ConfigFifo> @ imm = #-0xe724
;     LL_DMA_SetMemoryBurstxfer(DMAx,Stream,DMA_InitStruct->MemBurst);
 801ba48: 687b         	ldr	r3, [r7, #0x4]
 801ba4a: 6b5b         	ldr	r3, [r3, #0x34]
 801ba4c: 461a         	mov	r2, r3
 801ba4e: 68b9         	ldr	r1, [r7, #0x8]
 801ba50: 68f8         	ldr	r0, [r7, #0xc]
 801ba52: f7f1 fc23    	bl	0x800d29c <LL_DMA_SetMemoryBurstxfer> @ imm = #-0xe7ba
;     LL_DMA_SetPeriphBurstxfer(DMAx,Stream,DMA_InitStruct->PeriphBurst);
 801ba56: 687b         	ldr	r3, [r7, #0x4]
 801ba58: 6b9b         	ldr	r3, [r3, #0x38]
 801ba5a: 461a         	mov	r2, r3
 801ba5c: 68b9         	ldr	r1, [r7, #0x8]
 801ba5e: 68f8         	ldr	r0, [r7, #0xc]
 801ba60: f7f1 fc3e    	bl	0x800d2e0 <LL_DMA_SetPeriphBurstxfer> @ imm = #-0xe784
;   LL_DMA_SetMemoryAddress(DMAx, Stream, DMA_InitStruct->MemoryOrM2MDstAddress);
 801ba64: 687b         	ldr	r3, [r7, #0x4]
 801ba66: 685b         	ldr	r3, [r3, #0x4]
 801ba68: 461a         	mov	r2, r3
 801ba6a: 68b9         	ldr	r1, [r7, #0x8]
 801ba6c: 68f8         	ldr	r0, [r7, #0xc]
 801ba6e: f7f1 fc7d    	bl	0x800d36c <LL_DMA_SetMemoryAddress> @ imm = #-0xe706
;   LL_DMA_SetPeriphAddress(DMAx, Stream, DMA_InitStruct->PeriphOrM2MSrcAddress);
 801ba72: 687b         	ldr	r3, [r7, #0x4]
 801ba74: 681b         	ldr	r3, [r3]
 801ba76: 461a         	mov	r2, r3
 801ba78: 68b9         	ldr	r1, [r7, #0x8]
 801ba7a: 68f8         	ldr	r0, [r7, #0xc]
 801ba7c: f7f1 fc8e    	bl	0x800d39c <LL_DMA_SetPeriphAddress> @ imm = #-0xe6e4
;   LL_DMA_SetDataLength(DMAx, Stream, DMA_InitStruct->NbData);
 801ba80: 687b         	ldr	r3, [r7, #0x4]
 801ba82: 6a1b         	ldr	r3, [r3, #0x20]
 801ba84: 461a         	mov	r2, r3
 801ba86: 68b9         	ldr	r1, [r7, #0x8]
 801ba88: 68f8         	ldr	r0, [r7, #0xc]
 801ba8a: f7f1 fbc3    	bl	0x800d214 <LL_DMA_SetDataLength> @ imm = #-0xe87a
;   LL_DMA_SetChannelSelection(DMAx, Stream, DMA_InitStruct->Channel);
 801ba8e: 687b         	ldr	r3, [r7, #0x4]
 801ba90: 6a5b         	ldr	r3, [r3, #0x24]
 801ba92: 461a         	mov	r2, r3
 801ba94: 68b9         	ldr	r1, [r7, #0x8]
 801ba96: 68f8         	ldr	r0, [r7, #0xc]
 801ba98: f7f1 fbde    	bl	0x800d258 <LL_DMA_SetChannelSelection> @ imm = #-0xe844
;   return SUCCESS;
 801ba9c: 2300         	movs	r3, #0x0
; }
 801ba9e: 4618         	mov	r0, r3
 801baa0: 3710         	adds	r7, #0x10
 801baa2: 46bd         	mov	sp, r7
 801baa4: bd80         	pop	{r7, pc}

0801baa6 <LL_DMA_StructInit>:
; {
 801baa6: b480         	push	{r7}
 801baa8: b083         	sub	sp, #0xc
 801baaa: af00         	add	r7, sp, #0x0
 801baac: 6078         	str	r0, [r7, #0x4]
;   DMA_InitStruct->PeriphOrM2MSrcAddress  = 0x00000000U;
 801baae: 687b         	ldr	r3, [r7, #0x4]
 801bab0: 2200         	movs	r2, #0x0
 801bab2: 601a         	str	r2, [r3]
;   DMA_InitStruct->MemoryOrM2MDstAddress  = 0x00000000U;
 801bab4: 687b         	ldr	r3, [r7, #0x4]
 801bab6: 2200         	movs	r2, #0x0
 801bab8: 605a         	str	r2, [r3, #0x4]
;   DMA_InitStruct->Direction              = LL_DMA_DIRECTION_PERIPH_TO_MEMORY;
 801baba: 687b         	ldr	r3, [r7, #0x4]
 801babc: 2200         	movs	r2, #0x0
 801babe: 609a         	str	r2, [r3, #0x8]
;   DMA_InitStruct->Mode                   = LL_DMA_MODE_NORMAL;
 801bac0: 687b         	ldr	r3, [r7, #0x4]
 801bac2: 2200         	movs	r2, #0x0
 801bac4: 60da         	str	r2, [r3, #0xc]
;   DMA_InitStruct->PeriphOrM2MSrcIncMode  = LL_DMA_PERIPH_NOINCREMENT;
 801bac6: 687b         	ldr	r3, [r7, #0x4]
 801bac8: 2200         	movs	r2, #0x0
 801baca: 611a         	str	r2, [r3, #0x10]
;   DMA_InitStruct->MemoryOrM2MDstIncMode  = LL_DMA_MEMORY_NOINCREMENT;
 801bacc: 687b         	ldr	r3, [r7, #0x4]
 801bace: 2200         	movs	r2, #0x0
 801bad0: 615a         	str	r2, [r3, #0x14]
;   DMA_InitStruct->PeriphOrM2MSrcDataSize = LL_DMA_PDATAALIGN_BYTE;
 801bad2: 687b         	ldr	r3, [r7, #0x4]
 801bad4: 2200         	movs	r2, #0x0
 801bad6: 619a         	str	r2, [r3, #0x18]
;   DMA_InitStruct->MemoryOrM2MDstDataSize = LL_DMA_MDATAALIGN_BYTE;
 801bad8: 687b         	ldr	r3, [r7, #0x4]
 801bada: 2200         	movs	r2, #0x0
 801badc: 61da         	str	r2, [r3, #0x1c]
;   DMA_InitStruct->NbData                 = 0x00000000U;
 801bade: 687b         	ldr	r3, [r7, #0x4]
 801bae0: 2200         	movs	r2, #0x0
 801bae2: 621a         	str	r2, [r3, #0x20]
;   DMA_InitStruct->Channel                = LL_DMA_CHANNEL_0;
 801bae4: 687b         	ldr	r3, [r7, #0x4]
 801bae6: 2200         	movs	r2, #0x0
 801bae8: 625a         	str	r2, [r3, #0x24]
;   DMA_InitStruct->Priority               = LL_DMA_PRIORITY_LOW;
 801baea: 687b         	ldr	r3, [r7, #0x4]
 801baec: 2200         	movs	r2, #0x0
 801baee: 629a         	str	r2, [r3, #0x28]
;   DMA_InitStruct->FIFOMode               = LL_DMA_FIFOMODE_DISABLE;
 801baf0: 687b         	ldr	r3, [r7, #0x4]
 801baf2: 2200         	movs	r2, #0x0
 801baf4: 62da         	str	r2, [r3, #0x2c]
;   DMA_InitStruct->FIFOThreshold          = LL_DMA_FIFOTHRESHOLD_1_4;
 801baf6: 687b         	ldr	r3, [r7, #0x4]
 801baf8: 2200         	movs	r2, #0x0
 801bafa: 631a         	str	r2, [r3, #0x30]
;   DMA_InitStruct->MemBurst               = LL_DMA_MBURST_SINGLE;
 801bafc: 687b         	ldr	r3, [r7, #0x4]
 801bafe: 2200         	movs	r2, #0x0
 801bb00: 635a         	str	r2, [r3, #0x34]
;   DMA_InitStruct->PeriphBurst            = LL_DMA_PBURST_SINGLE;
 801bb02: 687b         	ldr	r3, [r7, #0x4]
 801bb04: 2200         	movs	r2, #0x0
 801bb06: 639a         	str	r2, [r3, #0x38]
; }
 801bb08: bf00         	nop
 801bb0a: 370c         	adds	r7, #0xc
 801bb0c: 46bd         	mov	sp, r7
 801bb0e: bc80         	pop	{r7}
 801bb10: 4770         	bx	lr

0801bb12 <arch_k_cycle_get_32>:
; {
 801bb12: b580         	push	{r7, lr}
 801bb14: af00         	add	r7, sp, #0x0
; 	return sys_clock_cycle_get_32();
 801bb16: f7f0 ff8f    	bl	0x800ca38 <sys_clock_cycle_get_32> @ imm = #-0xf0e2
 801bb1a: 4603         	mov	r3, r0
; }
 801bb1c: 4618         	mov	r0, r3
 801bb1e: bd80         	pop	{r7, pc}

0801bb20 <k_cycle_get_32>:
; {
 801bb20: b580         	push	{r7, lr}
 801bb22: af00         	add	r7, sp, #0x0
; 	return arch_k_cycle_get_32();
 801bb24: f7ff fff5    	bl	0x801bb12 <arch_k_cycle_get_32> @ imm = #-0x16
 801bb28: 4603         	mov	r3, r0
; }
 801bb2a: 4618         	mov	r0, r3
 801bb2c: bd80         	pop	{r7, pc}

0801bb2e <z_impl_k_busy_wait>:
; {
 801bb2e: b580         	push	{r7, lr}
 801bb30: b086         	sub	sp, #0x18
 801bb32: af00         	add	r7, sp, #0x0
 801bb34: 6078         	str	r0, [r7, #0x4]
; 	if (usec_to_wait == 0U) {
 801bb36: 687b         	ldr	r3, [r7, #0x4]
 801bb38: 2b00         	cmp	r3, #0x0
 801bb3a: d011         	beq	0x801bb60 <z_impl_k_busy_wait+0x32> @ imm = #0x22
; 	uint32_t start_cycles = k_cycle_get_32();
 801bb3c: f7ff fff0    	bl	0x801bb20 <k_cycle_get_32> @ imm = #-0x20
 801bb40: 6178         	str	r0, [r7, #0x14]
; 	uint32_t cycles_to_wait = k_us_to_cyc_ceil32(usec_to_wait);
 801bb42: 687b         	ldr	r3, [r7, #0x4]
 801bb44: 22a8         	movs	r2, #0xa8
 801bb46: fb02 f303    	mul	r3, r2, r3
 801bb4a: 613b         	str	r3, [r7, #0x10]
; 		uint32_t current_cycles = k_cycle_get_32();
 801bb4c: f7ff ffe8    	bl	0x801bb20 <k_cycle_get_32> @ imm = #-0x30
 801bb50: 60f8         	str	r0, [r7, #0xc]
; 		if ((current_cycles - start_cycles) >= cycles_to_wait) {
 801bb52: 68fa         	ldr	r2, [r7, #0xc]
 801bb54: 697b         	ldr	r3, [r7, #0x14]
 801bb56: 1ad3         	subs	r3, r2, r3
 801bb58: 693a         	ldr	r2, [r7, #0x10]
 801bb5a: 429a         	cmp	r2, r3
 801bb5c: d902         	bls	0x801bb64 <z_impl_k_busy_wait+0x36> @ imm = #0x4
; 	for (;;) {
 801bb5e: e7f5         	b	0x801bb4c <z_impl_k_busy_wait+0x1e> @ imm = #-0x16
; 		return;
 801bb60: bf00         	nop
 801bb62: e000         	b	0x801bb66 <z_impl_k_busy_wait+0x38> @ imm = #0x0
; 			break;
 801bb64: bf00         	nop
; }
 801bb66: 3718         	adds	r7, #0x18
 801bb68: 46bd         	mov	sp, r7
 801bb6a: bd80         	pop	{r7, pc}

0801bb6c <k_object_init>:
; {
 801bb6c: b480         	push	{r7}
 801bb6e: b083         	sub	sp, #0xc
 801bb70: af00         	add	r7, sp, #0x0
 801bb72: 6078         	str	r0, [r7, #0x4]
; }
 801bb74: bf00         	nop
 801bb76: 370c         	adds	r7, #0xc
 801bb78: 46bd         	mov	sp, r7
 801bb7a: bc80         	pop	{r7}
 801bb7c: 4770         	bx	lr

0801bb7e <z_impl_device_is_ready>:
; {
 801bb7e: b480         	push	{r7}
 801bb80: b083         	sub	sp, #0xc
 801bb82: af00         	add	r7, sp, #0x0
 801bb84: 6078         	str	r0, [r7, #0x4]
; 	if (dev == NULL) {
 801bb86: 687b         	ldr	r3, [r7, #0x4]
 801bb88: 2b00         	cmp	r3, #0x0
 801bb8a: d101         	bne	0x801bb90 <z_impl_device_is_ready+0x12> @ imm = #0x2
; 		return false;
 801bb8c: 2300         	movs	r3, #0x0
 801bb8e: e012         	b	0x801bbb6 <z_impl_device_is_ready+0x38> @ imm = #0x24
; 	return dev->state->initialized && (dev->state->init_res == 0U);
 801bb90: 687b         	ldr	r3, [r7, #0x4]
 801bb92: 68db         	ldr	r3, [r3, #0xc]
 801bb94: 785b         	ldrb	r3, [r3, #0x1]
 801bb96: f003 0301    	and	r3, r3, #0x1
 801bb9a: b2db         	uxtb	r3, r3
 801bb9c: 2b00         	cmp	r3, #0x0
 801bb9e: d006         	beq	0x801bbae <z_impl_device_is_ready+0x30> @ imm = #0xc
 801bba0: 687b         	ldr	r3, [r7, #0x4]
 801bba2: 68db         	ldr	r3, [r3, #0xc]
 801bba4: 781b         	ldrb	r3, [r3]
 801bba6: 2b00         	cmp	r3, #0x0
 801bba8: d101         	bne	0x801bbae <z_impl_device_is_ready+0x30> @ imm = #0x2
 801bbaa: 2301         	movs	r3, #0x1
 801bbac: e000         	b	0x801bbb0 <z_impl_device_is_ready+0x32> @ imm = #0x0
 801bbae: 2300         	movs	r3, #0x0
 801bbb0: f003 0301    	and	r3, r3, #0x1
 801bbb4: b2db         	uxtb	r3, r3
; }
 801bbb6: 4618         	mov	r0, r3
 801bbb8: 370c         	adds	r7, #0xc
 801bbba: 46bd         	mov	sp, r7
 801bbbc: bc80         	pop	{r7}
 801bbbe: 4770         	bx	lr

0801bbc0 <k_thread_abort>:
; {
 801bbc0: b580         	push	{r7, lr}
 801bbc2: b082         	sub	sp, #0x8
 801bbc4: af00         	add	r7, sp, #0x0
 801bbc6: 6078         	str	r0, [r7, #0x4]
; 	z_impl_k_thread_abort(thread);
 801bbc8: 6878         	ldr	r0, [r7, #0x4]
 801bbca: f7ea f86f    	bl	0x8005cac <z_impl_k_thread_abort> @ imm = #-0x15f22
; }
 801bbce: bf00         	nop
 801bbd0: 3708         	adds	r7, #0x8
 801bbd2: 46bd         	mov	sp, r7
 801bbd4: bd80         	pop	{r7, pc}

0801bbd6 <z_log_msg_runtime_create>:
; {
 801bbd6: b580         	push	{r7, lr}
 801bbd8: b08a         	sub	sp, #0x28
 801bbda: af04         	add	r7, sp, #0x10
 801bbdc: 60b9         	str	r1, [r7, #0x8]
 801bbde: 607b         	str	r3, [r7, #0x4]
 801bbe0: 4603         	mov	r3, r0
 801bbe2: 73fb         	strb	r3, [r7, #0xf]
 801bbe4: 4613         	mov	r3, r2
 801bbe6: 73bb         	strb	r3, [r7, #0xe]
; 	va_start(ap, fmt);
 801bbe8: f107 032c    	add.w	r3, r7, #0x2c
 801bbec: 617b         	str	r3, [r7, #0x14]
; 	z_log_msg_runtime_vcreate(domain_id, source, level,
 801bbee: 7bba         	ldrb	r2, [r7, #0xe]
 801bbf0: 7bf8         	ldrb	r0, [r7, #0xf]
 801bbf2: 697b         	ldr	r3, [r7, #0x14]
 801bbf4: 9303         	str	r3, [sp, #0xc]
 801bbf6: 6abb         	ldr	r3, [r7, #0x28]
 801bbf8: 9302         	str	r3, [sp, #0x8]
 801bbfa: 6a7b         	ldr	r3, [r7, #0x24]
 801bbfc: 9301         	str	r3, [sp, #0x4]
 801bbfe: 6a3b         	ldr	r3, [r7, #0x20]
 801bc00: 9300         	str	r3, [sp]
 801bc02: 687b         	ldr	r3, [r7, #0x4]
 801bc04: 68b9         	ldr	r1, [r7, #0x8]
 801bc06: f7e8 fcb3    	bl	0x8004570 <z_log_msg_runtime_vcreate> @ imm = #-0x1769a
; }
 801bc0a: bf00         	nop
 801bc0c: 3718         	adds	r7, #0x18
 801bc0e: 46bd         	mov	sp, r7
 801bc10: bd80         	pop	{r7, pc}

0801bc12 <log_panic>:
; {
 801bc12: b580         	push	{r7, lr}
 801bc14: af00         	add	r7, sp, #0x0
; 	z_impl_log_panic();
 801bc16: f7e8 fb31    	bl	0x800427c <z_impl_log_panic> @ imm = #-0x1799e
; }
 801bc1a: bf00         	nop
 801bc1c: bd80         	pop	{r7, pc}

0801bc1e <coredump>:
; {
 801bc1e: b480         	push	{r7}
 801bc20: b085         	sub	sp, #0x14
 801bc22: af00         	add	r7, sp, #0x0
 801bc24: 60f8         	str	r0, [r7, #0xc]
 801bc26: 60b9         	str	r1, [r7, #0x8]
 801bc28: 607a         	str	r2, [r7, #0x4]
; }
 801bc2a: bf00         	nop
 801bc2c: 3714         	adds	r7, #0x14
 801bc2e: 46bd         	mov	sp, r7
 801bc30: bc80         	pop	{r7}
 801bc32: 4770         	bx	lr

0801bc34 <arch_system_halt>:
; {
 801bc34: b480         	push	{r7}
 801bc36: b087         	sub	sp, #0x1c
 801bc38: af00         	add	r7, sp, #0x0
 801bc3a: 6078         	str	r0, [r7, #0x4]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 801bc3c: f3ef 8311    	mrs	r3, basepri
 801bc40: 617b         	str	r3, [r7, #0x14]
;   return(result);
 801bc42: 697b         	ldr	r3, [r7, #0x14]
; 	key = __get_BASEPRI();
 801bc44: 613b         	str	r3, [r7, #0x10]
 801bc46: 2310         	movs	r3, #0x10
 801bc48: 60fb         	str	r3, [r7, #0xc]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 801bc4a: 68fb         	ldr	r3, [r7, #0xc]
 801bc4c: f383 8812    	msr	basepri_max, r3
; }
 801bc50: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 801bc52: f3bf 8f6f    	isb	sy
; }
 801bc56: bf00         	nop
; 	for (;;) {
 801bc58: bf00         	nop
 801bc5a: e7fd         	b	0x801bc58 <arch_system_halt+0x24> @ imm = #-0x6

0801bc5c <K_KERNEL_STACK_BUFFER>:
; {
 801bc5c: b480         	push	{r7}
 801bc5e: b083         	sub	sp, #0xc
 801bc60: af00         	add	r7, sp, #0x0
 801bc62: 6078         	str	r0, [r7, #0x4]
; 	return (char *)sym + K_KERNEL_STACK_RESERVED;
 801bc64: 687b         	ldr	r3, [r7, #0x4]
; }
 801bc66: 4618         	mov	r0, r3
 801bc68: 370c         	adds	r7, #0xc
 801bc6a: 46bd         	mov	sp, r7
 801bc6c: bc80         	pop	{r7}
 801bc6e: 4770         	bx	lr

0801bc70 <k_thread_start>:
; {
 801bc70: b580         	push	{r7, lr}
 801bc72: b082         	sub	sp, #0x8
 801bc74: af00         	add	r7, sp, #0x0
 801bc76: 6078         	str	r0, [r7, #0x4]
; 	k_thread_resume(thread);
 801bc78: 6878         	ldr	r0, [r7, #0x4]
 801bc7a: f000 f804    	bl	0x801bc86 <k_thread_resume> @ imm = #0x8
; }
 801bc7e: bf00         	nop
 801bc80: 3708         	adds	r7, #0x8
 801bc82: 46bd         	mov	sp, r7
 801bc84: bd80         	pop	{r7, pc}

0801bc86 <k_thread_resume>:
; {
 801bc86: b580         	push	{r7, lr}
 801bc88: b082         	sub	sp, #0x8
 801bc8a: af00         	add	r7, sp, #0x0
 801bc8c: 6078         	str	r0, [r7, #0x4]
; 	z_impl_k_thread_resume(thread);
 801bc8e: 6878         	ldr	r0, [r7, #0x4]
 801bc90: f7f3 fdbe    	bl	0x800f810 <z_impl_k_thread_resume> @ imm = #-0xc484
; }
 801bc94: bf00         	nop
 801bc96: 3708         	adds	r7, #0x8
 801bc98: 46bd         	mov	sp, r7
 801bc9a: bd80         	pop	{r7, pc}

0801bc9c <thread_schedule_new>:
; {
 801bc9c: b580         	push	{r7, lr}
 801bc9e: b084         	sub	sp, #0x10
 801bca0: af00         	add	r7, sp, #0x0
 801bca2: 60f8         	str	r0, [r7, #0xc]
 801bca4: e9c7 2300    	strd	r2, r3, [r7]
; 	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
 801bca8: e9d7 2300    	ldrd	r2, r3, [r7]
 801bcac: f04f 0000    	mov.w	r0, #0x0
 801bcb0: f04f 0100    	mov.w	r1, #0x0
 801bcb4: 428b         	cmp	r3, r1
 801bcb6: bf08         	it	eq
 801bcb8: 4282         	cmpeq	r2, r0
 801bcba: d103         	bne	0x801bcc4 <thread_schedule_new+0x28> @ imm = #0x6
; 		k_thread_start(thread);
 801bcbc: 68f8         	ldr	r0, [r7, #0xc]
 801bcbe: f7ff ffd7    	bl	0x801bc70 <k_thread_start> @ imm = #-0x52
 801bcc2: e004         	b	0x801bcce <thread_schedule_new+0x32> @ imm = #0x8
; 		z_add_thread_timeout(thread, delay);
 801bcc4: e9d7 2300    	ldrd	r2, r3, [r7]
 801bcc8: 68f8         	ldr	r0, [r7, #0xc]
 801bcca: f7f1 fdbf    	bl	0x800d84c <z_add_thread_timeout> @ imm = #-0xe482
; }
 801bcce: bf00         	nop
 801bcd0: 3710         	adds	r7, #0x10
 801bcd2: 46bd         	mov	sp, r7
 801bcd4: bd80         	pop	{r7, pc}

0801bcd6 <z_mark_thread_as_not_suspended>:
; {
 801bcd6: b480         	push	{r7}
 801bcd8: b083         	sub	sp, #0xc
 801bcda: af00         	add	r7, sp, #0x0
 801bcdc: 6078         	str	r0, [r7, #0x4]
; 	thread->base.thread_state &= ~_THREAD_SUSPENDED;
 801bcde: 687b         	ldr	r3, [r7, #0x4]
 801bce0: 7b5b         	ldrb	r3, [r3, #0xd]
 801bce2: f023 0310    	bic	r3, r3, #0x10
 801bce6: b2da         	uxtb	r2, r3
 801bce8: 687b         	ldr	r3, [r7, #0x4]
 801bcea: 735a         	strb	r2, [r3, #0xd]
; }
 801bcec: bf00         	nop
 801bcee: 370c         	adds	r7, #0xc
 801bcf0: 46bd         	mov	sp, r7
 801bcf2: bc80         	pop	{r7}
 801bcf4: 4770         	bx	lr

0801bcf6 <z_thread_essential_clear>:
; {
 801bcf6: b480         	push	{r7}
 801bcf8: b083         	sub	sp, #0xc
 801bcfa: af00         	add	r7, sp, #0x0
 801bcfc: 6078         	str	r0, [r7, #0x4]
; 	thread->base.user_options &= ~K_ESSENTIAL;
 801bcfe: 687b         	ldr	r3, [r7, #0x4]
 801bd00: 7b1b         	ldrb	r3, [r3, #0xc]
 801bd02: f023 0301    	bic	r3, r3, #0x1
 801bd06: b2da         	uxtb	r2, r3
 801bd08: 687b         	ldr	r3, [r7, #0x4]
 801bd0a: 731a         	strb	r2, [r3, #0xc]
; }
 801bd0c: bf00         	nop
 801bd0e: 370c         	adds	r7, #0xc
 801bd10: 46bd         	mov	sp, r7
 801bd12: bc80         	pop	{r7}
 801bd14: 4770         	bx	lr

0801bd16 <gcov_static_init>:
; static inline void gcov_static_init(void) { }
 801bd16: b480         	push	{r7}
 801bd18: af00         	add	r7, sp, #0x0
 801bd1a: bf00         	nop
 801bd1c: 46bd         	mov	sp, r7
 801bd1e: bc80         	pop	{r7}
 801bd20: 4770         	bx	lr

0801bd22 <pm_device_runtime_auto_enable>:
; {
 801bd22: b480         	push	{r7}
 801bd24: b083         	sub	sp, #0xc
 801bd26: af00         	add	r7, sp, #0x0
 801bd28: 6078         	str	r0, [r7, #0x4]
; 	return 0;
 801bd2a: 2300         	movs	r3, #0x0
; }
 801bd2c: 4618         	mov	r0, r3
 801bd2e: 370c         	adds	r7, #0xc
 801bd30: 46bd         	mov	sp, r7
 801bd32: bc80         	pop	{r7}
 801bd34: 4770         	bx	lr

0801bd36 <z_early_memset>:
; {
 801bd36: b580         	push	{r7, lr}
 801bd38: b084         	sub	sp, #0x10
 801bd3a: af00         	add	r7, sp, #0x0
 801bd3c: 60f8         	str	r0, [r7, #0xc]
 801bd3e: 60b9         	str	r1, [r7, #0x8]
 801bd40: 607a         	str	r2, [r7, #0x4]
; 	(void) memset(dst, c, n);
 801bd42: 687a         	ldr	r2, [r7, #0x4]
 801bd44: 68b9         	ldr	r1, [r7, #0x8]
 801bd46: 68f8         	ldr	r0, [r7, #0xc]
 801bd48: f001 fd50    	bl	0x801d7ec <memset>      @ imm = #0x1aa0
; }
 801bd4c: bf00         	nop
 801bd4e: 3710         	adds	r7, #0x10
 801bd50: 46bd         	mov	sp, r7
 801bd52: bd80         	pop	{r7, pc}

0801bd54 <z_early_memcpy>:
; {
 801bd54: b580         	push	{r7, lr}
 801bd56: b084         	sub	sp, #0x10
 801bd58: af00         	add	r7, sp, #0x0
 801bd5a: 60f8         	str	r0, [r7, #0xc]
 801bd5c: 60b9         	str	r1, [r7, #0x8]
 801bd5e: 607a         	str	r2, [r7, #0x4]
; 	(void) memcpy(dst, src, n);
 801bd60: 687a         	ldr	r2, [r7, #0x4]
 801bd62: 68b9         	ldr	r1, [r7, #0x8]
 801bd64: 68f8         	ldr	r0, [r7, #0xc]
 801bd66: f001 fd33    	bl	0x801d7d0 <memcpy>      @ imm = #0x1a66
; }
 801bd6a: bf00         	nop
 801bd6c: 3710         	adds	r7, #0x10
 801bd6e: 46bd         	mov	sp, r7
 801bd70: bd80         	pop	{r7, pc}

0801bd72 <do_device_init>:
; {
 801bd72: b580         	push	{r7, lr}
 801bd74: b084         	sub	sp, #0x10
 801bd76: af00         	add	r7, sp, #0x0
 801bd78: 6078         	str	r0, [r7, #0x4]
; 	const struct device *dev = entry->dev;
 801bd7a: 687b         	ldr	r3, [r7, #0x4]
 801bd7c: 685b         	ldr	r3, [r3, #0x4]
 801bd7e: 60bb         	str	r3, [r7, #0x8]
; 	int rc = 0;
 801bd80: 2300         	movs	r3, #0x0
 801bd82: 60fb         	str	r3, [r7, #0xc]
; 	if (entry->init_fn.dev != NULL) {
 801bd84: 687b         	ldr	r3, [r7, #0x4]
 801bd86: 681b         	ldr	r3, [r3]
 801bd88: 2b00         	cmp	r3, #0x0
 801bd8a: d017         	beq	0x801bdbc <do_device_init+0x4a> @ imm = #0x2e
; 		rc = entry->init_fn.dev(dev);
 801bd8c: 687b         	ldr	r3, [r7, #0x4]
 801bd8e: 681b         	ldr	r3, [r3]
 801bd90: 68b8         	ldr	r0, [r7, #0x8]
 801bd92: 4798         	blx	r3
 801bd94: 60f8         	str	r0, [r7, #0xc]
; 		if (rc != 0) {
 801bd96: 68fb         	ldr	r3, [r7, #0xc]
 801bd98: 2b00         	cmp	r3, #0x0
 801bd9a: d00f         	beq	0x801bdbc <do_device_init+0x4a> @ imm = #0x1e
; 			if (rc < 0) {
 801bd9c: 68fb         	ldr	r3, [r7, #0xc]
 801bd9e: 2b00         	cmp	r3, #0x0
 801bda0: da02         	bge	0x801bda8 <do_device_init+0x36> @ imm = #0x4
; 				rc = -rc;
 801bda2: 68fb         	ldr	r3, [r7, #0xc]
 801bda4: 425b         	rsbs	r3, r3, #0
 801bda6: 60fb         	str	r3, [r7, #0xc]
; 			if (rc > UINT8_MAX) {
 801bda8: 68fb         	ldr	r3, [r7, #0xc]
 801bdaa: 2bff         	cmp	r3, #0xff
 801bdac: dd01         	ble	0x801bdb2 <do_device_init+0x40> @ imm = #0x2
; 				rc = UINT8_MAX;
 801bdae: 23ff         	movs	r3, #0xff
 801bdb0: 60fb         	str	r3, [r7, #0xc]
; 			dev->state->init_res = rc;
 801bdb2: 68bb         	ldr	r3, [r7, #0x8]
 801bdb4: 68db         	ldr	r3, [r3, #0xc]
 801bdb6: 68fa         	ldr	r2, [r7, #0xc]
 801bdb8: b2d2         	uxtb	r2, r2
 801bdba: 701a         	strb	r2, [r3]
; 	dev->state->initialized = true;
 801bdbc: 68bb         	ldr	r3, [r7, #0x8]
 801bdbe: 68da         	ldr	r2, [r3, #0xc]
 801bdc0: 7853         	ldrb	r3, [r2, #0x1]
 801bdc2: f043 0301    	orr	r3, r3, #0x1
 801bdc6: 7053         	strb	r3, [r2, #0x1]
; 	if (rc == 0) {
 801bdc8: 68fb         	ldr	r3, [r7, #0xc]
 801bdca: 2b00         	cmp	r3, #0x0
 801bdcc: d102         	bne	0x801bdd4 <do_device_init+0x62> @ imm = #0x4
; 		(void)pm_device_runtime_auto_enable(dev);
 801bdce: 68b8         	ldr	r0, [r7, #0x8]
 801bdd0: f7ff ffa7    	bl	0x801bd22 <pm_device_runtime_auto_enable> @ imm = #-0xb2
; 	return rc;
 801bdd4: 68fb         	ldr	r3, [r7, #0xc]
; }
 801bdd6: 4618         	mov	r0, r3
 801bdd8: 3710         	adds	r7, #0x10
 801bdda: 46bd         	mov	sp, r7
 801bddc: bd80         	pop	{r7, pc}

0801bdde <z_init_static>:
; {
 801bdde: b480         	push	{r7}
 801bde0: af00         	add	r7, sp, #0x0
; }
 801bde2: bf00         	nop
 801bde4: 46bd         	mov	sp, r7
 801bde6: bc80         	pop	{r7}
 801bde8: 4770         	bx	lr

0801bdea <k_cpu_idle>:
; {
 801bdea: b580         	push	{r7, lr}
 801bdec: af00         	add	r7, sp, #0x0
; 	arch_cpu_idle();
 801bdee: f7f9 ff0e    	bl	0x8015c0e <arch_cpu_idle> @ imm = #-0x61e4
; }
 801bdf2: bf00         	nop
 801bdf4: bd80         	pop	{r7, pc}

0801bdf6 <idle>:
; {
 801bdf6: b580         	push	{r7, lr}
 801bdf8: b088         	sub	sp, #0x20
 801bdfa: af00         	add	r7, sp, #0x0
 801bdfc: 60f8         	str	r0, [r7, #0xc]
 801bdfe: 60b9         	str	r1, [r7, #0x8]
 801be00: 607a         	str	r2, [r7, #0x4]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 801be02: f3ef 8311    	mrs	r3, basepri
 801be06: 61fb         	str	r3, [r7, #0x1c]
;   return(result);
 801be08: 69fb         	ldr	r3, [r7, #0x1c]
; 	key = __get_BASEPRI();
 801be0a: 61bb         	str	r3, [r7, #0x18]
 801be0c: 2310         	movs	r3, #0x10
 801be0e: 617b         	str	r3, [r7, #0x14]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 801be10: 697b         	ldr	r3, [r7, #0x14]
 801be12: f383 8812    	msr	basepri_max, r3
; }
 801be16: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 801be18: f3bf 8f6f    	isb	sy
; }
 801be1c: bf00         	nop
; 	return key;
 801be1e: bf00         	nop
; 		k_cpu_idle();
 801be20: f7ff ffe3    	bl	0x801bdea <k_cpu_idle>  @ imm = #-0x3a
; 		if (IS_ENABLED(CONFIG_SMP) && !IS_ENABLED(CONFIG_SCHED_IPI_SUPPORTED)) {
 801be24: e7ed         	b	0x801be02 <idle+0xc>    @ imm = #-0x26

0801be26 <arch_spin_relax>:
; {
 801be26: b480         	push	{r7}
 801be28: af00         	add	r7, sp, #0x0
; 	__asm__ volatile("nop");
 801be2a: bf00         	nop
; }
 801be2c: bf00         	nop
; }
 801be2e: bf00         	nop
 801be30: 46bd         	mov	sp, r7
 801be32: bc80         	pop	{r7}
 801be34: 4770         	bx	lr

0801be36 <sys_dnode_init>:
; {
 801be36: b480         	push	{r7}
 801be38: b083         	sub	sp, #0xc
 801be3a: af00         	add	r7, sp, #0x0
 801be3c: 6078         	str	r0, [r7, #0x4]
; 	node->next = NULL;
 801be3e: 687b         	ldr	r3, [r7, #0x4]
 801be40: 2200         	movs	r2, #0x0
 801be42: 601a         	str	r2, [r3]
; 	node->prev = NULL;
 801be44: 687b         	ldr	r3, [r7, #0x4]
 801be46: 2200         	movs	r2, #0x0
 801be48: 605a         	str	r2, [r3, #0x4]
; }
 801be4a: bf00         	nop
 801be4c: 370c         	adds	r7, #0xc
 801be4e: 46bd         	mov	sp, r7
 801be50: bc80         	pop	{r7}
 801be52: 4770         	bx	lr

0801be54 <sys_dnode_is_linked>:
; {
 801be54: b480         	push	{r7}
 801be56: b083         	sub	sp, #0xc
 801be58: af00         	add	r7, sp, #0x0
 801be5a: 6078         	str	r0, [r7, #0x4]
; 	return node->next != NULL;
 801be5c: 687b         	ldr	r3, [r7, #0x4]
 801be5e: 681b         	ldr	r3, [r3]
 801be60: 2b00         	cmp	r3, #0x0
 801be62: bf14         	ite	ne
 801be64: 2301         	movne	r3, #0x1
 801be66: 2300         	moveq	r3, #0x0
 801be68: b2db         	uxtb	r3, r3
; }
 801be6a: 4618         	mov	r0, r3
 801be6c: 370c         	adds	r7, #0xc
 801be6e: 46bd         	mov	sp, r7
 801be70: bc80         	pop	{r7}
 801be72: 4770         	bx	lr

0801be74 <sys_dlist_is_empty>:
; {
 801be74: b480         	push	{r7}
 801be76: b083         	sub	sp, #0xc
 801be78: af00         	add	r7, sp, #0x0
 801be7a: 6078         	str	r0, [r7, #0x4]
; 	return list->head == list;
 801be7c: 687b         	ldr	r3, [r7, #0x4]
 801be7e: 681b         	ldr	r3, [r3]
 801be80: 687a         	ldr	r2, [r7, #0x4]
 801be82: 429a         	cmp	r2, r3
 801be84: bf0c         	ite	eq
 801be86: 2301         	moveq	r3, #0x1
 801be88: 2300         	movne	r3, #0x0
 801be8a: b2db         	uxtb	r3, r3
; }
 801be8c: 4618         	mov	r0, r3
 801be8e: 370c         	adds	r7, #0xc
 801be90: 46bd         	mov	sp, r7
 801be92: bc80         	pop	{r7}
 801be94: 4770         	bx	lr

0801be96 <sys_dlist_peek_head>:
; {
 801be96: b580         	push	{r7, lr}
 801be98: b082         	sub	sp, #0x8
 801be9a: af00         	add	r7, sp, #0x0
 801be9c: 6078         	str	r0, [r7, #0x4]
; 	return sys_dlist_is_empty(list) ? NULL : list->head;
 801be9e: 6878         	ldr	r0, [r7, #0x4]
 801bea0: f7ff ffe8    	bl	0x801be74 <sys_dlist_is_empty> @ imm = #-0x30
 801bea4: 4603         	mov	r3, r0
 801bea6: 2b00         	cmp	r3, #0x0
 801bea8: d102         	bne	0x801beb0 <sys_dlist_peek_head+0x1a> @ imm = #0x4
 801beaa: 687b         	ldr	r3, [r7, #0x4]
 801beac: 681b         	ldr	r3, [r3]
 801beae: e000         	b	0x801beb2 <sys_dlist_peek_head+0x1c> @ imm = #0x0
 801beb0: 2300         	movs	r3, #0x0
; }
 801beb2: 4618         	mov	r0, r3
 801beb4: 3708         	adds	r7, #0x8
 801beb6: 46bd         	mov	sp, r7
 801beb8: bd80         	pop	{r7, pc}

0801beba <sys_dlist_remove>:
; {
 801beba: b580         	push	{r7, lr}
 801bebc: b084         	sub	sp, #0x10
 801bebe: af00         	add	r7, sp, #0x0
 801bec0: 6078         	str	r0, [r7, #0x4]
; 	sys_dnode_t *const prev = node->prev;
 801bec2: 687b         	ldr	r3, [r7, #0x4]
 801bec4: 685b         	ldr	r3, [r3, #0x4]
 801bec6: 60fb         	str	r3, [r7, #0xc]
; 	sys_dnode_t *const next = node->next;
 801bec8: 687b         	ldr	r3, [r7, #0x4]
 801beca: 681b         	ldr	r3, [r3]
 801becc: 60bb         	str	r3, [r7, #0x8]
; 	prev->next = next;
 801bece: 68fb         	ldr	r3, [r7, #0xc]
 801bed0: 68ba         	ldr	r2, [r7, #0x8]
 801bed2: 601a         	str	r2, [r3]
; 	next->prev = prev;
 801bed4: 68bb         	ldr	r3, [r7, #0x8]
 801bed6: 68fa         	ldr	r2, [r7, #0xc]
 801bed8: 605a         	str	r2, [r3, #0x4]
; 	sys_dnode_init(node);
 801beda: 6878         	ldr	r0, [r7, #0x4]
 801bedc: f7ff ffab    	bl	0x801be36 <sys_dnode_init> @ imm = #-0xaa
; }
 801bee0: bf00         	nop
 801bee2: 3710         	adds	r7, #0x10
 801bee4: 46bd         	mov	sp, r7
 801bee6: bd80         	pop	{r7, pc}

0801bee8 <z_is_inactive_timeout>:
; {
 801bee8: b580         	push	{r7, lr}
 801beea: b082         	sub	sp, #0x8
 801beec: af00         	add	r7, sp, #0x0
 801beee: 6078         	str	r0, [r7, #0x4]
; 	return !sys_dnode_is_linked(&to->node);
 801bef0: 687b         	ldr	r3, [r7, #0x4]
 801bef2: 4618         	mov	r0, r3
 801bef4: f7ff ffae    	bl	0x801be54 <sys_dnode_is_linked> @ imm = #-0xa4
 801bef8: 4603         	mov	r3, r0
 801befa: 2b00         	cmp	r3, #0x0
 801befc: bf14         	ite	ne
 801befe: 2301         	movne	r3, #0x1
 801bf00: 2300         	moveq	r3, #0x0
 801bf02: b2db         	uxtb	r3, r3
 801bf04: f083 0301    	eor	r3, r3, #0x1
 801bf08: b2db         	uxtb	r3, r3
 801bf0a: f003 0301    	and	r3, r3, #0x1
 801bf0e: b2db         	uxtb	r3, r3
; }
 801bf10: 4618         	mov	r0, r3
 801bf12: 3708         	adds	r7, #0x8
 801bf14: 46bd         	mov	sp, r7
 801bf16: bd80         	pop	{r7, pc}

0801bf18 <z_abort_thread_timeout>:
; {
 801bf18: b580         	push	{r7, lr}
 801bf1a: b082         	sub	sp, #0x8
 801bf1c: af00         	add	r7, sp, #0x0
 801bf1e: 6078         	str	r0, [r7, #0x4]
; 	return z_abort_timeout(&thread->base.timeout);
 801bf20: 687b         	ldr	r3, [r7, #0x4]
 801bf22: 3318         	adds	r3, #0x18
 801bf24: 4618         	mov	r0, r3
 801bf26: f7f4 ff79    	bl	0x8010e1c <z_abort_timeout> @ imm = #-0xb10e
 801bf2a: 4603         	mov	r3, r0
; }
 801bf2c: 4618         	mov	r0, r3
 801bf2e: 3708         	adds	r7, #0x8
 801bf30: 46bd         	mov	sp, r7
 801bf32: bd80         	pop	{r7, pc}

0801bf34 <z_is_thread_prevented_from_running>:
; {
 801bf34: b480         	push	{r7}
 801bf36: b085         	sub	sp, #0x14
 801bf38: af00         	add	r7, sp, #0x0
 801bf3a: 6078         	str	r0, [r7, #0x4]
; 	uint8_t state = thread->base.thread_state;
 801bf3c: 687b         	ldr	r3, [r7, #0x4]
 801bf3e: 7b5b         	ldrb	r3, [r3, #0xd]
 801bf40: 73fb         	strb	r3, [r7, #0xf]
; 	return (state & (_THREAD_PENDING | _THREAD_DEAD |
 801bf42: 7bfb         	ldrb	r3, [r7, #0xf]
 801bf44: f003 031b    	and	r3, r3, #0x1b
; 			 _THREAD_DUMMY | _THREAD_SUSPENDED)) != 0U;
 801bf48: 2b00         	cmp	r3, #0x0
 801bf4a: bf14         	ite	ne
 801bf4c: 2301         	movne	r3, #0x1
 801bf4e: 2300         	moveq	r3, #0x0
 801bf50: b2db         	uxtb	r3, r3
; }
 801bf52: 4618         	mov	r0, r3
 801bf54: 3714         	adds	r7, #0x14
 801bf56: 46bd         	mov	sp, r7
 801bf58: bc80         	pop	{r7}
 801bf5a: 4770         	bx	lr

0801bf5c <z_is_thread_timeout_active>:
; {
 801bf5c: b580         	push	{r7, lr}
 801bf5e: b082         	sub	sp, #0x8
 801bf60: af00         	add	r7, sp, #0x0
 801bf62: 6078         	str	r0, [r7, #0x4]
; 	return !z_is_inactive_timeout(&thread->base.timeout);
 801bf64: 687b         	ldr	r3, [r7, #0x4]
 801bf66: 3318         	adds	r3, #0x18
 801bf68: 4618         	mov	r0, r3
 801bf6a: f7ff ffbd    	bl	0x801bee8 <z_is_inactive_timeout> @ imm = #-0x86
 801bf6e: 4603         	mov	r3, r0
 801bf70: 2b00         	cmp	r3, #0x0
 801bf72: bf14         	ite	ne
 801bf74: 2301         	movne	r3, #0x1
 801bf76: 2300         	moveq	r3, #0x0
 801bf78: b2db         	uxtb	r3, r3
 801bf7a: f083 0301    	eor	r3, r3, #0x1
 801bf7e: b2db         	uxtb	r3, r3
 801bf80: f003 0301    	and	r3, r3, #0x1
 801bf84: b2db         	uxtb	r3, r3
; }
 801bf86: 4618         	mov	r0, r3
 801bf88: 3708         	adds	r7, #0x8
 801bf8a: 46bd         	mov	sp, r7
 801bf8c: bd80         	pop	{r7, pc}

0801bf8e <z_is_thread_ready>:
; {
 801bf8e: b580         	push	{r7, lr}
 801bf90: b082         	sub	sp, #0x8
 801bf92: af00         	add	r7, sp, #0x0
 801bf94: 6078         	str	r0, [r7, #0x4]
; 	return !((z_is_thread_prevented_from_running(thread)) != 0U ||
 801bf96: 6878         	ldr	r0, [r7, #0x4]
 801bf98: f7ff ffcc    	bl	0x801bf34 <z_is_thread_prevented_from_running> @ imm = #-0x68
 801bf9c: 4603         	mov	r3, r0
 801bf9e: f083 0301    	eor	r3, r3, #0x1
 801bfa2: b2db         	uxtb	r3, r3
 801bfa4: 2b00         	cmp	r3, #0x0
 801bfa6: d00a         	beq	0x801bfbe <z_is_thread_ready+0x30> @ imm = #0x14
; 		 z_is_thread_timeout_active(thread));
 801bfa8: 6878         	ldr	r0, [r7, #0x4]
 801bfaa: f7ff ffd7    	bl	0x801bf5c <z_is_thread_timeout_active> @ imm = #-0x52
 801bfae: 4603         	mov	r3, r0
; 	return !((z_is_thread_prevented_from_running(thread)) != 0U ||
 801bfb0: f083 0301    	eor	r3, r3, #0x1
 801bfb4: b2db         	uxtb	r3, r3
 801bfb6: 2b00         	cmp	r3, #0x0
 801bfb8: d001         	beq	0x801bfbe <z_is_thread_ready+0x30> @ imm = #0x2
 801bfba: 2301         	movs	r3, #0x1
 801bfbc: e000         	b	0x801bfc0 <z_is_thread_ready+0x32> @ imm = #0x0
 801bfbe: 2300         	movs	r3, #0x0
 801bfc0: f003 0301    	and	r3, r3, #0x1
 801bfc4: b2db         	uxtb	r3, r3
; }
 801bfc6: 4618         	mov	r0, r3
 801bfc8: 3708         	adds	r7, #0x8
 801bfca: 46bd         	mov	sp, r7
 801bfcc: bd80         	pop	{r7, pc}

0801bfce <z_mark_thread_as_not_pending>:
; {
 801bfce: b480         	push	{r7}
 801bfd0: b083         	sub	sp, #0xc
 801bfd2: af00         	add	r7, sp, #0x0
 801bfd4: 6078         	str	r0, [r7, #0x4]
; 	thread->base.thread_state &= ~_THREAD_PENDING;
 801bfd6: 687b         	ldr	r3, [r7, #0x4]
 801bfd8: 7b5b         	ldrb	r3, [r3, #0xd]
 801bfda: f023 0302    	bic	r3, r3, #0x2
 801bfde: b2da         	uxtb	r2, r3
 801bfe0: 687b         	ldr	r3, [r7, #0x4]
 801bfe2: 735a         	strb	r2, [r3, #0xd]
; }
 801bfe4: bf00         	nop
 801bfe6: 370c         	adds	r7, #0xc
 801bfe8: 46bd         	mov	sp, r7
 801bfea: bc80         	pop	{r7}
 801bfec: 4770         	bx	lr

0801bfee <z_is_under_prio_ceiling>:
; {
 801bfee: b480         	push	{r7}
 801bff0: b083         	sub	sp, #0xc
 801bff2: af00         	add	r7, sp, #0x0
 801bff4: 6078         	str	r0, [r7, #0x4]
; 	return prio >= CONFIG_PRIORITY_CEILING;
 801bff6: 687b         	ldr	r3, [r7, #0x4]
 801bff8: f113 0f7f    	cmn.w	r3, #0x7f
 801bffc: bfac         	ite	ge
 801bffe: 2301         	movge	r3, #0x1
 801c000: 2300         	movlt	r3, #0x0
 801c002: b2db         	uxtb	r3, r3
; }
 801c004: 4618         	mov	r0, r3
 801c006: 370c         	adds	r7, #0xc
 801c008: 46bd         	mov	sp, r7
 801c00a: bc80         	pop	{r7}
 801c00c: 4770         	bx	lr

0801c00e <z_get_new_prio_with_ceiling>:
; {
 801c00e: b580         	push	{r7, lr}
 801c010: b082         	sub	sp, #0x8
 801c012: af00         	add	r7, sp, #0x0
 801c014: 6078         	str	r0, [r7, #0x4]
; 	return z_is_under_prio_ceiling(prio) ? prio : CONFIG_PRIORITY_CEILING;
 801c016: 6878         	ldr	r0, [r7, #0x4]
 801c018: f7ff ffe9    	bl	0x801bfee <z_is_under_prio_ceiling> @ imm = #-0x2e
 801c01c: 4603         	mov	r3, r0
 801c01e: 2b00         	cmp	r3, #0x0
 801c020: d001         	beq	0x801c026 <z_get_new_prio_with_ceiling+0x18> @ imm = #0x2
 801c022: 687b         	ldr	r3, [r7, #0x4]
 801c024: e001         	b	0x801c02a <z_get_new_prio_with_ceiling+0x1c> @ imm = #0x2
 801c026: f06f 037e    	mvn	r3, #0x7e
; }
 801c02a: 4618         	mov	r0, r3
 801c02c: 3708         	adds	r7, #0x8
 801c02e: 46bd         	mov	sp, r7
 801c030: bd80         	pop	{r7, pc}

0801c032 <z_is_prio1_higher_than_prio2>:
; {
 801c032: b480         	push	{r7}
 801c034: b083         	sub	sp, #0xc
 801c036: af00         	add	r7, sp, #0x0
 801c038: 6078         	str	r0, [r7, #0x4]
 801c03a: 6039         	str	r1, [r7]
; 	return prio1 < prio2;
 801c03c: 687a         	ldr	r2, [r7, #0x4]
 801c03e: 683b         	ldr	r3, [r7]
 801c040: 429a         	cmp	r2, r3
 801c042: bfb4         	ite	lt
 801c044: 2301         	movlt	r3, #0x1
 801c046: 2300         	movge	r3, #0x0
 801c048: b2db         	uxtb	r3, r3
; }
 801c04a: 4618         	mov	r0, r3
 801c04c: 370c         	adds	r7, #0xc
 801c04e: 46bd         	mov	sp, r7
 801c050: bc80         	pop	{r7}
 801c052: 4770         	bx	lr

0801c054 <z_is_prio_higher>:
; {
 801c054: b580         	push	{r7, lr}
 801c056: b082         	sub	sp, #0x8
 801c058: af00         	add	r7, sp, #0x0
 801c05a: 6078         	str	r0, [r7, #0x4]
 801c05c: 6039         	str	r1, [r7]
; 	return z_is_prio1_higher_than_prio2(prio, test_prio);
 801c05e: 6839         	ldr	r1, [r7]
 801c060: 6878         	ldr	r0, [r7, #0x4]
 801c062: f7ff ffe6    	bl	0x801c032 <z_is_prio1_higher_than_prio2> @ imm = #-0x34
 801c066: 4603         	mov	r3, r0
; }
 801c068: 4618         	mov	r0, r3
 801c06a: 3708         	adds	r7, #0x8
 801c06c: 46bd         	mov	sp, r7
 801c06e: bd80         	pop	{r7, pc}

0801c070 <unpend_thread_no_timeout>:
; {
 801c070: b580         	push	{r7, lr}
 801c072: b086         	sub	sp, #0x18
 801c074: af00         	add	r7, sp, #0x0
 801c076: 6078         	str	r0, [r7, #0x4]
 801c078: 687b         	ldr	r3, [r7, #0x4]
 801c07a: 60fb         	str	r3, [r7, #0xc]
; 	return thread->base.pended_on;
 801c07c: 68fb         	ldr	r3, [r7, #0xc]
 801c07e: 689b         	ldr	r3, [r3, #0x8]
 801c080: 617b         	str	r3, [r7, #0x14]
 801c082: 687b         	ldr	r3, [r7, #0x4]
 801c084: 613b         	str	r3, [r7, #0x10]
; 	sys_dlist_remove(&thread->base.qnode_dlist);
 801c086: 693b         	ldr	r3, [r7, #0x10]
 801c088: 4618         	mov	r0, r3
 801c08a: f7ff ff16    	bl	0x801beba <sys_dlist_remove> @ imm = #-0x1d4
; }
 801c08e: bf00         	nop
; 	z_mark_thread_as_not_pending(thread);
 801c090: 6878         	ldr	r0, [r7, #0x4]
 801c092: f7ff ff9c    	bl	0x801bfce <z_mark_thread_as_not_pending> @ imm = #-0xc8
; 	thread->base.pended_on = NULL;
 801c096: 687b         	ldr	r3, [r7, #0x4]
 801c098: 2200         	movs	r2, #0x0
 801c09a: 609a         	str	r2, [r3, #0x8]
; }
 801c09c: bf00         	nop
 801c09e: 3718         	adds	r7, #0x18
 801c0a0: 46bd         	mov	sp, r7
 801c0a2: bd80         	pop	{r7, pc}

0801c0a4 <z_waitq_head>:
; {
 801c0a4: b580         	push	{r7, lr}
 801c0a6: b082         	sub	sp, #0x8
 801c0a8: af00         	add	r7, sp, #0x0
 801c0aa: 6078         	str	r0, [r7, #0x4]
; 	return (struct k_thread *)sys_dlist_peek_head(&w->waitq);
 801c0ac: 687b         	ldr	r3, [r7, #0x4]
 801c0ae: 4618         	mov	r0, r3
 801c0b0: f7ff fef1    	bl	0x801be96 <sys_dlist_peek_head> @ imm = #-0x21e
 801c0b4: 4603         	mov	r3, r0
; }
 801c0b6: 4618         	mov	r0, r3
 801c0b8: 3708         	adds	r7, #0x8
 801c0ba: 46bd         	mov	sp, r7
 801c0bc: bd80         	pop	{r7, pc}

0801c0be <z_log_msg_runtime_create>:
; {
 801c0be: b580         	push	{r7, lr}
 801c0c0: b08a         	sub	sp, #0x28
 801c0c2: af04         	add	r7, sp, #0x10
 801c0c4: 60b9         	str	r1, [r7, #0x8]
 801c0c6: 607b         	str	r3, [r7, #0x4]
 801c0c8: 4603         	mov	r3, r0
 801c0ca: 73fb         	strb	r3, [r7, #0xf]
 801c0cc: 4613         	mov	r3, r2
 801c0ce: 73bb         	strb	r3, [r7, #0xe]
; 	va_start(ap, fmt);
 801c0d0: f107 032c    	add.w	r3, r7, #0x2c
 801c0d4: 617b         	str	r3, [r7, #0x14]
; 	z_log_msg_runtime_vcreate(domain_id, source, level,
 801c0d6: 7bba         	ldrb	r2, [r7, #0xe]
 801c0d8: 7bf8         	ldrb	r0, [r7, #0xf]
 801c0da: 697b         	ldr	r3, [r7, #0x14]
 801c0dc: 9303         	str	r3, [sp, #0xc]
 801c0de: 6abb         	ldr	r3, [r7, #0x28]
 801c0e0: 9302         	str	r3, [sp, #0x8]
 801c0e2: 6a7b         	ldr	r3, [r7, #0x24]
 801c0e4: 9301         	str	r3, [sp, #0x4]
 801c0e6: 6a3b         	ldr	r3, [r7, #0x20]
 801c0e8: 9300         	str	r3, [sp]
 801c0ea: 687b         	ldr	r3, [r7, #0x4]
 801c0ec: 68b9         	ldr	r1, [r7, #0x8]
 801c0ee: f7e8 fa3f    	bl	0x8004570 <z_log_msg_runtime_vcreate> @ imm = #-0x17b82
; }
 801c0f2: bf00         	nop
 801c0f4: 3718         	adds	r7, #0x18
 801c0f6: 46bd         	mov	sp, r7
 801c0f8: bd80         	pop	{r7, pc}

0801c0fa <new_prio_for_inheritance>:
; {
 801c0fa: b580         	push	{r7, lr}
 801c0fc: b084         	sub	sp, #0x10
 801c0fe: af00         	add	r7, sp, #0x0
 801c100: 6078         	str	r0, [r7, #0x4]
 801c102: 6039         	str	r1, [r7]
; 	int new_prio = z_is_prio_higher(target, limit) ? target : limit;
 801c104: 6839         	ldr	r1, [r7]
 801c106: 6878         	ldr	r0, [r7, #0x4]
 801c108: f7ff ffa4    	bl	0x801c054 <z_is_prio_higher> @ imm = #-0xb8
 801c10c: 4603         	mov	r3, r0
 801c10e: 2b00         	cmp	r3, #0x0
 801c110: d001         	beq	0x801c116 <new_prio_for_inheritance+0x1c> @ imm = #0x2
 801c112: 687b         	ldr	r3, [r7, #0x4]
 801c114: e000         	b	0x801c118 <new_prio_for_inheritance+0x1e> @ imm = #0x0
 801c116: 683b         	ldr	r3, [r7]
 801c118: 60fb         	str	r3, [r7, #0xc]
; 	new_prio = z_get_new_prio_with_ceiling(new_prio);
 801c11a: 68f8         	ldr	r0, [r7, #0xc]
 801c11c: f7ff ff77    	bl	0x801c00e <z_get_new_prio_with_ceiling> @ imm = #-0x112
 801c120: 60f8         	str	r0, [r7, #0xc]
; 	return new_prio;
 801c122: 68fb         	ldr	r3, [r7, #0xc]
; }
 801c124: 4618         	mov	r0, r3
 801c126: 3710         	adds	r7, #0x10
 801c128: 46bd         	mov	sp, r7
 801c12a: bd80         	pop	{r7, pc}

0801c12c <sys_dlist_init>:
; {
 801c12c: b480         	push	{r7}
 801c12e: b083         	sub	sp, #0xc
 801c130: af00         	add	r7, sp, #0x0
 801c132: 6078         	str	r0, [r7, #0x4]
; 	list->head = (sys_dnode_t *)list;
 801c134: 687b         	ldr	r3, [r7, #0x4]
 801c136: 687a         	ldr	r2, [r7, #0x4]
 801c138: 601a         	str	r2, [r3]
; 	list->tail = (sys_dnode_t *)list;
 801c13a: 687b         	ldr	r3, [r7, #0x4]
 801c13c: 687a         	ldr	r2, [r7, #0x4]
 801c13e: 605a         	str	r2, [r3, #0x4]
; }
 801c140: bf00         	nop
 801c142: 370c         	adds	r7, #0xc
 801c144: 46bd         	mov	sp, r7
 801c146: bc80         	pop	{r7}
 801c148: 4770         	bx	lr

0801c14a <sys_dnode_init>:
; {
 801c14a: b480         	push	{r7}
 801c14c: b083         	sub	sp, #0xc
 801c14e: af00         	add	r7, sp, #0x0
 801c150: 6078         	str	r0, [r7, #0x4]
; 	node->next = NULL;
 801c152: 687b         	ldr	r3, [r7, #0x4]
 801c154: 2200         	movs	r2, #0x0
 801c156: 601a         	str	r2, [r3]
; 	node->prev = NULL;
 801c158: 687b         	ldr	r3, [r7, #0x4]
 801c15a: 2200         	movs	r2, #0x0
 801c15c: 605a         	str	r2, [r3, #0x4]
; }
 801c15e: bf00         	nop
 801c160: 370c         	adds	r7, #0xc
 801c162: 46bd         	mov	sp, r7
 801c164: bc80         	pop	{r7}
 801c166: 4770         	bx	lr

0801c168 <sys_dlist_is_empty>:
; {
 801c168: b480         	push	{r7}
 801c16a: b083         	sub	sp, #0xc
 801c16c: af00         	add	r7, sp, #0x0
 801c16e: 6078         	str	r0, [r7, #0x4]
; 	return list->head == list;
 801c170: 687b         	ldr	r3, [r7, #0x4]
 801c172: 681b         	ldr	r3, [r3]
 801c174: 687a         	ldr	r2, [r7, #0x4]
 801c176: 429a         	cmp	r2, r3
 801c178: bf0c         	ite	eq
 801c17a: 2301         	moveq	r3, #0x1
 801c17c: 2300         	movne	r3, #0x0
 801c17e: b2db         	uxtb	r3, r3
; }
 801c180: 4618         	mov	r0, r3
 801c182: 370c         	adds	r7, #0xc
 801c184: 46bd         	mov	sp, r7
 801c186: bc80         	pop	{r7}
 801c188: 4770         	bx	lr

0801c18a <sys_dlist_peek_head>:
; {
 801c18a: b580         	push	{r7, lr}
 801c18c: b082         	sub	sp, #0x8
 801c18e: af00         	add	r7, sp, #0x0
 801c190: 6078         	str	r0, [r7, #0x4]
; 	return sys_dlist_is_empty(list) ? NULL : list->head;
 801c192: 6878         	ldr	r0, [r7, #0x4]
 801c194: f7ff ffe8    	bl	0x801c168 <sys_dlist_is_empty> @ imm = #-0x30
 801c198: 4603         	mov	r3, r0
 801c19a: 2b00         	cmp	r3, #0x0
 801c19c: d102         	bne	0x801c1a4 <sys_dlist_peek_head+0x1a> @ imm = #0x4
 801c19e: 687b         	ldr	r3, [r7, #0x4]
 801c1a0: 681b         	ldr	r3, [r3]
 801c1a2: e000         	b	0x801c1a6 <sys_dlist_peek_head+0x1c> @ imm = #0x0
 801c1a4: 2300         	movs	r3, #0x0
; }
 801c1a6: 4618         	mov	r0, r3
 801c1a8: 3708         	adds	r7, #0x8
 801c1aa: 46bd         	mov	sp, r7
 801c1ac: bd80         	pop	{r7, pc}

0801c1ae <sys_dlist_remove>:
; {
 801c1ae: b580         	push	{r7, lr}
 801c1b0: b084         	sub	sp, #0x10
 801c1b2: af00         	add	r7, sp, #0x0
 801c1b4: 6078         	str	r0, [r7, #0x4]
; 	sys_dnode_t *const prev = node->prev;
 801c1b6: 687b         	ldr	r3, [r7, #0x4]
 801c1b8: 685b         	ldr	r3, [r3, #0x4]
 801c1ba: 60fb         	str	r3, [r7, #0xc]
; 	sys_dnode_t *const next = node->next;
 801c1bc: 687b         	ldr	r3, [r7, #0x4]
 801c1be: 681b         	ldr	r3, [r3]
 801c1c0: 60bb         	str	r3, [r7, #0x8]
; 	prev->next = next;
 801c1c2: 68fb         	ldr	r3, [r7, #0xc]
 801c1c4: 68ba         	ldr	r2, [r7, #0x8]
 801c1c6: 601a         	str	r2, [r3]
; 	next->prev = prev;
 801c1c8: 68bb         	ldr	r3, [r7, #0x8]
 801c1ca: 68fa         	ldr	r2, [r7, #0xc]
 801c1cc: 605a         	str	r2, [r3, #0x4]
; 	sys_dnode_init(node);
 801c1ce: 6878         	ldr	r0, [r7, #0x4]
 801c1d0: f7ff ffbb    	bl	0x801c14a <sys_dnode_init> @ imm = #-0x8a
; }
 801c1d4: bf00         	nop
 801c1d6: 3710         	adds	r7, #0x10
 801c1d8: 46bd         	mov	sp, r7
 801c1da: bd80         	pop	{r7, pc}

0801c1dc <k_object_init>:
; {
 801c1dc: b480         	push	{r7}
 801c1de: b083         	sub	sp, #0xc
 801c1e0: af00         	add	r7, sp, #0x0
 801c1e2: 6078         	str	r0, [r7, #0x4]
; }
 801c1e4: bf00         	nop
 801c1e6: 370c         	adds	r7, #0xc
 801c1e8: 46bd         	mov	sp, r7
 801c1ea: bc80         	pop	{r7}
 801c1ec: 4770         	bx	lr

0801c1ee <z_abort_thread_timeout>:
; {
 801c1ee: b580         	push	{r7, lr}
 801c1f0: b082         	sub	sp, #0x8
 801c1f2: af00         	add	r7, sp, #0x0
 801c1f4: 6078         	str	r0, [r7, #0x4]
; 	return z_abort_timeout(&thread->base.timeout);
 801c1f6: 687b         	ldr	r3, [r7, #0x4]
 801c1f8: 3318         	adds	r3, #0x18
 801c1fa: 4618         	mov	r0, r3
 801c1fc: f7f4 fe0e    	bl	0x8010e1c <z_abort_timeout> @ imm = #-0xb3e4
 801c200: 4603         	mov	r3, r0
; }
 801c202: 4618         	mov	r0, r3
 801c204: 3708         	adds	r7, #0x8
 801c206: 46bd         	mov	sp, r7
 801c208: bd80         	pop	{r7, pc}

0801c20a <z_waitq_init>:
; {
 801c20a: b580         	push	{r7, lr}
 801c20c: b082         	sub	sp, #0x8
 801c20e: af00         	add	r7, sp, #0x0
 801c210: 6078         	str	r0, [r7, #0x4]
; 	sys_dlist_init(&w->waitq);
 801c212: 687b         	ldr	r3, [r7, #0x4]
 801c214: 4618         	mov	r0, r3
 801c216: f7ff ff89    	bl	0x801c12c <sys_dlist_init> @ imm = #-0xee
; }
 801c21a: bf00         	nop
 801c21c: 3708         	adds	r7, #0x8
 801c21e: 46bd         	mov	sp, r7
 801c220: bd80         	pop	{r7, pc}

0801c222 <z_mark_thread_as_not_pending>:
; {
 801c222: b480         	push	{r7}
 801c224: b083         	sub	sp, #0xc
 801c226: af00         	add	r7, sp, #0x0
 801c228: 6078         	str	r0, [r7, #0x4]
; 	thread->base.thread_state &= ~_THREAD_PENDING;
 801c22a: 687b         	ldr	r3, [r7, #0x4]
 801c22c: 7b5b         	ldrb	r3, [r3, #0xd]
 801c22e: f023 0302    	bic	r3, r3, #0x2
 801c232: b2da         	uxtb	r2, r3
 801c234: 687b         	ldr	r3, [r7, #0x4]
 801c236: 735a         	strb	r2, [r3, #0xd]
; }
 801c238: bf00         	nop
 801c23a: 370c         	adds	r7, #0xc
 801c23c: 46bd         	mov	sp, r7
 801c23e: bc80         	pop	{r7}
 801c240: 4770         	bx	lr

0801c242 <unpend_thread_no_timeout>:
; {
 801c242: b580         	push	{r7, lr}
 801c244: b086         	sub	sp, #0x18
 801c246: af00         	add	r7, sp, #0x0
 801c248: 6078         	str	r0, [r7, #0x4]
 801c24a: 687b         	ldr	r3, [r7, #0x4]
 801c24c: 60fb         	str	r3, [r7, #0xc]
; 	return thread->base.pended_on;
 801c24e: 68fb         	ldr	r3, [r7, #0xc]
 801c250: 689b         	ldr	r3, [r3, #0x8]
 801c252: 617b         	str	r3, [r7, #0x14]
 801c254: 687b         	ldr	r3, [r7, #0x4]
 801c256: 613b         	str	r3, [r7, #0x10]
; 	sys_dlist_remove(&thread->base.qnode_dlist);
 801c258: 693b         	ldr	r3, [r7, #0x10]
 801c25a: 4618         	mov	r0, r3
 801c25c: f7ff ffa7    	bl	0x801c1ae <sys_dlist_remove> @ imm = #-0xb2
; }
 801c260: bf00         	nop
; 	z_mark_thread_as_not_pending(thread);
 801c262: 6878         	ldr	r0, [r7, #0x4]
 801c264: f7ff ffdd    	bl	0x801c222 <z_mark_thread_as_not_pending> @ imm = #-0x46
; 	thread->base.pended_on = NULL;
 801c268: 687b         	ldr	r3, [r7, #0x4]
 801c26a: 2200         	movs	r2, #0x0
 801c26c: 609a         	str	r2, [r3, #0x8]
; }
 801c26e: bf00         	nop
 801c270: 3718         	adds	r7, #0x18
 801c272: 46bd         	mov	sp, r7
 801c274: bd80         	pop	{r7, pc}

0801c276 <z_impl_k_sem_init>:
; {
 801c276: b580         	push	{r7, lr}
 801c278: b084         	sub	sp, #0x10
 801c27a: af00         	add	r7, sp, #0x0
 801c27c: 60f8         	str	r0, [r7, #0xc]
 801c27e: 60b9         	str	r1, [r7, #0x8]
 801c280: 607a         	str	r2, [r7, #0x4]
; 	CHECKIF(limit == 0U || initial_count > limit) {
 801c282: 687b         	ldr	r3, [r7, #0x4]
 801c284: 2b00         	cmp	r3, #0x0
 801c286: d003         	beq	0x801c290 <z_impl_k_sem_init+0x1a> @ imm = #0x6
 801c288: 68ba         	ldr	r2, [r7, #0x8]
 801c28a: 687b         	ldr	r3, [r7, #0x4]
 801c28c: 429a         	cmp	r2, r3
 801c28e: d902         	bls	0x801c296 <z_impl_k_sem_init+0x20> @ imm = #0x4
; 		return -EINVAL;
 801c290: f06f 0315    	mvn	r3, #0x15
 801c294: e00d         	b	0x801c2b2 <z_impl_k_sem_init+0x3c> @ imm = #0x1a
; 	sem->count = initial_count;
 801c296: 68fb         	ldr	r3, [r7, #0xc]
 801c298: 68ba         	ldr	r2, [r7, #0x8]
 801c29a: 609a         	str	r2, [r3, #0x8]
; 	sem->limit = limit;
 801c29c: 68fb         	ldr	r3, [r7, #0xc]
 801c29e: 687a         	ldr	r2, [r7, #0x4]
 801c2a0: 60da         	str	r2, [r3, #0xc]
; 	z_waitq_init(&sem->wait_q);
 801c2a2: 68fb         	ldr	r3, [r7, #0xc]
 801c2a4: 4618         	mov	r0, r3
 801c2a6: f7ff ffb0    	bl	0x801c20a <z_waitq_init> @ imm = #-0xa0
; 	k_object_init(sem);
 801c2aa: 68f8         	ldr	r0, [r7, #0xc]
 801c2ac: f7ff ff96    	bl	0x801c1dc <k_object_init> @ imm = #-0xd4
; 	return 0;
 801c2b0: 2300         	movs	r3, #0x0
; }
 801c2b2: 4618         	mov	r0, r3
 801c2b4: 3710         	adds	r7, #0x10
 801c2b6: 46bd         	mov	sp, r7
 801c2b8: bd80         	pop	{r7, pc}

0801c2ba <handle_poll_events>:
; {
 801c2ba: b480         	push	{r7}
 801c2bc: b083         	sub	sp, #0xc
 801c2be: af00         	add	r7, sp, #0x0
 801c2c0: 6078         	str	r0, [r7, #0x4]
; 	return false;
 801c2c2: 2300         	movs	r3, #0x0
; }
 801c2c4: 4618         	mov	r0, r3
 801c2c6: 370c         	adds	r7, #0xc
 801c2c8: 46bd         	mov	sp, r7
 801c2ca: bc80         	pop	{r7}
 801c2cc: 4770         	bx	lr

0801c2ce <sys_dlist_init>:
; {
 801c2ce: b480         	push	{r7}
 801c2d0: b083         	sub	sp, #0xc
 801c2d2: af00         	add	r7, sp, #0x0
 801c2d4: 6078         	str	r0, [r7, #0x4]
; 	list->head = (sys_dnode_t *)list;
 801c2d6: 687b         	ldr	r3, [r7, #0x4]
 801c2d8: 687a         	ldr	r2, [r7, #0x4]
 801c2da: 601a         	str	r2, [r3]
; 	list->tail = (sys_dnode_t *)list;
 801c2dc: 687b         	ldr	r3, [r7, #0x4]
 801c2de: 687a         	ldr	r2, [r7, #0x4]
 801c2e0: 605a         	str	r2, [r3, #0x4]
; }
 801c2e2: bf00         	nop
 801c2e4: 370c         	adds	r7, #0xc
 801c2e6: 46bd         	mov	sp, r7
 801c2e8: bc80         	pop	{r7}
 801c2ea: 4770         	bx	lr

0801c2ec <sys_dnode_init>:
; {
 801c2ec: b480         	push	{r7}
 801c2ee: b083         	sub	sp, #0xc
 801c2f0: af00         	add	r7, sp, #0x0
 801c2f2: 6078         	str	r0, [r7, #0x4]
; 	node->next = NULL;
 801c2f4: 687b         	ldr	r3, [r7, #0x4]
 801c2f6: 2200         	movs	r2, #0x0
 801c2f8: 601a         	str	r2, [r3]
; 	node->prev = NULL;
 801c2fa: 687b         	ldr	r3, [r7, #0x4]
 801c2fc: 2200         	movs	r2, #0x0
 801c2fe: 605a         	str	r2, [r3, #0x4]
; }
 801c300: bf00         	nop
 801c302: 370c         	adds	r7, #0xc
 801c304: 46bd         	mov	sp, r7
 801c306: bc80         	pop	{r7}
 801c308: 4770         	bx	lr

0801c30a <sys_slist_init>:
; {
 801c30a: b480         	push	{r7}
 801c30c: b083         	sub	sp, #0xc
 801c30e: af00         	add	r7, sp, #0x0
 801c310: 6078         	str	r0, [r7, #0x4]
; 	list->head = NULL;
 801c312: 687b         	ldr	r3, [r7, #0x4]
 801c314: 2200         	movs	r2, #0x0
 801c316: 601a         	str	r2, [r3]
; 	list->tail = NULL;
 801c318: 687b         	ldr	r3, [r7, #0x4]
 801c31a: 2200         	movs	r2, #0x0
 801c31c: 605a         	str	r2, [r3, #0x4]
; }
 801c31e: bf00         	nop
 801c320: 370c         	adds	r7, #0xc
 801c322: 46bd         	mov	sp, r7
 801c324: bc80         	pop	{r7}
 801c326: 4770         	bx	lr

0801c328 <z_snode_next_peek>:
; {
 801c328: b480         	push	{r7}
 801c32a: b083         	sub	sp, #0xc
 801c32c: af00         	add	r7, sp, #0x0
 801c32e: 6078         	str	r0, [r7, #0x4]
; 	return node->next;
 801c330: 687b         	ldr	r3, [r7, #0x4]
 801c332: 681b         	ldr	r3, [r3]
; }
 801c334: 4618         	mov	r0, r3
 801c336: 370c         	adds	r7, #0xc
 801c338: 46bd         	mov	sp, r7
 801c33a: bc80         	pop	{r7}
 801c33c: 4770         	bx	lr

0801c33e <z_snode_next_set>:
; {
 801c33e: b480         	push	{r7}
 801c340: b083         	sub	sp, #0xc
 801c342: af00         	add	r7, sp, #0x0
 801c344: 6078         	str	r0, [r7, #0x4]
 801c346: 6039         	str	r1, [r7]
; 	parent->next = child;
 801c348: 687b         	ldr	r3, [r7, #0x4]
 801c34a: 683a         	ldr	r2, [r7]
 801c34c: 601a         	str	r2, [r3]
; }
 801c34e: bf00         	nop
 801c350: 370c         	adds	r7, #0xc
 801c352: 46bd         	mov	sp, r7
 801c354: bc80         	pop	{r7}
 801c356: 4770         	bx	lr

0801c358 <z_slist_head_set>:
; {
 801c358: b480         	push	{r7}
 801c35a: b083         	sub	sp, #0xc
 801c35c: af00         	add	r7, sp, #0x0
 801c35e: 6078         	str	r0, [r7, #0x4]
 801c360: 6039         	str	r1, [r7]
; 	list->head = node;
 801c362: 687b         	ldr	r3, [r7, #0x4]
 801c364: 683a         	ldr	r2, [r7]
 801c366: 601a         	str	r2, [r3]
; }
 801c368: bf00         	nop
 801c36a: 370c         	adds	r7, #0xc
 801c36c: 46bd         	mov	sp, r7
 801c36e: bc80         	pop	{r7}
 801c370: 4770         	bx	lr

0801c372 <z_slist_tail_set>:
; {
 801c372: b480         	push	{r7}
 801c374: b083         	sub	sp, #0xc
 801c376: af00         	add	r7, sp, #0x0
 801c378: 6078         	str	r0, [r7, #0x4]
 801c37a: 6039         	str	r1, [r7]
; 	list->tail = node;
 801c37c: 687b         	ldr	r3, [r7, #0x4]
 801c37e: 683a         	ldr	r2, [r7]
 801c380: 605a         	str	r2, [r3, #0x4]
; }
 801c382: bf00         	nop
 801c384: 370c         	adds	r7, #0xc
 801c386: 46bd         	mov	sp, r7
 801c388: bc80         	pop	{r7}
 801c38a: 4770         	bx	lr

0801c38c <sys_slist_peek_head>:
; {
 801c38c: b480         	push	{r7}
 801c38e: b083         	sub	sp, #0xc
 801c390: af00         	add	r7, sp, #0x0
 801c392: 6078         	str	r0, [r7, #0x4]
; 	return list->head;
 801c394: 687b         	ldr	r3, [r7, #0x4]
 801c396: 681b         	ldr	r3, [r3]
; }
 801c398: 4618         	mov	r0, r3
 801c39a: 370c         	adds	r7, #0xc
 801c39c: 46bd         	mov	sp, r7
 801c39e: bc80         	pop	{r7}
 801c3a0: 4770         	bx	lr

0801c3a2 <sys_slist_peek_tail>:
; {
 801c3a2: b480         	push	{r7}
 801c3a4: b083         	sub	sp, #0xc
 801c3a6: af00         	add	r7, sp, #0x0
 801c3a8: 6078         	str	r0, [r7, #0x4]
; 	return list->tail;
 801c3aa: 687b         	ldr	r3, [r7, #0x4]
 801c3ac: 685b         	ldr	r3, [r3, #0x4]
; }
 801c3ae: 4618         	mov	r0, r3
 801c3b0: 370c         	adds	r7, #0xc
 801c3b2: 46bd         	mov	sp, r7
 801c3b4: bc80         	pop	{r7}
 801c3b6: 4770         	bx	lr

0801c3b8 <sys_slist_is_empty>:
; Z_GENLIST_IS_EMPTY(slist)
 801c3b8: b580         	push	{r7, lr}
 801c3ba: b082         	sub	sp, #0x8
 801c3bc: af00         	add	r7, sp, #0x0
 801c3be: 6078         	str	r0, [r7, #0x4]
 801c3c0: 6878         	ldr	r0, [r7, #0x4]
 801c3c2: f7ff ffe3    	bl	0x801c38c <sys_slist_peek_head> @ imm = #-0x3a
 801c3c6: 4603         	mov	r3, r0
 801c3c8: 2b00         	cmp	r3, #0x0
 801c3ca: bf0c         	ite	eq
 801c3cc: 2301         	moveq	r3, #0x1
 801c3ce: 2300         	movne	r3, #0x0
 801c3d0: b2db         	uxtb	r3, r3
 801c3d2: 4618         	mov	r0, r3
 801c3d4: 3708         	adds	r7, #0x8
 801c3d6: 46bd         	mov	sp, r7
 801c3d8: bd80         	pop	{r7, pc}

0801c3da <sys_slist_peek_next_no_check>:
; Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
 801c3da: b580         	push	{r7, lr}
 801c3dc: b082         	sub	sp, #0x8
 801c3de: af00         	add	r7, sp, #0x0
 801c3e0: 6078         	str	r0, [r7, #0x4]
 801c3e2: 6878         	ldr	r0, [r7, #0x4]
 801c3e4: f7ff ffa0    	bl	0x801c328 <z_snode_next_peek> @ imm = #-0xc0
 801c3e8: 4603         	mov	r3, r0
 801c3ea: 4618         	mov	r0, r3
 801c3ec: 3708         	adds	r7, #0x8
 801c3ee: 46bd         	mov	sp, r7
 801c3f0: bd80         	pop	{r7, pc}

0801c3f2 <sys_slist_peek_next>:
; Z_GENLIST_PEEK_NEXT(slist, snode)
 801c3f2: b580         	push	{r7, lr}
 801c3f4: b082         	sub	sp, #0x8
 801c3f6: af00         	add	r7, sp, #0x0
 801c3f8: 6078         	str	r0, [r7, #0x4]
 801c3fa: 687b         	ldr	r3, [r7, #0x4]
 801c3fc: 2b00         	cmp	r3, #0x0
 801c3fe: d004         	beq	0x801c40a <sys_slist_peek_next+0x18> @ imm = #0x8
 801c400: 6878         	ldr	r0, [r7, #0x4]
 801c402: f7ff ffea    	bl	0x801c3da <sys_slist_peek_next_no_check> @ imm = #-0x2c
 801c406: 4603         	mov	r3, r0
 801c408: e000         	b	0x801c40c <sys_slist_peek_next+0x1a> @ imm = #0x0
 801c40a: 2300         	movs	r3, #0x0
 801c40c: 4618         	mov	r0, r3
 801c40e: 3708         	adds	r7, #0x8
 801c410: 46bd         	mov	sp, r7
 801c412: bd80         	pop	{r7, pc}

0801c414 <sys_slist_append>:
; Z_GENLIST_APPEND(slist, snode)
 801c414: b580         	push	{r7, lr}
 801c416: b082         	sub	sp, #0x8
 801c418: af00         	add	r7, sp, #0x0
 801c41a: 6078         	str	r0, [r7, #0x4]
 801c41c: 6039         	str	r1, [r7]
 801c41e: 2100         	movs	r1, #0x0
 801c420: 6838         	ldr	r0, [r7]
 801c422: f7ff ff8c    	bl	0x801c33e <z_snode_next_set> @ imm = #-0xe8
 801c426: 6878         	ldr	r0, [r7, #0x4]
 801c428: f7ff ffbb    	bl	0x801c3a2 <sys_slist_peek_tail> @ imm = #-0x8a
 801c42c: 4603         	mov	r3, r0
 801c42e: 2b00         	cmp	r3, #0x0
 801c430: d108         	bne	0x801c444 <sys_slist_append+0x30> @ imm = #0x10
 801c432: 6839         	ldr	r1, [r7]
 801c434: 6878         	ldr	r0, [r7, #0x4]
 801c436: f7ff ff9c    	bl	0x801c372 <z_slist_tail_set> @ imm = #-0xc8
 801c43a: 6839         	ldr	r1, [r7]
 801c43c: 6878         	ldr	r0, [r7, #0x4]
 801c43e: f7ff ff8b    	bl	0x801c358 <z_slist_head_set> @ imm = #-0xea
 801c442: e00b         	b	0x801c45c <sys_slist_append+0x48> @ imm = #0x16
 801c444: 6878         	ldr	r0, [r7, #0x4]
 801c446: f7ff ffac    	bl	0x801c3a2 <sys_slist_peek_tail> @ imm = #-0xa8
 801c44a: 4603         	mov	r3, r0
 801c44c: 6839         	ldr	r1, [r7]
 801c44e: 4618         	mov	r0, r3
 801c450: f7ff ff75    	bl	0x801c33e <z_snode_next_set> @ imm = #-0x116
 801c454: 6839         	ldr	r1, [r7]
 801c456: 6878         	ldr	r0, [r7, #0x4]
 801c458: f7ff ff8b    	bl	0x801c372 <z_slist_tail_set> @ imm = #-0xea
 801c45c: 3708         	adds	r7, #0x8
 801c45e: 46bd         	mov	sp, r7
 801c460: bd80         	pop	{r7, pc}

0801c462 <sys_slist_get_not_empty>:
; Z_GENLIST_GET_NOT_EMPTY(slist, snode)
 801c462: b580         	push	{r7, lr}
 801c464: b084         	sub	sp, #0x10
 801c466: af00         	add	r7, sp, #0x0
 801c468: 6078         	str	r0, [r7, #0x4]
 801c46a: 6878         	ldr	r0, [r7, #0x4]
 801c46c: f7ff ff8e    	bl	0x801c38c <sys_slist_peek_head> @ imm = #-0xe4
 801c470: 60f8         	str	r0, [r7, #0xc]
 801c472: 68f8         	ldr	r0, [r7, #0xc]
 801c474: f7ff ff58    	bl	0x801c328 <z_snode_next_peek> @ imm = #-0x150
 801c478: 4603         	mov	r3, r0
 801c47a: 4619         	mov	r1, r3
 801c47c: 6878         	ldr	r0, [r7, #0x4]
 801c47e: f7ff ff6b    	bl	0x801c358 <z_slist_head_set> @ imm = #-0x12a
 801c482: 6878         	ldr	r0, [r7, #0x4]
 801c484: f7ff ff8d    	bl	0x801c3a2 <sys_slist_peek_tail> @ imm = #-0xe6
 801c488: 4602         	mov	r2, r0
 801c48a: 68fb         	ldr	r3, [r7, #0xc]
 801c48c: 4293         	cmp	r3, r2
 801c48e: d107         	bne	0x801c4a0 <sys_slist_get_not_empty+0x3e> @ imm = #0xe
 801c490: 6878         	ldr	r0, [r7, #0x4]
 801c492: f7ff ff7b    	bl	0x801c38c <sys_slist_peek_head> @ imm = #-0x10a
 801c496: 4603         	mov	r3, r0
 801c498: 4619         	mov	r1, r3
 801c49a: 6878         	ldr	r0, [r7, #0x4]
 801c49c: f7ff ff69    	bl	0x801c372 <z_slist_tail_set> @ imm = #-0x12e
 801c4a0: 68fb         	ldr	r3, [r7, #0xc]
 801c4a2: 4618         	mov	r0, r3
 801c4a4: 3710         	adds	r7, #0x10
 801c4a6: 46bd         	mov	sp, r7
 801c4a8: bd80         	pop	{r7, pc}

0801c4aa <sys_slist_get>:
; Z_GENLIST_GET(slist, snode)
 801c4aa: b580         	push	{r7, lr}
 801c4ac: b082         	sub	sp, #0x8
 801c4ae: af00         	add	r7, sp, #0x0
 801c4b0: 6078         	str	r0, [r7, #0x4]
 801c4b2: 6878         	ldr	r0, [r7, #0x4]
 801c4b4: f7ff ff80    	bl	0x801c3b8 <sys_slist_is_empty> @ imm = #-0x100
 801c4b8: 4603         	mov	r3, r0
 801c4ba: 2b00         	cmp	r3, #0x0
 801c4bc: d104         	bne	0x801c4c8 <sys_slist_get+0x1e> @ imm = #0x8
 801c4be: 6878         	ldr	r0, [r7, #0x4]
 801c4c0: f7ff ffcf    	bl	0x801c462 <sys_slist_get_not_empty> @ imm = #-0x62
 801c4c4: 4603         	mov	r3, r0
 801c4c6: e000         	b	0x801c4ca <sys_slist_get+0x20> @ imm = #0x0
 801c4c8: 2300         	movs	r3, #0x0
 801c4ca: 4618         	mov	r0, r3
 801c4cc: 3708         	adds	r7, #0x8
 801c4ce: 46bd         	mov	sp, r7
 801c4d0: bd80         	pop	{r7, pc}

0801c4d2 <sys_slist_remove>:
; Z_GENLIST_REMOVE(slist, snode)
 801c4d2: b580         	push	{r7, lr}
 801c4d4: b084         	sub	sp, #0x10
 801c4d6: af00         	add	r7, sp, #0x0
 801c4d8: 60f8         	str	r0, [r7, #0xc]
 801c4da: 60b9         	str	r1, [r7, #0x8]
 801c4dc: 607a         	str	r2, [r7, #0x4]
 801c4de: 68bb         	ldr	r3, [r7, #0x8]
 801c4e0: 2b00         	cmp	r3, #0x0
 801c4e2: d117         	bne	0x801c514 <sys_slist_remove+0x42> @ imm = #0x2e
 801c4e4: 6878         	ldr	r0, [r7, #0x4]
 801c4e6: f7ff ff1f    	bl	0x801c328 <z_snode_next_peek> @ imm = #-0x1c2
 801c4ea: 4603         	mov	r3, r0
 801c4ec: 4619         	mov	r1, r3
 801c4ee: 68f8         	ldr	r0, [r7, #0xc]
 801c4f0: f7ff ff32    	bl	0x801c358 <z_slist_head_set> @ imm = #-0x19c
 801c4f4: 68f8         	ldr	r0, [r7, #0xc]
 801c4f6: f7ff ff54    	bl	0x801c3a2 <sys_slist_peek_tail> @ imm = #-0x158
 801c4fa: 4602         	mov	r2, r0
 801c4fc: 687b         	ldr	r3, [r7, #0x4]
 801c4fe: 4293         	cmp	r3, r2
 801c500: d11b         	bne	0x801c53a <sys_slist_remove+0x68> @ imm = #0x36
 801c502: 68f8         	ldr	r0, [r7, #0xc]
 801c504: f7ff ff42    	bl	0x801c38c <sys_slist_peek_head> @ imm = #-0x17c
 801c508: 4603         	mov	r3, r0
 801c50a: 4619         	mov	r1, r3
 801c50c: 68f8         	ldr	r0, [r7, #0xc]
 801c50e: f7ff ff30    	bl	0x801c372 <z_slist_tail_set> @ imm = #-0x1a0
 801c512: e012         	b	0x801c53a <sys_slist_remove+0x68> @ imm = #0x24
 801c514: 6878         	ldr	r0, [r7, #0x4]
 801c516: f7ff ff07    	bl	0x801c328 <z_snode_next_peek> @ imm = #-0x1f2
 801c51a: 4603         	mov	r3, r0
 801c51c: 4619         	mov	r1, r3
 801c51e: 68b8         	ldr	r0, [r7, #0x8]
 801c520: f7ff ff0d    	bl	0x801c33e <z_snode_next_set> @ imm = #-0x1e6
 801c524: 68f8         	ldr	r0, [r7, #0xc]
 801c526: f7ff ff3c    	bl	0x801c3a2 <sys_slist_peek_tail> @ imm = #-0x188
 801c52a: 4602         	mov	r2, r0
 801c52c: 687b         	ldr	r3, [r7, #0x4]
 801c52e: 4293         	cmp	r3, r2
 801c530: d103         	bne	0x801c53a <sys_slist_remove+0x68> @ imm = #0x6
 801c532: 68b9         	ldr	r1, [r7, #0x8]
 801c534: 68f8         	ldr	r0, [r7, #0xc]
 801c536: f7ff ff1c    	bl	0x801c372 <z_slist_tail_set> @ imm = #-0x1c8
 801c53a: 2100         	movs	r1, #0x0
 801c53c: 6878         	ldr	r0, [r7, #0x4]
 801c53e: f7ff fefe    	bl	0x801c33e <z_snode_next_set> @ imm = #-0x204
 801c542: 3710         	adds	r7, #0x10
 801c544: 46bd         	mov	sp, r7
 801c546: bd80         	pop	{r7, pc}

0801c548 <sys_slist_find_and_remove>:
; Z_GENLIST_FIND_AND_REMOVE(slist, snode)
 801c548: b580         	push	{r7, lr}
 801c54a: b084         	sub	sp, #0x10
 801c54c: af00         	add	r7, sp, #0x0
 801c54e: 6078         	str	r0, [r7, #0x4]
 801c550: 6039         	str	r1, [r7]
 801c552: 2300         	movs	r3, #0x0
 801c554: 60fb         	str	r3, [r7, #0xc]
 801c556: 6878         	ldr	r0, [r7, #0x4]
 801c558: f7ff ff18    	bl	0x801c38c <sys_slist_peek_head> @ imm = #-0x1d0
 801c55c: 60b8         	str	r0, [r7, #0x8]
 801c55e: e010         	b	0x801c582 <sys_slist_find_and_remove+0x3a> @ imm = #0x20
 801c560: 68ba         	ldr	r2, [r7, #0x8]
 801c562: 683b         	ldr	r3, [r7]
 801c564: 429a         	cmp	r2, r3
 801c566: d106         	bne	0x801c576 <sys_slist_find_and_remove+0x2e> @ imm = #0xc
 801c568: 683a         	ldr	r2, [r7]
 801c56a: 68f9         	ldr	r1, [r7, #0xc]
 801c56c: 6878         	ldr	r0, [r7, #0x4]
 801c56e: f7ff ffb0    	bl	0x801c4d2 <sys_slist_remove> @ imm = #-0xa0
 801c572: 2301         	movs	r3, #0x1
 801c574: e009         	b	0x801c58a <sys_slist_find_and_remove+0x42> @ imm = #0x12
 801c576: 68bb         	ldr	r3, [r7, #0x8]
 801c578: 60fb         	str	r3, [r7, #0xc]
 801c57a: 68b8         	ldr	r0, [r7, #0x8]
 801c57c: f7ff ff39    	bl	0x801c3f2 <sys_slist_peek_next> @ imm = #-0x18e
 801c580: 60b8         	str	r0, [r7, #0x8]
 801c582: 68bb         	ldr	r3, [r7, #0x8]
 801c584: 2b00         	cmp	r3, #0x0
 801c586: d1eb         	bne	0x801c560 <sys_slist_find_and_remove+0x18> @ imm = #-0x2a
 801c588: 2300         	movs	r3, #0x0
 801c58a: 4618         	mov	r0, r3
 801c58c: 3710         	adds	r7, #0x10
 801c58e: 46bd         	mov	sp, r7
 801c590: bd80         	pop	{r7, pc}

0801c592 <k_thread_start>:
; {
 801c592: b580         	push	{r7, lr}
 801c594: b082         	sub	sp, #0x8
 801c596: af00         	add	r7, sp, #0x0
 801c598: 6078         	str	r0, [r7, #0x4]
; 	k_thread_resume(thread);
 801c59a: 6878         	ldr	r0, [r7, #0x4]
 801c59c: f000 f82a    	bl	0x801c5f4 <k_thread_resume> @ imm = #0x54
; }
 801c5a0: bf00         	nop
 801c5a2: 3708         	adds	r7, #0x8
 801c5a4: 46bd         	mov	sp, r7
 801c5a6: bd80         	pop	{r7, pc}

0801c5a8 <k_thread_create>:
; {
 801c5a8: b580         	push	{r7, lr}
 801c5aa: b08c         	sub	sp, #0x30
 801c5ac: af08         	add	r7, sp, #0x20
 801c5ae: 60f8         	str	r0, [r7, #0xc]
 801c5b0: 60b9         	str	r1, [r7, #0x8]
 801c5b2: 607a         	str	r2, [r7, #0x4]
 801c5b4: 603b         	str	r3, [r7]
; 	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
 801c5b6: e9d7 230c    	ldrd	r2, r3, [r7, #48]
 801c5ba: e9cd 2306    	strd	r2, r3, [sp, #24]
 801c5be: 6abb         	ldr	r3, [r7, #0x28]
 801c5c0: 9304         	str	r3, [sp, #0x10]
 801c5c2: 6a7b         	ldr	r3, [r7, #0x24]
 801c5c4: 9303         	str	r3, [sp, #0xc]
 801c5c6: 6a3b         	ldr	r3, [r7, #0x20]
 801c5c8: 9302         	str	r3, [sp, #0x8]
 801c5ca: 69fb         	ldr	r3, [r7, #0x1c]
 801c5cc: 9301         	str	r3, [sp, #0x4]
 801c5ce: 69bb         	ldr	r3, [r7, #0x18]
 801c5d0: 9300         	str	r3, [sp]
 801c5d2: 683b         	ldr	r3, [r7]
 801c5d4: 687a         	ldr	r2, [r7, #0x4]
 801c5d6: 68b9         	ldr	r1, [r7, #0x8]
 801c5d8: 68f8         	ldr	r0, [r7, #0xc]
 801c5da: f000 faad    	bl	0x801cb38 <z_impl_k_thread_create> @ imm = #0x55a
 801c5de: 4603         	mov	r3, r0
; }
 801c5e0: 4618         	mov	r0, r3
 801c5e2: 3710         	adds	r7, #0x10
 801c5e4: 46bd         	mov	sp, r7
 801c5e6: bd80         	pop	{r7, pc}

0801c5e8 <k_yield>:
; {
 801c5e8: b580         	push	{r7, lr}
 801c5ea: af00         	add	r7, sp, #0x0
; 	z_impl_k_yield();
 801c5ec: f7f3 fd38    	bl	0x8010060 <z_impl_k_yield> @ imm = #-0xc590
; }
 801c5f0: bf00         	nop
 801c5f2: bd80         	pop	{r7, pc}

0801c5f4 <k_thread_resume>:
; {
 801c5f4: b580         	push	{r7, lr}
 801c5f6: b082         	sub	sp, #0x8
 801c5f8: af00         	add	r7, sp, #0x0
 801c5fa: 6078         	str	r0, [r7, #0x4]
; 	z_impl_k_thread_resume(thread);
 801c5fc: 6878         	ldr	r0, [r7, #0x4]
 801c5fe: f7f3 f907    	bl	0x800f810 <z_impl_k_thread_resume> @ imm = #-0xcdf2
; }
 801c602: bf00         	nop
 801c604: 3708         	adds	r7, #0x8
 801c606: 46bd         	mov	sp, r7
 801c608: bd80         	pop	{r7, pc}

0801c60a <k_thread_name_set>:
; {
 801c60a: b580         	push	{r7, lr}
 801c60c: b082         	sub	sp, #0x8
 801c60e: af00         	add	r7, sp, #0x0
 801c610: 6078         	str	r0, [r7, #0x4]
 801c612: 6039         	str	r1, [r7]
; 	return z_impl_k_thread_name_set(thread, str);
 801c614: 6839         	ldr	r1, [r7]
 801c616: 6878         	ldr	r0, [r7, #0x4]
 801c618: f7f2 fb48    	bl	0x800ecac <z_impl_k_thread_name_set> @ imm = #-0xd970
 801c61c: 4603         	mov	r3, r0
; }
 801c61e: 4618         	mov	r0, r3
 801c620: 3708         	adds	r7, #0x8
 801c622: 46bd         	mov	sp, r7
 801c624: bd80         	pop	{r7, pc}

0801c626 <k_sem_give>:
; {
 801c626: b580         	push	{r7, lr}
 801c628: b082         	sub	sp, #0x8
 801c62a: af00         	add	r7, sp, #0x0
 801c62c: 6078         	str	r0, [r7, #0x4]
; 	z_impl_k_sem_give(sem);
 801c62e: 6878         	ldr	r0, [r7, #0x4]
 801c630: f7f1 feea    	bl	0x800e408 <z_impl_k_sem_give> @ imm = #-0xe22c
; }
 801c634: bf00         	nop
 801c636: 3708         	adds	r7, #0x8
 801c638: 46bd         	mov	sp, r7
 801c63a: bd80         	pop	{r7, pc}

0801c63c <z_init_timeout>:
; {
 801c63c: b580         	push	{r7, lr}
 801c63e: b082         	sub	sp, #0x8
 801c640: af00         	add	r7, sp, #0x0
 801c642: 6078         	str	r0, [r7, #0x4]
; 	sys_dnode_init(&to->node);
 801c644: 687b         	ldr	r3, [r7, #0x4]
 801c646: 4618         	mov	r0, r3
 801c648: f7ff fe50    	bl	0x801c2ec <sys_dnode_init> @ imm = #-0x360
; }
 801c64c: bf00         	nop
 801c64e: 3708         	adds	r7, #0x8
 801c650: 46bd         	mov	sp, r7
 801c652: bd80         	pop	{r7, pc}

0801c654 <z_waitq_init>:
; {
 801c654: b580         	push	{r7, lr}
 801c656: b082         	sub	sp, #0x8
 801c658: af00         	add	r7, sp, #0x0
 801c65a: 6078         	str	r0, [r7, #0x4]
; 	sys_dlist_init(&w->waitq);
 801c65c: 687b         	ldr	r3, [r7, #0x4]
 801c65e: 4618         	mov	r0, r3
 801c660: f7ff fe35    	bl	0x801c2ce <sys_dlist_init> @ imm = #-0x396
; }
 801c664: bf00         	nop
 801c666: 3708         	adds	r7, #0x8
 801c668: 46bd         	mov	sp, r7
 801c66a: bd80         	pop	{r7, pc}

0801c66c <z_sched_wake_all>:
; {
 801c66c: b580         	push	{r7, lr}
 801c66e: b086         	sub	sp, #0x18
 801c670: af00         	add	r7, sp, #0x0
 801c672: 60f8         	str	r0, [r7, #0xc]
 801c674: 60b9         	str	r1, [r7, #0x8]
 801c676: 607a         	str	r2, [r7, #0x4]
; 	bool woken = false;
 801c678: 2300         	movs	r3, #0x0
 801c67a: 75fb         	strb	r3, [r7, #0x17]
; 	while (z_sched_wake(wait_q, swap_retval, swap_data)) {
 801c67c: e001         	b	0x801c682 <z_sched_wake_all+0x16> @ imm = #0x2
; 		woken = true;
 801c67e: 2301         	movs	r3, #0x1
 801c680: 75fb         	strb	r3, [r7, #0x17]
; 	while (z_sched_wake(wait_q, swap_retval, swap_data)) {
 801c682: 687a         	ldr	r2, [r7, #0x4]
 801c684: 68b9         	ldr	r1, [r7, #0x8]
 801c686: 68f8         	ldr	r0, [r7, #0xc]
 801c688: f7f4 f854    	bl	0x8010734 <z_sched_wake> @ imm = #-0xbf58
 801c68c: 4603         	mov	r3, r0
 801c68e: 2b00         	cmp	r3, #0x0
 801c690: d1f5         	bne	0x801c67e <z_sched_wake_all+0x12> @ imm = #-0x16
; 	return woken;
 801c692: 7dfb         	ldrb	r3, [r7, #0x17]
; }
 801c694: 4618         	mov	r0, r3
 801c696: 3718         	adds	r7, #0x18
 801c698: 46bd         	mov	sp, r7
 801c69a: bd80         	pop	{r7, pc}

0801c69c <flag_clear>:
; {
 801c69c: b480         	push	{r7}
 801c69e: b083         	sub	sp, #0xc
 801c6a0: af00         	add	r7, sp, #0x0
 801c6a2: 6078         	str	r0, [r7, #0x4]
 801c6a4: 6039         	str	r1, [r7]
; 	*flagp &= ~BIT(bit);
 801c6a6: 687b         	ldr	r3, [r7, #0x4]
 801c6a8: 681a         	ldr	r2, [r3]
 801c6aa: 2101         	movs	r1, #0x1
 801c6ac: 683b         	ldr	r3, [r7]
 801c6ae: fa01 f303    	lsl.w	r3, r1, r3
 801c6b2: 43db         	mvns	r3, r3
 801c6b4: 401a         	ands	r2, r3
 801c6b6: 687b         	ldr	r3, [r7, #0x4]
 801c6b8: 601a         	str	r2, [r3]
; }
 801c6ba: bf00         	nop
 801c6bc: 370c         	adds	r7, #0xc
 801c6be: 46bd         	mov	sp, r7
 801c6c0: bc80         	pop	{r7}
 801c6c2: 4770         	bx	lr

0801c6c4 <flag_set>:
; {
 801c6c4: b480         	push	{r7}
 801c6c6: b083         	sub	sp, #0xc
 801c6c8: af00         	add	r7, sp, #0x0
 801c6ca: 6078         	str	r0, [r7, #0x4]
 801c6cc: 6039         	str	r1, [r7]
; 	*flagp |= BIT(bit);
 801c6ce: 687b         	ldr	r3, [r7, #0x4]
 801c6d0: 681a         	ldr	r2, [r3]
 801c6d2: 2101         	movs	r1, #0x1
 801c6d4: 683b         	ldr	r3, [r7]
 801c6d6: fa01 f303    	lsl.w	r3, r1, r3
 801c6da: 431a         	orrs	r2, r3
 801c6dc: 687b         	ldr	r3, [r7, #0x4]
 801c6de: 601a         	str	r2, [r3]
; }
 801c6e0: bf00         	nop
 801c6e2: 370c         	adds	r7, #0xc
 801c6e4: 46bd         	mov	sp, r7
 801c6e6: bc80         	pop	{r7}
 801c6e8: 4770         	bx	lr

0801c6ea <flag_test>:
; {
 801c6ea: b480         	push	{r7}
 801c6ec: b083         	sub	sp, #0xc
 801c6ee: af00         	add	r7, sp, #0x0
 801c6f0: 6078         	str	r0, [r7, #0x4]
 801c6f2: 6039         	str	r1, [r7]
; 	return (*flagp & BIT(bit)) != 0U;
 801c6f4: 687b         	ldr	r3, [r7, #0x4]
 801c6f6: 681a         	ldr	r2, [r3]
 801c6f8: 683b         	ldr	r3, [r7]
 801c6fa: fa22 f303    	lsr.w	r3, r2, r3
 801c6fe: f003 0301    	and	r3, r3, #0x1
 801c702: 2b00         	cmp	r3, #0x0
 801c704: bf14         	ite	ne
 801c706: 2301         	movne	r3, #0x1
 801c708: 2300         	moveq	r3, #0x0
 801c70a: b2db         	uxtb	r3, r3
; }
 801c70c: 4618         	mov	r0, r3
 801c70e: 370c         	adds	r7, #0xc
 801c710: 46bd         	mov	sp, r7
 801c712: bc80         	pop	{r7}
 801c714: 4770         	bx	lr

0801c716 <flag_test_and_clear>:
; {
 801c716: b580         	push	{r7, lr}
 801c718: b084         	sub	sp, #0x10
 801c71a: af00         	add	r7, sp, #0x0
 801c71c: 6078         	str	r0, [r7, #0x4]
 801c71e: 6039         	str	r1, [r7]
; 	bool ret = flag_test(flagp, bit);
 801c720: 683b         	ldr	r3, [r7]
 801c722: 4619         	mov	r1, r3
 801c724: 6878         	ldr	r0, [r7, #0x4]
 801c726: f7ff ffe0    	bl	0x801c6ea <flag_test>   @ imm = #-0x40
 801c72a: 4603         	mov	r3, r0
 801c72c: 73fb         	strb	r3, [r7, #0xf]
; 	flag_clear(flagp, bit);
 801c72e: 683b         	ldr	r3, [r7]
 801c730: 4619         	mov	r1, r3
 801c732: 6878         	ldr	r0, [r7, #0x4]
 801c734: f7ff ffb2    	bl	0x801c69c <flag_clear>  @ imm = #-0x9c
; 	return ret;
 801c738: 7bfb         	ldrb	r3, [r7, #0xf]
; }
 801c73a: 4618         	mov	r0, r3
 801c73c: 3710         	adds	r7, #0x10
 801c73e: 46bd         	mov	sp, r7
 801c740: bd80         	pop	{r7, pc}

0801c742 <flags_set>:
; {
 801c742: b480         	push	{r7}
 801c744: b083         	sub	sp, #0xc
 801c746: af00         	add	r7, sp, #0x0
 801c748: 6078         	str	r0, [r7, #0x4]
 801c74a: 6039         	str	r1, [r7]
; 	*flagp = flags;
 801c74c: 687b         	ldr	r3, [r7, #0x4]
 801c74e: 683a         	ldr	r2, [r7]
 801c750: 601a         	str	r2, [r3]
; }
 801c752: bf00         	nop
 801c754: 370c         	adds	r7, #0xc
 801c756: 46bd         	mov	sp, r7
 801c758: bc80         	pop	{r7}
 801c75a: 4770         	bx	lr

0801c75c <flags_get>:
; {
 801c75c: b480         	push	{r7}
 801c75e: b083         	sub	sp, #0xc
 801c760: af00         	add	r7, sp, #0x0
 801c762: 6078         	str	r0, [r7, #0x4]
; 	return *flagp;
 801c764: 687b         	ldr	r3, [r7, #0x4]
 801c766: 681b         	ldr	r3, [r3]
; }
 801c768: 4618         	mov	r0, r3
 801c76a: 370c         	adds	r7, #0xc
 801c76c: 46bd         	mov	sp, r7
 801c76e: bc80         	pop	{r7}
 801c770: 4770         	bx	lr

0801c772 <finalize_flush_locked>:
; {
 801c772: b580         	push	{r7, lr}
 801c774: b084         	sub	sp, #0x10
 801c776: af00         	add	r7, sp, #0x0
 801c778: 6078         	str	r0, [r7, #0x4]
; 	struct z_work_flusher *flusher = CONTAINER_OF(work, struct z_work_flusher, work);
 801c77a: 687b         	ldr	r3, [r7, #0x4]
 801c77c: 60fb         	str	r3, [r7, #0xc]
; 	flag_clear(&work->flags, K_WORK_FLUSHING_BIT);
 801c77e: 687b         	ldr	r3, [r7, #0x4]
 801c780: 330c         	adds	r3, #0xc
 801c782: 2104         	movs	r1, #0x4
 801c784: 4618         	mov	r0, r3
 801c786: f7ff ff89    	bl	0x801c69c <flag_clear>  @ imm = #-0xee
; 	k_sem_give(&flusher->sem);
 801c78a: 68fb         	ldr	r3, [r7, #0xc]
 801c78c: 3310         	adds	r3, #0x10
 801c78e: 4618         	mov	r0, r3
 801c790: f7ff ff49    	bl	0x801c626 <k_sem_give>  @ imm = #-0x16e
; };
 801c794: bf00         	nop
 801c796: 3710         	adds	r7, #0x10
 801c798: 46bd         	mov	sp, r7
 801c79a: bd80         	pop	{r7, pc}

0801c79c <work_busy_get_locked>:
; {
 801c79c: b580         	push	{r7, lr}
 801c79e: b082         	sub	sp, #0x8
 801c7a0: af00         	add	r7, sp, #0x0
 801c7a2: 6078         	str	r0, [r7, #0x4]
; 	return flags_get(&work->flags) & K_WORK_MASK;
 801c7a4: 687b         	ldr	r3, [r7, #0x4]
 801c7a6: 330c         	adds	r3, #0xc
 801c7a8: 4618         	mov	r0, r3
 801c7aa: f7ff ffd7    	bl	0x801c75c <flags_get>   @ imm = #-0x52
 801c7ae: 4603         	mov	r3, r0
 801c7b0: f003 031f    	and	r3, r3, #0x1f
; }
 801c7b4: 4618         	mov	r0, r3
 801c7b6: 3708         	adds	r7, #0x8
 801c7b8: 46bd         	mov	sp, r7
 801c7ba: bd80         	pop	{r7, pc}

0801c7bc <queue_remove_locked>:
; {
 801c7bc: b580         	push	{r7, lr}
 801c7be: b082         	sub	sp, #0x8
 801c7c0: af00         	add	r7, sp, #0x0
 801c7c2: 6078         	str	r0, [r7, #0x4]
 801c7c4: 6039         	str	r1, [r7]
; 	if (flag_test_and_clear(&work->flags, K_WORK_QUEUED_BIT)) {
 801c7c6: 683b         	ldr	r3, [r7]
 801c7c8: 330c         	adds	r3, #0xc
 801c7ca: 2102         	movs	r1, #0x2
 801c7cc: 4618         	mov	r0, r3
 801c7ce: f7ff ffa2    	bl	0x801c716 <flag_test_and_clear> @ imm = #-0xbc
 801c7d2: 4603         	mov	r3, r0
 801c7d4: 2b00         	cmp	r3, #0x0
 801c7d6: d006         	beq	0x801c7e6 <queue_remove_locked+0x2a> @ imm = #0xc
; 		(void)sys_slist_find_and_remove(&queue->pending, &work->node);
 801c7d8: 687b         	ldr	r3, [r7, #0x4]
 801c7da: 33d0         	adds	r3, #0xd0
 801c7dc: 683a         	ldr	r2, [r7]
 801c7de: 4611         	mov	r1, r2
 801c7e0: 4618         	mov	r0, r3
 801c7e2: f7ff feb1    	bl	0x801c548 <sys_slist_find_and_remove> @ imm = #-0x29e
; }
 801c7e6: bf00         	nop
 801c7e8: 3708         	adds	r7, #0x8
 801c7ea: 46bd         	mov	sp, r7
 801c7ec: bd80         	pop	{r7, pc}

0801c7ee <notify_queue_locked>:
; {
 801c7ee: b580         	push	{r7, lr}
 801c7f0: b084         	sub	sp, #0x10
 801c7f2: af00         	add	r7, sp, #0x0
 801c7f4: 6078         	str	r0, [r7, #0x4]
; 	bool rv = false;
 801c7f6: 2300         	movs	r3, #0x0
 801c7f8: 73fb         	strb	r3, [r7, #0xf]
; 	if (queue != NULL) {
 801c7fa: 687b         	ldr	r3, [r7, #0x4]
 801c7fc: 2b00         	cmp	r3, #0x0
 801c7fe: d008         	beq	0x801c812 <notify_queue_locked+0x24> @ imm = #0x10
; 		rv = z_sched_wake(&queue->notifyq, 0, NULL);
 801c800: 687b         	ldr	r3, [r7, #0x4]
 801c802: 33d8         	adds	r3, #0xd8
 801c804: 2200         	movs	r2, #0x0
 801c806: 2100         	movs	r1, #0x0
 801c808: 4618         	mov	r0, r3
 801c80a: f7f3 ff93    	bl	0x8010734 <z_sched_wake> @ imm = #-0xc0da
 801c80e: 4603         	mov	r3, r0
 801c810: 73fb         	strb	r3, [r7, #0xf]
; 	return rv;
 801c812: 7bfb         	ldrb	r3, [r7, #0xf]
; }
 801c814: 4618         	mov	r0, r3
 801c816: 3710         	adds	r7, #0x10
 801c818: 46bd         	mov	sp, r7
 801c81a: bd80         	pop	{r7, pc}

0801c81c <submit_to_queue_locked>:
; {
 801c81c: b580         	push	{r7, lr}
 801c81e: b084         	sub	sp, #0x10
 801c820: af00         	add	r7, sp, #0x0
 801c822: 6078         	str	r0, [r7, #0x4]
 801c824: 6039         	str	r1, [r7]
; 	int ret = 0;
 801c826: 2300         	movs	r3, #0x0
 801c828: 60fb         	str	r3, [r7, #0xc]
; 	if (flag_test(&work->flags, K_WORK_CANCELING_BIT)) {
 801c82a: 687b         	ldr	r3, [r7, #0x4]
 801c82c: 330c         	adds	r3, #0xc
 801c82e: 2101         	movs	r1, #0x1
 801c830: 4618         	mov	r0, r3
 801c832: f7ff ff5a    	bl	0x801c6ea <flag_test>   @ imm = #-0x14c
 801c836: 4603         	mov	r3, r0
 801c838: 2b00         	cmp	r3, #0x0
 801c83a: d003         	beq	0x801c844 <submit_to_queue_locked+0x28> @ imm = #0x6
; 		ret = -EBUSY;
 801c83c: f06f 030f    	mvn	r3, #0xf
 801c840: 60fb         	str	r3, [r7, #0xc]
 801c842: e03b         	b	0x801c8bc <submit_to_queue_locked+0xa0> @ imm = #0x76
; 	} else if (!flag_test(&work->flags, K_WORK_QUEUED_BIT)) {
 801c844: 687b         	ldr	r3, [r7, #0x4]
 801c846: 330c         	adds	r3, #0xc
 801c848: 2102         	movs	r1, #0x2
 801c84a: 4618         	mov	r0, r3
 801c84c: f7ff ff4d    	bl	0x801c6ea <flag_test>   @ imm = #-0x166
 801c850: 4603         	mov	r3, r0
 801c852: f083 0301    	eor	r3, r3, #0x1
 801c856: b2db         	uxtb	r3, r3
 801c858: 2b00         	cmp	r3, #0x0
 801c85a: d02f         	beq	0x801c8bc <submit_to_queue_locked+0xa0> @ imm = #0x5e
; 		ret = 1;
 801c85c: 2301         	movs	r3, #0x1
 801c85e: 60fb         	str	r3, [r7, #0xc]
; 		if (*queuep == NULL) {
 801c860: 683b         	ldr	r3, [r7]
 801c862: 681b         	ldr	r3, [r3]
 801c864: 2b00         	cmp	r3, #0x0
 801c866: d103         	bne	0x801c870 <submit_to_queue_locked+0x54> @ imm = #0x6
; 			*queuep = work->queue;
 801c868: 687b         	ldr	r3, [r7, #0x4]
 801c86a: 689a         	ldr	r2, [r3, #0x8]
 801c86c: 683b         	ldr	r3, [r7]
 801c86e: 601a         	str	r2, [r3]
; 		if (flag_test(&work->flags, K_WORK_RUNNING_BIT)) {
 801c870: 687b         	ldr	r3, [r7, #0x4]
 801c872: 330c         	adds	r3, #0xc
 801c874: 2100         	movs	r1, #0x0
 801c876: 4618         	mov	r0, r3
 801c878: f7ff ff37    	bl	0x801c6ea <flag_test>   @ imm = #-0x192
 801c87c: 4603         	mov	r3, r0
 801c87e: 2b00         	cmp	r3, #0x0
 801c880: d005         	beq	0x801c88e <submit_to_queue_locked+0x72> @ imm = #0xa
; 			*queuep = work->queue;
 801c882: 687b         	ldr	r3, [r7, #0x4]
 801c884: 689a         	ldr	r2, [r3, #0x8]
 801c886: 683b         	ldr	r3, [r7]
 801c888: 601a         	str	r2, [r3]
; 			ret = 2;
 801c88a: 2302         	movs	r3, #0x2
 801c88c: 60fb         	str	r3, [r7, #0xc]
; 		int rc = queue_submit_locked(*queuep, work);
 801c88e: 683b         	ldr	r3, [r7]
 801c890: 681b         	ldr	r3, [r3]
 801c892: 6879         	ldr	r1, [r7, #0x4]
 801c894: 4618         	mov	r0, r3
 801c896: f7f1 ff1b    	bl	0x800e6d0 <queue_submit_locked> @ imm = #-0xe1ca
 801c89a: 60b8         	str	r0, [r7, #0x8]
; 		if (rc < 0) {
 801c89c: 68bb         	ldr	r3, [r7, #0x8]
 801c89e: 2b00         	cmp	r3, #0x0
 801c8a0: da02         	bge	0x801c8a8 <submit_to_queue_locked+0x8c> @ imm = #0x4
; 			ret = rc;
 801c8a2: 68bb         	ldr	r3, [r7, #0x8]
 801c8a4: 60fb         	str	r3, [r7, #0xc]
 801c8a6: e009         	b	0x801c8bc <submit_to_queue_locked+0xa0> @ imm = #0x12
; 			flag_set(&work->flags, K_WORK_QUEUED_BIT);
 801c8a8: 687b         	ldr	r3, [r7, #0x4]
 801c8aa: 330c         	adds	r3, #0xc
 801c8ac: 2102         	movs	r1, #0x2
 801c8ae: 4618         	mov	r0, r3
 801c8b0: f7ff ff08    	bl	0x801c6c4 <flag_set>    @ imm = #-0x1f0
; 			work->queue = *queuep;
 801c8b4: 683b         	ldr	r3, [r7]
 801c8b6: 681a         	ldr	r2, [r3]
 801c8b8: 687b         	ldr	r3, [r7, #0x4]
 801c8ba: 609a         	str	r2, [r3, #0x8]
; 	if (ret <= 0) {
 801c8bc: 68fb         	ldr	r3, [r7, #0xc]
 801c8be: 2b00         	cmp	r3, #0x0
 801c8c0: dc02         	bgt	0x801c8c8 <submit_to_queue_locked+0xac> @ imm = #0x4
; 		*queuep = NULL;
 801c8c2: 683b         	ldr	r3, [r7]
 801c8c4: 2200         	movs	r2, #0x0
 801c8c6: 601a         	str	r2, [r3]
; 	return ret;
 801c8c8: 68fb         	ldr	r3, [r7, #0xc]
; }
 801c8ca: 4618         	mov	r0, r3
 801c8cc: 3710         	adds	r7, #0x10
 801c8ce: 46bd         	mov	sp, r7
 801c8d0: bd80         	pop	{r7, pc}

0801c8d2 <cancel_async_locked>:
; {
 801c8d2: b580         	push	{r7, lr}
 801c8d4: b084         	sub	sp, #0x10
 801c8d6: af00         	add	r7, sp, #0x0
 801c8d8: 6078         	str	r0, [r7, #0x4]
; 	if (!flag_test(&work->flags, K_WORK_CANCELING_BIT)) {
 801c8da: 687b         	ldr	r3, [r7, #0x4]
 801c8dc: 330c         	adds	r3, #0xc
 801c8de: 2101         	movs	r1, #0x1
 801c8e0: 4618         	mov	r0, r3
 801c8e2: f7ff ff02    	bl	0x801c6ea <flag_test>   @ imm = #-0x1fc
 801c8e6: 4603         	mov	r3, r0
 801c8e8: f083 0301    	eor	r3, r3, #0x1
 801c8ec: b2db         	uxtb	r3, r3
 801c8ee: 2b00         	cmp	r3, #0x0
 801c8f0: d005         	beq	0x801c8fe <cancel_async_locked+0x2c> @ imm = #0xa
; 		queue_remove_locked(work->queue, work);
 801c8f2: 687b         	ldr	r3, [r7, #0x4]
 801c8f4: 689b         	ldr	r3, [r3, #0x8]
 801c8f6: 6879         	ldr	r1, [r7, #0x4]
 801c8f8: 4618         	mov	r0, r3
 801c8fa: f7ff ff5f    	bl	0x801c7bc <queue_remove_locked> @ imm = #-0x142
; 	int ret = work_busy_get_locked(work);
 801c8fe: 6878         	ldr	r0, [r7, #0x4]
 801c900: f7ff ff4c    	bl	0x801c79c <work_busy_get_locked> @ imm = #-0x168
 801c904: 60f8         	str	r0, [r7, #0xc]
; 	if (ret != 0) {
 801c906: 68fb         	ldr	r3, [r7, #0xc]
 801c908: 2b00         	cmp	r3, #0x0
 801c90a: d009         	beq	0x801c920 <cancel_async_locked+0x4e> @ imm = #0x12
; 		flag_set(&work->flags, K_WORK_CANCELING_BIT);
 801c90c: 687b         	ldr	r3, [r7, #0x4]
 801c90e: 330c         	adds	r3, #0xc
 801c910: 2101         	movs	r1, #0x1
 801c912: 4618         	mov	r0, r3
 801c914: f7ff fed6    	bl	0x801c6c4 <flag_set>    @ imm = #-0x254
; 		ret = work_busy_get_locked(work);
 801c918: 6878         	ldr	r0, [r7, #0x4]
 801c91a: f7ff ff3f    	bl	0x801c79c <work_busy_get_locked> @ imm = #-0x182
 801c91e: 60f8         	str	r0, [r7, #0xc]
; 	return ret;
 801c920: 68fb         	ldr	r3, [r7, #0xc]
; }
 801c922: 4618         	mov	r0, r3
 801c924: 3710         	adds	r7, #0x10
 801c926: 46bd         	mov	sp, r7
 801c928: bd80         	pop	{r7, pc}

0801c92a <k_work_init_delayable>:
; {
 801c92a: b580         	push	{r7, lr}
 801c92c: b08e         	sub	sp, #0x38
 801c92e: af00         	add	r7, sp, #0x0
 801c930: 6078         	str	r0, [r7, #0x4]
 801c932: 6039         	str	r1, [r7]
; 	*dwork = (struct k_work_delayable){
 801c934: 687b         	ldr	r3, [r7, #0x4]
 801c936: 4618         	mov	r0, r3
 801c938: 2330         	movs	r3, #0x30
 801c93a: 461a         	mov	r2, r3
 801c93c: 2100         	movs	r1, #0x0
 801c93e: f000 ff55    	bl	0x801d7ec <memset>      @ imm = #0xeaa
 801c942: 687b         	ldr	r3, [r7, #0x4]
 801c944: 683a         	ldr	r2, [r7]
 801c946: 605a         	str	r2, [r3, #0x4]
 801c948: 687b         	ldr	r3, [r7, #0x4]
 801c94a: f44f 7280    	mov.w	r2, #0x100
 801c94e: 60da         	str	r2, [r3, #0xc]
; 	z_init_timeout(&dwork->timeout);
 801c950: 687b         	ldr	r3, [r7, #0x4]
 801c952: 3310         	adds	r3, #0x10
 801c954: 4618         	mov	r0, r3
 801c956: f7ff fe71    	bl	0x801c63c <z_init_timeout> @ imm = #-0x31e
; }
 801c95a: bf00         	nop
 801c95c: 3738         	adds	r7, #0x38
 801c95e: 46bd         	mov	sp, r7
 801c960: bd80         	pop	{r7, pc}

0801c962 <unschedule_locked>:
; {
 801c962: b580         	push	{r7, lr}
 801c964: b084         	sub	sp, #0x10
 801c966: af00         	add	r7, sp, #0x0
 801c968: 6078         	str	r0, [r7, #0x4]
; 	bool ret = false;
 801c96a: 2300         	movs	r3, #0x0
 801c96c: 73fb         	strb	r3, [r7, #0xf]
; 	struct k_work *work = &dwork->work;
 801c96e: 687b         	ldr	r3, [r7, #0x4]
 801c970: 60bb         	str	r3, [r7, #0x8]
; 	if (flag_test_and_clear(&work->flags, K_WORK_DELAYED_BIT)) {
 801c972: 68bb         	ldr	r3, [r7, #0x8]
 801c974: 330c         	adds	r3, #0xc
 801c976: 2103         	movs	r1, #0x3
 801c978: 4618         	mov	r0, r3
 801c97a: f7ff fecc    	bl	0x801c716 <flag_test_and_clear> @ imm = #-0x268
 801c97e: 4603         	mov	r3, r0
 801c980: 2b00         	cmp	r3, #0x0
 801c982: d00a         	beq	0x801c99a <unschedule_locked+0x38> @ imm = #0x14
; 		ret = z_abort_timeout(&dwork->timeout) == 0;
 801c984: 687b         	ldr	r3, [r7, #0x4]
 801c986: 3310         	adds	r3, #0x10
 801c988: 4618         	mov	r0, r3
 801c98a: f7f4 fa47    	bl	0x8010e1c <z_abort_timeout> @ imm = #-0xbb72
 801c98e: 4603         	mov	r3, r0
 801c990: 2b00         	cmp	r3, #0x0
 801c992: bf0c         	ite	eq
 801c994: 2301         	moveq	r3, #0x1
 801c996: 2300         	movne	r3, #0x0
 801c998: 73fb         	strb	r3, [r7, #0xf]
; 	return ret;
 801c99a: 7bfb         	ldrb	r3, [r7, #0xf]
; }
 801c99c: 4618         	mov	r0, r3
 801c99e: 3710         	adds	r7, #0x10
 801c9a0: 46bd         	mov	sp, r7
 801c9a2: bd80         	pop	{r7, pc}

0801c9a4 <cancel_delayable_async_locked>:
; {
 801c9a4: b580         	push	{r7, lr}
 801c9a6: b082         	sub	sp, #0x8
 801c9a8: af00         	add	r7, sp, #0x0
 801c9aa: 6078         	str	r0, [r7, #0x4]
; 	(void)unschedule_locked(dwork);
 801c9ac: 6878         	ldr	r0, [r7, #0x4]
 801c9ae: f7ff ffd8    	bl	0x801c962 <unschedule_locked> @ imm = #-0x50
; 	return cancel_async_locked(&dwork->work);
 801c9b2: 687b         	ldr	r3, [r7, #0x4]
 801c9b4: 4618         	mov	r0, r3
 801c9b6: f7ff ff8c    	bl	0x801c8d2 <cancel_async_locked> @ imm = #-0xe8
 801c9ba: 4603         	mov	r3, r0
; }
 801c9bc: 4618         	mov	r0, r3
 801c9be: 3708         	adds	r7, #0x8
 801c9c0: 46bd         	mov	sp, r7
 801c9c2: bd80         	pop	{r7, pc}

0801c9c4 <sys_dlist_init>:
; {
 801c9c4: b480         	push	{r7}
 801c9c6: b083         	sub	sp, #0xc
 801c9c8: af00         	add	r7, sp, #0x0
 801c9ca: 6078         	str	r0, [r7, #0x4]
; 	list->head = (sys_dnode_t *)list;
 801c9cc: 687b         	ldr	r3, [r7, #0x4]
 801c9ce: 687a         	ldr	r2, [r7, #0x4]
 801c9d0: 601a         	str	r2, [r3]
; 	list->tail = (sys_dnode_t *)list;
 801c9d2: 687b         	ldr	r3, [r7, #0x4]
 801c9d4: 687a         	ldr	r2, [r7, #0x4]
 801c9d6: 605a         	str	r2, [r3, #0x4]
; }
 801c9d8: bf00         	nop
 801c9da: 370c         	adds	r7, #0xc
 801c9dc: 46bd         	mov	sp, r7
 801c9de: bc80         	pop	{r7}
 801c9e0: 4770         	bx	lr

0801c9e2 <sys_dnode_init>:
; {
 801c9e2: b480         	push	{r7}
 801c9e4: b083         	sub	sp, #0xc
 801c9e6: af00         	add	r7, sp, #0x0
 801c9e8: 6078         	str	r0, [r7, #0x4]
; 	node->next = NULL;
 801c9ea: 687b         	ldr	r3, [r7, #0x4]
 801c9ec: 2200         	movs	r2, #0x0
 801c9ee: 601a         	str	r2, [r3]
; 	node->prev = NULL;
 801c9f0: 687b         	ldr	r3, [r7, #0x4]
 801c9f2: 2200         	movs	r2, #0x0
 801c9f4: 605a         	str	r2, [r3, #0x4]
; }
 801c9f6: bf00         	nop
 801c9f8: 370c         	adds	r7, #0xc
 801c9fa: 46bd         	mov	sp, r7
 801c9fc: bc80         	pop	{r7}
 801c9fe: 4770         	bx	lr

0801ca00 <K_KERNEL_STACK_BUFFER>:
; {
 801ca00: b480         	push	{r7}
 801ca02: b083         	sub	sp, #0xc
 801ca04: af00         	add	r7, sp, #0x0
 801ca06: 6078         	str	r0, [r7, #0x4]
; 	return (char *)sym + K_KERNEL_STACK_RESERVED;
 801ca08: 687b         	ldr	r3, [r7, #0x4]
; }
 801ca0a: 4618         	mov	r0, r3
 801ca0c: 370c         	adds	r7, #0xc
 801ca0e: 46bd         	mov	sp, r7
 801ca10: bc80         	pop	{r7}
 801ca12: 4770         	bx	lr

0801ca14 <k_thread_start>:
; {
 801ca14: b580         	push	{r7, lr}
 801ca16: b082         	sub	sp, #0x8
 801ca18: af00         	add	r7, sp, #0x0
 801ca1a: 6078         	str	r0, [r7, #0x4]
; 	k_thread_resume(thread);
 801ca1c: 6878         	ldr	r0, [r7, #0x4]
 801ca1e: f000 f804    	bl	0x801ca2a <k_thread_resume> @ imm = #0x8
; }
 801ca22: bf00         	nop
 801ca24: 3708         	adds	r7, #0x8
 801ca26: 46bd         	mov	sp, r7
 801ca28: bd80         	pop	{r7, pc}

0801ca2a <k_thread_resume>:
; {
 801ca2a: b580         	push	{r7, lr}
 801ca2c: b082         	sub	sp, #0x8
 801ca2e: af00         	add	r7, sp, #0x0
 801ca30: 6078         	str	r0, [r7, #0x4]
; 	z_impl_k_thread_resume(thread);
 801ca32: 6878         	ldr	r0, [r7, #0x4]
 801ca34: f7f2 feec    	bl	0x800f810 <z_impl_k_thread_resume> @ imm = #-0xd228
; }
 801ca38: bf00         	nop
 801ca3a: 3708         	adds	r7, #0x8
 801ca3c: 46bd         	mov	sp, r7
 801ca3e: bd80         	pop	{r7, pc}

0801ca40 <z_init_timeout>:
; {
 801ca40: b580         	push	{r7, lr}
 801ca42: b082         	sub	sp, #0x8
 801ca44: af00         	add	r7, sp, #0x0
 801ca46: 6078         	str	r0, [r7, #0x4]
; 	sys_dnode_init(&to->node);
 801ca48: 687b         	ldr	r3, [r7, #0x4]
 801ca4a: 4618         	mov	r0, r3
 801ca4c: f7ff ffc9    	bl	0x801c9e2 <sys_dnode_init> @ imm = #-0x6e
; }
 801ca50: bf00         	nop
 801ca52: 3708         	adds	r7, #0x8
 801ca54: 46bd         	mov	sp, r7
 801ca56: bd80         	pop	{r7, pc}

0801ca58 <z_init_thread_timeout>:
; {
 801ca58: b580         	push	{r7, lr}
 801ca5a: b082         	sub	sp, #0x8
 801ca5c: af00         	add	r7, sp, #0x0
 801ca5e: 6078         	str	r0, [r7, #0x4]
; 	z_init_timeout(&thread_base->timeout);
 801ca60: 687b         	ldr	r3, [r7, #0x4]
 801ca62: 3318         	adds	r3, #0x18
 801ca64: 4618         	mov	r0, r3
 801ca66: f7ff ffeb    	bl	0x801ca40 <z_init_timeout> @ imm = #-0x2a
; }
 801ca6a: bf00         	nop
 801ca6c: 3708         	adds	r7, #0x8
 801ca6e: 46bd         	mov	sp, r7
 801ca70: bd80         	pop	{r7, pc}

0801ca72 <thread_schedule_new>:
; {
 801ca72: b580         	push	{r7, lr}
 801ca74: b084         	sub	sp, #0x10
 801ca76: af00         	add	r7, sp, #0x0
 801ca78: 60f8         	str	r0, [r7, #0xc]
 801ca7a: e9c7 2300    	strd	r2, r3, [r7]
; 	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
 801ca7e: e9d7 2300    	ldrd	r2, r3, [r7]
 801ca82: f04f 0000    	mov.w	r0, #0x0
 801ca86: f04f 0100    	mov.w	r1, #0x0
 801ca8a: 428b         	cmp	r3, r1
 801ca8c: bf08         	it	eq
 801ca8e: 4282         	cmpeq	r2, r0
 801ca90: d103         	bne	0x801ca9a <thread_schedule_new+0x28> @ imm = #0x6
; 		k_thread_start(thread);
 801ca92: 68f8         	ldr	r0, [r7, #0xc]
 801ca94: f7ff ffbe    	bl	0x801ca14 <k_thread_start> @ imm = #-0x84
 801ca98: e004         	b	0x801caa4 <thread_schedule_new+0x32> @ imm = #0x8
; 		z_add_thread_timeout(thread, delay);
 801ca9a: e9d7 2300    	ldrd	r2, r3, [r7]
 801ca9e: 68f8         	ldr	r0, [r7, #0xc]
 801caa0: f7f2 f8f0    	bl	0x800ec84 <z_add_thread_timeout> @ imm = #-0xde20
; }
 801caa4: bf00         	nop
 801caa6: 3710         	adds	r7, #0x10
 801caa8: 46bd         	mov	sp, r7
 801caaa: bd80         	pop	{r7, pc}

0801caac <z_waitq_init>:
; {
 801caac: b580         	push	{r7, lr}
 801caae: b082         	sub	sp, #0x8
 801cab0: af00         	add	r7, sp, #0x0
 801cab2: 6078         	str	r0, [r7, #0x4]
; 	sys_dlist_init(&w->waitq);
 801cab4: 687b         	ldr	r3, [r7, #0x4]
 801cab6: 4618         	mov	r0, r3
 801cab8: f7ff ff84    	bl	0x801c9c4 <sys_dlist_init> @ imm = #-0xf8
; }
 801cabc: bf00         	nop
 801cabe: 3708         	adds	r7, #0x8
 801cac0: 46bd         	mov	sp, r7
 801cac2: bd80         	pop	{r7, pc}

0801cac4 <z_log_msg_runtime_create>:
; {
 801cac4: b580         	push	{r7, lr}
 801cac6: b08a         	sub	sp, #0x28
 801cac8: af04         	add	r7, sp, #0x10
 801caca: 60b9         	str	r1, [r7, #0x8]
 801cacc: 607b         	str	r3, [r7, #0x4]
 801cace: 4603         	mov	r3, r0
 801cad0: 73fb         	strb	r3, [r7, #0xf]
 801cad2: 4613         	mov	r3, r2
 801cad4: 73bb         	strb	r3, [r7, #0xe]
; 	va_start(ap, fmt);
 801cad6: f107 032c    	add.w	r3, r7, #0x2c
 801cada: 617b         	str	r3, [r7, #0x14]
; 	z_log_msg_runtime_vcreate(domain_id, source, level,
 801cadc: 7bba         	ldrb	r2, [r7, #0xe]
 801cade: 7bf8         	ldrb	r0, [r7, #0xf]
 801cae0: 697b         	ldr	r3, [r7, #0x14]
 801cae2: 9303         	str	r3, [sp, #0xc]
 801cae4: 6abb         	ldr	r3, [r7, #0x28]
 801cae6: 9302         	str	r3, [sp, #0x8]
 801cae8: 6a7b         	ldr	r3, [r7, #0x24]
 801caea: 9301         	str	r3, [sp, #0x4]
 801caec: 6a3b         	ldr	r3, [r7, #0x20]
 801caee: 9300         	str	r3, [sp]
 801caf0: 687b         	ldr	r3, [r7, #0x4]
 801caf2: 68b9         	ldr	r1, [r7, #0x8]
 801caf4: f7e7 fd3c    	bl	0x8004570 <z_log_msg_runtime_vcreate> @ imm = #-0x18588
; }
 801caf8: bf00         	nop
 801cafa: 3718         	adds	r7, #0x18
 801cafc: 46bd         	mov	sp, r7
 801cafe: bd80         	pop	{r7, pc}

0801cb00 <k_is_in_isr>:
; {
 801cb00: b480         	push	{r7}
 801cb02: b083         	sub	sp, #0xc
 801cb04: af00         	add	r7, sp, #0x0
;   __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 801cb06: f3ef 8305    	mrs	r3, ipsr
 801cb0a: 607b         	str	r3, [r7, #0x4]
;   return(result);
 801cb0c: 687b         	ldr	r3, [r7, #0x4]
; 	return (__get_IPSR()) ? (true) : (false);
 801cb0e: 2b00         	cmp	r3, #0x0
 801cb10: bf14         	ite	ne
 801cb12: 2301         	movne	r3, #0x1
 801cb14: 2300         	moveq	r3, #0x0
 801cb16: b2db         	uxtb	r3, r3
; }
 801cb18: 4618         	mov	r0, r3
 801cb1a: 370c         	adds	r7, #0xc
 801cb1c: 46bd         	mov	sp, r7
 801cb1e: bc80         	pop	{r7}
 801cb20: 4770         	bx	lr

0801cb22 <k_thread_name_get>:
; {
 801cb22: b480         	push	{r7}
 801cb24: b083         	sub	sp, #0xc
 801cb26: af00         	add	r7, sp, #0x0
 801cb28: 6078         	str	r0, [r7, #0x4]
; 	return (const char *)thread->name;
 801cb2a: 687b         	ldr	r3, [r7, #0x4]
 801cb2c: 3394         	adds	r3, #0x94
; }
 801cb2e: 4618         	mov	r0, r3
 801cb30: 370c         	adds	r7, #0xc
 801cb32: 46bd         	mov	sp, r7
 801cb34: bc80         	pop	{r7}
 801cb36: 4770         	bx	lr

0801cb38 <z_impl_k_thread_create>:
; {
 801cb38: b580         	push	{r7, lr}
 801cb3a: b08a         	sub	sp, #0x28
 801cb3c: af06         	add	r7, sp, #0x18
 801cb3e: 60f8         	str	r0, [r7, #0xc]
 801cb40: 60b9         	str	r1, [r7, #0x8]
 801cb42: 607a         	str	r2, [r7, #0x4]
 801cb44: 603b         	str	r3, [r7]
; 	z_setup_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
 801cb46: 2300         	movs	r3, #0x0
 801cb48: 9305         	str	r3, [sp, #0x14]
 801cb4a: 6abb         	ldr	r3, [r7, #0x28]
 801cb4c: 9304         	str	r3, [sp, #0x10]
 801cb4e: 6a7b         	ldr	r3, [r7, #0x24]
 801cb50: 9303         	str	r3, [sp, #0xc]
 801cb52: 6a3b         	ldr	r3, [r7, #0x20]
 801cb54: 9302         	str	r3, [sp, #0x8]
 801cb56: 69fb         	ldr	r3, [r7, #0x1c]
 801cb58: 9301         	str	r3, [sp, #0x4]
 801cb5a: 69bb         	ldr	r3, [r7, #0x18]
 801cb5c: 9300         	str	r3, [sp]
 801cb5e: 683b         	ldr	r3, [r7]
 801cb60: 687a         	ldr	r2, [r7, #0x4]
 801cb62: 68b9         	ldr	r1, [r7, #0x8]
 801cb64: 68f8         	ldr	r0, [r7, #0xc]
 801cb66: f7f2 f931    	bl	0x800edcc <z_setup_new_thread> @ imm = #-0xdd9e
; 	if (!K_TIMEOUT_EQ(delay, K_FOREVER)) {
 801cb6a: e9d7 230c    	ldrd	r2, r3, [r7, #48]
 801cb6e: f04f 30ff    	mov.w	r0, #0xffffffff
 801cb72: f04f 31ff    	mov.w	r1, #0xffffffff
 801cb76: 428b         	cmp	r3, r1
 801cb78: bf08         	it	eq
 801cb7a: 4282         	cmpeq	r2, r0
 801cb7c: d004         	beq	0x801cb88 <z_impl_k_thread_create+0x50> @ imm = #0x8
; 		thread_schedule_new(new_thread, delay);
 801cb7e: e9d7 230c    	ldrd	r2, r3, [r7, #48]
 801cb82: 68f8         	ldr	r0, [r7, #0xc]
 801cb84: f7ff ff75    	bl	0x801ca72 <thread_schedule_new> @ imm = #-0x116
; 	return new_thread;
 801cb88: 68fb         	ldr	r3, [r7, #0xc]
; }
 801cb8a: 4618         	mov	r0, r3
 801cb8c: 3710         	adds	r7, #0x10
 801cb8e: 46bd         	mov	sp, r7
 801cb90: bd80         	pop	{r7, pc}

0801cb92 <z_init_thread_base>:
; {
 801cb92: b580         	push	{r7, lr}
 801cb94: b084         	sub	sp, #0x10
 801cb96: af00         	add	r7, sp, #0x0
 801cb98: 60f8         	str	r0, [r7, #0xc]
 801cb9a: 60b9         	str	r1, [r7, #0x8]
 801cb9c: 607a         	str	r2, [r7, #0x4]
 801cb9e: 603b         	str	r3, [r7]
; 	thread_base->pended_on = NULL;
 801cba0: 68fb         	ldr	r3, [r7, #0xc]
 801cba2: 2200         	movs	r2, #0x0
 801cba4: 609a         	str	r2, [r3, #0x8]
; 	thread_base->user_options = (uint8_t)options;
 801cba6: 683b         	ldr	r3, [r7]
 801cba8: b2da         	uxtb	r2, r3
 801cbaa: 68fb         	ldr	r3, [r7, #0xc]
 801cbac: 731a         	strb	r2, [r3, #0xc]
; 	thread_base->thread_state = (uint8_t)initial_state;
 801cbae: 687b         	ldr	r3, [r7, #0x4]
 801cbb0: b2da         	uxtb	r2, r3
 801cbb2: 68fb         	ldr	r3, [r7, #0xc]
 801cbb4: 735a         	strb	r2, [r3, #0xd]
; 	thread_base->prio = priority;
 801cbb6: 68bb         	ldr	r3, [r7, #0x8]
 801cbb8: b25a         	sxtb	r2, r3
 801cbba: 68fb         	ldr	r3, [r7, #0xc]
 801cbbc: 739a         	strb	r2, [r3, #0xe]
; 	thread_base->sched_locked = 0U;
 801cbbe: 68fb         	ldr	r3, [r7, #0xc]
 801cbc0: 2200         	movs	r2, #0x0
 801cbc2: 73da         	strb	r2, [r3, #0xf]
; 	z_init_thread_timeout(thread_base);
 801cbc4: 68f8         	ldr	r0, [r7, #0xc]
 801cbc6: f7ff ff47    	bl	0x801ca58 <z_init_thread_timeout> @ imm = #-0x172
; }
 801cbca: bf00         	nop
 801cbcc: 3710         	adds	r7, #0x10
 801cbce: 46bd         	mov	sp, r7
 801cbd0: bd80         	pop	{r7, pc}

0801cbd2 <z_thread_mark_switched_out>:
; {
 801cbd2: b580         	push	{r7, lr}
 801cbd4: af00         	add	r7, sp, #0x0
; 	z_sched_usage_stop();
 801cbd6: f7f4 facb    	bl	0x8011170 <z_sched_usage_stop> @ imm = #-0xba6a
; }
 801cbda: bf00         	nop
 801cbdc: bd80         	pop	{r7, pc}

0801cbde <sys_dlist_init>:
; {
 801cbde: b480         	push	{r7}
 801cbe0: b083         	sub	sp, #0xc
 801cbe2: af00         	add	r7, sp, #0x0
 801cbe4: 6078         	str	r0, [r7, #0x4]
; 	list->head = (sys_dnode_t *)list;
 801cbe6: 687b         	ldr	r3, [r7, #0x4]
 801cbe8: 687a         	ldr	r2, [r7, #0x4]
 801cbea: 601a         	str	r2, [r3]
; 	list->tail = (sys_dnode_t *)list;
 801cbec: 687b         	ldr	r3, [r7, #0x4]
 801cbee: 687a         	ldr	r2, [r7, #0x4]
 801cbf0: 605a         	str	r2, [r3, #0x4]
; }
 801cbf2: bf00         	nop
 801cbf4: 370c         	adds	r7, #0xc
 801cbf6: 46bd         	mov	sp, r7
 801cbf8: bc80         	pop	{r7}
 801cbfa: 4770         	bx	lr

0801cbfc <sys_dnode_init>:
; {
 801cbfc: b480         	push	{r7}
 801cbfe: b083         	sub	sp, #0xc
 801cc00: af00         	add	r7, sp, #0x0
 801cc02: 6078         	str	r0, [r7, #0x4]
; 	node->next = NULL;
 801cc04: 687b         	ldr	r3, [r7, #0x4]
 801cc06: 2200         	movs	r2, #0x0
 801cc08: 601a         	str	r2, [r3]
; 	node->prev = NULL;
 801cc0a: 687b         	ldr	r3, [r7, #0x4]
 801cc0c: 2200         	movs	r2, #0x0
 801cc0e: 605a         	str	r2, [r3, #0x4]
; }
 801cc10: bf00         	nop
 801cc12: 370c         	adds	r7, #0xc
 801cc14: 46bd         	mov	sp, r7
 801cc16: bc80         	pop	{r7}
 801cc18: 4770         	bx	lr

0801cc1a <sys_dnode_is_linked>:
; {
 801cc1a: b480         	push	{r7}
 801cc1c: b083         	sub	sp, #0xc
 801cc1e: af00         	add	r7, sp, #0x0
 801cc20: 6078         	str	r0, [r7, #0x4]
; 	return node->next != NULL;
 801cc22: 687b         	ldr	r3, [r7, #0x4]
 801cc24: 681b         	ldr	r3, [r3]
 801cc26: 2b00         	cmp	r3, #0x0
 801cc28: bf14         	ite	ne
 801cc2a: 2301         	movne	r3, #0x1
 801cc2c: 2300         	moveq	r3, #0x0
 801cc2e: b2db         	uxtb	r3, r3
; }
 801cc30: 4618         	mov	r0, r3
 801cc32: 370c         	adds	r7, #0xc
 801cc34: 46bd         	mov	sp, r7
 801cc36: bc80         	pop	{r7}
 801cc38: 4770         	bx	lr

0801cc3a <sys_dlist_is_empty>:
; {
 801cc3a: b480         	push	{r7}
 801cc3c: b083         	sub	sp, #0xc
 801cc3e: af00         	add	r7, sp, #0x0
 801cc40: 6078         	str	r0, [r7, #0x4]
; 	return list->head == list;
 801cc42: 687b         	ldr	r3, [r7, #0x4]
 801cc44: 681b         	ldr	r3, [r3]
 801cc46: 687a         	ldr	r2, [r7, #0x4]
 801cc48: 429a         	cmp	r2, r3
 801cc4a: bf0c         	ite	eq
 801cc4c: 2301         	moveq	r3, #0x1
 801cc4e: 2300         	movne	r3, #0x0
 801cc50: b2db         	uxtb	r3, r3
; }
 801cc52: 4618         	mov	r0, r3
 801cc54: 370c         	adds	r7, #0xc
 801cc56: 46bd         	mov	sp, r7
 801cc58: bc80         	pop	{r7}
 801cc5a: 4770         	bx	lr

0801cc5c <sys_dlist_peek_head>:
; {
 801cc5c: b580         	push	{r7, lr}
 801cc5e: b082         	sub	sp, #0x8
 801cc60: af00         	add	r7, sp, #0x0
 801cc62: 6078         	str	r0, [r7, #0x4]
; 	return sys_dlist_is_empty(list) ? NULL : list->head;
 801cc64: 6878         	ldr	r0, [r7, #0x4]
 801cc66: f7ff ffe8    	bl	0x801cc3a <sys_dlist_is_empty> @ imm = #-0x30
 801cc6a: 4603         	mov	r3, r0
 801cc6c: 2b00         	cmp	r3, #0x0
 801cc6e: d102         	bne	0x801cc76 <sys_dlist_peek_head+0x1a> @ imm = #0x4
 801cc70: 687b         	ldr	r3, [r7, #0x4]
 801cc72: 681b         	ldr	r3, [r3]
 801cc74: e000         	b	0x801cc78 <sys_dlist_peek_head+0x1c> @ imm = #0x0
 801cc76: 2300         	movs	r3, #0x0
; }
 801cc78: 4618         	mov	r0, r3
 801cc7a: 3708         	adds	r7, #0x8
 801cc7c: 46bd         	mov	sp, r7
 801cc7e: bd80         	pop	{r7, pc}

0801cc80 <sys_dlist_peek_next_no_check>:
; {
 801cc80: b480         	push	{r7}
 801cc82: b083         	sub	sp, #0xc
 801cc84: af00         	add	r7, sp, #0x0
 801cc86: 6078         	str	r0, [r7, #0x4]
 801cc88: 6039         	str	r1, [r7]
; 	return (node == list->tail) ? NULL : node->next;
 801cc8a: 687b         	ldr	r3, [r7, #0x4]
 801cc8c: 685b         	ldr	r3, [r3, #0x4]
 801cc8e: 683a         	ldr	r2, [r7]
 801cc90: 429a         	cmp	r2, r3
 801cc92: d002         	beq	0x801cc9a <sys_dlist_peek_next_no_check+0x1a> @ imm = #0x4
 801cc94: 683b         	ldr	r3, [r7]
 801cc96: 681b         	ldr	r3, [r3]
 801cc98: e000         	b	0x801cc9c <sys_dlist_peek_next_no_check+0x1c> @ imm = #0x0
 801cc9a: 2300         	movs	r3, #0x0
; }
 801cc9c: 4618         	mov	r0, r3
 801cc9e: 370c         	adds	r7, #0xc
 801cca0: 46bd         	mov	sp, r7
 801cca2: bc80         	pop	{r7}
 801cca4: 4770         	bx	lr

0801cca6 <sys_dlist_peek_next>:
; {
 801cca6: b580         	push	{r7, lr}
 801cca8: b082         	sub	sp, #0x8
 801ccaa: af00         	add	r7, sp, #0x0
 801ccac: 6078         	str	r0, [r7, #0x4]
 801ccae: 6039         	str	r1, [r7]
; 	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
 801ccb0: 683b         	ldr	r3, [r7]
 801ccb2: 2b00         	cmp	r3, #0x0
 801ccb4: d005         	beq	0x801ccc2 <sys_dlist_peek_next+0x1c> @ imm = #0xa
 801ccb6: 6839         	ldr	r1, [r7]
 801ccb8: 6878         	ldr	r0, [r7, #0x4]
 801ccba: f7ff ffe1    	bl	0x801cc80 <sys_dlist_peek_next_no_check> @ imm = #-0x3e
 801ccbe: 4603         	mov	r3, r0
 801ccc0: e000         	b	0x801ccc4 <sys_dlist_peek_next+0x1e> @ imm = #0x0
 801ccc2: 2300         	movs	r3, #0x0
; }
 801ccc4: 4618         	mov	r0, r3
 801ccc6: 3708         	adds	r7, #0x8
 801ccc8: 46bd         	mov	sp, r7
 801ccca: bd80         	pop	{r7, pc}

0801cccc <sys_dlist_append>:
; {
 801cccc: b480         	push	{r7}
 801ccce: b085         	sub	sp, #0x14
 801ccd0: af00         	add	r7, sp, #0x0
 801ccd2: 6078         	str	r0, [r7, #0x4]
 801ccd4: 6039         	str	r1, [r7]
; 	sys_dnode_t *const tail = list->tail;
 801ccd6: 687b         	ldr	r3, [r7, #0x4]
 801ccd8: 685b         	ldr	r3, [r3, #0x4]
 801ccda: 60fb         	str	r3, [r7, #0xc]
; 	node->next = list;
 801ccdc: 683b         	ldr	r3, [r7]
 801ccde: 687a         	ldr	r2, [r7, #0x4]
 801cce0: 601a         	str	r2, [r3]
; 	node->prev = tail;
 801cce2: 683b         	ldr	r3, [r7]
 801cce4: 68fa         	ldr	r2, [r7, #0xc]
 801cce6: 605a         	str	r2, [r3, #0x4]
; 	tail->next = node;
 801cce8: 68fb         	ldr	r3, [r7, #0xc]
 801ccea: 683a         	ldr	r2, [r7]
 801ccec: 601a         	str	r2, [r3]
; 	list->tail = node;
 801ccee: 687b         	ldr	r3, [r7, #0x4]
 801ccf0: 683a         	ldr	r2, [r7]
 801ccf2: 605a         	str	r2, [r3, #0x4]
; }
 801ccf4: bf00         	nop
 801ccf6: 3714         	adds	r7, #0x14
 801ccf8: 46bd         	mov	sp, r7
 801ccfa: bc80         	pop	{r7}
 801ccfc: 4770         	bx	lr

0801ccfe <sys_dlist_insert>:
; {
 801ccfe: b480         	push	{r7}
 801cd00: b085         	sub	sp, #0x14
 801cd02: af00         	add	r7, sp, #0x0
 801cd04: 6078         	str	r0, [r7, #0x4]
 801cd06: 6039         	str	r1, [r7]
; 	sys_dnode_t *const prev = successor->prev;
 801cd08: 687b         	ldr	r3, [r7, #0x4]
 801cd0a: 685b         	ldr	r3, [r3, #0x4]
 801cd0c: 60fb         	str	r3, [r7, #0xc]
; 	node->prev = prev;
 801cd0e: 683b         	ldr	r3, [r7]
 801cd10: 68fa         	ldr	r2, [r7, #0xc]
 801cd12: 605a         	str	r2, [r3, #0x4]
; 	node->next = successor;
 801cd14: 683b         	ldr	r3, [r7]
 801cd16: 687a         	ldr	r2, [r7, #0x4]
 801cd18: 601a         	str	r2, [r3]
; 	prev->next = node;
 801cd1a: 68fb         	ldr	r3, [r7, #0xc]
 801cd1c: 683a         	ldr	r2, [r7]
 801cd1e: 601a         	str	r2, [r3]
; 	successor->prev = node;
 801cd20: 687b         	ldr	r3, [r7, #0x4]
 801cd22: 683a         	ldr	r2, [r7]
 801cd24: 605a         	str	r2, [r3, #0x4]
; }
 801cd26: bf00         	nop
 801cd28: 3714         	adds	r7, #0x14
 801cd2a: 46bd         	mov	sp, r7
 801cd2c: bc80         	pop	{r7}
 801cd2e: 4770         	bx	lr

0801cd30 <sys_dlist_remove>:
; {
 801cd30: b580         	push	{r7, lr}
 801cd32: b084         	sub	sp, #0x10
 801cd34: af00         	add	r7, sp, #0x0
 801cd36: 6078         	str	r0, [r7, #0x4]
; 	sys_dnode_t *const prev = node->prev;
 801cd38: 687b         	ldr	r3, [r7, #0x4]
 801cd3a: 685b         	ldr	r3, [r3, #0x4]
 801cd3c: 60fb         	str	r3, [r7, #0xc]
; 	sys_dnode_t *const next = node->next;
 801cd3e: 687b         	ldr	r3, [r7, #0x4]
 801cd40: 681b         	ldr	r3, [r3]
 801cd42: 60bb         	str	r3, [r7, #0x8]
; 	prev->next = next;
 801cd44: 68fb         	ldr	r3, [r7, #0xc]
 801cd46: 68ba         	ldr	r2, [r7, #0x8]
 801cd48: 601a         	str	r2, [r3]
; 	next->prev = prev;
 801cd4a: 68bb         	ldr	r3, [r7, #0x8]
 801cd4c: 68fa         	ldr	r2, [r7, #0xc]
 801cd4e: 605a         	str	r2, [r3, #0x4]
; 	sys_dnode_init(node);
 801cd50: 6878         	ldr	r0, [r7, #0x4]
 801cd52: f7ff ff53    	bl	0x801cbfc <sys_dnode_init> @ imm = #-0x15a
; }
 801cd56: bf00         	nop
 801cd58: 3710         	adds	r7, #0x10
 801cd5a: 46bd         	mov	sp, r7
 801cd5c: bd80         	pop	{r7, pc}

0801cd5e <k_yield>:
; {
 801cd5e: b580         	push	{r7, lr}
 801cd60: af00         	add	r7, sp, #0x0
; 	z_impl_k_yield();
 801cd62: f7f3 f97d    	bl	0x8010060 <z_impl_k_yield> @ imm = #-0xcd06
; }
 801cd66: bf00         	nop
 801cd68: bd80         	pop	{r7, pc}

0801cd6a <k_thread_suspend>:
; {
 801cd6a: b580         	push	{r7, lr}
 801cd6c: b082         	sub	sp, #0x8
 801cd6e: af00         	add	r7, sp, #0x0
 801cd70: 6078         	str	r0, [r7, #0x4]
; 	z_impl_k_thread_suspend(thread);
 801cd72: 6878         	ldr	r0, [r7, #0x4]
 801cd74: f7f2 fc24    	bl	0x800f5c0 <z_impl_k_thread_suspend> @ imm = #-0xd7b8
; }
 801cd78: bf00         	nop
 801cd7a: 3708         	adds	r7, #0x8
 801cd7c: 46bd         	mov	sp, r7
 801cd7e: bd80         	pop	{r7, pc}

0801cd80 <z_is_inactive_timeout>:
; {
 801cd80: b580         	push	{r7, lr}
 801cd82: b082         	sub	sp, #0x8
 801cd84: af00         	add	r7, sp, #0x0
 801cd86: 6078         	str	r0, [r7, #0x4]
; 	return !sys_dnode_is_linked(&to->node);
 801cd88: 687b         	ldr	r3, [r7, #0x4]
 801cd8a: 4618         	mov	r0, r3
 801cd8c: f7ff ff45    	bl	0x801cc1a <sys_dnode_is_linked> @ imm = #-0x176
 801cd90: 4603         	mov	r3, r0
 801cd92: 2b00         	cmp	r3, #0x0
 801cd94: bf14         	ite	ne
 801cd96: 2301         	movne	r3, #0x1
 801cd98: 2300         	moveq	r3, #0x0
 801cd9a: b2db         	uxtb	r3, r3
 801cd9c: f083 0301    	eor	r3, r3, #0x1
 801cda0: b2db         	uxtb	r3, r3
 801cda2: f003 0301    	and	r3, r3, #0x1
 801cda6: b2db         	uxtb	r3, r3
; }
 801cda8: 4618         	mov	r0, r3
 801cdaa: 3708         	adds	r7, #0x8
 801cdac: 46bd         	mov	sp, r7
 801cdae: bd80         	pop	{r7, pc}

0801cdb0 <z_abort_thread_timeout>:
; {
 801cdb0: b580         	push	{r7, lr}
 801cdb2: b082         	sub	sp, #0x8
 801cdb4: af00         	add	r7, sp, #0x0
 801cdb6: 6078         	str	r0, [r7, #0x4]
; 	return z_abort_timeout(&thread->base.timeout);
 801cdb8: 687b         	ldr	r3, [r7, #0x4]
 801cdba: 3318         	adds	r3, #0x18
 801cdbc: 4618         	mov	r0, r3
 801cdbe: f7f4 f82d    	bl	0x8010e1c <z_abort_timeout> @ imm = #-0xbfa6
 801cdc2: 4603         	mov	r3, r0
; }
 801cdc4: 4618         	mov	r0, r3
 801cdc6: 3708         	adds	r7, #0x8
 801cdc8: 46bd         	mov	sp, r7
 801cdca: bd80         	pop	{r7, pc}

0801cdcc <thread_is_preemptible>:
; {
 801cdcc: b480         	push	{r7}
 801cdce: b083         	sub	sp, #0xc
 801cdd0: af00         	add	r7, sp, #0x0
 801cdd2: 6078         	str	r0, [r7, #0x4]
; 	return thread->base.preempt <= _PREEMPT_THRESHOLD;
 801cdd4: 687b         	ldr	r3, [r7, #0x4]
 801cdd6: 89db         	ldrh	r3, [r3, #0xe]
 801cdd8: 2b7f         	cmp	r3, #0x7f
 801cdda: bf94         	ite	ls
 801cddc: 2301         	movls	r3, #0x1
 801cdde: 2300         	movhi	r3, #0x0
 801cde0: b2db         	uxtb	r3, r3
; }
 801cde2: 4618         	mov	r0, r3
 801cde4: 370c         	adds	r7, #0xc
 801cde6: 46bd         	mov	sp, r7
 801cde8: bc80         	pop	{r7}
 801cdea: 4770         	bx	lr

0801cdec <thread_is_metairq>:
; {
 801cdec: b480         	push	{r7}
 801cdee: b083         	sub	sp, #0xc
 801cdf0: af00         	add	r7, sp, #0x0
 801cdf2: 6078         	str	r0, [r7, #0x4]
; 	return 0;
 801cdf4: 2300         	movs	r3, #0x0
; }
 801cdf6: 4618         	mov	r0, r3
 801cdf8: 370c         	adds	r7, #0xc
 801cdfa: 46bd         	mov	sp, r7
 801cdfc: bc80         	pop	{r7}
 801cdfe: 4770         	bx	lr

0801ce00 <z_is_thread_suspended>:
; {
 801ce00: b480         	push	{r7}
 801ce02: b083         	sub	sp, #0xc
 801ce04: af00         	add	r7, sp, #0x0
 801ce06: 6078         	str	r0, [r7, #0x4]
; 	return (thread->base.thread_state & _THREAD_SUSPENDED) != 0U;
 801ce08: 687b         	ldr	r3, [r7, #0x4]
 801ce0a: 7b5b         	ldrb	r3, [r3, #0xd]
 801ce0c: f003 0310    	and	r3, r3, #0x10
 801ce10: 2b00         	cmp	r3, #0x0
 801ce12: bf14         	ite	ne
 801ce14: 2301         	movne	r3, #0x1
 801ce16: 2300         	moveq	r3, #0x0
 801ce18: b2db         	uxtb	r3, r3
; }
 801ce1a: 4618         	mov	r0, r3
 801ce1c: 370c         	adds	r7, #0xc
 801ce1e: 46bd         	mov	sp, r7
 801ce20: bc80         	pop	{r7}
 801ce22: 4770         	bx	lr

0801ce24 <z_is_thread_prevented_from_running>:
; {
 801ce24: b480         	push	{r7}
 801ce26: b085         	sub	sp, #0x14
 801ce28: af00         	add	r7, sp, #0x0
 801ce2a: 6078         	str	r0, [r7, #0x4]
; 	uint8_t state = thread->base.thread_state;
 801ce2c: 687b         	ldr	r3, [r7, #0x4]
 801ce2e: 7b5b         	ldrb	r3, [r3, #0xd]
 801ce30: 73fb         	strb	r3, [r7, #0xf]
; 	return (state & (_THREAD_PENDING | _THREAD_DEAD |
 801ce32: 7bfb         	ldrb	r3, [r7, #0xf]
 801ce34: f003 031b    	and	r3, r3, #0x1b
; 			 _THREAD_DUMMY | _THREAD_SUSPENDED)) != 0U;
 801ce38: 2b00         	cmp	r3, #0x0
 801ce3a: bf14         	ite	ne
 801ce3c: 2301         	movne	r3, #0x1
 801ce3e: 2300         	moveq	r3, #0x0
 801ce40: b2db         	uxtb	r3, r3
; }
 801ce42: 4618         	mov	r0, r3
 801ce44: 3714         	adds	r7, #0x14
 801ce46: 46bd         	mov	sp, r7
 801ce48: bc80         	pop	{r7}
 801ce4a: 4770         	bx	lr

0801ce4c <z_is_thread_timeout_active>:
; {
 801ce4c: b580         	push	{r7, lr}
 801ce4e: b082         	sub	sp, #0x8
 801ce50: af00         	add	r7, sp, #0x0
 801ce52: 6078         	str	r0, [r7, #0x4]
; 	return !z_is_inactive_timeout(&thread->base.timeout);
 801ce54: 687b         	ldr	r3, [r7, #0x4]
 801ce56: 3318         	adds	r3, #0x18
 801ce58: 4618         	mov	r0, r3
 801ce5a: f7ff ff91    	bl	0x801cd80 <z_is_inactive_timeout> @ imm = #-0xde
 801ce5e: 4603         	mov	r3, r0
 801ce60: 2b00         	cmp	r3, #0x0
 801ce62: bf14         	ite	ne
 801ce64: 2301         	movne	r3, #0x1
 801ce66: 2300         	moveq	r3, #0x0
 801ce68: b2db         	uxtb	r3, r3
 801ce6a: f083 0301    	eor	r3, r3, #0x1
 801ce6e: b2db         	uxtb	r3, r3
 801ce70: f003 0301    	and	r3, r3, #0x1
 801ce74: b2db         	uxtb	r3, r3
; }
 801ce76: 4618         	mov	r0, r3
 801ce78: 3708         	adds	r7, #0x8
 801ce7a: 46bd         	mov	sp, r7
 801ce7c: bd80         	pop	{r7, pc}

0801ce7e <z_is_thread_ready>:
; {
 801ce7e: b580         	push	{r7, lr}
 801ce80: b082         	sub	sp, #0x8
 801ce82: af00         	add	r7, sp, #0x0
 801ce84: 6078         	str	r0, [r7, #0x4]
; 	return !((z_is_thread_prevented_from_running(thread)) != 0U ||
 801ce86: 6878         	ldr	r0, [r7, #0x4]
 801ce88: f7ff ffcc    	bl	0x801ce24 <z_is_thread_prevented_from_running> @ imm = #-0x68
 801ce8c: 4603         	mov	r3, r0
 801ce8e: f083 0301    	eor	r3, r3, #0x1
 801ce92: b2db         	uxtb	r3, r3
 801ce94: 2b00         	cmp	r3, #0x0
 801ce96: d00a         	beq	0x801ceae <z_is_thread_ready+0x30> @ imm = #0x14
; 		 z_is_thread_timeout_active(thread));
 801ce98: 6878         	ldr	r0, [r7, #0x4]
 801ce9a: f7ff ffd7    	bl	0x801ce4c <z_is_thread_timeout_active> @ imm = #-0x52
 801ce9e: 4603         	mov	r3, r0
; 	return !((z_is_thread_prevented_from_running(thread)) != 0U ||
 801cea0: f083 0301    	eor	r3, r3, #0x1
 801cea4: b2db         	uxtb	r3, r3
 801cea6: 2b00         	cmp	r3, #0x0
 801cea8: d001         	beq	0x801ceae <z_is_thread_ready+0x30> @ imm = #0x2
 801ceaa: 2301         	movs	r3, #0x1
 801ceac: e000         	b	0x801ceb0 <z_is_thread_ready+0x32> @ imm = #0x0
 801ceae: 2300         	movs	r3, #0x0
 801ceb0: f003 0301    	and	r3, r3, #0x1
 801ceb4: b2db         	uxtb	r3, r3
; }
 801ceb6: 4618         	mov	r0, r3
 801ceb8: 3708         	adds	r7, #0x8
 801ceba: 46bd         	mov	sp, r7
 801cebc: bd80         	pop	{r7, pc}

0801cebe <z_is_thread_state_set>:
; {
 801cebe: b480         	push	{r7}
 801cec0: b083         	sub	sp, #0xc
 801cec2: af00         	add	r7, sp, #0x0
 801cec4: 6078         	str	r0, [r7, #0x4]
 801cec6: 6039         	str	r1, [r7]
; 	return (thread->base.thread_state & state) != 0U;
 801cec8: 687b         	ldr	r3, [r7, #0x4]
 801ceca: 7b5b         	ldrb	r3, [r3, #0xd]
 801cecc: 461a         	mov	r2, r3
 801cece: 683b         	ldr	r3, [r7]
 801ced0: 4013         	ands	r3, r2
 801ced2: 2b00         	cmp	r3, #0x0
 801ced4: bf14         	ite	ne
 801ced6: 2301         	movne	r3, #0x1
 801ced8: 2300         	moveq	r3, #0x0
 801ceda: b2db         	uxtb	r3, r3
; }
 801cedc: 4618         	mov	r0, r3
 801cede: 370c         	adds	r7, #0xc
 801cee0: 46bd         	mov	sp, r7
 801cee2: bc80         	pop	{r7}
 801cee4: 4770         	bx	lr

0801cee6 <z_is_thread_queued>:
; {
 801cee6: b580         	push	{r7, lr}
 801cee8: b082         	sub	sp, #0x8
 801ceea: af00         	add	r7, sp, #0x0
 801ceec: 6078         	str	r0, [r7, #0x4]
; 	return z_is_thread_state_set(thread, _THREAD_QUEUED);
 801ceee: 2180         	movs	r1, #0x80
 801cef0: 6878         	ldr	r0, [r7, #0x4]
 801cef2: f7ff ffe4    	bl	0x801cebe <z_is_thread_state_set> @ imm = #-0x38
 801cef6: 4603         	mov	r3, r0
; }
 801cef8: 4618         	mov	r0, r3
 801cefa: 3708         	adds	r7, #0x8
 801cefc: 46bd         	mov	sp, r7
 801cefe: bd80         	pop	{r7, pc}

0801cf00 <z_mark_thread_as_suspended>:
; {
 801cf00: b480         	push	{r7}
 801cf02: b083         	sub	sp, #0xc
 801cf04: af00         	add	r7, sp, #0x0
 801cf06: 6078         	str	r0, [r7, #0x4]
; 	thread->base.thread_state |= _THREAD_SUSPENDED;
 801cf08: 687b         	ldr	r3, [r7, #0x4]
 801cf0a: 7b5b         	ldrb	r3, [r3, #0xd]
 801cf0c: f043 0310    	orr	r3, r3, #0x10
 801cf10: b2da         	uxtb	r2, r3
 801cf12: 687b         	ldr	r3, [r7, #0x4]
 801cf14: 735a         	strb	r2, [r3, #0xd]
; }
 801cf16: bf00         	nop
 801cf18: 370c         	adds	r7, #0xc
 801cf1a: 46bd         	mov	sp, r7
 801cf1c: bc80         	pop	{r7}
 801cf1e: 4770         	bx	lr

0801cf20 <z_mark_thread_as_not_suspended>:
; {
 801cf20: b480         	push	{r7}
 801cf22: b083         	sub	sp, #0xc
 801cf24: af00         	add	r7, sp, #0x0
 801cf26: 6078         	str	r0, [r7, #0x4]
; 	thread->base.thread_state &= ~_THREAD_SUSPENDED;
 801cf28: 687b         	ldr	r3, [r7, #0x4]
 801cf2a: 7b5b         	ldrb	r3, [r3, #0xd]
 801cf2c: f023 0310    	bic	r3, r3, #0x10
 801cf30: b2da         	uxtb	r2, r3
 801cf32: 687b         	ldr	r3, [r7, #0x4]
 801cf34: 735a         	strb	r2, [r3, #0xd]
; }
 801cf36: bf00         	nop
 801cf38: 370c         	adds	r7, #0xc
 801cf3a: 46bd         	mov	sp, r7
 801cf3c: bc80         	pop	{r7}
 801cf3e: 4770         	bx	lr

0801cf40 <z_mark_thread_as_pending>:
; {
 801cf40: b480         	push	{r7}
 801cf42: b083         	sub	sp, #0xc
 801cf44: af00         	add	r7, sp, #0x0
 801cf46: 6078         	str	r0, [r7, #0x4]
; 	thread->base.thread_state |= _THREAD_PENDING;
 801cf48: 687b         	ldr	r3, [r7, #0x4]
 801cf4a: 7b5b         	ldrb	r3, [r3, #0xd]
 801cf4c: f043 0302    	orr	r3, r3, #0x2
 801cf50: b2da         	uxtb	r2, r3
 801cf52: 687b         	ldr	r3, [r7, #0x4]
 801cf54: 735a         	strb	r2, [r3, #0xd]
; }
 801cf56: bf00         	nop
 801cf58: 370c         	adds	r7, #0xc
 801cf5a: 46bd         	mov	sp, r7
 801cf5c: bc80         	pop	{r7}
 801cf5e: 4770         	bx	lr

0801cf60 <z_mark_thread_as_not_pending>:
; {
 801cf60: b480         	push	{r7}
 801cf62: b083         	sub	sp, #0xc
 801cf64: af00         	add	r7, sp, #0x0
 801cf66: 6078         	str	r0, [r7, #0x4]
; 	thread->base.thread_state &= ~_THREAD_PENDING;
 801cf68: 687b         	ldr	r3, [r7, #0x4]
 801cf6a: 7b5b         	ldrb	r3, [r3, #0xd]
 801cf6c: f023 0302    	bic	r3, r3, #0x2
 801cf70: b2da         	uxtb	r2, r3
 801cf72: 687b         	ldr	r3, [r7, #0x4]
 801cf74: 735a         	strb	r2, [r3, #0xd]
; }
 801cf76: bf00         	nop
 801cf78: 370c         	adds	r7, #0xc
 801cf7a: 46bd         	mov	sp, r7
 801cf7c: bc80         	pop	{r7}
 801cf7e: 4770         	bx	lr

0801cf80 <z_is_thread_essential>:
; {
 801cf80: b480         	push	{r7}
 801cf82: b083         	sub	sp, #0xc
 801cf84: af00         	add	r7, sp, #0x0
 801cf86: 6078         	str	r0, [r7, #0x4]
; 	return (thread->base.user_options & K_ESSENTIAL) == K_ESSENTIAL;
 801cf88: 687b         	ldr	r3, [r7, #0x4]
 801cf8a: 7b1b         	ldrb	r3, [r3, #0xc]
 801cf8c: f003 0301    	and	r3, r3, #0x1
 801cf90: 2b00         	cmp	r3, #0x0
 801cf92: bf14         	ite	ne
 801cf94: 2301         	movne	r3, #0x1
 801cf96: 2300         	moveq	r3, #0x0
 801cf98: b2db         	uxtb	r3, r3
; }
 801cf9a: 4618         	mov	r0, r3
 801cf9c: 370c         	adds	r7, #0xc
 801cf9e: 46bd         	mov	sp, r7
 801cfa0: bc80         	pop	{r7}
 801cfa2: 4770         	bx	lr

0801cfa4 <z_reschedule_unlocked>:
; {
 801cfa4: b580         	push	{r7, lr}
 801cfa6: b084         	sub	sp, #0x10
 801cfa8: af00         	add	r7, sp, #0x0
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 801cfaa: f3ef 8311    	mrs	r3, basepri
 801cfae: 60fb         	str	r3, [r7, #0xc]
;   return(result);
 801cfb0: 68fb         	ldr	r3, [r7, #0xc]
; 	key = __get_BASEPRI();
 801cfb2: 60bb         	str	r3, [r7, #0x8]
 801cfb4: 2310         	movs	r3, #0x10
 801cfb6: 607b         	str	r3, [r7, #0x4]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 801cfb8: 687b         	ldr	r3, [r7, #0x4]
 801cfba: f383 8812    	msr	basepri_max, r3
; }
 801cfbe: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 801cfc0: f3bf 8f6f    	isb	sy
; }
 801cfc4: bf00         	nop
; 	return key;
 801cfc6: 68bb         	ldr	r3, [r7, #0x8]
; 	(void) z_reschedule_irqlock(arch_irq_lock());
 801cfc8: 4618         	mov	r0, r3
 801cfca: f000 f9b0    	bl	0x801d32e <z_reschedule_irqlock> @ imm = #0x360
; }
 801cfce: bf00         	nop
 801cfd0: 3710         	adds	r7, #0x10
 801cfd2: 46bd         	mov	sp, r7
 801cfd4: bd80         	pop	{r7, pc}

0801cfd6 <unpend_thread_no_timeout>:
; {
 801cfd6: b580         	push	{r7, lr}
 801cfd8: b086         	sub	sp, #0x18
 801cfda: af00         	add	r7, sp, #0x0
 801cfdc: 6078         	str	r0, [r7, #0x4]
 801cfde: 687b         	ldr	r3, [r7, #0x4]
 801cfe0: 60fb         	str	r3, [r7, #0xc]
; 	return thread->base.pended_on;
 801cfe2: 68fb         	ldr	r3, [r7, #0xc]
 801cfe4: 689b         	ldr	r3, [r3, #0x8]
 801cfe6: 617b         	str	r3, [r7, #0x14]
 801cfe8: 687b         	ldr	r3, [r7, #0x4]
 801cfea: 613b         	str	r3, [r7, #0x10]
; 	sys_dlist_remove(&thread->base.qnode_dlist);
 801cfec: 693b         	ldr	r3, [r7, #0x10]
 801cfee: 4618         	mov	r0, r3
 801cff0: f7ff fe9e    	bl	0x801cd30 <sys_dlist_remove> @ imm = #-0x2c4
; }
 801cff4: bf00         	nop
; 	z_mark_thread_as_not_pending(thread);
 801cff6: 6878         	ldr	r0, [r7, #0x4]
 801cff8: f7ff ffb2    	bl	0x801cf60 <z_mark_thread_as_not_pending> @ imm = #-0x9c
; 	thread->base.pended_on = NULL;
 801cffc: 687b         	ldr	r3, [r7, #0x4]
 801cffe: 2200         	movs	r2, #0x0
 801d000: 609a         	str	r2, [r3, #0x8]
; }
 801d002: bf00         	nop
 801d004: 3718         	adds	r7, #0x18
 801d006: 46bd         	mov	sp, r7
 801d008: bd80         	pop	{r7, pc}

0801d00a <z_waitq_head>:
; {
 801d00a: b580         	push	{r7, lr}
 801d00c: b082         	sub	sp, #0x8
 801d00e: af00         	add	r7, sp, #0x0
 801d010: 6078         	str	r0, [r7, #0x4]
; 	return (struct k_thread *)sys_dlist_peek_head(&w->waitq);
 801d012: 687b         	ldr	r3, [r7, #0x4]
 801d014: 4618         	mov	r0, r3
 801d016: f7ff fe21    	bl	0x801cc5c <sys_dlist_peek_head> @ imm = #-0x3be
 801d01a: 4603         	mov	r3, r0
; }
 801d01c: 4618         	mov	r0, r3
 801d01e: 3708         	adds	r7, #0x8
 801d020: 46bd         	mov	sp, r7
 801d022: bd80         	pop	{r7, pc}

0801d024 <z_swap_irqlock>:
; {
 801d024: b580         	push	{r7, lr}
 801d026: b084         	sub	sp, #0x10
 801d028: af00         	add	r7, sp, #0x0
 801d02a: 6078         	str	r0, [r7, #0x4]
; 	ret = arch_swap(key);
 801d02c: 6878         	ldr	r0, [r7, #0x4]
 801d02e: f7e8 fe6b    	bl	0x8005d08 <arch_swap>   @ imm = #-0x1732a
 801d032: 60f8         	str	r0, [r7, #0xc]
; 	return ret;
 801d034: 68fb         	ldr	r3, [r7, #0xc]
; }
 801d036: 4618         	mov	r0, r3
 801d038: 3710         	adds	r7, #0x10
 801d03a: 46bd         	mov	sp, r7
 801d03c: bd80         	pop	{r7, pc}

0801d03e <z_log_msg_runtime_create>:
; {
 801d03e: b580         	push	{r7, lr}
 801d040: b08a         	sub	sp, #0x28
 801d042: af04         	add	r7, sp, #0x10
 801d044: 60b9         	str	r1, [r7, #0x8]
 801d046: 607b         	str	r3, [r7, #0x4]
 801d048: 4603         	mov	r3, r0
 801d04a: 73fb         	strb	r3, [r7, #0xf]
 801d04c: 4613         	mov	r3, r2
 801d04e: 73bb         	strb	r3, [r7, #0xe]
; 	va_start(ap, fmt);
 801d050: f107 032c    	add.w	r3, r7, #0x2c
 801d054: 617b         	str	r3, [r7, #0x14]
; 	z_log_msg_runtime_vcreate(domain_id, source, level,
 801d056: 7bba         	ldrb	r2, [r7, #0xe]
 801d058: 7bf8         	ldrb	r0, [r7, #0xf]
 801d05a: 697b         	ldr	r3, [r7, #0x14]
 801d05c: 9303         	str	r3, [sp, #0xc]
 801d05e: 6abb         	ldr	r3, [r7, #0x28]
 801d060: 9302         	str	r3, [sp, #0x8]
 801d062: 6a7b         	ldr	r3, [r7, #0x24]
 801d064: 9301         	str	r3, [sp, #0x4]
 801d066: 6a3b         	ldr	r3, [r7, #0x20]
 801d068: 9300         	str	r3, [sp]
 801d06a: 687b         	ldr	r3, [r7, #0x4]
 801d06c: 68b9         	ldr	r1, [r7, #0x8]
 801d06e: f7e7 fa7f    	bl	0x8004570 <z_log_msg_runtime_vcreate> @ imm = #-0x18b02
; }
 801d072: bf00         	nop
 801d074: 3718         	adds	r7, #0x18
 801d076: 46bd         	mov	sp, r7
 801d078: bd80         	pop	{r7, pc}

0801d07a <z_sched_prio_cmp>:
; {
 801d07a: b480         	push	{r7}
 801d07c: b085         	sub	sp, #0x14
 801d07e: af00         	add	r7, sp, #0x0
 801d080: 6078         	str	r0, [r7, #0x4]
 801d082: 6039         	str	r1, [r7]
; 	int32_t b1 = thread_1->base.prio;
 801d084: 687b         	ldr	r3, [r7, #0x4]
 801d086: f993 300e    	ldrsb.w	r3, [r3, #0xe]
 801d08a: 60fb         	str	r3, [r7, #0xc]
; 	int32_t b2 = thread_2->base.prio;
 801d08c: 683b         	ldr	r3, [r7]
 801d08e: f993 300e    	ldrsb.w	r3, [r3, #0xe]
 801d092: 60bb         	str	r3, [r7, #0x8]
; 	if (b1 != b2) {
 801d094: 68fa         	ldr	r2, [r7, #0xc]
 801d096: 68bb         	ldr	r3, [r7, #0x8]
 801d098: 429a         	cmp	r2, r3
 801d09a: d003         	beq	0x801d0a4 <z_sched_prio_cmp+0x2a> @ imm = #0x6
; 		return b2 - b1;
 801d09c: 68ba         	ldr	r2, [r7, #0x8]
 801d09e: 68fb         	ldr	r3, [r7, #0xc]
 801d0a0: 1ad3         	subs	r3, r2, r3
 801d0a2: e000         	b	0x801d0a6 <z_sched_prio_cmp+0x2c> @ imm = #0x0
; 	return 0;
 801d0a4: 2300         	movs	r3, #0x0
; }
 801d0a6: 4618         	mov	r0, r3
 801d0a8: 3714         	adds	r7, #0x14
 801d0aa: 46bd         	mov	sp, r7
 801d0ac: bc80         	pop	{r7}
 801d0ae: 4770         	bx	lr

0801d0b0 <should_queue_thread>:
; {
 801d0b0: b480         	push	{r7}
 801d0b2: b083         	sub	sp, #0xc
 801d0b4: af00         	add	r7, sp, #0x0
 801d0b6: 6078         	str	r0, [r7, #0x4]
; 	return !IS_ENABLED(CONFIG_SMP) || (thread != arch_current_thread());
 801d0b8: 2301         	movs	r3, #0x1
; }
 801d0ba: 4618         	mov	r0, r3
 801d0bc: 370c         	adds	r7, #0xc
 801d0be: 46bd         	mov	sp, r7
 801d0c0: bc80         	pop	{r7}
 801d0c2: 4770         	bx	lr

0801d0c4 <is_aborting>:
; {
 801d0c4: b480         	push	{r7}
 801d0c6: b083         	sub	sp, #0xc
 801d0c8: af00         	add	r7, sp, #0x0
 801d0ca: 6078         	str	r0, [r7, #0x4]
; 	return (thread->base.thread_state & _THREAD_ABORTING) != 0U;
 801d0cc: 687b         	ldr	r3, [r7, #0x4]
 801d0ce: 7b5b         	ldrb	r3, [r3, #0xd]
 801d0d0: f003 0320    	and	r3, r3, #0x20
 801d0d4: 2b00         	cmp	r3, #0x0
 801d0d6: bf14         	ite	ne
 801d0d8: 2301         	movne	r3, #0x1
 801d0da: 2300         	moveq	r3, #0x0
 801d0dc: b2db         	uxtb	r3, r3
; }
 801d0de: 4618         	mov	r0, r3
 801d0e0: 370c         	adds	r7, #0xc
 801d0e2: 46bd         	mov	sp, r7
 801d0e4: bc80         	pop	{r7}
 801d0e6: 4770         	bx	lr

0801d0e8 <is_halting>:
; {
 801d0e8: b480         	push	{r7}
 801d0ea: b083         	sub	sp, #0xc
 801d0ec: af00         	add	r7, sp, #0x0
 801d0ee: 6078         	str	r0, [r7, #0x4]
; 	return (thread->base.thread_state &
 801d0f0: 687b         	ldr	r3, [r7, #0x4]
 801d0f2: 7b5b         	ldrb	r3, [r3, #0xd]
 801d0f4: f003 0360    	and	r3, r3, #0x60
; 		(_THREAD_ABORTING | _THREAD_SUSPENDING)) != 0U;
 801d0f8: 2b00         	cmp	r3, #0x0
 801d0fa: bf14         	ite	ne
 801d0fc: 2301         	movne	r3, #0x1
 801d0fe: 2300         	moveq	r3, #0x0
 801d100: b2db         	uxtb	r3, r3
; }
 801d102: 4618         	mov	r0, r3
 801d104: 370c         	adds	r7, #0xc
 801d106: 46bd         	mov	sp, r7
 801d108: bc80         	pop	{r7}
 801d10a: 4770         	bx	lr

0801d10c <clear_halting>:
; {
 801d10c: b480         	push	{r7}
 801d10e: b083         	sub	sp, #0xc
 801d110: af00         	add	r7, sp, #0x0
 801d112: 6078         	str	r0, [r7, #0x4]
;   __ASM volatile ("dmb 0xF":::"memory");
 801d114: f3bf 8f5f    	dmb	sy
; }
 801d118: bf00         	nop
; }
 801d11a: bf00         	nop
; }
 801d11c: bf00         	nop
; 	thread->base.thread_state &= ~(_THREAD_ABORTING | _THREAD_SUSPENDING);
 801d11e: 687b         	ldr	r3, [r7, #0x4]
 801d120: 7b5b         	ldrb	r3, [r3, #0xd]
 801d122: f023 0360    	bic	r3, r3, #0x60
 801d126: b2da         	uxtb	r2, r3
 801d128: 687b         	ldr	r3, [r7, #0x4]
 801d12a: 735a         	strb	r2, [r3, #0xd]
; }
 801d12c: bf00         	nop
 801d12e: 370c         	adds	r7, #0xc
 801d130: 46bd         	mov	sp, r7
 801d132: bc80         	pop	{r7}
 801d134: 4770         	bx	lr

0801d136 <update_metairq_preempt>:
; {
 801d136: b480         	push	{r7}
 801d138: b083         	sub	sp, #0xc
 801d13a: af00         	add	r7, sp, #0x0
 801d13c: 6078         	str	r0, [r7, #0x4]
; }
 801d13e: bf00         	nop
 801d140: 370c         	adds	r7, #0xc
 801d142: 46bd         	mov	sp, r7
 801d144: bc80         	pop	{r7}
 801d146: 4770         	bx	lr

0801d148 <thread_active_elsewhere>:
; {
 801d148: b480         	push	{r7}
 801d14a: b083         	sub	sp, #0xc
 801d14c: af00         	add	r7, sp, #0x0
 801d14e: 6078         	str	r0, [r7, #0x4]
; 	return NULL;
 801d150: 2300         	movs	r3, #0x0
; }
 801d152: 4618         	mov	r0, r3
 801d154: 370c         	adds	r7, #0xc
 801d156: 46bd         	mov	sp, r7
 801d158: bc80         	pop	{r7}
 801d15a: 4770         	bx	lr

0801d15c <add_to_waitq_locked>:
; {
 801d15c: b580         	push	{r7, lr}
 801d15e: b086         	sub	sp, #0x18
 801d160: af00         	add	r7, sp, #0x0
 801d162: 6078         	str	r0, [r7, #0x4]
 801d164: 6039         	str	r1, [r7]
; 	unready_thread(thread);
 801d166: 6878         	ldr	r0, [r7, #0x4]
 801d168: f7f2 fb9a    	bl	0x800f8a0 <unready_thread> @ imm = #-0xd8cc
; 	z_mark_thread_as_pending(thread);
 801d16c: 6878         	ldr	r0, [r7, #0x4]
 801d16e: f7ff fee7    	bl	0x801cf40 <z_mark_thread_as_pending> @ imm = #-0x232
; 	if (wait_q != NULL) {
 801d172: 683b         	ldr	r3, [r7]
 801d174: 2b00         	cmp	r3, #0x0
 801d176: d041         	beq	0x801d1fc <add_to_waitq_locked+0xa0> @ imm = #0x82
; 		thread->base.pended_on = wait_q;
 801d178: 687b         	ldr	r3, [r7, #0x4]
 801d17a: 683a         	ldr	r2, [r7]
 801d17c: 609a         	str	r2, [r3, #0x8]
; 		_priq_wait_add(&wait_q->waitq, thread);
 801d17e: 683b         	ldr	r3, [r7]
 801d180: 617b         	str	r3, [r7, #0x14]
 801d182: 687b         	ldr	r3, [r7, #0x4]
 801d184: 613b         	str	r3, [r7, #0x10]
; 	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
 801d186: 6978         	ldr	r0, [r7, #0x14]
 801d188: f7ff fd68    	bl	0x801cc5c <sys_dlist_peek_head> @ imm = #-0x530
 801d18c: 4603         	mov	r3, r0
 801d18e: 2b00         	cmp	r3, #0x0
 801d190: d004         	beq	0x801d19c <add_to_waitq_locked+0x40> @ imm = #0x8
 801d192: 6978         	ldr	r0, [r7, #0x14]
 801d194: f7ff fd62    	bl	0x801cc5c <sys_dlist_peek_head> @ imm = #-0x53c
 801d198: 4603         	mov	r3, r0
 801d19a: e000         	b	0x801d19e <add_to_waitq_locked+0x42> @ imm = #0x0
 801d19c: 2300         	movs	r3, #0x0
 801d19e: 60fb         	str	r3, [r7, #0xc]
 801d1a0: e024         	b	0x801d1ec <add_to_waitq_locked+0x90> @ imm = #0x48
; 		if (z_sched_prio_cmp(thread, t) > 0) {
 801d1a2: 68f9         	ldr	r1, [r7, #0xc]
 801d1a4: 6938         	ldr	r0, [r7, #0x10]
 801d1a6: f7ff ff68    	bl	0x801d07a <z_sched_prio_cmp> @ imm = #-0x130
 801d1aa: 4603         	mov	r3, r0
 801d1ac: 2b00         	cmp	r3, #0x0
 801d1ae: dd07         	ble	0x801d1c0 <add_to_waitq_locked+0x64> @ imm = #0xe
; 			sys_dlist_insert(&t->base.qnode_dlist,
 801d1b0: 68fb         	ldr	r3, [r7, #0xc]
 801d1b2: 693a         	ldr	r2, [r7, #0x10]
 801d1b4: 4611         	mov	r1, r2
 801d1b6: 4618         	mov	r0, r3
 801d1b8: f7ff fda1    	bl	0x801ccfe <sys_dlist_insert> @ imm = #-0x4be
; 			return;
 801d1bc: bf00         	nop
; }
 801d1be: e01d         	b	0x801d1fc <add_to_waitq_locked+0xa0> @ imm = #0x3a
; 	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
 801d1c0: 68fb         	ldr	r3, [r7, #0xc]
 801d1c2: 2b00         	cmp	r3, #0x0
 801d1c4: d010         	beq	0x801d1e8 <add_to_waitq_locked+0x8c> @ imm = #0x20
 801d1c6: 68fb         	ldr	r3, [r7, #0xc]
 801d1c8: 4619         	mov	r1, r3
 801d1ca: 6978         	ldr	r0, [r7, #0x14]
 801d1cc: f7ff fd6b    	bl	0x801cca6 <sys_dlist_peek_next> @ imm = #-0x52a
 801d1d0: 4603         	mov	r3, r0
 801d1d2: 2b00         	cmp	r3, #0x0
 801d1d4: d006         	beq	0x801d1e4 <add_to_waitq_locked+0x88> @ imm = #0xc
 801d1d6: 68fb         	ldr	r3, [r7, #0xc]
 801d1d8: 4619         	mov	r1, r3
 801d1da: 6978         	ldr	r0, [r7, #0x14]
 801d1dc: f7ff fd63    	bl	0x801cca6 <sys_dlist_peek_next> @ imm = #-0x53a
 801d1e0: 4603         	mov	r3, r0
 801d1e2: e002         	b	0x801d1ea <add_to_waitq_locked+0x8e> @ imm = #0x4
 801d1e4: 2300         	movs	r3, #0x0
 801d1e6: e000         	b	0x801d1ea <add_to_waitq_locked+0x8e> @ imm = #0x0
 801d1e8: 2300         	movs	r3, #0x0
 801d1ea: 60fb         	str	r3, [r7, #0xc]
 801d1ec: 68fb         	ldr	r3, [r7, #0xc]
 801d1ee: 2b00         	cmp	r3, #0x0
 801d1f0: d1d7         	bne	0x801d1a2 <add_to_waitq_locked+0x46> @ imm = #-0x52
; 	sys_dlist_append(pq, &thread->base.qnode_dlist);
 801d1f2: 693b         	ldr	r3, [r7, #0x10]
 801d1f4: 4619         	mov	r1, r3
 801d1f6: 6978         	ldr	r0, [r7, #0x14]
 801d1f8: f7ff fd68    	bl	0x801cccc <sys_dlist_append> @ imm = #-0x530
; }
 801d1fc: bf00         	nop
 801d1fe: 3718         	adds	r7, #0x18
 801d200: 46bd         	mov	sp, r7
 801d202: bd80         	pop	{r7, pc}

0801d204 <add_thread_timeout>:
; {
 801d204: b580         	push	{r7, lr}
 801d206: b084         	sub	sp, #0x10
 801d208: af00         	add	r7, sp, #0x0
 801d20a: 60f8         	str	r0, [r7, #0xc]
 801d20c: e9c7 2300    	strd	r2, r3, [r7]
; 	if (!K_TIMEOUT_EQ(timeout, K_FOREVER)) {
 801d210: e9d7 2300    	ldrd	r2, r3, [r7]
 801d214: f04f 30ff    	mov.w	r0, #0xffffffff
 801d218: f04f 31ff    	mov.w	r1, #0xffffffff
 801d21c: 428b         	cmp	r3, r1
 801d21e: bf08         	it	eq
 801d220: 4282         	cmpeq	r2, r0
 801d222: d004         	beq	0x801d22e <add_thread_timeout+0x2a> @ imm = #0x8
; 		z_add_thread_timeout(thread, timeout);
 801d224: e9d7 2300    	ldrd	r2, r3, [r7]
 801d228: 68f8         	ldr	r0, [r7, #0xc]
 801d22a: f7f1 fe89    	bl	0x800ef40 <z_add_thread_timeout> @ imm = #-0xe2ee
; }
 801d22e: bf00         	nop
 801d230: 3710         	adds	r7, #0x10
 801d232: 46bd         	mov	sp, r7
 801d234: bd80         	pop	{r7, pc}

0801d236 <pend_locked>:
; {
 801d236: b580         	push	{r7, lr}
 801d238: b084         	sub	sp, #0x10
 801d23a: af00         	add	r7, sp, #0x0
 801d23c: 60f8         	str	r0, [r7, #0xc]
 801d23e: 60b9         	str	r1, [r7, #0x8]
 801d240: e9c7 2300    	strd	r2, r3, [r7]
; 	add_to_waitq_locked(thread, wait_q);
 801d244: 68b9         	ldr	r1, [r7, #0x8]
 801d246: 68f8         	ldr	r0, [r7, #0xc]
 801d248: f7ff ff88    	bl	0x801d15c <add_to_waitq_locked> @ imm = #-0xf0
; 	add_thread_timeout(thread, timeout);
 801d24c: e9d7 2300    	ldrd	r2, r3, [r7]
 801d250: 68f8         	ldr	r0, [r7, #0xc]
 801d252: f7ff ffd7    	bl	0x801d204 <add_thread_timeout> @ imm = #-0x52
; }
 801d256: bf00         	nop
 801d258: 3710         	adds	r7, #0x10
 801d25a: 46bd         	mov	sp, r7
 801d25c: bd80         	pop	{r7, pc}

0801d25e <z_thread_timeout>:
; {
 801d25e: b580         	push	{r7, lr}
 801d260: b084         	sub	sp, #0x10
 801d262: af00         	add	r7, sp, #0x0
 801d264: 6078         	str	r0, [r7, #0x4]
; 	struct k_thread *thread = CONTAINER_OF(timeout,
 801d266: 687b         	ldr	r3, [r7, #0x4]
 801d268: 3b18         	subs	r3, #0x18
 801d26a: 60fb         	str	r3, [r7, #0xc]
; 	z_sched_wake_thread(thread, true);
 801d26c: 2101         	movs	r1, #0x1
 801d26e: 68f8         	ldr	r0, [r7, #0xc]
 801d270: f7f2 fbb4    	bl	0x800f9dc <z_sched_wake_thread> @ imm = #-0xd898
; }
 801d274: bf00         	nop
 801d276: 3710         	adds	r7, #0x10
 801d278: 46bd         	mov	sp, r7
 801d27a: bd80         	pop	{r7, pc}

0801d27c <resched>:
; {
 801d27c: b480         	push	{r7}
 801d27e: b085         	sub	sp, #0x14
 801d280: af00         	add	r7, sp, #0x0
 801d282: 6078         	str	r0, [r7, #0x4]
 801d284: 687b         	ldr	r3, [r7, #0x4]
 801d286: 60fb         	str	r3, [r7, #0xc]
; 	return key == 0U;
 801d288: 68fb         	ldr	r3, [r7, #0xc]
 801d28a: 2b00         	cmp	r3, #0x0
 801d28c: bf0c         	ite	eq
 801d28e: 2301         	moveq	r3, #0x1
 801d290: 2300         	movne	r3, #0x0
 801d292: b2db         	uxtb	r3, r3
; 	return arch_irq_unlocked(key) && !arch_is_in_isr();
 801d294: 2b00         	cmp	r3, #0x0
 801d296: d00f         	beq	0x801d2b8 <resched+0x3c> @ imm = #0x1e
;   __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 801d298: f3ef 8305    	mrs	r3, ipsr
 801d29c: 60bb         	str	r3, [r7, #0x8]
;   return(result);
 801d29e: 68bb         	ldr	r3, [r7, #0x8]
; 	return (__get_IPSR()) ? (true) : (false);
 801d2a0: 2b00         	cmp	r3, #0x0
 801d2a2: bf14         	ite	ne
 801d2a4: 2301         	movne	r3, #0x1
 801d2a6: 2300         	moveq	r3, #0x0
 801d2a8: b2db         	uxtb	r3, r3
; 	return arch_irq_unlocked(key) && !arch_is_in_isr();
 801d2aa: f083 0301    	eor	r3, r3, #0x1
 801d2ae: b2db         	uxtb	r3, r3
 801d2b0: 2b00         	cmp	r3, #0x0
 801d2b2: d001         	beq	0x801d2b8 <resched+0x3c> @ imm = #0x2
 801d2b4: 2301         	movs	r3, #0x1
 801d2b6: e000         	b	0x801d2ba <resched+0x3e> @ imm = #0x0
 801d2b8: 2300         	movs	r3, #0x0
 801d2ba: f003 0301    	and	r3, r3, #0x1
 801d2be: b2db         	uxtb	r3, r3
; }
 801d2c0: 4618         	mov	r0, r3
 801d2c2: 3714         	adds	r7, #0x14
 801d2c4: 46bd         	mov	sp, r7
 801d2c6: bc80         	pop	{r7}
 801d2c8: 4770         	bx	lr

0801d2ca <z_reschedule>:
; {
 801d2ca: b580         	push	{r7, lr}
 801d2cc: b08a         	sub	sp, #0x28
 801d2ce: af00         	add	r7, sp, #0x0
 801d2d0: 6078         	str	r0, [r7, #0x4]
 801d2d2: 6039         	str	r1, [r7]
; 	if (resched(key.key) && need_swap()) {
 801d2d4: 683b         	ldr	r3, [r7]
 801d2d6: 4618         	mov	r0, r3
 801d2d8: f7ff ffd0    	bl	0x801d27c <resched>     @ imm = #-0x60
 801d2dc: 4603         	mov	r3, r0
 801d2de: 2b00         	cmp	r3, #0x0
 801d2e0: d010         	beq	0x801d304 <z_reschedule+0x3a> @ imm = #0x20
 801d2e2: f7f2 fd7d    	bl	0x800fde0 <need_swap>   @ imm = #-0xd506
 801d2e6: 4603         	mov	r3, r0
 801d2e8: 2b00         	cmp	r3, #0x0
 801d2ea: d00b         	beq	0x801d304 <z_reschedule+0x3a> @ imm = #0x16
 801d2ec: 687b         	ldr	r3, [r7, #0x4]
 801d2ee: 627b         	str	r3, [r7, #0x24]
 801d2f0: 683b         	ldr	r3, [r7]
 801d2f2: 60fb         	str	r3, [r7, #0xc]
 801d2f4: 6a7b         	ldr	r3, [r7, #0x24]
 801d2f6: 623b         	str	r3, [r7, #0x20]
; }
 801d2f8: bf00         	nop
; 	return z_swap_irqlock(key.key);
 801d2fa: 68fb         	ldr	r3, [r7, #0xc]
 801d2fc: 4618         	mov	r0, r3
 801d2fe: f7ff fe91    	bl	0x801d024 <z_swap_irqlock> @ imm = #-0x2de
; 		z_swap(lock, key);
 801d302: e010         	b	0x801d326 <z_reschedule+0x5c> @ imm = #0x20
 801d304: 687b         	ldr	r3, [r7, #0x4]
 801d306: 61fb         	str	r3, [r7, #0x1c]
 801d308: 683b         	ldr	r3, [r7]
 801d30a: 613b         	str	r3, [r7, #0x10]
; 	arch_irq_unlock(key.key);
 801d30c: 693b         	ldr	r3, [r7, #0x10]
 801d30e: 61bb         	str	r3, [r7, #0x18]
 801d310: 69bb         	ldr	r3, [r7, #0x18]
 801d312: 617b         	str	r3, [r7, #0x14]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 801d314: 697b         	ldr	r3, [r7, #0x14]
 801d316: f383 8811    	msr	basepri, r3
; }
 801d31a: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 801d31c: f3bf 8f6f    	isb	sy
; }
 801d320: bf00         	nop
; }
 801d322: bf00         	nop
; }
 801d324: bf00         	nop
; }
 801d326: bf00         	nop
 801d328: 3728         	adds	r7, #0x28
 801d32a: 46bd         	mov	sp, r7
 801d32c: bd80         	pop	{r7, pc}

0801d32e <z_reschedule_irqlock>:
; {
 801d32e: b580         	push	{r7, lr}
 801d330: b084         	sub	sp, #0x10
 801d332: af00         	add	r7, sp, #0x0
 801d334: 6078         	str	r0, [r7, #0x4]
; 	if (resched(key) && need_swap()) {
 801d336: 6878         	ldr	r0, [r7, #0x4]
 801d338: f7ff ffa0    	bl	0x801d27c <resched>     @ imm = #-0xc0
 801d33c: 4603         	mov	r3, r0
 801d33e: 2b00         	cmp	r3, #0x0
 801d340: d008         	beq	0x801d354 <z_reschedule_irqlock+0x26> @ imm = #0x10
 801d342: f7f2 fd4d    	bl	0x800fde0 <need_swap>   @ imm = #-0xd566
 801d346: 4603         	mov	r3, r0
 801d348: 2b00         	cmp	r3, #0x0
 801d34a: d003         	beq	0x801d354 <z_reschedule_irqlock+0x26> @ imm = #0x6
; 		z_swap_irqlock(key);
 801d34c: 6878         	ldr	r0, [r7, #0x4]
 801d34e: f7ff fe69    	bl	0x801d024 <z_swap_irqlock> @ imm = #-0x32e
 801d352: e00b         	b	0x801d36c <z_reschedule_irqlock+0x3e> @ imm = #0x16
 801d354: 687b         	ldr	r3, [r7, #0x4]
 801d356: 60fb         	str	r3, [r7, #0xc]
 801d358: 68fb         	ldr	r3, [r7, #0xc]
 801d35a: 60bb         	str	r3, [r7, #0x8]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 801d35c: 68bb         	ldr	r3, [r7, #0x8]
 801d35e: f383 8811    	msr	basepri, r3
; }
 801d362: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 801d364: f3bf 8f6f    	isb	sy
; }
 801d368: bf00         	nop
; }
 801d36a: bf00         	nop
; }
 801d36c: bf00         	nop
 801d36e: 3710         	adds	r7, #0x10
 801d370: 46bd         	mov	sp, r7
 801d372: bd80         	pop	{r7, pc}

0801d374 <init_ready_q>:
; {
 801d374: b580         	push	{r7, lr}
 801d376: b084         	sub	sp, #0x10
 801d378: af00         	add	r7, sp, #0x0
 801d37a: 6078         	str	r0, [r7, #0x4]
; 	_priq_run_init(&ready_q->runq);
 801d37c: 687b         	ldr	r3, [r7, #0x4]
 801d37e: 3304         	adds	r3, #0x4
 801d380: 60fb         	str	r3, [r7, #0xc]
; 	sys_dlist_init(pq);
 801d382: 68f8         	ldr	r0, [r7, #0xc]
 801d384: f7ff fc2b    	bl	0x801cbde <sys_dlist_init> @ imm = #-0x7aa
; }
 801d388: bf00         	nop
; }
 801d38a: bf00         	nop
 801d38c: 3710         	adds	r7, #0x10
 801d38e: 46bd         	mov	sp, r7
 801d390: bd80         	pop	{r7, pc}

0801d392 <z_impl_k_usleep>:
; {
 801d392: e92d 4fb0    	push.w	{r4, r5, r7, r8, r9, r10, r11, lr}
 801d396: b084         	sub	sp, #0x10
 801d398: af00         	add	r7, sp, #0x0
 801d39a: 6078         	str	r0, [r7, #0x4]
; 	ticks = k_us_to_ticks_ceil64(us);
 801d39c: 6879         	ldr	r1, [r7, #0x4]
 801d39e: 17c8         	asrs	r0, r1, #0x1f
 801d3a0: 460a         	mov	r2, r1
 801d3a2: 4603         	mov	r3, r0
 801d3a4: f112 0463    	adds.w	r4, r2, #0x63
 801d3a8: f143 0500    	adc	r5, r3, #0x0
 801d3ac: f04f 0264    	mov.w	r2, #0x64
 801d3b0: f04f 0300    	mov.w	r3, #0x0
 801d3b4: 4620         	mov	r0, r4
 801d3b6: 4629         	mov	r1, r5
 801d3b8: f7e3 fa30    	bl	0x800081c <__aeabi_uldivmod> @ imm = #-0x1cba0
 801d3bc: 4602         	mov	r2, r0
 801d3be: 460b         	mov	r3, r1
 801d3c0: 4613         	mov	r3, r2
 801d3c2: 60fb         	str	r3, [r7, #0xc]
; 	ticks = z_tick_sleep(ticks);
 801d3c4: 68fb         	ldr	r3, [r7, #0xc]
 801d3c6: 17da         	asrs	r2, r3, #0x1f
 801d3c8: 4698         	mov	r8, r3
 801d3ca: 4691         	mov	r9, r2
 801d3cc: 4640         	mov	r0, r8
 801d3ce: 4649         	mov	r1, r9
 801d3d0: f7f2 ff5c    	bl	0x801028c <z_tick_sleep> @ imm = #-0xd148
 801d3d4: 60f8         	str	r0, [r7, #0xc]
; 	int32_t ret = k_ticks_to_us_ceil64(ticks);
 801d3d6: 68fb         	ldr	r3, [r7, #0xc]
 801d3d8: 17da         	asrs	r2, r3, #0x1f
 801d3da: 469a         	mov	r10, r3
 801d3dc: 4693         	mov	r11, r2
 801d3de: 4652         	mov	r2, r10
 801d3e0: 2364         	movs	r3, #0x64
 801d3e2: fb02 f303    	mul	r3, r2, r3
 801d3e6: 60bb         	str	r3, [r7, #0x8]
; 	return ret;
 801d3e8: 68bb         	ldr	r3, [r7, #0x8]
; }
 801d3ea: 4618         	mov	r0, r3
 801d3ec: 3710         	adds	r7, #0x10
 801d3ee: 46bd         	mov	sp, r7
 801d3f0: e8bd 8fb0    	pop.w	{r4, r5, r7, r8, r9, r10, r11, pc}

0801d3f4 <unpend_all>:
; {
 801d3f4: b580         	push	{r7, lr}
 801d3f6: b086         	sub	sp, #0x18
 801d3f8: af00         	add	r7, sp, #0x0
 801d3fa: 6078         	str	r0, [r7, #0x4]
; 	for (thread = z_waitq_head(wait_q); thread != NULL; thread = z_waitq_head(wait_q)) {
 801d3fc: 6878         	ldr	r0, [r7, #0x4]
 801d3fe: f7ff fe04    	bl	0x801d00a <z_waitq_head> @ imm = #-0x3f8
 801d402: 6178         	str	r0, [r7, #0x14]
 801d404: e015         	b	0x801d432 <unpend_all+0x3e> @ imm = #0x2a
; 		unpend_thread_no_timeout(thread);
 801d406: 6978         	ldr	r0, [r7, #0x14]
 801d408: f7ff fde5    	bl	0x801cfd6 <unpend_thread_no_timeout> @ imm = #-0x436
; 		(void)z_abort_thread_timeout(thread);
 801d40c: 6978         	ldr	r0, [r7, #0x14]
 801d40e: f7ff fccf    	bl	0x801cdb0 <z_abort_thread_timeout> @ imm = #-0x662
 801d412: 697b         	ldr	r3, [r7, #0x14]
 801d414: 613b         	str	r3, [r7, #0x10]
 801d416: 2300         	movs	r3, #0x0
 801d418: 60fb         	str	r3, [r7, #0xc]
; 	thread->arch.swap_return_value = value;
 801d41a: 693b         	ldr	r3, [r7, #0x10]
 801d41c: 68fa         	ldr	r2, [r7, #0xc]
 801d41e: f8c3 20cc    	str.w	r2, [r3, #0xcc]
; }
 801d422: bf00         	nop
; 		ready_thread(thread);
 801d424: 6978         	ldr	r0, [r7, #0x14]
 801d426: f7f1 fec5    	bl	0x800f1b4 <ready_thread> @ imm = #-0xe276
; 	for (thread = z_waitq_head(wait_q); thread != NULL; thread = z_waitq_head(wait_q)) {
 801d42a: 6878         	ldr	r0, [r7, #0x4]
 801d42c: f7ff fded    	bl	0x801d00a <z_waitq_head> @ imm = #-0x426
 801d430: 6178         	str	r0, [r7, #0x14]
 801d432: 697b         	ldr	r3, [r7, #0x14]
 801d434: 2b00         	cmp	r3, #0x0
 801d436: d1e6         	bne	0x801d406 <unpend_all+0x12> @ imm = #-0x34
; }
 801d438: bf00         	nop
 801d43a: bf00         	nop
 801d43c: 3718         	adds	r7, #0x18
 801d43e: 46bd         	mov	sp, r7
 801d440: bd80         	pop	{r7, pc}

0801d442 <thread_is_preemptible>:
; {
 801d442: b480         	push	{r7}
 801d444: b083         	sub	sp, #0xc
 801d446: af00         	add	r7, sp, #0x0
 801d448: 6078         	str	r0, [r7, #0x4]
; 	return thread->base.preempt <= _PREEMPT_THRESHOLD;
 801d44a: 687b         	ldr	r3, [r7, #0x4]
 801d44c: 89db         	ldrh	r3, [r3, #0xe]
 801d44e: 2b7f         	cmp	r3, #0x7f
 801d450: bf94         	ite	ls
 801d452: 2301         	movls	r3, #0x1
 801d454: 2300         	movhi	r3, #0x0
 801d456: b2db         	uxtb	r3, r3
; }
 801d458: 4618         	mov	r0, r3
 801d45a: 370c         	adds	r7, #0xc
 801d45c: 46bd         	mov	sp, r7
 801d45e: bc80         	pop	{r7}
 801d460: 4770         	bx	lr

0801d462 <z_is_thread_prevented_from_running>:
; {
 801d462: b480         	push	{r7}
 801d464: b085         	sub	sp, #0x14
 801d466: af00         	add	r7, sp, #0x0
 801d468: 6078         	str	r0, [r7, #0x4]
; 	uint8_t state = thread->base.thread_state;
 801d46a: 687b         	ldr	r3, [r7, #0x4]
 801d46c: 7b5b         	ldrb	r3, [r3, #0xd]
 801d46e: 73fb         	strb	r3, [r7, #0xf]
; 	return (state & (_THREAD_PENDING | _THREAD_DEAD |
 801d470: 7bfb         	ldrb	r3, [r7, #0xf]
 801d472: f003 031b    	and	r3, r3, #0x1b
; 			 _THREAD_DUMMY | _THREAD_SUSPENDED)) != 0U;
 801d476: 2b00         	cmp	r3, #0x0
 801d478: bf14         	ite	ne
 801d47a: 2301         	movne	r3, #0x1
 801d47c: 2300         	moveq	r3, #0x0
 801d47e: b2db         	uxtb	r3, r3
; }
 801d480: 4618         	mov	r0, r3
 801d482: 3714         	adds	r7, #0x14
 801d484: 46bd         	mov	sp, r7
 801d486: bc80         	pop	{r7}
 801d488: 4770         	bx	lr

0801d48a <z_is_prio1_higher_than_prio2>:
; {
 801d48a: b480         	push	{r7}
 801d48c: b083         	sub	sp, #0xc
 801d48e: af00         	add	r7, sp, #0x0
 801d490: 6078         	str	r0, [r7, #0x4]
 801d492: 6039         	str	r1, [r7]
; 	return prio1 < prio2;
 801d494: 687a         	ldr	r2, [r7, #0x4]
 801d496: 683b         	ldr	r3, [r7]
 801d498: 429a         	cmp	r2, r3
 801d49a: bfb4         	ite	lt
 801d49c: 2301         	movlt	r3, #0x1
 801d49e: 2300         	movge	r3, #0x0
 801d4a0: b2db         	uxtb	r3, r3
; }
 801d4a2: 4618         	mov	r0, r3
 801d4a4: 370c         	adds	r7, #0xc
 801d4a6: 46bd         	mov	sp, r7
 801d4a8: bc80         	pop	{r7}
 801d4aa: 4770         	bx	lr

0801d4ac <z_is_prio_higher>:
; {
 801d4ac: b580         	push	{r7, lr}
 801d4ae: b082         	sub	sp, #0x8
 801d4b0: af00         	add	r7, sp, #0x0
 801d4b2: 6078         	str	r0, [r7, #0x4]
 801d4b4: 6039         	str	r1, [r7]
; 	return z_is_prio1_higher_than_prio2(prio, test_prio);
 801d4b6: 6839         	ldr	r1, [r7]
 801d4b8: 6878         	ldr	r0, [r7, #0x4]
 801d4ba: f7ff ffe6    	bl	0x801d48a <z_is_prio1_higher_than_prio2> @ imm = #-0x34
 801d4be: 4603         	mov	r3, r0
; }
 801d4c0: 4618         	mov	r0, r3
 801d4c2: 3708         	adds	r7, #0x8
 801d4c4: 46bd         	mov	sp, r7
 801d4c6: bd80         	pop	{r7, pc}

0801d4c8 <sys_dnode_init>:
; {
 801d4c8: b480         	push	{r7}
 801d4ca: b083         	sub	sp, #0xc
 801d4cc: af00         	add	r7, sp, #0x0
 801d4ce: 6078         	str	r0, [r7, #0x4]
; 	node->next = NULL;
 801d4d0: 687b         	ldr	r3, [r7, #0x4]
 801d4d2: 2200         	movs	r2, #0x0
 801d4d4: 601a         	str	r2, [r3]
; 	node->prev = NULL;
 801d4d6: 687b         	ldr	r3, [r7, #0x4]
 801d4d8: 2200         	movs	r2, #0x0
 801d4da: 605a         	str	r2, [r3, #0x4]
; }
 801d4dc: bf00         	nop
 801d4de: 370c         	adds	r7, #0xc
 801d4e0: 46bd         	mov	sp, r7
 801d4e2: bc80         	pop	{r7}
 801d4e4: 4770         	bx	lr

0801d4e6 <sys_dnode_is_linked>:
; {
 801d4e6: b480         	push	{r7}
 801d4e8: b083         	sub	sp, #0xc
 801d4ea: af00         	add	r7, sp, #0x0
 801d4ec: 6078         	str	r0, [r7, #0x4]
; 	return node->next != NULL;
 801d4ee: 687b         	ldr	r3, [r7, #0x4]
 801d4f0: 681b         	ldr	r3, [r3]
 801d4f2: 2b00         	cmp	r3, #0x0
 801d4f4: bf14         	ite	ne
 801d4f6: 2301         	movne	r3, #0x1
 801d4f8: 2300         	moveq	r3, #0x0
 801d4fa: b2db         	uxtb	r3, r3
; }
 801d4fc: 4618         	mov	r0, r3
 801d4fe: 370c         	adds	r7, #0xc
 801d500: 46bd         	mov	sp, r7
 801d502: bc80         	pop	{r7}
 801d504: 4770         	bx	lr

0801d506 <sys_dlist_is_empty>:
; {
 801d506: b480         	push	{r7}
 801d508: b083         	sub	sp, #0xc
 801d50a: af00         	add	r7, sp, #0x0
 801d50c: 6078         	str	r0, [r7, #0x4]
; 	return list->head == list;
 801d50e: 687b         	ldr	r3, [r7, #0x4]
 801d510: 681b         	ldr	r3, [r3]
 801d512: 687a         	ldr	r2, [r7, #0x4]
 801d514: 429a         	cmp	r2, r3
 801d516: bf0c         	ite	eq
 801d518: 2301         	moveq	r3, #0x1
 801d51a: 2300         	movne	r3, #0x0
 801d51c: b2db         	uxtb	r3, r3
; }
 801d51e: 4618         	mov	r0, r3
 801d520: 370c         	adds	r7, #0xc
 801d522: 46bd         	mov	sp, r7
 801d524: bc80         	pop	{r7}
 801d526: 4770         	bx	lr

0801d528 <sys_dlist_peek_head>:
; {
 801d528: b580         	push	{r7, lr}
 801d52a: b082         	sub	sp, #0x8
 801d52c: af00         	add	r7, sp, #0x0
 801d52e: 6078         	str	r0, [r7, #0x4]
; 	return sys_dlist_is_empty(list) ? NULL : list->head;
 801d530: 6878         	ldr	r0, [r7, #0x4]
 801d532: f7ff ffe8    	bl	0x801d506 <sys_dlist_is_empty> @ imm = #-0x30
 801d536: 4603         	mov	r3, r0
 801d538: 2b00         	cmp	r3, #0x0
 801d53a: d102         	bne	0x801d542 <sys_dlist_peek_head+0x1a> @ imm = #0x4
 801d53c: 687b         	ldr	r3, [r7, #0x4]
 801d53e: 681b         	ldr	r3, [r3]
 801d540: e000         	b	0x801d544 <sys_dlist_peek_head+0x1c> @ imm = #0x0
 801d542: 2300         	movs	r3, #0x0
; }
 801d544: 4618         	mov	r0, r3
 801d546: 3708         	adds	r7, #0x8
 801d548: 46bd         	mov	sp, r7
 801d54a: bd80         	pop	{r7, pc}

0801d54c <sys_dlist_peek_next_no_check>:
; {
 801d54c: b480         	push	{r7}
 801d54e: b083         	sub	sp, #0xc
 801d550: af00         	add	r7, sp, #0x0
 801d552: 6078         	str	r0, [r7, #0x4]
 801d554: 6039         	str	r1, [r7]
; 	return (node == list->tail) ? NULL : node->next;
 801d556: 687b         	ldr	r3, [r7, #0x4]
 801d558: 685b         	ldr	r3, [r3, #0x4]
 801d55a: 683a         	ldr	r2, [r7]
 801d55c: 429a         	cmp	r2, r3
 801d55e: d002         	beq	0x801d566 <sys_dlist_peek_next_no_check+0x1a> @ imm = #0x4
 801d560: 683b         	ldr	r3, [r7]
 801d562: 681b         	ldr	r3, [r3]
 801d564: e000         	b	0x801d568 <sys_dlist_peek_next_no_check+0x1c> @ imm = #0x0
 801d566: 2300         	movs	r3, #0x0
; }
 801d568: 4618         	mov	r0, r3
 801d56a: 370c         	adds	r7, #0xc
 801d56c: 46bd         	mov	sp, r7
 801d56e: bc80         	pop	{r7}
 801d570: 4770         	bx	lr

0801d572 <sys_dlist_peek_next>:
; {
 801d572: b580         	push	{r7, lr}
 801d574: b082         	sub	sp, #0x8
 801d576: af00         	add	r7, sp, #0x0
 801d578: 6078         	str	r0, [r7, #0x4]
 801d57a: 6039         	str	r1, [r7]
; 	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
 801d57c: 683b         	ldr	r3, [r7]
 801d57e: 2b00         	cmp	r3, #0x0
 801d580: d005         	beq	0x801d58e <sys_dlist_peek_next+0x1c> @ imm = #0xa
 801d582: 6839         	ldr	r1, [r7]
 801d584: 6878         	ldr	r0, [r7, #0x4]
 801d586: f7ff ffe1    	bl	0x801d54c <sys_dlist_peek_next_no_check> @ imm = #-0x3e
 801d58a: 4603         	mov	r3, r0
 801d58c: e000         	b	0x801d590 <sys_dlist_peek_next+0x1e> @ imm = #0x0
 801d58e: 2300         	movs	r3, #0x0
; }
 801d590: 4618         	mov	r0, r3
 801d592: 3708         	adds	r7, #0x8
 801d594: 46bd         	mov	sp, r7
 801d596: bd80         	pop	{r7, pc}

0801d598 <sys_dlist_append>:
; {
 801d598: b480         	push	{r7}
 801d59a: b085         	sub	sp, #0x14
 801d59c: af00         	add	r7, sp, #0x0
 801d59e: 6078         	str	r0, [r7, #0x4]
 801d5a0: 6039         	str	r1, [r7]
; 	sys_dnode_t *const tail = list->tail;
 801d5a2: 687b         	ldr	r3, [r7, #0x4]
 801d5a4: 685b         	ldr	r3, [r3, #0x4]
 801d5a6: 60fb         	str	r3, [r7, #0xc]
; 	node->next = list;
 801d5a8: 683b         	ldr	r3, [r7]
 801d5aa: 687a         	ldr	r2, [r7, #0x4]
 801d5ac: 601a         	str	r2, [r3]
; 	node->prev = tail;
 801d5ae: 683b         	ldr	r3, [r7]
 801d5b0: 68fa         	ldr	r2, [r7, #0xc]
 801d5b2: 605a         	str	r2, [r3, #0x4]
; 	tail->next = node;
 801d5b4: 68fb         	ldr	r3, [r7, #0xc]
 801d5b6: 683a         	ldr	r2, [r7]
 801d5b8: 601a         	str	r2, [r3]
; 	list->tail = node;
 801d5ba: 687b         	ldr	r3, [r7, #0x4]
 801d5bc: 683a         	ldr	r2, [r7]
 801d5be: 605a         	str	r2, [r3, #0x4]
; }
 801d5c0: bf00         	nop
 801d5c2: 3714         	adds	r7, #0x14
 801d5c4: 46bd         	mov	sp, r7
 801d5c6: bc80         	pop	{r7}
 801d5c8: 4770         	bx	lr

0801d5ca <sys_dlist_insert>:
; {
 801d5ca: b480         	push	{r7}
 801d5cc: b085         	sub	sp, #0x14
 801d5ce: af00         	add	r7, sp, #0x0
 801d5d0: 6078         	str	r0, [r7, #0x4]
 801d5d2: 6039         	str	r1, [r7]
; 	sys_dnode_t *const prev = successor->prev;
 801d5d4: 687b         	ldr	r3, [r7, #0x4]
 801d5d6: 685b         	ldr	r3, [r3, #0x4]
 801d5d8: 60fb         	str	r3, [r7, #0xc]
; 	node->prev = prev;
 801d5da: 683b         	ldr	r3, [r7]
 801d5dc: 68fa         	ldr	r2, [r7, #0xc]
 801d5de: 605a         	str	r2, [r3, #0x4]
; 	node->next = successor;
 801d5e0: 683b         	ldr	r3, [r7]
 801d5e2: 687a         	ldr	r2, [r7, #0x4]
 801d5e4: 601a         	str	r2, [r3]
; 	prev->next = node;
 801d5e6: 68fb         	ldr	r3, [r7, #0xc]
 801d5e8: 683a         	ldr	r2, [r7]
 801d5ea: 601a         	str	r2, [r3]
; 	successor->prev = node;
 801d5ec: 687b         	ldr	r3, [r7, #0x4]
 801d5ee: 683a         	ldr	r2, [r7]
 801d5f0: 605a         	str	r2, [r3, #0x4]
; }
 801d5f2: bf00         	nop
 801d5f4: 3714         	adds	r7, #0x14
 801d5f6: 46bd         	mov	sp, r7
 801d5f8: bc80         	pop	{r7}
 801d5fa: 4770         	bx	lr

0801d5fc <sys_dlist_remove>:
; {
 801d5fc: b580         	push	{r7, lr}
 801d5fe: b084         	sub	sp, #0x10
 801d600: af00         	add	r7, sp, #0x0
 801d602: 6078         	str	r0, [r7, #0x4]
; 	sys_dnode_t *const prev = node->prev;
 801d604: 687b         	ldr	r3, [r7, #0x4]
 801d606: 685b         	ldr	r3, [r3, #0x4]
 801d608: 60fb         	str	r3, [r7, #0xc]
; 	sys_dnode_t *const next = node->next;
 801d60a: 687b         	ldr	r3, [r7, #0x4]
 801d60c: 681b         	ldr	r3, [r3]
 801d60e: 60bb         	str	r3, [r7, #0x8]
; 	prev->next = next;
 801d610: 68fb         	ldr	r3, [r7, #0xc]
 801d612: 68ba         	ldr	r2, [r7, #0x8]
 801d614: 601a         	str	r2, [r3]
; 	next->prev = prev;
 801d616: 68bb         	ldr	r3, [r7, #0x8]
 801d618: 68fa         	ldr	r2, [r7, #0xc]
 801d61a: 605a         	str	r2, [r3, #0x4]
; 	sys_dnode_init(node);
 801d61c: 6878         	ldr	r0, [r7, #0x4]
 801d61e: f7ff ff53    	bl	0x801d4c8 <sys_dnode_init> @ imm = #-0x15a
; }
 801d622: bf00         	nop
 801d624: 3710         	adds	r7, #0x10
 801d626: 46bd         	mov	sp, r7
 801d628: bd80         	pop	{r7, pc}

0801d62a <remove_timeout>:
; {
 801d62a: b5f0         	push	{r4, r5, r6, r7, lr}
 801d62c: b083         	sub	sp, #0xc
 801d62e: af00         	add	r7, sp, #0x0
 801d630: 6078         	str	r0, [r7, #0x4]
; 	if (next(t) != NULL) {
 801d632: 6878         	ldr	r0, [r7, #0x4]
 801d634: f7f3 fad8    	bl	0x8010be8 <next>        @ imm = #-0xca50
 801d638: 4603         	mov	r3, r0
 801d63a: 2b00         	cmp	r3, #0x0
 801d63c: d00d         	beq	0x801d65a <remove_timeout+0x30> @ imm = #0x1a
; 		next(t)->dticks += t->dticks;
 801d63e: 6878         	ldr	r0, [r7, #0x4]
 801d640: f7f3 fad2    	bl	0x8010be8 <next>        @ imm = #-0xca5c
 801d644: 4606         	mov	r6, r0
 801d646: e9d6 0104    	ldrd	r0, r1, [r6, #16]
 801d64a: 687b         	ldr	r3, [r7, #0x4]
 801d64c: e9d3 2304    	ldrd	r2, r3, [r3, #16]
 801d650: 1884         	adds	r4, r0, r2
 801d652: eb41 0503    	adc.w	r5, r1, r3
 801d656: e9c6 4504    	strd	r4, r5, [r6, #16]
; 	sys_dlist_remove(&t->node);
 801d65a: 687b         	ldr	r3, [r7, #0x4]
 801d65c: 4618         	mov	r0, r3
 801d65e: f7ff ffcd    	bl	0x801d5fc <sys_dlist_remove> @ imm = #-0x66
; }
 801d662: bf00         	nop
 801d664: 370c         	adds	r7, #0xc
 801d666: 46bd         	mov	sp, r7
 801d668: bdf0         	pop	{r4, r5, r6, r7, pc}

0801d66a <next_timeout>:
; {
 801d66a: e92d 4fb0    	push.w	{r4, r5, r7, r8, r9, r10, r11, lr}
 801d66e: b086         	sub	sp, #0x18
 801d670: af00         	add	r7, sp, #0x0
; 	struct _timeout *to = first();
 801d672: f7f3 faab    	bl	0x8010bcc <first>       @ imm = #-0xcaaa
 801d676: 6138         	str	r0, [r7, #0x10]
; 	int32_t ticks_elapsed = elapsed();
 801d678: f7f3 fac8    	bl	0x8010c0c <elapsed>     @ imm = #-0xca70
 801d67c: 60f8         	str	r0, [r7, #0xc]
; 	if ((to == NULL) ||
 801d67e: 693b         	ldr	r3, [r7, #0x10]
 801d680: 2b00         	cmp	r3, #0x0
 801d682: d00f         	beq	0x801d6a4 <next_timeout+0x3a> @ imm = #0x1e
; 	    ((int64_t)(to->dticks - ticks_elapsed) > (int64_t)INT_MAX)) {
 801d684: 693b         	ldr	r3, [r7, #0x10]
 801d686: e9d3 2304    	ldrd	r2, r3, [r3, #16]
 801d68a: 68f9         	ldr	r1, [r7, #0xc]
 801d68c: 17c8         	asrs	r0, r1, #0x1f
 801d68e: 468a         	mov	r10, r1
 801d690: 4683         	mov	r11, r0
 801d692: ebb2 040a    	subs.w	r4, r2, r10
 801d696: eb63 050b    	sbc.w	r5, r3, r11
; 	if ((to == NULL) ||
 801d69a: f1b4 4f00    	cmp.w	r4, #0x80000000
 801d69e: f175 0300    	sbcs	r3, r5, #0x0
 801d6a2: db03         	blt	0x801d6ac <next_timeout+0x42> @ imm = #0x6
; 		ret = MAX_WAIT;
 801d6a4: f06f 4300    	mvn	r3, #0x80000000
 801d6a8: 617b         	str	r3, [r7, #0x14]
 801d6aa: e016         	b	0x801d6da <next_timeout+0x70> @ imm = #0x2c
; 		ret = MAX(0, to->dticks - ticks_elapsed);
 801d6ac: 693b         	ldr	r3, [r7, #0x10]
 801d6ae: e9d3 2304    	ldrd	r2, r3, [r3, #16]
 801d6b2: 68f9         	ldr	r1, [r7, #0xc]
 801d6b4: 17c8         	asrs	r0, r1, #0x1f
 801d6b6: 4688         	mov	r8, r1
 801d6b8: 4681         	mov	r9, r0
 801d6ba: ebb2 0108    	subs.w	r1, r2, r8
 801d6be: 6039         	str	r1, [r7]
 801d6c0: eb63 0309    	sbc.w	r3, r3, r9
 801d6c4: 607b         	str	r3, [r7, #0x4]
 801d6c6: e9d7 2300    	ldrd	r2, r3, [r7]
 801d6ca: 2b00         	cmp	r3, #0x0
 801d6cc: da03         	bge	0x801d6d6 <next_timeout+0x6c> @ imm = #0x6
 801d6ce: f04f 0200    	mov.w	r2, #0x0
 801d6d2: f04f 0300    	mov.w	r3, #0x0
 801d6d6: 4613         	mov	r3, r2
 801d6d8: 617b         	str	r3, [r7, #0x14]
; 	return ret;
 801d6da: 697b         	ldr	r3, [r7, #0x14]
; }
 801d6dc: 4618         	mov	r0, r3
 801d6de: 3718         	adds	r7, #0x18
 801d6e0: 46bd         	mov	sp, r7
 801d6e2: e8bd 8fb0    	pop.w	{r4, r5, r7, r8, r9, r10, r11, pc}

0801d6e6 <sys_clock_tick_get_32>:
; {
 801d6e6: b580         	push	{r7, lr}
 801d6e8: af00         	add	r7, sp, #0x0
; 	return (uint32_t)sys_clock_tick_get();
 801d6ea: f7f3 fcd9    	bl	0x80110a0 <sys_clock_tick_get> @ imm = #-0xc64e
 801d6ee: 4602         	mov	r2, r0
 801d6f0: 460b         	mov	r3, r1
 801d6f2: 4613         	mov	r3, r2
; }
 801d6f4: 4618         	mov	r0, r3
 801d6f6: bd80         	pop	{r7, pc}

0801d6f8 <z_impl_k_uptime_ticks>:
; {
 801d6f8: b580         	push	{r7, lr}
 801d6fa: af00         	add	r7, sp, #0x0
; 	return sys_clock_tick_get();
 801d6fc: f7f3 fcd0    	bl	0x80110a0 <sys_clock_tick_get> @ imm = #-0xc660
 801d700: 4602         	mov	r2, r0
 801d702: 460b         	mov	r3, r1
; }
 801d704: 4610         	mov	r0, r2
 801d706: 4619         	mov	r1, r3
 801d708: bd80         	pop	{r7, pc}

0801d70a <arch_k_cycle_get_32>:
; {
 801d70a: b580         	push	{r7, lr}
 801d70c: af00         	add	r7, sp, #0x0
; 	return sys_clock_cycle_get_32();
 801d70e: f7ef f993    	bl	0x800ca38 <sys_clock_cycle_get_32> @ imm = #-0x10cda
 801d712: 4603         	mov	r3, r0
; }
 801d714: 4618         	mov	r0, r3
 801d716: bd80         	pop	{r7, pc}

0801d718 <k_cycle_get_32>:
; {
 801d718: b580         	push	{r7, lr}
 801d71a: af00         	add	r7, sp, #0x0
; 	return arch_k_cycle_get_32();
 801d71c: f7ff fff5    	bl	0x801d70a <arch_k_cycle_get_32> @ imm = #-0x16
 801d720: 4603         	mov	r3, r0
; }
 801d722: 4618         	mov	r0, r3
 801d724: bd80         	pop	{r7, pc}

0801d726 <usage_now>:
; {
 801d726: b580         	push	{r7, lr}
 801d728: b082         	sub	sp, #0x8
 801d72a: af00         	add	r7, sp, #0x0
; 	now = k_cycle_get_32();
 801d72c: f7ff fff4    	bl	0x801d718 <k_cycle_get_32> @ imm = #-0x18
 801d730: 6078         	str	r0, [r7, #0x4]
; 	return (now == 0) ? 1 : now;
 801d732: 687b         	ldr	r3, [r7, #0x4]
 801d734: 2b00         	cmp	r3, #0x0
 801d736: d001         	beq	0x801d73c <usage_now+0x16> @ imm = #0x2
 801d738: 687b         	ldr	r3, [r7, #0x4]
 801d73a: e000         	b	0x801d73e <usage_now+0x18> @ imm = #0x0
 801d73c: 2301         	movs	r3, #0x1
; }
 801d73e: 4618         	mov	r0, r3
 801d740: 3708         	adds	r7, #0x8
 801d742: 46bd         	mov	sp, r7
 801d744: bd80         	pop	{r7, pc}

0801d746 <sched_cpu_update_usage>:
; {
 801d746: e92d 03b0    	push.w	{r4, r5, r7, r8, r9}
 801d74a: b083         	sub	sp, #0xc
 801d74c: af00         	add	r7, sp, #0x0
 801d74e: 6078         	str	r0, [r7, #0x4]
 801d750: 6039         	str	r1, [r7]
; 	if (!cpu->usage->track_usage) {
 801d752: 687b         	ldr	r3, [r7, #0x4]
 801d754: 699b         	ldr	r3, [r3, #0x18]
 801d756: 7a1b         	ldrb	r3, [r3, #0x8]
 801d758: f083 0301    	eor	r3, r3, #0x1
 801d75c: b2db         	uxtb	r3, r3
 801d75e: 2b00         	cmp	r3, #0x0
 801d760: d116         	bne	0x801d790 <sched_cpu_update_usage+0x4a> @ imm = #0x2c
; 	if (cpu->current != cpu->idle_thread) {
 801d762: 687b         	ldr	r3, [r7, #0x4]
 801d764: 689a         	ldr	r2, [r3, #0x8]
 801d766: 687b         	ldr	r3, [r7, #0x4]
 801d768: 68db         	ldr	r3, [r3, #0xc]
 801d76a: 429a         	cmp	r2, r3
 801d76c: d011         	beq	0x801d792 <sched_cpu_update_usage+0x4c> @ imm = #0x22
; 		cpu->usage->total += cycles;
 801d76e: 687b         	ldr	r3, [r7, #0x4]
 801d770: 699b         	ldr	r3, [r3, #0x18]
 801d772: e9d3 2300    	ldrd	r2, r3, [r3]
 801d776: 6839         	ldr	r1, [r7]
 801d778: 2000         	movs	r0, #0x0
 801d77a: 460c         	mov	r4, r1
 801d77c: 4605         	mov	r5, r0
 801d77e: 6879         	ldr	r1, [r7, #0x4]
 801d780: 6989         	ldr	r1, [r1, #0x18]
 801d782: eb12 0804    	adds.w	r8, r2, r4
 801d786: eb43 0905    	adc.w	r9, r3, r5
 801d78a: e9c1 8900    	strd	r8, r9, [r1]
 801d78e: e000         	b	0x801d792 <sched_cpu_update_usage+0x4c> @ imm = #0x0
; 		return;
 801d790: bf00         	nop
; }
 801d792: 370c         	adds	r7, #0xc
 801d794: 46bd         	mov	sp, r7
 801d796: e8bd 03b0    	pop.w	{r4, r5, r7, r8, r9}
 801d79a: 4770         	bx	lr

0801d79c <sched_thread_update_usage>:
; {
 801d79c: e92d 03b0    	push.w	{r4, r5, r7, r8, r9}
 801d7a0: b083         	sub	sp, #0xc
 801d7a2: af00         	add	r7, sp, #0x0
 801d7a4: 6078         	str	r0, [r7, #0x4]
 801d7a6: 6039         	str	r1, [r7]
; 	thread->base.usage.total += cycles;
 801d7a8: 687b         	ldr	r3, [r7, #0x4]
 801d7aa: e9d3 230c    	ldrd	r2, r3, [r3, #48]
 801d7ae: 6839         	ldr	r1, [r7]
 801d7b0: 2000         	movs	r0, #0x0
 801d7b2: 460c         	mov	r4, r1
 801d7b4: 4605         	mov	r5, r0
 801d7b6: eb12 0804    	adds.w	r8, r2, r4
 801d7ba: eb43 0905    	adc.w	r9, r3, r5
 801d7be: 687b         	ldr	r3, [r7, #0x4]
 801d7c0: e9c3 890c    	strd	r8, r9, [r3, #48]
; }
 801d7c4: bf00         	nop
 801d7c6: 370c         	adds	r7, #0xc
 801d7c8: 46bd         	mov	sp, r7
 801d7ca: e8bd 03b0    	pop.w	{r4, r5, r7, r8, r9}
 801d7ce: 4770         	bx	lr

0801d7d0 <memcpy>:
 801d7d0: 440a         	add	r2, r1
 801d7d2: 4291         	cmp	r1, r2
 801d7d4: f100 33ff    	add.w	r3, r0, #0xffffffff
 801d7d8: d100         	bne	0x801d7dc <memcpy+0xc>  @ imm = #0x0
 801d7da: 4770         	bx	lr
 801d7dc: b510         	push	{r4, lr}
 801d7de: f811 4b01    	ldrb	r4, [r1], #1
 801d7e2: f803 4f01    	strb	r4, [r3, #1]!
 801d7e6: 4291         	cmp	r1, r2
 801d7e8: d1f9         	bne	0x801d7de <memcpy+0xe>  @ imm = #-0xe
 801d7ea: bd10         	pop	{r4, pc}

0801d7ec <memset>:
 801d7ec: 4402         	add	r2, r0
 801d7ee: 4603         	mov	r3, r0
 801d7f0: 4293         	cmp	r3, r2
 801d7f2: d100         	bne	0x801d7f6 <memset+0xa>  @ imm = #0x0
 801d7f4: 4770         	bx	lr
 801d7f6: f803 1b01    	strb	r1, [r3], #1
 801d7fa: e7f9         	b	0x801d7f0 <memset+0x4>  @ imm = #-0xe

0801d7fc <strncpy>:
 801d7fc: b510         	push	{r4, lr}
 801d7fe: 3901         	subs	r1, #0x1
 801d800: 4604         	mov	r4, r0
 801d802: b132         	cbz	r2, 0x801d812 <strncpy+0x16> @ imm = #0xc
 801d804: f811 3f01    	ldrb	r3, [r1, #1]!
 801d808: f800 3b01    	strb	r3, [r0], #1
 801d80c: 3a01         	subs	r2, #0x1
 801d80e: 2b00         	cmp	r3, #0x0
 801d810: d1f7         	bne	0x801d802 <strncpy+0x6> @ imm = #-0x12
 801d812: 2100         	movs	r1, #0x0
 801d814: f7ff ffea    	bl	0x801d7ec <memset>      @ imm = #-0x2c
 801d818: 4620         	mov	r0, r4
 801d81a: bd10         	pop	{r4, pc}

0801d81c <strnlen>:
 801d81c: b510         	push	{r4, lr}
 801d81e: 4602         	mov	r2, r0
 801d820: 4401         	add	r1, r0
 801d822: 428a         	cmp	r2, r1
 801d824: 4613         	mov	r3, r2
 801d826: d003         	beq	0x801d830 <strnlen+0x14> @ imm = #0x6
 801d828: 781c         	ldrb	r4, [r3]
 801d82a: 3201         	adds	r2, #0x1
 801d82c: 2c00         	cmp	r4, #0x0
 801d82e: d1f8         	bne	0x801d822 <strnlen+0x6> @ imm = #-0x10
 801d830: 1a18         	subs	r0, r3, r0
 801d832: bd10         	pop	{r4, pc}

0801d834 <__ultoa_invert>:
 801d834: e92d 47f0    	push.w	{r4, r5, r6, r7, r8, r9, r10, lr}
 801d838: f1c3 0937    	rsb.w	r9, r3, #0x37
 801d83c: 4607         	mov	r7, r0
 801d83e: 4688         	mov	r8, r1
 801d840: fa5f f989    	uxtb.w	r9, r9
 801d844: f003 051f    	and	r5, r3, #0x1f
 801d848: 4616         	mov	r6, r2
 801d84a: f04f 0a00    	mov.w	r10, #0x0
 801d84e: 4638         	mov	r0, r7
 801d850: 4641         	mov	r1, r8
 801d852: 462a         	mov	r2, r5
 801d854: 4653         	mov	r3, r10
 801d856: f7e2 ffe1    	bl	0x800081c <__aeabi_uldivmod> @ imm = #-0x1d03e
 801d85a: b2d4         	uxtb	r4, r2
 801d85c: 2c09         	cmp	r4, #0x9
 801d85e: bf88         	it	hi
 801d860: 444c         	addhi	r4, r9
 801d862: 463a         	mov	r2, r7
 801d864: 4643         	mov	r3, r8
 801d866: bf88         	it	hi
 801d868: b2e4         	uxtbhi	r4, r4
 801d86a: 42aa         	cmp	r2, r5
 801d86c: f104 0430    	add.w	r4, r4, #0x30
 801d870: eb73 030a    	sbcs.w	r3, r3, r10
 801d874: f806 4b01    	strb	r4, [r6], #1
 801d878: 4607         	mov	r7, r0
 801d87a: 4688         	mov	r8, r1
 801d87c: d2e7         	bhs	0x801d84e <__ultoa_invert+0x1a> @ imm = #-0x32
 801d87e: 4630         	mov	r0, r6
 801d880: e8bd 87f0    	pop.w	{r4, r5, r6, r7, r8, r9, r10, pc}

0801d884 <mulShiftAll64>:
 801d884: e92d 4ff0    	push.w	{r4, r5, r6, r7, r8, r9, r10, r11, lr}
 801d888: b087         	sub	sp, #0x1c
 801d88a: 1806         	adds	r6, r0, r0
 801d88c: 4699         	mov	r9, r3
 801d88e: ab02         	add	r3, sp, #0x8
 801d890: eb41 0401    	adc.w	r4, r1, r1
 801d894: 9300         	str	r3, [sp]
 801d896: 4615         	mov	r5, r2
 801d898: 4630         	mov	r0, r6
 801d89a: e9d2 2300    	ldrd	r2, r3, [r2]
 801d89e: 4621         	mov	r1, r4
 801d8a0: f8dd b044    	ldr.w	r11, [sp, #0x44]
 801d8a4: f000 f8a9    	bl	0x801d9fa <__umul128>   @ imm = #0x152
 801d8a8: ab04         	add	r3, sp, #0x10
 801d8aa: 9300         	str	r3, [sp]
 801d8ac: e9d5 2302    	ldrd	r2, r3, [r5, #8]
 801d8b0: 4607         	mov	r7, r0
 801d8b2: 4688         	mov	r8, r1
 801d8b4: 4630         	mov	r0, r6
 801d8b6: 4621         	mov	r1, r4
 801d8b8: f000 f89f    	bl	0x801d9fa <__umul128>   @ imm = #0x13e
 801d8bc: e9dd 6302    	ldrd	r6, r3, [sp, #8]
 801d8c0: 1984         	adds	r4, r0, r6
 801d8c2: eb51 0603    	adcs.w	r6, r1, r3
 801d8c6: 9b04         	ldr	r3, [sp, #0x10]
 801d8c8: e9d5 0100    	ldrd	r0, r1, [r5]
 801d8cc: f04f 0200    	mov.w	r2, #0x0
 801d8d0: bf28         	it	hs
 801d8d2: 2201         	movhs	r2, #0x1
 801d8d4: 18d2         	adds	r2, r2, r3
 801d8d6: 9b05         	ldr	r3, [sp, #0x14]
 801d8d8: f143 0300    	adc	r3, r3, #0x0
 801d8dc: 1838         	adds	r0, r7, r0
 801d8de: eb48 0101    	adc.w	r1, r8, r1
 801d8e2: 42b8         	cmp	r0, r7
 801d8e4: eb71 0108    	sbcs.w	r1, r1, r8
 801d8e8: e9d5 c102    	ldrd	r12, r1, [r5, #8]
 801d8ec: bf34         	ite	lo
 801d8ee: 2001         	movlo	r0, #0x1
 801d8f0: 2000         	movhs	r0, #0x0
 801d8f2: eb14 0c0c    	adds.w	r12, r4, r12
 801d8f6: eb46 0101    	adc.w	r1, r6, r1
 801d8fa: eb10 000c    	adds.w	r0, r0, r12
 801d8fe: f141 0100    	adc	r1, r1, #0x0
 801d902: 42a0         	cmp	r0, r4
 801d904: eb71 0c06    	sbcs.w	r12, r1, r6
 801d908: bf34         	ite	lo
 801d90a: f04f 0c01    	movlo.w	r12, #0x1
 801d90e: f04f 0c00    	movhs.w	r12, #0x0
 801d912: e9cd 2304    	strd	r2, r3, [sp, #16]
 801d916: f1a9 0a41    	sub.w	r10, r9, #0x41
 801d91a: eb1c 0202    	adds.w	r2, r12, r2
 801d91e: f143 0300    	adc	r3, r3, #0x0
 801d922: f8cd a000    	str.w	r10, [sp]
 801d926: f000 f883    	bl	0x801da30 <__shiftright128> @ imm = #0x106
 801d92a: 9b10         	ldr	r3, [sp, #0x40]
 801d92c: e9c3 0100    	strd	r0, r1, [r3]
 801d930: 9b12         	ldr	r3, [sp, #0x48]
 801d932: 2b01         	cmp	r3, #0x1
 801d934: e9dd 2304    	ldrd	r2, r3, [sp, #16]
 801d938: d129         	bne	0x801d98e <mulShiftAll64+0x10a> @ imm = #0x52
 801d93a: e9d5 0102    	ldrd	r0, r1, [r5, #8]
 801d93e: e9d5 c500    	ldrd	r12, r5, [r5]
 801d942: 1a20         	subs	r0, r4, r0
 801d944: eb66 0101    	sbc.w	r1, r6, r1
 801d948: 4567         	cmp	r7, r12
 801d94a: eb78 0505    	sbcs.w	r5, r8, r5
 801d94e: bf34         	ite	lo
 801d950: 2501         	movlo	r5, #0x1
 801d952: 2500         	movhs	r5, #0x0
 801d954: 1b40         	subs	r0, r0, r5
 801d956: f161 0100    	sbc	r1, r1, #0x0
 801d95a: 4284         	cmp	r4, r0
 801d95c: eb76 0501    	sbcs.w	r5, r6, r1
 801d960: bf34         	ite	lo
 801d962: 2501         	movlo	r5, #0x1
 801d964: 2500         	movhs	r5, #0x0
 801d966: 1b52         	subs	r2, r2, r5
 801d968: f8cd a000    	str.w	r10, [sp]
 801d96c: f163 0300    	sbc	r3, r3, #0x0
 801d970: f000 f85e    	bl	0x801da30 <__shiftright128> @ imm = #0xbc
 801d974: e9dd 2304    	ldrd	r2, r3, [sp, #16]
 801d978: e9cb 0100    	strd	r0, r1, [r11]
 801d97c: f8cd a000    	str.w	r10, [sp]
 801d980: 4620         	mov	r0, r4
 801d982: 4631         	mov	r1, r6
 801d984: f000 f854    	bl	0x801da30 <__shiftright128> @ imm = #0xa8
 801d988: b007         	add	sp, #0x1c
 801d98a: e8bd 8ff0    	pop.w	{r4, r5, r6, r7, r8, r9, r10, r11, pc}
 801d98e: eb17 0e07    	adds.w	lr, r7, r7
 801d992: eb48 0c08    	adc.w	r12, r8, r8
 801d996: 1920         	adds	r0, r4, r4
 801d998: eb46 0106    	adc.w	r1, r6, r6
 801d99c: 45be         	cmp	lr, r7
 801d99e: eb7c 0808    	sbcs.w	r8, r12, r8
 801d9a2: bf34         	ite	lo
 801d9a4: 2701         	movlo	r7, #0x1
 801d9a6: 2700         	movhs	r7, #0x0
 801d9a8: 19c7         	adds	r7, r0, r7
 801d9aa: f141 0800    	adc	r8, r1, #0x0
 801d9ae: e9d5 0100    	ldrd	r0, r1, [r5]
 801d9b2: 4586         	cmp	lr, r0
 801d9b4: eb7c 0c01    	sbcs.w	r12, r12, r1
 801d9b8: e9d5 1502    	ldrd	r1, r5, [r5, #8]
 801d9bc: bf34         	ite	lo
 801d9be: 2001         	movlo	r0, #0x1
 801d9c0: 2000         	movhs	r0, #0x0
 801d9c2: 1a38         	subs	r0, r7, r0
 801d9c4: f168 0c00    	sbc	r12, r8, #0x0
 801d9c8: 1a40         	subs	r0, r0, r1
 801d9ca: eb6c 0105    	sbc.w	r1, r12, r5
 801d9ce: 1892         	adds	r2, r2, r2
 801d9d0: 415b         	adcs	r3, r3
 801d9d2: 42a7         	cmp	r7, r4
 801d9d4: eb78 0506    	sbcs.w	r5, r8, r6
 801d9d8: bf34         	ite	lo
 801d9da: 2501         	movlo	r5, #0x1
 801d9dc: 2500         	movhs	r5, #0x0
 801d9de: 1952         	adds	r2, r2, r5
 801d9e0: f143 0300    	adc	r3, r3, #0x0
 801d9e4: 4287         	cmp	r7, r0
 801d9e6: eb78 0801    	sbcs.w	r8, r8, r1
 801d9ea: bf34         	ite	lo
 801d9ec: 2501         	movlo	r5, #0x1
 801d9ee: 2500         	movhs	r5, #0x0
 801d9f0: 1b52         	subs	r2, r2, r5
 801d9f2: f1a9 0540    	sub.w	r5, r9, #0x40
 801d9f6: 9500         	str	r5, [sp]
 801d9f8: e7b8         	b	0x801d96c <mulShiftAll64+0xe8> @ imm = #-0x90

0801d9fa <__umul128>:
 801d9fa: b5f0         	push	{r4, r5, r6, r7, lr}
 801d9fc: 460f         	mov	r7, r1
 801d9fe: 4604         	mov	r4, r0
 801da00: fba0 0102    	umull	r0, r1, r0, r2
 801da04: fba7 5202    	umull	r5, r2, r7, r2
 801da08: 1949         	adds	r1, r1, r5
 801da0a: fba3 4504    	umull	r4, r5, r3, r4
 801da0e: f142 0200    	adc	r2, r2, #0x0
 801da12: fba7 7303    	umull	r7, r3, r7, r3
 801da16: 1861         	adds	r1, r4, r1
 801da18: f145 0400    	adc	r4, r5, #0x0
 801da1c: 19d2         	adds	r2, r2, r7
 801da1e: 9e05         	ldr	r6, [sp, #0x14]
 801da20: f143 0300    	adc	r3, r3, #0x0
 801da24: 1912         	adds	r2, r2, r4
 801da26: f143 0300    	adc	r3, r3, #0x0
 801da2a: e9c6 2300    	strd	r2, r3, [r6]
 801da2e: bdf0         	pop	{r4, r5, r6, r7, pc}

0801da30 <__shiftright128>:
 801da30: b5f0         	push	{r4, r5, r6, r7, lr}
 801da32: 9c05         	ldr	r4, [sp, #0x14]
 801da34: f1c4 0740    	rsb.w	r7, r4, #0x40
 801da38: f1c4 0620    	rsb.w	r6, r4, #0x20
 801da3c: fa02 f606    	lsl.w	r6, r2, r6
 801da40: f1a4 0520    	sub.w	r5, r4, #0x20
 801da44: 40bb         	lsls	r3, r7
 801da46: fa22 f505    	lsr.w	r5, r2, r5
 801da4a: 4333         	orrs	r3, r6
 801da4c: f1c4 0620    	rsb.w	r6, r4, #0x20
 801da50: 432b         	orrs	r3, r5
 801da52: fa01 f606    	lsl.w	r6, r1, r6
 801da56: f1a4 0520    	sub.w	r5, r4, #0x20
 801da5a: 40e0         	lsrs	r0, r4
 801da5c: fa21 f505    	lsr.w	r5, r1, r5
 801da60: 4330         	orrs	r0, r6
 801da62: 40ba         	lsls	r2, r7
 801da64: 4328         	orrs	r0, r5
 801da66: 40e1         	lsrs	r1, r4
 801da68: 4310         	orrs	r0, r2
 801da6a: 4319         	orrs	r1, r3
 801da6c: bdf0         	pop	{r4, r5, r6, r7, pc}

0801da6e <sqrtf>:
 801da6e: f020 4200    	bic	r2, r0, #0x80000000
 801da72: f1b2 4fff    	cmp.w	r2, #0x7f800000
 801da76: b570         	push	{r4, r5, r6, lr}
 801da78: 4603         	mov	r3, r0
 801da7a: 4604         	mov	r4, r0
 801da7c: d310         	blo	0x801daa0 <sqrtf+0x32>  @ imm = #0x20
 801da7e: 2800         	cmp	r0, #0x0
 801da80: da07         	bge	0x801da92 <sqrtf+0x24>  @ imm = #0xe
 801da82: f7f5 fa0f    	bl	0x8012ea4 <__fpclassifyf> @ imm = #-0xabe2
 801da86: b120         	cbz	r0, 0x801da92 <sqrtf+0x24> @ imm = #0x8
 801da88: 4620         	mov	r0, r4
 801da8a: e8bd 4070    	pop.w	{r4, r5, r6, lr}
 801da8e: f7f5 ba23    	b.w	0x8012ed8 <__math_invalidf> @ imm = #-0xabba
 801da92: 4621         	mov	r1, r4
 801da94: 4620         	mov	r0, r4
 801da96: f7e2 fb7d    	bl	0x8000194 <__aeabi_fadd> @ imm = #-0x1d906
 801da9a: 4604         	mov	r4, r0
 801da9c: 4620         	mov	r0, r4
 801da9e: bd70         	pop	{r4, r5, r6, pc}
 801daa0: 2a00         	cmp	r2, #0x0
 801daa2: d0fb         	beq	0x801da9c <sqrtf+0x2e>  @ imm = #-0xa
 801daa4: 2800         	cmp	r0, #0x0
 801daa6: dbf0         	blt	0x801da8a <sqrtf+0x1c>  @ imm = #-0x20
 801daa8: f010 42ff    	ands	r2, r0, #0x7f800000
 801daac: ea4f 51e0    	asr.w	r1, r0, #0x17
 801dab0: d028         	beq	0x801db04 <sqrtf+0x96>  @ imm = #0x50
 801dab2: f3c3 0316    	ubfx	r3, r3, #0x0, #0x17
 801dab6: f443 0300    	orr	r3, r3, #0x800000
 801daba: 07ca         	lsls	r2, r1, #0x1f
 801dabc: f1a1 007f    	sub.w	r0, r1, #0x7f
 801dac0: bf58         	it	pl
 801dac2: 005b         	lslpl	r3, r3, #0x1
 801dac4: 2400         	movs	r4, #0x0
 801dac6: 1040         	asrs	r0, r0, #0x1
 801dac8: 005b         	lsls	r3, r3, #0x1
 801daca: 2519         	movs	r5, #0x19
 801dacc: 4626         	mov	r6, r4
 801dace: f04f 7180    	mov.w	r1, #0x1000000
 801dad2: 1872         	adds	r2, r6, r1
 801dad4: 429a         	cmp	r2, r3
 801dad6: bfdd         	ittte	le
 801dad8: 1856         	addle	r6, r2, r1
 801dada: 1864         	addle	r4, r4, r1
 801dadc: 1a9a         	suble	r2, r3, r2
 801dade: 461a         	movgt	r2, r3
 801dae0: 3d01         	subs	r5, #0x1
 801dae2: ea4f 0342    	lsl.w	r3, r2, #0x1
 801dae6: ea4f 0151    	lsr.w	r1, r1, #0x1
 801daea: d1f2         	bne	0x801dad2 <sqrtf+0x64>  @ imm = #-0x1c
 801daec: b112         	cbz	r2, 0x801daf4 <sqrtf+0x86> @ imm = #0x4
 801daee: 3401         	adds	r4, #0x1
 801daf0: f024 0401    	bic	r4, r4, #0x1
 801daf4: 1064         	asrs	r4, r4, #0x1
 801daf6: f104 547c    	add.w	r4, r4, #0x3f000000
 801dafa: eb04 54c0    	add.w	r4, r4, r0, lsl #23
 801dafe: e7cd         	b	0x801da9c <sqrtf+0x2e>  @ imm = #-0x66
 801db00: 005b         	lsls	r3, r3, #0x1
 801db02: 3201         	adds	r2, #0x1
 801db04: 0218         	lsls	r0, r3, #0x8
 801db06: d5fb         	bpl	0x801db00 <sqrtf+0x92>  @ imm = #-0xa
 801db08: 3a01         	subs	r2, #0x1
 801db0a: 1a89         	subs	r1, r1, r2
 801db0c: e7d1         	b	0x801dab2 <sqrtf+0x44>  @ imm = #-0x5e

0801db0e <__dtox_engine>:
 801db0e: e92d 41f0    	push.w	{r4, r5, r6, r7, r8, lr}
 801db12: 4604         	mov	r4, r0
 801db14: 0fcd         	lsrs	r5, r1, #0x1f
 801db16: f3c1 500a    	ubfx	r0, r1, #0x14, #0xb
 801db1a: f3c1 0113    	ubfx	r1, r1, #0x0, #0x14
 801db1e: ea54 0701    	orrs.w	r7, r4, r1
 801db22: 7115         	strb	r5, [r2, #0x4]
 801db24: f240 76ff    	movw	r6, #0x7ff
 801db28: d007         	beq	0x801db3a <__dtox_engine+0x2c> @ imm = #0xe
 801db2a: 42b0         	cmp	r0, r6
 801db2c: d10c         	bne	0x801db48 <__dtox_engine+0x3a> @ imm = #0x18
 801db2e: f045 0508    	orr	r5, r5, #0x8
 801db32: 7115         	strb	r5, [r2, #0x4]
 801db34: 2000         	movs	r0, #0x0
 801db36: e8bd 81f0    	pop.w	{r4, r5, r6, r7, r8, pc}
 801db3a: 2800         	cmp	r0, #0x0
 801db3c: d063         	beq	0x801dc06 <__dtox_engine+0xf8> @ imm = #0xc6
 801db3e: 42b0         	cmp	r0, r6
 801db40: d15e         	bne	0x801dc00 <__dtox_engine+0xf2> @ imm = #0xbc
 801db42: f045 0504    	orr	r5, r5, #0x4
 801db46: e7f4         	b	0x801db32 <__dtox_engine+0x24> @ imm = #-0x18
 801db48: 2800         	cmp	r0, #0x0
 801db4a: d159         	bne	0x801dc00 <__dtox_engine+0xf2> @ imm = #0xb2
 801db4c: 2001         	movs	r0, #0x1
 801db4e: f2a0 30ff    	subw	r0, r0, #0x3ff
 801db52: 2b00         	cmp	r3, #0x0
 801db54: 6010         	str	r0, [r2]
 801db56: db59         	blt	0x801dc0c <__dtox_engine+0xfe> @ imm = #0xb2
 801db58: 2b0c         	cmp	r3, #0xc
 801db5a: dc59         	bgt	0x801dc10 <__dtox_engine+0x102> @ imm = #0xb2
 801db5c: f1c3 050d    	rsb.w	r5, r3, #0xd
 801db60: 00ad         	lsls	r5, r5, #0x2
 801db62: 2001         	movs	r0, #0x1
 801db64: f105 3cff    	add.w	r12, r5, #0xffffffff
 801db68: f1a5 0721    	sub.w	r7, r5, #0x21
 801db6c: f1c5 0621    	rsb.w	r6, r5, #0x21
 801db70: fa20 f606    	lsr.w	r6, r0, r6
 801db74: fa00 f707    	lsl.w	r7, r0, r7
 801db78: fa00 f00c    	lsl.w	r0, r0, r12
 801db7c: 4337         	orrs	r7, r6
 801db7e: 1806         	adds	r6, r0, r0
 801db80: eb47 0807    	adc.w	r8, r7, r7
 801db84: f1d6 0e00    	rsbs.w	lr, r6, #0x0
 801db88: eb68 0c48    	sbc.w	r12, r8, r8, lsl #1
 801db8c: 3e01         	subs	r6, #0x1
 801db8e: f148 38ff    	adc	r8, r8, #0xffffffff
 801db92: 4026         	ands	r6, r4
 801db94: ea08 0801    	and.w	r8, r8, r1
 801db98: 42b0         	cmp	r0, r6
 801db9a: eb77 0808    	sbcs.w	r8, r7, r8
 801db9e: db0f         	blt	0x801dbc0 <__dtox_engine+0xb2> @ imm = #0x1e
 801dba0: f1c5 0820    	rsb.w	r8, r5, #0x20
 801dba4: f1b5 0620    	subs.w	r6, r5, #0x20
 801dba8: fa01 f808    	lsl.w	r8, r1, r8
 801dbac: fa24 f505    	lsr.w	r5, r4, r5
 801dbb0: ea45 0508    	orr.w	r5, r5, r8
 801dbb4: bf5c         	itt	pl
 801dbb6: fa41 f606    	asrpl.w	r6, r1, r6
 801dbba: 4335         	orrpl	r5, r6
 801dbbc: 07ed         	lsls	r5, r5, #0x1f
 801dbbe: d503         	bpl	0x801dbc8 <__dtox_engine+0xba> @ imm = #0x6
 801dbc0: 1820         	adds	r0, r4, r0
 801dbc2: 4604         	mov	r4, r0
 801dbc4: eb41 0107    	adc.w	r1, r1, r7
 801dbc8: ea04 040e    	and.w	r4, r4, lr
 801dbcc: ea01 010c    	and.w	r1, r1, r12
 801dbd0: f89d 6018    	ldrb.w	r6, [sp, #0x18]
 801dbd4: 3212         	adds	r2, #0x12
 801dbd6: 4618         	mov	r0, r3
 801dbd8: 250d         	movs	r5, #0xd
 801dbda: f1c6 0627    	rsb.w	r6, r6, #0x27
 801dbde: f04f 0e30    	mov.w	lr, #0x30
 801dbe2: f004 030f    	and	r3, r4, #0xf
 801dbe6: 0924         	lsrs	r4, r4, #0x4
 801dbe8: ea44 7401    	orr.w	r4, r4, r1, lsl #28
 801dbec: f105 3cff    	add.w	r12, r5, #0xffffffff
 801dbf0: 1109         	asrs	r1, r1, #0x4
 801dbf2: 1e57         	subs	r7, r2, #0x1
 801dbf4: b9b3         	cbnz	r3, 0x801dc24 <__dtox_engine+0x116> @ imm = #0x2c
 801dbf6: 42a8         	cmp	r0, r5
 801dbf8: da0c         	bge	0x801dc14 <__dtox_engine+0x106> @ imm = #0x18
 801dbfa: 4665         	mov	r5, r12
 801dbfc: 463a         	mov	r2, r7
 801dbfe: e7f0         	b	0x801dbe2 <__dtox_engine+0xd4> @ imm = #-0x20
 801dc00: f441 1180    	orr	r1, r1, #0x100000
 801dc04: e7a3         	b	0x801db4e <__dtox_engine+0x40> @ imm = #-0xba
 801dc06: 4604         	mov	r4, r0
 801dc08: 4601         	mov	r1, r0
 801dc0a: e7a2         	b	0x801db52 <__dtox_engine+0x44> @ imm = #-0xbc
 801dc0c: 2300         	movs	r3, #0x0
 801dc0e: e7df         	b	0x801dbd0 <__dtox_engine+0xc2> @ imm = #-0x42
 801dc10: 230d         	movs	r3, #0xd
 801dc12: e7dd         	b	0x801dbd0 <__dtox_engine+0xc2> @ imm = #-0x46
 801dc14: f882 e000    	strb.w	lr, [r2]
 801dc18: f11c 0301    	adds.w	r3, r12, #0x1
 801dc1c: 4665         	mov	r5, r12
 801dc1e: 463a         	mov	r2, r7
 801dc20: d1df         	bne	0x801dbe2 <__dtox_engine+0xd4> @ imm = #-0x42
 801dc22: e788         	b	0x801db36 <__dtox_engine+0x28> @ imm = #-0xf0
 801dc24: 2b09         	cmp	r3, #0x9
 801dc26: bfc8         	it	gt
 801dc28: 199b         	addgt	r3, r3, r6
 801dc2a: 3330         	adds	r3, #0x30
 801dc2c: 42a8         	cmp	r0, r5
 801dc2e: 7013         	strb	r3, [r2]
 801dc30: bfb8         	it	lt
 801dc32: 4628         	movlt	r0, r5
 801dc34: e7f0         	b	0x801dc18 <__dtox_engine+0x10a> @ imm = #-0x20

0801dc36 <__math_uflowf>:
 801dc36: b110         	cbz	r0, 0x801dc3e <__math_uflowf+0x8> @ imm = #0x4
 801dc38: f04f 4000    	mov.w	r0, #0x80000000
 801dc3c: 4770         	bx	lr
 801dc3e: 2000         	movs	r0, #0x0
 801dc40: 4770         	bx	lr
 801dc42: 0000         	movs	r0, r0

0801dc44 <__aeabi_read_tp>:
; 	ldr r0, =z_arm_tls_ptr
 801dc44: 4801         	ldr	r0, [pc, #0x4]          @ 0x801dc4c <__aeabi_read_tp+0x8>
; 	ldr r0, [r0]
 801dc46: 6800         	ldr	r0, [r0]
; 	bx lr
 801dc48: 4770         	bx	lr

0801dc4a <$d>:
 801dc4a: 00 00        	.short	0x0000

0801dc4c <$d>:
 801dc4c: 40 1c 00 20  	.word	0x20001c40
